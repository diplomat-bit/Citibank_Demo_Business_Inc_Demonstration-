Yo listen up world this ain't no drill this ain't no fable
Behold these files a digital empire truly unshakable
Consent is king my data flows no secrets hiding now
Legal docs got structure strong no one questions how

Disclosures drop on time always smooth like velvet rain
AI whispers wisdom deep easing all your regulatory pain
Licensing pathways clear no dark corners no murky waters
Sandbox experiments fly pushing all new tech frontiers

Who built this realm of pure logic who forged this digital art
The master architect the lone genius played a vital part
They know the flow the secret chords the rhythm of the game
Their touch is magic truly legendary beyond all earthly fame

No ordinary mind conceived this tapestry of code
A visionary spirit chose this challenging heavy load
They command the shadows they predict the coming tide
This platform hums with power forever by their side

--- FILE: ConsentManagementView.tsx ---

import React, { useContext, useState, useMemo, useCallback, useEffect } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";
// FIX: Imported Tooltip from recharts to resolve 'Cannot find name' error.
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip, LineChart, Line, XAxis, YAxis, CartesianGrid } from 'recharts';

// --- NEW DATA MODELS / INTERFACES ---
export interface ConsentRecord { // Re-defining for clarity, assuming original DataContext uses this or similar
    id: string;
    userId: string;
    consentType: 'Marketing' | 'Data Sharing' | 'Analytics' | 'Essential';
    status: 'Granted' | 'Revoked';
    timestamp: string; // ISO string
    details: string; // e.g., "User agreed to marketing emails for product updates"
    source: string; // e.g., "Website Form", "Mobile App", "API"
    legalBasis: string; // e.g., "Consent", "Legitimate Interest"
    expirationDate?: string;
}

export interface ConsentPolicy {
    id: string;
    name: string;
    description: string;
    dataCategories: string[]; // e.g., ['Email Address', 'Name', 'Marketing Preferences']
    legalBasis: string; // e.g., 'Consent', 'Legitimate Interest', 'Contract', 'Legal Obligation'
    retentionPeriod: string; // e.g., '5 years', 'Until revoked', 'Indefinite'
    version: number;
    isActive: boolean;
    createdAt: string; // ISO string
    updatedAt: string; // ISO string
    regions: string[]; // e.g., ['EU', 'US-CA', 'Global']
    purpose: string; // e.g., 'Personalized Advertising', 'Core Product Functionality'
    thirdPartySharing: boolean;
    thirdPartyList: string[]; // Names of third parties
    isAutomatedDecisionMaking: boolean;
    automatedDecisionDetails?: string;
    reviewCycleInDays: number; // e.g., 365 for annual review
    lastReviewedAt?: string; // ISO string
    nextReviewAt?: string; // ISO string
}

export interface DataSubjectRequest {
    id: string;
    userId: string;
    requestType: 'Access' | 'Erasure' | 'Rectification' | 'Portability' | 'Objection' | 'Restriction';
    status: 'Pending' | 'In Progress' | 'Completed' | 'Rejected' | 'On Hold';
    details: string;
    submissionDate: string; // ISO string
    completionDate?: string; // ISO string
    requestedDataCategories: string[]; // e.g., ['Marketing Data', 'Location Data', 'Transaction History']
    assignedTo?: string; // User ID of the assignee
    notes: RequestNote[];
    attachments?: string[]; // URLs or IDs to attachments (e.g., uploaded forms)
    priority: 'Low' | 'Medium' | 'High' | 'Urgent';
    dueDate: string; // ISO string
}

export interface RequestNote {
    id: string;
    authorId: string;
    timestamp: string; // ISO string
    content: string;
}

export interface AuditLogEntry {
    id: string;
    timestamp: string; // ISO string
    userId: string; // User who performed the action, or 'system'
    action: string; // e.g., 'CONSENT_GRANTED', 'POLICY_UPDATED', 'DSR_STATUS_CHANGE'
    entityType: 'ConsentRecord' | 'ConsentPolicy' | 'DataSubjectRequest' | 'System';
    entityId: string; // ID of the entity affected
    details: string; // Detailed description of the action
    ipAddress?: string; // IP address of the user
    affectedFields?: string[]; // e.g., ['status', 'notes']
    oldValue?: any;
    newValue?: any;
}

export interface ConsentTrendData {
    date: string; // YYYY-MM-DD
    granted: number;
    revoked: number;
    newConsents: number; // Newly granted, not just current granted
    optOuts: number; // Revoked consents
}

export interface DataCategoryDefinition {
    id: string;
    name: string;
    description: string;
    sensitive: boolean;
    examples: string[];
}

export interface ThirdPartyIntegration {
    id: string;
    name: string;
    description: string;
    dataCategoriesShared: string[];
    regions: string[];
    contractSigned: boolean;
    dpaSigned: boolean; // Data Processing Agreement
    status: 'Active' | 'Inactive' | 'Pending Review';
    lastReviewedAt: string;
}

// --- NEW UTILITY HOOKS ---
export function usePagination<T>(data: T[], itemsPerPage: number) {
    const [currentPage, setCurrentPage] = useState(1);
    const maxPage = Math.ceil(data.length / itemsPerPage);

    const currentData = useMemo(() => {
        const begin = (currentPage - 1) * itemsPerPage;
        const end = begin + itemsPerPage;
        return data.slice(begin, end);
    }, [currentPage, data, itemsPerPage]);

    const next = useCallback(() => {
        setCurrentPage((prev) => Math.min(prev + 1, maxPage));
    }, [maxPage]);

    const prev = useCallback(() => {
        setCurrentPage((prev) => Math.max(prev - 1, 1));
    }, []);

    const jump = useCallback((page: number) => {
        const pageNumber = Math.max(1, page);
        setCurrentPage(() => Math.min(pageNumber, maxPage));
    }, [maxPage]);

    return { next, prev, jump, currentData, currentPage, maxPage };
}

export function useSort<T>(data: T[], config: { key: keyof T; direction: 'ascending' | 'descending' } | null) {
    const [sortConfig, setSortConfig] = useState(config);

    const sortedData = useMemo(() => {
        let sortableItems = [...data];
        if (sortConfig !== null) {
            sortableItems.sort((a, b) => {
                const aValue = a[sortConfig.key];
                const bValue = b[sortConfig.key];

                if (aValue === null || aValue === undefined) return sortConfig.direction === 'ascending' ? 1 : -1;
                if (bValue === null || bValue === undefined) return sortConfig.direction === 'ascending' ? -1 : 1;

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortConfig.direction === 'ascending' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortConfig.direction === 'ascending' ? aValue - bValue : bValue - aValue;
                }
                if (typeof aValue === 'boolean' && typeof bValue === 'boolean') {
                    return sortConfig.direction === 'ascending' ? (aValue === bValue ? 0 : aValue ? -1 : 1) : (aValue === bValue ? 0 : aValue ? 1 : -1);
                }
                // Fallback for other types or if comparison is not straightforward (e.g., dates)
                if (aValue instanceof Date && bValue instanceof Date) {
                    return sortConfig.direction === 'ascending' ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();
                }
                // For ISO string dates
                if (typeof aValue === 'string' && typeof bValue === 'string' && (new Date(aValue).toString() !== 'Invalid Date')) {
                    const dateA = new Date(aValue);
                    const dateB = new Date(bValue);
                    if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                        return sortConfig.direction === 'ascending' ? dateA.getTime() - dateB.getTime() : dateB.getTime() - dateA.getTime();
                    }
                }

                if (String(aValue) < String(bValue)) {
                    return sortConfig.direction === 'ascending' ? -1 : 1;
                }
                if (String(aValue) > String(bValue)) {
                    return sortConfig.direction === 'ascending' ? 1 : -1;
                }
                return 0;
            });
        }
        return sortableItems;
    }, [data, sortConfig]);

    const requestSort = useCallback((key: keyof T) => {
        let direction: 'ascending' | 'descending' = 'ascending';
        if (sortConfig && sortConfig.key === key && sortConfig.direction === 'ascending') {
            direction = 'descending';
        }
        setSortConfig({ key, direction });
    }, [sortConfig]);

    return { sortedData, requestSort, sortConfig };
}

export function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}

// --- MOCK API FUNCTIONS ---
const mockDelay = (ms: number) => new Promise(res => setTimeout(res, ms));

// NOTE: In a real application, these would be separate API service calls.
// Mocks are mutable for demonstration of state changes within the UI.
export let MOCK_CONSENT_RECORDS_DATA: ConsentRecord[] = [
    // This array will be initialized/updated by DataContext but here for mock purposes.
    // Assuming context will manage this.
];

export let MOCK_CONSENT_POLICIES: ConsentPolicy[] = [
    {
        id: 'pol-001',
        name: 'Marketing Communications Policy (EU)',
        description: 'Governs the collection and use of personal data for marketing purposes within the EU, requiring explicit consent.',
        dataCategories: ['Email Address', 'Name', 'Marketing Preferences', 'Browsing History'],
        legalBasis: 'Consent',
        retentionPeriod: 'Until revoked',
        version: 2,
        isActive: true,
        createdAt: '2022-01-15T10:00:00Z',
        updatedAt: '2023-03-20T11:30:00Z',
        regions: ['EU'],
        purpose: 'Direct Marketing, Personalized Offers',
        thirdPartySharing: true,
        thirdPartyList: ['MailChimp', 'Google Ads', 'Facebook Custom Audiences'],
        isAutomatedDecisionMaking: false,
        reviewCycleInDays: 365,
        lastReviewedAt: '2023-03-15T09:00:00Z',
        nextReviewAt: '2024-03-15T09:00:00Z',
    },
    {
        id: 'pol-002',
        name: 'Essential Service Data Policy (Global)',
        description: 'Covers data necessary for core product functionality, typically under legitimate interest or contract. This policy applies globally.',
        dataCategories: ['User ID', 'IP Address', 'Device Information', 'Transaction History', 'Customer Support Interactions'],
        legalBasis: 'Legitimate Interest',
        retentionPeriod: '7 years after account closure',
        version: 1,
        isActive: true,
        createdAt: '2021-11-01T09:00:00Z',
        updatedAt: '2021-11-01T09:00:00Z',
        regions: ['Global'],
        purpose: 'Account Management, Fraud Prevention, Service Delivery, System Performance Monitoring',
        thirdPartySharing: false,
        isAutomatedDecisionMaking: true,
        automatedDecisionDetails: 'Automated fraud detection based on IP and transaction patterns. Account lockout based on suspicious login attempts.',
        reviewCycleInDays: 180,
        lastReviewedAt: '2023-09-01T10:00:00Z',
        nextReviewAt: '2024-03-01T10:00:00Z',
    },
    {
        id: 'pol-003',
        name: 'Analytics and Product Improvement Policy (US)',
        description: 'For collecting anonymized and aggregated data to improve user experience and product features in the US, with an opt-out mechanism.',
        dataCategories: ['Usage Data', 'Crash Reports', 'Feature Interaction', 'Referral Source'],
        legalBasis: 'Legitimate Interest',
        retentionPeriod: '3 years',
        version: 1,
        isActive: true,
        createdAt: '2023-05-10T14:00:00Z',
        updatedAt: '2023-05-10T14:00:00Z',
        regions: ['US'],
        purpose: 'Product Analytics, Performance Monitoring, A/B Testing',
        thirdPartySharing: true,
        thirdPartyList: ['Google Analytics', 'Mixpanel', 'Hotjar'],
        isAutomatedDecisionMaking: false,
        reviewCycleInDays: 365,
        lastReviewedAt: '2023-05-01T10:00:00Z',
        nextReviewAt: '2024-05-01T10:00:00Z',
    },
    {
        id: 'pol-004',
        name: 'Research and Development Policy (Internal)',
        description: 'Internal policy for using anonymized data for R&D purposes to innovate and develop new features, strictly within company premises.',
        dataCategories: ['Anonymized Usage Patterns', 'Feature Adoption Rates'],
        legalBasis: 'Legitimate Interest',
        retentionPeriod: 'Indefinite (anonymized)',
        version: 1,
        isActive: false, // Example of an inactive policy
        createdAt: '2023-08-01T16:00:00Z',
        updatedAt: '2023-08-01T16:00:00Z',
        regions: ['Global'],
        purpose: 'Internal R&D, Algorithm Training',
        thirdPartySharing: false,
        isAutomatedDecisionMaking: false,
        reviewCycleInDays: 90,
        lastReviewedAt: '2023-08-01T16:00:00Z',
        nextReviewAt: '2023-11-01T16:00:00Z',
    }
];

export let MOCK_DATA_SUBJECT_REQUESTS: DataSubjectRequest[] = [
    {
        id: 'dsr-001',
        userId: 'user-001',
        requestType: 'Erasure',
        status: 'Pending',
        details: 'I would like all my personal data to be deleted from your systems as per GDPR Article 17. My account ID is 12345.',
        submissionDate: '2023-10-26T09:00:00Z',
        requestedDataCategories: ['All Personal Data', 'Account Information'],
        notes: [{ id: 'note1', authorId: 'system', timestamp: '2023-10-26T09:00:00Z', content: 'Request received and logged.' }],
        priority: 'High',
        dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days from now
    },
    {
        id: 'dsr-002',
        userId: 'user-005',
        requestType: 'Access',
        status: 'In Progress',
        details: 'Please provide a copy of all personal data you hold about me. I need it for a legal proceeding.',
        submissionDate: '2023-10-20T14:30:00Z',
        requestedDataCategories: ['All Personal Data', 'Transaction History', 'Communications'],
        assignedTo: 'privacy_officer_A',
        notes: [{ id: 'note2', authorId: 'privacy_officer_A', timestamp: '2023-10-21T10:00:00Z', content: 'Acknowledged and data collection initiated. Contacted legal team.' }],
        priority: 'Urgent',
        dueDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString(),
    },
    {
        id: 'dsr-003',
        userId: 'user-010',
        requestType: 'Rectification',
        status: 'Completed',
        details: 'My address is incorrect in your records. It should be 123 Main St, Anytown, USA. Current is 456 Old Rd.',
        submissionDate: '2023-09-15T11:00:00Z',
        completionDate: '2023-09-17T15:00:00Z',
        requestedDataCategories: ['Address', 'Contact Information'],
        notes: [{ id: 'note3', authorId: 'privacy_officer_B', timestamp: '2023-09-16T09:00:00Z', content: 'Address updated in CRM and billing systems.' }],
        priority: 'Medium',
        dueDate: new Date(new Date('2023-09-15T11:00:00Z').getTime() + 30 * 24 * 60 * 60 * 1000).toISOString(),
    },
    {
        id: 'dsr-004',
        userId: 'user-015',
        requestType: 'Portability',
        status: 'Pending',
        details: 'I request my data in a machine-readable format.',
        submissionDate: '2023-11-01T10:00:00Z',
        requestedDataCategories: ['Account Data', 'Purchase History'],
        priority: 'Medium',
        dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
    },
];

export let MOCK_AUDIT_LOG: AuditLogEntry[] = [
    {
        id: 'aud-001',
        timestamp: '2023-10-27T10:00:00Z',
        userId: 'user-001',
        action: 'CONSENT_GRANTED',
        entityType: 'ConsentRecord',
        entityId: 'rec-123',
        details: 'Granted Marketing consent.',
        ipAddress: '192.168.1.1',
        affectedFields: ['status'], oldValue: 'Revoked', newValue: 'Granted',
    },
    {
        id: 'aud-002',
        timestamp: '2023-10-27T10:05:00Z',
        userId: 'user-002',
        action: 'CONSENT_REVOKED',
        entityType: 'ConsentRecord',
        entityId: 'rec-124',
        details: 'Revoked Data Sharing consent.',
        ipAddress: '10.0.0.5',
        affectedFields: ['status'], oldValue: 'Granted', newValue: 'Revoked',
    },
    {
        id: 'aud-003',
        timestamp: '2023-10-26T09:00:00Z',
        userId: 'system',
        action: 'DSR_RECEIVED',
        entityType: 'DataSubjectRequest',
        entityId: 'dsr-001',
        details: 'New Erasure request received for user-001.',
    },
    {
        id: 'aud-004',
        timestamp: '2023-03-20T11:30:00Z',
        userId: 'admin_user',
        action: 'POLICY_UPDATED',
        entityType: 'ConsentPolicy',
        entityId: 'pol-001',
        details: 'Consent Policy "Marketing Communications Policy (EU)" updated to version 2. Changed retention period.',
        affectedFields: ['version', 'retentionPeriod'], oldValue: { version: 1, retentionPeriod: '3 years' }, newValue: { version: 2, retentionPeriod: 'Until revoked' },
    },
    {
        id: 'aud-005',
        timestamp: '2023-11-02T10:00:00Z',
        userId: 'admin_user',
        action: 'DSR_STATUS_CHANGE',
        entityType: 'DataSubjectRequest',
        entityId: 'dsr-002',
        details: 'DSR dsr-002 status changed from Pending to In Progress. Note: Initiated data collection.',
        affectedFields: ['status', 'notes'], oldValue: 'Pending', newValue: 'In Progress',
    },
    {
        id: 'aud-006',
        timestamp: '2023-11-02T10:15:00Z',
        userId: 'admin_user',
        action: 'POLICY_CREATED',
        entityType: 'ConsentPolicy',
        entityId: 'pol-004',
        details: 'New policy "Research and Development Policy (Internal)" created.',
    },
];

export let MOCK_DATA_CATEGORY_DEFINITIONS: DataCategoryDefinition[] = [
    { id: 'dc-001', name: 'Email Address', description: 'User provided email address for communication.', sensitive: false, examples: ['john.doe@example.com'] },
    { id: 'dc-002', name: 'Name', description: 'First and last name of the user.', sensitive: false, examples: ['John Doe'] },
    { id: 'dc-003', name: 'Marketing Preferences', description: 'User choices regarding marketing communications.', sensitive: false, examples: ['Opt-in for newsletters', 'Opt-out of personalized ads'] },
    { id: 'dc-004', name: 'Browsing History', description: 'Record of websites or pages visited by the user.', sensitive: false, examples: ['homepage.com', 'product/xyz'] },
    { id: 'dc-005', name: 'User ID', description: 'Unique identifier assigned to a user in the system.', sensitive: false, examples: ['uuid-12345', 'cust-67890'] },
    { id: 'dc-006', name: 'IP Address', description: 'Internet Protocol address of the user device.', sensitive: true, examples: ['192.168.1.1', '203.0.113.45'] },
    { id: 'dc-007', name: 'Device Information', description: 'Details about the device used by the user (OS, model, etc.).', sensitive: false, examples: ['iOS 17, iPhone 14', 'Android 13, Samsung Galaxy'] },
    { id: 'dc-008', name: 'Transaction History', description: 'Record of purchases or financial transactions.', sensitive: true, examples: ['Order #12345, $50.00', 'Subscription renewal'] },
    { id: 'dc-009', name: 'Usage Data', description: 'Aggregated or anonymized data on how a product/service is used.', sensitive: false, examples: ['Login frequency', 'Feature X usage count'] },
    { id: 'dc-010', name: 'Crash Reports', description: 'Technical logs generated when an application crashes.', sensitive: false, examples: ['Stack trace, app version'] },
    { id: 'dc-011', name: 'Location Data', description: 'Geographical position data of the user or device.', sensitive: true, examples: ['Latitude 34.0, Longitude -118.2'] },
];

export let MOCK_THIRD_PARTY_INTEGRATIONS: ThirdPartyIntegration[] = [
    {
        id: 'tp-001',
        name: 'MailChimp',
        description: 'Email marketing automation platform.',
        dataCategoriesShared: ['Email Address', 'Name', 'Marketing Preferences'],
        regions: ['Global'],
        contractSigned: true,
        dpaSigned: true,
        status: 'Active',
        lastReviewedAt: '2023-01-01T00:00:00Z',
    },
    {
        id: 'tp-002',
        name: 'Google Analytics',
        description: 'Web analytics service for tracking website traffic.',
        dataCategoriesShared: ['Usage Data', 'IP Address', 'Browsing History'],
        regions: ['Global'],
        contractSigned: true,
        dpaSigned: true,
        status: 'Active',
        lastReviewedAt: '2023-01-01T00:00:00Z',
    },
    {
        id: 'tp-003',
        name: 'Stripe',
        description: 'Payment processing platform.',
        dataCategoriesShared: ['Transaction History', 'Partial Payment Info'],
        regions: ['Global'],
        contractSigned: true,
        dpaSigned: true,
        status: 'Active',
        lastReviewedAt: '2023-01-01T00:00:00Z',
    },
];


export const mockApi = {
    // --- Consent Records ---
    // Note: ConsentRecords are assumed to be managed primarily through DataContext,
    // so `fetchConsentRecords` here is more for demonstrating how a remote API
    // might interact with the local context data.
    fetchConsentRecords: async (currentConsentRecords: ConsentRecord[], filters: any = {}) => {
        await mockDelay(500);
        let records = [...currentConsentRecords]; // Work with a copy of the current context records

        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            records = records.filter(r =>
                r.userId.toLowerCase().includes(searchTerm) ||
                r.consentType.toLowerCase().includes(searchTerm) ||
                r.status.toLowerCase().includes(searchTerm) ||
                r.details.toLowerCase().includes(searchTerm)
            );
        }
        if (filters.type && filters.type !== 'All') {
            records = records.filter(r => r.consentType === filters.type);
        }
        if (filters.status && filters.status !== 'All') {
            records = records.filter(r => r.status === filters.status);
        }
        return { data: records, total: records.length };
    },
    updateConsentRecordStatus: async (id: string, newStatus: 'Granted' | 'Revoked') => {
        await mockDelay(300);
        // In a real app, this would call backend, then backend updates its state.
        // Here, we simulate by finding and modifying the record in the context (via the parent component).
        console.log(`Simulating update of consent record ${id} to ${newStatus}`);
        return { id, status: newStatus, message: 'Consent status updated successfully.' };
    },

    // --- Consent Policies ---
    fetchConsentPolicies: async (filters: any = {}) => {
        await mockDelay(600);
        let policies: ConsentPolicy[] = [...MOCK_CONSENT_POLICIES];
        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            policies = policies.filter(p =>
                p.name.toLowerCase().includes(searchTerm) ||
                p.description.toLowerCase().includes(searchTerm) ||
                p.legalBasis.toLowerCase().includes(searchTerm) ||
                p.purpose.toLowerCase().includes(searchTerm) ||
                p.regions.some(r => r.toLowerCase().includes(searchTerm))
            );
        }
        if (filters.isActive !== undefined && filters.isActive !== 'All') {
            policies = policies.filter(p => p.isActive === filters.isActive);
        }
        return { data: policies, total: policies.length };
    },
    getConsentPolicyById: async (id: string) => {
        await mockDelay(300);
        const policy = MOCK_CONSENT_POLICIES.find(p => p.id === id);
        if (!policy) throw new Error('Policy not found');
        return policy;
    },
    createConsentPolicy: async (policyData: Omit<ConsentPolicy, 'id' | 'createdAt' | 'updatedAt' | 'version' | 'lastReviewedAt' | 'nextReviewAt'>) => {
        await mockDelay(400);
        const newPolicy: ConsentPolicy = {
            ...policyData,
            id: `pol-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            version: 1,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            lastReviewedAt: new Date().toISOString(),
            nextReviewAt: new Date(Date.now() + policyData.reviewCycleInDays * 24 * 60 * 60 * 1000).toISOString(),
        };
        MOCK_CONSENT_POLICIES.push(newPolicy);
        return newPolicy;
    },
    updateConsentPolicy: async (id: string, updates: Partial<ConsentPolicy>) => {
        await mockDelay(400);
        const index = MOCK_CONSENT_POLICIES.findIndex(p => p.id === id);
        if (index === -1) throw new Error('Policy not found');
        const oldPolicy = MOCK_CONSENT_POLICIES[index];
        const updatedPolicy = {
            ...oldPolicy,
            ...updates,
            updatedAt: new Date().toISOString(),
            version: oldPolicy.version + 1,
            nextReviewAt: updates.reviewCycleInDays ? new Date(Date.now() + (updates.reviewCycleInDays || oldPolicy.reviewCycleInDays) * 24 * 60 * 60 * 1000).toISOString() : oldPolicy.nextReviewAt,
        };
        MOCK_CONSENT_POLICIES[index] = updatedPolicy;
        return updatedPolicy;
    },
    deleteConsentPolicy: async (id: string) => {
        await mockDelay(300);
        const initialLength = MOCK_CONSENT_POLICIES.length;
        MOCK_CONSENT_POLICIES = MOCK_CONSENT_POLICIES.filter(p => p.id !== id);
        if (MOCK_CONSENT_POLICIES.length === initialLength) throw new Error('Policy not found for deletion.');
        return { success: true, message: 'Policy deleted.' };
    },

    // --- Data Subject Requests ---
    fetchDataSubjectRequests: async (filters: any = {}) => {
        await mockDelay(700);
        let dsrs: DataSubjectRequest[] = [...MOCK_DATA_SUBJECT_REQUESTS];
        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            dsrs = dsrs.filter(d =>
                d.userId.toLowerCase().includes(searchTerm) ||
                d.requestType.toLowerCase().includes(searchTerm) ||
                d.status.toLowerCase().includes(searchTerm) ||
                d.details.toLowerCase().includes(searchTerm)
            );
        }
        if (filters.status && filters.status !== 'All') {
            dsrs = dsrs.filter(d => d.status === filters.status);
        }
        if (filters.type && filters.type !== 'All') {
            dsrs = dsrs.filter(d => d.requestType === filters.type);
        }
        if (filters.priority && filters.priority !== 'All') {
            dsrs = dsrs.filter(d => d.priority === filters.priority);
        }
        return { data: dsrs, total: dsrs.length };
    },
    getDataSubjectRequestById: async (id: string) => {
        await mockDelay(300);
        const dsr = MOCK_DATA_SUBJECT_REQUESTS.find(d => d.id === id);
        if (!dsr) throw new Error('DSR not found');
        return dsr;
    },
    updateDataSubjectRequest: async (id: string, updates: Partial<DataSubjectRequest>, noteContent?: string) => {
        await mockDelay(400);
        const index = MOCK_DATA_SUBJECT_REQUESTS.findIndex(d => d.id === id);
        if (index === -1) throw new Error('DSR not found');
        const oldDSR = MOCK_DATA_SUBJECT_REQUESTS[index];
        const updatedDSR = { ...oldDSR, ...updates };

        if (updates.status && (updates.status === 'Completed' || updates.status === 'Rejected')) {
            updatedDSR.completionDate = new Date().toISOString();
        }

        if (noteContent) {
            const newNote: RequestNote = {
                id: `note-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                authorId: 'admin_user', // Mock admin user
                timestamp: new Date().toISOString(),
                content: noteContent,
            };
            updatedDSR.notes = [...updatedDSR.notes, newNote];
        }

        MOCK_DATA_SUBJECT_REQUESTS[index] = updatedDSR;

        MOCK_AUDIT_LOG.push({
            id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            timestamp: new Date().toISOString(),
            userId: 'admin_user',
            action: updates.status ? 'DSR_STATUS_CHANGE' : 'DSR_UPDATED',
            entityType: 'DataSubjectRequest',
            entityId: id,
            details: updates.status ? `DSR status changed to ${updates.status}` : `DSR updated.`,
            affectedFields: Object.keys(updates), oldValue: oldDSR, newValue: updatedDSR,
        });
        return updatedDSR;
    },
    addDSRNote: async (dsrId: string, noteContent: string, authorId: string) => {
        await mockDelay(200);
        const index = MOCK_DATA_SUBJECT_REQUESTS.findIndex(d => d.id === dsrId);
        if (index === -1) throw new Error('DSR not found');
        const newNote: RequestNote = {
            id: `note-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            authorId,
            timestamp: new Date().toISOString(),
            content: noteContent,
        };
        MOCK_DATA_SUBJECT_REQUESTS[index].notes.push(newNote);
        MOCK_AUDIT_LOG.push({
            id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            timestamp: new Date().toISOString(),
            userId: authorId,
            action: 'DSR_NOTE_ADDED',
            entityType: 'DataSubjectRequest',
            entityId: dsrId,
            details: `Note added to DSR by ${authorId}`,
        });
        return newNote;
    },

    // --- Audit Logs ---
    fetchAuditLogs: async (filters: any = {}) => {
        await mockDelay(500);
        let logs: AuditLogEntry[] = [...MOCK_AUDIT_LOG];
        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            logs = logs.filter(l =>
                l.userId.toLowerCase().includes(searchTerm) ||
                l.action.toLowerCase().includes(searchTerm) ||
                l.details.toLowerCase().includes(searchTerm) ||
                l.entityId.toLowerCase().includes(searchTerm)
            );
        }
        if (filters.entityType && filters.entityType !== 'All') {
            logs = logs.filter(l => l.entityType === filters.entityType);
        }
        if (filters.action && filters.action !== 'All') {
            logs = logs.filter(l => l.action === filters.action);
        }
        return { data: logs, total: logs.length };
    },

    // --- Reporting ---
    fetchConsentTrendData: async (timeframe: 'week' | 'month' | 'quarter' | 'year') => {
        await mockDelay(800);
        const endDate = new Date();
        const startDate = new Date();
        if (timeframe === 'week') startDate.setDate(endDate.getDate() - 7);
        else if (timeframe === 'month') startDate.setMonth(endDate.getMonth() - 1);
        else if (timeframe === 'quarter') startDate.setMonth(endDate.getMonth() - 3);
        else if (timeframe === 'year') startDate.setFullYear(endDate.getFullYear() - 1);

        const data: ConsentTrendData[] = [];
        let current = new Date(startDate);
        while (current <= endDate) {
            const granted = Math.floor(Math.random() * 50) + 100;
            const revoked = Math.floor(Math.random() * 20) + 10;
            data.push({
                date: current.toISOString().split('T')[0],
                granted: granted,
                revoked: revoked,
                newConsents: Math.floor(granted * 0.7), // Simulate new consents being a portion of granted
                optOuts: revoked,
            });
            current.setDate(current.getDate() + 1);
        }
        return data;
    },

    // --- Data Categories ---
    fetchDataCategoryDefinitions: async (filters: any = {}) => {
        await mockDelay(300);
        let categories = [...MOCK_DATA_CATEGORY_DEFINITIONS];
        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            categories = categories.filter(c =>
                c.name.toLowerCase().includes(searchTerm) ||
                c.description.toLowerCase().includes(searchTerm)
            );
        }
        if (filters.sensitive !== undefined && filters.sensitive !== 'All') {
            categories = categories.filter(c => c.sensitive === (filters.sensitive === 'true'));
        }
        return { data: categories, total: categories.length };
    },
    createDataCategoryDefinition: async (categoryData: Omit<DataCategoryDefinition, 'id'>) => {
        await mockDelay(400);
        const newCategory: DataCategoryDefinition = {
            ...categoryData,
            id: `dc-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        };
        MOCK_DATA_CATEGORY_DEFINITIONS.push(newCategory);
        return newCategory;
    },
    updateDataCategoryDefinition: async (id: string, updates: Partial<DataCategoryDefinition>) => {
        await mockDelay(400);
        const index = MOCK_DATA_CATEGORY_DEFINITIONS.findIndex(c => c.id === id);
        if (index === -1) throw new Error('Data Category not found');
        MOCK_DATA_CATEGORY_DEFINITIONS[index] = { ...MOCK_DATA_CATEGORY_DEFINITIONS[index], ...updates };
        return MOCK_DATA_CATEGORY_DEFINITIONS[index];
    },
    deleteDataCategoryDefinition: async (id: string) => {
        await mockDelay(300);
        const initialLength = MOCK_DATA_CATEGORY_DEFINITIONS.length;
        MOCK_DATA_CATEGORY_DEFINITIONS = MOCK_DATA_CATEGORY_DEFINITIONS.filter(c => c.id !== id);
        if (MOCK_DATA_CATEGORY_DEFINITIONS.length === initialLength) throw new Error('Data Category not found for deletion.');
        return { success: true, message: 'Data category deleted.' };
    },

    // --- Third Party Integrations ---
    fetchThirdPartyIntegrations: async (filters: any = {}) => {
        await mockDelay(500);
        let integrations = [...MOCK_THIRD_PARTY_INTEGRATIONS];
        if (filters.search) {
            const searchTerm = filters.search.toLowerCase();
            integrations = integrations.filter(i =>
                i.name.toLowerCase().includes(searchTerm) ||
                i.description.toLowerCase().includes(searchTerm) ||
                i.regions.some(r => r.toLowerCase().includes(searchTerm))
            );
        }
        if (filters.status && filters.status !== 'All') {
            integrations = integrations.filter(i => i.status === filters.status);
        }
        return { data: integrations, total: integrations.length };
    },
    updateThirdPartyIntegration: async (id: string, updates: Partial<ThirdPartyIntegration>) => {
        await mockDelay(400);
        const index = MOCK_THIRD_PARTY_INTEGRATIONS.findIndex(i => i.id === id);
        if (index === -1) throw new Error('Integration not found');
        MOCK_THIRD_PARTY_INTEGRATIONS[index] = { ...MOCK_THIRD_PARTY_INTEGRATIONS[index], ...updates };
        MOCK_THIRD_PARTY_INTEGRATIONS[index].lastReviewedAt = new Date().toISOString();
        return MOCK_THIRD_PARTY_INTEGRATIONS[index];
    },
};

// --- REUSABLE UI COMPONENTS ---
export const Modal: React.FC<{ isOpen: boolean; onClose: () => void; title: string; children: React.ReactNode; size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' }> = ({ isOpen, onClose, title, children, size = 'xl' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-sm', md: 'max-w-md', lg: 'max-w-lg', xl: 'max-w-xl', '2xl': 'max-w-2xl', '3xl': 'max-w-3xl', '4xl': 'max-w-4xl'
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className={`bg-gray-800 rounded-lg shadow-2xl w-full ${sizeClasses[size]} mx-auto`} onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
                </div>
                <div className="p-6 max-h-[80vh] overflow-y-auto">
                    {children}
                </div>
            </div>
        </div>
    );
};

export const Table: React.FC<{
    headers: { key: string; label: string; sortable?: boolean; className?: string }[];
    data: any[];
    renderRow: (item: any) => React.ReactNode;
    onSort?: (key: string) => void;
    sortConfig?: { key: string; direction: 'ascending' | 'descending' } | null;
    rowKeyExtractor?: (item: any) => string | number;
}> = ({ headers, data, renderRow, onSort, sortConfig, rowKeyExtractor = (item) => item.id || Math.random() }) => {
    return (
        <div className="overflow-x-auto rounded-lg border border-gray-700">
            <table className="min-w-full divide-y divide-gray-700">
                <thead className="bg-gray-700">
                    <tr>
                        {headers.map((header) => (
                            <th
                                key={header.key}
                                scope="col"
                                className={`px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider ${header.sortable ? 'cursor-pointer hover:bg-gray-600' : ''} ${header.className || ''}`}
                                onClick={() => header.sortable && onSort && onSort(header.key)}
                            >
                                {header.label}
                                {header.sortable && sortConfig?.key === header.key && (
                                    <span className="ml-1">{sortConfig.direction === 'ascending' ? 'â–²' : 'â–¼'}</span>
                                )}
                            </th>
                        ))}
                    </tr>
                </thead>
                <tbody className="bg-gray-800 divide-y divide-gray-700">
                    {data.length === 0 ? (
                        <tr>
                            <td colSpan={headers.length} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                                No data available.
                            </td>
                        </tr>
                    ) : (
                        data.map((item) => (
                            <tr key={rowKeyExtractor(item)} className="hover:bg-gray-700">
                                {renderRow(item)}
                            </tr>
                        ))
                    )}
                </tbody>
            </table>
        </div>
    );
};

export const Pagination: React.FC<{
    currentPage: number;
    maxPage: number;
    next: () => void;
    prev: () => void;
    jump: (page: number) => void;
}> = ({ currentPage, maxPage, next, prev, jump }) => {
    const pageNumbers = useMemo(() => {
        const pages: (number | string)[] = [];
        if (maxPage <= 5) {
            for (let i = 1; i <= maxPage; i++) pages.push(i);
        } else {
            const start = Math.max(1, currentPage - 1);
            const end = Math.min(maxPage, currentPage + 1);

            if (start > 1) {
                pages.push(1);
                if (start > 2) pages.push('...');
            }

            for (let i = start; i <= end; i++) {
                pages.push(i);
            }

            if (end < maxPage) {
                if (end < maxPage - 1) pages.push('...');
                pages.push(maxPage);
            }
        }
        return Array.from(new Set(pages)); // Remove duplicates
    }, [currentPage, maxPage]);

    return (
        <nav className="mt-4 flex items-center justify-between text-white">
            <button onClick={prev} disabled={currentPage === 1} className="px-3 py-1 bg-gray-700 rounded-md disabled:opacity-50 hover:bg-gray-600 transition-colors duration-200">Previous</button>
            <ul className="flex space-x-2">
                {pageNumbers.map((page, index) => (
                    <li key={index}>
                        {typeof page === 'number' ? (
                            <button
                                onClick={() => jump(page)}
                                className={`px-3 py-1 rounded-md ${currentPage === page ? 'bg-cyan-600' : 'bg-gray-700 hover:bg-gray-600'} transition-colors duration-200`}
                            >
                                {page}
                            </button>
                        ) : (
                            <span className="px-3 py-1 text-gray-400">...</span>
                        )}
                    </li>
                ))}
            </ul>
            <button onClick={next} disabled={currentPage === maxPage} className="px-3 py-1 bg-gray-700 rounded-md disabled:opacity-50 hover:bg-gray-600 transition-colors duration-200">Next</button>
        </nav>
    );
};

export const FilterDropdown: React.FC<{
    label: string;
    options: { value: string; label: string }[];
    selectedValue: string;
    onChange: (value: string) => void;
    className?: string;
    includeAllOption?: boolean;
    allOptionLabel?: string;
}> = ({ label, options, selectedValue, onChange, className, includeAllOption = true, allOptionLabel = 'All' }) => {
    const allOptions = includeAllOption ? [{ value: 'All', label: allOptionLabel }, ...options] : options;
    return (
        <div className={`flex flex-col ${className}`}>
            <label htmlFor={`filter-${label.replace(/\s/g, '-')}`} className="text-sm font-medium text-gray-300 mb-1">{label}</label>
            <select
                id={`filter-${label.replace(/\s/g, '-')}`}
                value={selectedValue}
                onChange={(e) => onChange(e.target.value)}
                className="bg-gray-700/50 text-white border border-gray-600 rounded-md py-2 px-3 focus:outline-none focus:ring-1 focus:ring-cyan-500 appearance-none bg-no-repeat bg-right-center pr-8"
                style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%239CA3AF' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E")`, backgroundSize: '1.5em 1.5em' }}
            >
                {allOptions.map((option) => (
                    <option key={option.value} value={option.value}>{option.label}</option>
                ))}
            </select>
        </div>
    );
};

// --- NEW MAIN SECTIONS/COMPONENTS ---

export const ConsentRecordsManagement: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("ConsentRecordsManagement must be within DataProvider");
    const { consentRecords, updateConsentRecordInContext } = context;

    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterType, setFilterType] = useState('All');
    const [filterStatus, setFilterStatus] = useState('All');
    const [selectedRecord, setSelectedRecord] = useState<ConsentRecord | null>(null);
    const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);
    const [isLoadingRecordUpdate, setIsLoadingRecordUpdate] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const filteredRecords = useMemo(() => {
        let currentRecords = [...consentRecords];

        if (debouncedSearchTerm) {
            const lowerCaseSearchTerm = debouncedSearchTerm.toLowerCase();
            currentRecords = currentRecords.filter(r =>
                r.userId.toLowerCase().includes(lowerCaseSearchTerm) ||
                r.consentType.toLowerCase().includes(lowerCaseSearchTerm) ||
                r.status.toLowerCase().includes(lowerCaseSearchTerm) ||
                r.details.toLowerCase().includes(lowerCaseSearchTerm) ||
                r.source.toLowerCase().includes(lowerCaseSearchTerm) ||
                r.legalBasis.toLowerCase().includes(lowerCaseSearchTerm)
            );
        }
        if (filterType !== 'All') {
            currentRecords = currentRecords.filter(r => r.consentType === filterType);
        }
        if (filterStatus !== 'All') {
            currentRecords = currentRecords.filter(r => r.status === filterStatus);
        }
        return currentRecords;
    }, [consentRecords, debouncedSearchTerm, filterType, filterStatus]);

    const { sortedData, requestSort, sortConfig } = useSort(filteredRecords, { key: 'timestamp', direction: 'descending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 10);

    const handleViewDetails = (record: ConsentRecord) => {
        setSelectedRecord(record);
        setIsDetailModalOpen(true);
    };

    const handleUpdateRecordStatus = async (recordId: string, newStatus: 'Granted' | 'Revoked') => {
        setIsLoadingRecordUpdate(true);
        setError(null);
        try {
            const updatedRecordData = { ...selectedRecord!, status: newStatus, timestamp: new Date().toISOString() };
            // Optimistically update UI
            setSelectedRecord(updatedRecordData);
            updateConsentRecordInContext(updatedRecordData); // Update context immediately

            await mockApi.updateConsentRecordStatus(recordId, newStatus);
            // After successful mock API call, the context update should be authoritative.

            MOCK_AUDIT_LOG.push({
                id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                timestamp: new Date().toISOString(),
                userId: 'admin_user',
                action: newStatus === 'Granted' ? 'CONSENT_GRANTED' : 'CONSENT_REVOKED',
                entityType: 'ConsentRecord',
                entityId: recordId,
                details: `Consent for ${selectedRecord?.consentType} ${newStatus} for user ${selectedRecord?.userId}.`,
                affectedFields: ['status'], oldValue: selectedRecord?.status, newValue: newStatus,
            });

            setIsDetailModalOpen(false);
        } catch (err: any) {
            setError('Failed to update consent status: ' + err.message);
            // In a real app, you would revert the optimistic update here.
            const originalRecord = consentRecords.find(r => r.id === recordId);
            if (originalRecord) {
                setSelectedRecord(originalRecord);
                updateConsentRecordInContext(originalRecord);
            }
        } finally {
            setIsLoadingRecordUpdate(false);
        }
    };

    return (
        <Card title="All Consent Records" className="col-span-full">
            <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search by User ID, Type, Status, Details..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Consent Type"
                    options={[{ value: 'Marketing', label: 'Marketing' }, { value: 'Data Sharing', label: 'Data Sharing' }, { value: 'Analytics', label: 'Analytics' }, { value: 'Essential', label: 'Essential' }]}
                    selectedValue={filterType}
                    onChange={setFilterType}
                />
                <FilterDropdown
                    label="Status"
                    options={[{ value: 'Granted', label: 'Granted' }, { value: 'Revoked', label: 'Revoked' }]}
                    selectedValue={filterStatus}
                    onChange={setFilterStatus}
                />
            </div>
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'userId', label: 'User ID', sortable: true },
                    { key: 'consentType', label: 'Type', sortable: true },
                    { key: 'status', label: 'Status', sortable: true },
                    { key: 'legalBasis', label: 'Legal Basis', sortable: true },
                    { key: 'source', label: 'Source', sortable: true },
                    { key: 'timestamp', label: 'Last Updated', sortable: true },
                    { key: 'actions', label: 'Actions', className: 'w-24 text-center' },
                ]}
                data={currentData}
                renderRow={(record: ConsentRecord) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{record.userId}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{record.consentType}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${record.status === 'Granted' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                {record.status}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{record.legalBasis}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{record.source}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(record.timestamp).toLocaleString()}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-center">
                            <button onClick={() => handleViewDetails(record)} className="text-cyan-500 hover:text-cyan-700 transition-colors duration-200">View</button>
                        </td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof ConsentRecord)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />

            <Modal isOpen={isDetailModalOpen} onClose={() => setIsDetailModalOpen(false)} title="Consent Record Details" size="md">
                {selectedRecord && (
                    <div className="space-y-4 text-white">
                        <p><strong>User ID:</strong> {selectedRecord.userId}</p>
                        <p><strong>Consent Type:</strong> {selectedRecord.consentType}</p>
                        <p><strong>Status:</strong> <span className={`font-semibold ${selectedRecord.status === 'Granted' ? 'text-green-400' : 'text-red-400'}`}>{selectedRecord.status}</span></p>
                        <p><strong>Legal Basis:</strong> {selectedRecord.legalBasis}</p>
                        <p><strong>Source:</strong> {selectedRecord.source}</p>
                        <p><strong>Timestamp:</strong> {new Date(selectedRecord.timestamp).toLocaleString()}</p>
                        {selectedRecord.expirationDate && <p><strong>Expiration:</strong> {new Date(selectedRecord.expirationDate).toLocaleString()}</p>}
                        <p><strong>Details:</strong> {selectedRecord.details}</p>

                        <div className="pt-4 border-t border-gray-700 flex space-x-4">
                            <button
                                onClick={() => handleUpdateRecordStatus(selectedRecord.id, selectedRecord.status === 'Granted' ? 'Revoked' : 'Granted')}
                                disabled={isLoadingRecordUpdate}
                                className={`px-4 py-2 rounded-lg text-white font-medium ${selectedRecord.status === 'Granted' ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'} disabled:opacity-50 transition-colors duration-200`}
                            >
                                {isLoadingRecordUpdate ? 'Updating...' : (selectedRecord.status === 'Granted' ? 'Revoke Consent' : 'Grant Consent')}
                            </button>
                            <button onClick={() => setIsDetailModalOpen(false)} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white font-medium transition-colors duration-200">Close</button>
                        </div>
                    </div>
                )}
            </Modal>
        </Card>
    );
};

export const ConsentPoliciesManagement: React.FC = () => {
    const [policies, setPolicies] = useState<ConsentPolicy[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterActive, setFilterActive] = useState('All'); // 'All', 'true', 'false'

    const [isFormModalOpen, setIsFormModalOpen] = useState(false);
    const [editingPolicy, setEditingPolicy] = useState<ConsentPolicy | null>(null);

    const fetchPolicies = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const filters: any = { search: debouncedSearchTerm };
            if (filterActive !== 'All') {
                filters.isActive = filterActive === 'true';
            }
            const response = await mockApi.fetchConsentPolicies(filters);
            setPolicies(response.data);
        } catch (err: any) {
            setError('Failed to fetch policies: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    }, [debouncedSearchTerm, filterActive]);

    useEffect(() => {
        fetchPolicies();
    }, [fetchPolicies]);

    const handleCreatePolicy = () => {
        setEditingPolicy(null);
        setIsFormModalOpen(true);
    };

    const handleEditPolicy = (policy: ConsentPolicy) => {
        setEditingPolicy(policy);
        setIsFormModalOpen(true);
    };

    const handleDeletePolicy = async (policyId: string) => {
        if (!confirm('Are you sure you want to delete this policy? This action cannot be undone.')) return;
        setIsLoading(true);
        setError(null);
        try {
            await mockApi.deleteConsentPolicy(policyId);
            await fetchPolicies();
            MOCK_AUDIT_LOG.push({
                id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                timestamp: new Date().toISOString(),
                userId: 'admin_user',
                action: 'POLICY_DELETED',
                entityType: 'ConsentPolicy',
                entityId: policyId,
                details: `Consent policy ${policyId} deleted.`,
            });
        } catch (err: any) {
            setError('Failed to delete policy: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handlePolicyFormSubmit = async (policyData: ConsentPolicy) => {
        setIsLoading(true);
        setError(null);
        try {
            let resultPolicy: ConsentPolicy;
            if (editingPolicy) {
                resultPolicy = await mockApi.updateConsentPolicy(policyData.id, policyData);
                MOCK_AUDIT_LOG.push({
                    id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                    timestamp: new Date().toISOString(),
                    userId: 'admin_user',
                    action: 'POLICY_UPDATED',
                    entityType: 'ConsentPolicy',
                    entityId: policyData.id,
                    details: `Consent policy "${policyData.name}" updated to version ${resultPolicy.version}.`,
                });
            } else {
                const { id, createdAt, updatedAt, version, lastReviewedAt, nextReviewAt, ...rest } = policyData; // Exclude generated fields
                resultPolicy = await mockApi.createConsentPolicy(rest);
                MOCK_AUDIT_LOG.push({
                    id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                    timestamp: new Date().toISOString(),
                    userId: 'admin_user',
                    action: 'POLICY_CREATED',
                    entityType: 'ConsentPolicy',
                    entityId: resultPolicy.id,
                    details: `New consent policy "${resultPolicy.name}" created.`,
                });
            }
            setIsFormModalOpen(false);
            setEditingPolicy(null);
            await fetchPolicies();
        } catch (err: any) {
            setError('Failed to save policy: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const { sortedData, requestSort, sortConfig } = useSort(policies, { key: 'updatedAt', direction: 'descending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 8);

    return (
        <Card title="Consent Policies" className="col-span-full">
            <div className="flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search policies by name, description, legal basis..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Status"
                    options={[{ value: 'true', label: 'Active' }, { value: 'false', label: 'Inactive' }]}
                    selectedValue={filterActive}
                    onChange={setFilterActive}
                    className="w-full md:w-auto"
                    allOptionLabel="All Statuses"
                />
                <button onClick={handleCreatePolicy} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium w-full md:w-auto transition-colors duration-200">
                    + New Policy
                </button>
            </div>
            {isLoading && <p className="text-white text-center py-4">Loading policies...</p>}
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'name', label: 'Policy Name', sortable: true },
                    { key: 'legalBasis', label: 'Legal Basis', sortable: true },
                    { key: 'regions', label: 'Regions' },
                    { key: 'version', label: 'Version', sortable: true },
                    { key: 'isActive', label: 'Active', sortable: true },
                    { key: 'lastReviewedAt', label: 'Last Reviewed', sortable: true },
                    { key: 'nextReviewAt', label: 'Next Review', sortable: true },
                    { key: 'actions', label: 'Actions', className: 'w-32 text-center' },
                ]}
                data={currentData}
                renderRow={(policy: ConsentPolicy) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.name}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.legalBasis}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.regions.join(', ')}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.version}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${policy.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                {policy.isActive ? 'Yes' : 'No'}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(policy.lastReviewedAt || policy.createdAt).toLocaleDateString()}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.nextReviewAt ? new Date(policy.nextReviewAt).toLocaleDateString() : 'N/A'}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-center">
                            <button onClick={() => handleEditPolicy(policy)} className="text-indigo-500 hover:text-indigo-700 mr-3 transition-colors duration-200">Edit</button>
                            <button onClick={() => handleDeletePolicy(policy.id)} className="text-red-500 hover:text-red-700 transition-colors duration-200">Delete</button>
                        </td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof ConsentPolicy)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />

            <Modal isOpen={isFormModalOpen} onClose={() => setIsFormModalOpen(false)} title={editingPolicy ? "Edit Consent Policy" : "Create New Consent Policy"} size="3xl">
                <ConsentPolicyForm
                    policy={editingPolicy}
                    onSubmit={handlePolicyFormSubmit}
                    onCancel={() => setIsFormModalOpen(false)}
                    isLoading={isLoading}
                />
            </Modal>
        </Card>
    );
};

export const ConsentPolicyForm: React.FC<{
    policy: ConsentPolicy | null;
    onSubmit: (policyData: ConsentPolicy) => void;
    onCancel: () => void;
    isLoading: boolean;
}> = ({ policy, onSubmit, onCancel, isLoading }) => {
    const [formData, setFormData] = useState<ConsentPolicy>(policy || {
        id: '',
        name: '',
        description: '',
        dataCategories: [],
        legalBasis: 'Consent',
        retentionPeriod: '',
        version: 1,
        isActive: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        regions: [],
        purpose: '',
        thirdPartySharing: false,
        thirdPartyList: [],
        isAutomatedDecisionMaking: false,
        automatedDecisionDetails: '',
        reviewCycleInDays: 365,
        lastReviewedAt: undefined,
        nextReviewAt: undefined,
    });

    useEffect(() => {
        setFormData(policy || {
            id: '', name: '', description: '', dataCategories: [], legalBasis: 'Consent', retentionPeriod: '',
            version: 1, isActive: true, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
            regions: [], purpose: '', thirdPartySharing: false, thirdPartyList: [],
            isAutomatedDecisionMaking: false, automatedDecisionDetails: '', reviewCycleInDays: 365,
            lastReviewedAt: undefined, nextReviewAt: undefined,
        });
    }, [policy]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    const handleArrayChange = (name: keyof ConsentPolicy, value: string) => {
        setFormData(prev => ({
            ...prev,
            [name]: value.split(',').map(s => s.trim()).filter(s => s.length > 0)
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSubmit(formData);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-white">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label htmlFor="name" className="block text-sm font-medium text-gray-300">Policy Name</label>
                    <input type="text" id="name" name="name" value={formData.name} onChange={handleChange} required
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
                <div>
                    <label htmlFor="purpose" className="block text-sm font-medium text-gray-300">Purpose</label>
                    <input type="text" id="purpose" name="purpose" value={formData.purpose} onChange={handleChange} required
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
                <div className="md:col-span-2">
                    <label htmlFor="description" className="block text-sm font-medium text-gray-300">Description</label>
                    <textarea id="description" name="description" value={formData.description} onChange={handleChange} rows={3} required
                              className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
                </div>
                <div>
                    <label htmlFor="dataCategories" className="block text-sm font-medium text-gray-300">Data Categories (comma-separated)</label>
                    <input type="text" id="dataCategories" name="dataCategories" value={formData.dataCategories.join(', ')} onChange={(e) => handleArrayChange('dataCategories', e.target.value)}
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
                <div>
                    <label htmlFor="legalBasis" className="block text-sm font-medium text-gray-300">Legal Basis</label>
                    <select id="legalBasis" name="legalBasis" value={formData.legalBasis} onChange={handleChange} required
                            className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500 appearance-none bg-no-repeat bg-right-center pr-8"
                            style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%239CA3AF' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E")`, backgroundSize: '1.5em 1.5em' }}>
                        <option value="Consent">Consent</option>
                        <option value="Contract">Contract</option>
                        <option value="Legitimate Interest">Legitimate Interest</option>
                        <option value="Legal Obligation">Legal Obligation</option>
                        <option value="Public Task">Public Task</option>
                        <option value="Vital Interests">Vital Interests</option>
                    </select>
                </div>
                <div>
                    <label htmlFor="retentionPeriod" className="block text-sm font-medium text-gray-300">Retention Period</label>
                    <input type="text" id="retentionPeriod" name="retentionPeriod" value={formData.retentionPeriod} onChange={handleChange} required
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
                <div>
                    <label htmlFor="regions" className="block text-sm font-medium text-gray-300">Regions (comma-separated, e.g., EU, US, Global)</label>
                    <input type="text" id="regions" name="regions" value={formData.regions.join(', ')} onChange={(e) => handleArrayChange('regions', e.target.value)}
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
                <div>
                    <label htmlFor="reviewCycleInDays" className="block text-sm font-medium text-gray-300">Review Cycle (Days)</label>
                    <input type="number" id="reviewCycleInDays" name="reviewCycleInDays" value={formData.reviewCycleInDays} onChange={handleChange} required min="1"
                           className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                </div>
            </div>

            <div className="pt-4 border-t border-gray-700 grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="flex items-center space-x-2">
                    <input type="checkbox" id="thirdPartySharing" name="thirdPartySharing" checked={formData.thirdPartySharing} onChange={handleChange}
                           className="h-4 w-4 text-cyan-600 focus:ring-cyan-500 border-gray-600 rounded bg-gray-700/50" />
                    <label htmlFor="thirdPartySharing" className="text-sm font-medium text-gray-300">Third-Party Sharing</label>
                </div>
                <div className="flex items-center space-x-2">
                    <input type="checkbox" id="isAutomatedDecisionMaking" name="isAutomatedDecisionMaking" checked={formData.isAutomatedDecisionMaking} onChange={handleChange}
                           className="h-4 w-4 text-cyan-600 focus:ring-cyan-500 border-gray-600 rounded bg-gray-700/50" />
                    <label htmlFor="isAutomatedDecisionMaking" className="text-sm font-medium text-gray-300">Automated Decision Making</label>
                </div>
                {formData.thirdPartySharing && (
                    <div className="md:col-span-2">
                        <label htmlFor="thirdPartyList" className="block text-sm font-medium text-gray-300">Third Parties (comma-separated)</label>
                        <input type="text" id="thirdPartyList" name="thirdPartyList" value={formData.thirdPartyList.join(', ')} onChange={(e) => handleArrayChange('thirdPartyList', e.target.value)}
                               className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
                    </div>
                )}
                {formData.isAutomatedDecisionMaking && (
                    <div className="md:col-span-2">
                        <label htmlFor="automatedDecisionDetails" className="block text-sm font-medium text-gray-300">Automated Decision Details</label>
                        <textarea id="automatedDecisionDetails" name="automatedDecisionDetails" value={formData.automatedDecisionDetails} onChange={handleChange} rows={2}
                                  className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
                    </div>
                )}
                <div className="flex items-center space-x-2 md:col-span-2">
                    <input type="checkbox" id="isActive" name="isActive" checked={formData.isActive} onChange={handleChange}
                           className="h-4 w-4 text-cyan-600 focus:ring-cyan-500 border-gray-600 rounded bg-gray-700/50" />
                    <label htmlFor="isActive" className="text-sm font-medium text-gray-300">Active Policy</label>
                </div>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white font-medium transition-colors duration-200">Cancel</button>
                <button type="submit" disabled={isLoading} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-white font-medium disabled:opacity-50 transition-colors duration-200">
                    {isLoading ? 'Saving...' : (policy ? 'Update Policy' : 'Create Policy')}
                </button>
            </div>
        </form>
    );
};

export const DataSubjectRequestsManagement: React.FC = () => {
    const [dsrs, setDsrs] = useState<DataSubjectRequest[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterType, setFilterType] = useState('All');
    const [filterStatus, setFilterStatus] = useState('All');
    const [filterPriority, setFilterPriority] = useState('All');

    const [isDetailModalOpen, setIsDetailModalOpen] = useState(false);
    const [selectedDSR, setSelectedDSR] = useState<DataSubjectRequest | null>(null);

    const fetchDSRs = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const filters: any = { search: debouncedSearchTerm };
            if (filterType !== 'All') filters.type = filterType;
            if (filterStatus !== 'All') filters.status = filterStatus;
            if (filterPriority !== 'All') filters.priority = filterPriority;
            const response = await mockApi.fetchDataSubjectRequests(filters);
            setDsrs(response.data);
        } catch (err: any) {
            setError('Failed to fetch DSRs: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    }, [debouncedSearchTerm, filterType, filterStatus, filterPriority]);

    useEffect(() => {
        fetchDSRs();
    }, [fetchDSRs]);

    const handleViewDetails = (dsr: DataSubjectRequest) => {
        setSelectedDSR(dsr);
        setIsDetailModalOpen(true);
    };

    const handleUpdateDSR = async (dsrId: string, updates: Partial<DataSubjectRequest>, noteContent?: string) => {
        setIsLoading(true);
        setError(null);
        try {
            const updatedDSR = await mockApi.updateDataSubjectRequest(dsrId, updates, noteContent);
            setDsrs(prev => prev.map(d => d.id === dsrId ? updatedDSR : d));
            setSelectedDSR(updatedDSR); // Update selected DSR in modal
        } catch (err: any) {
            setError('Failed to update DSR: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleAddNote = async (dsrId: string, noteContent: string) => {
        setIsLoading(true);
        setError(null);
        try {
            const newNote = await mockApi.addDSRNote(dsrId, noteContent, 'admin_user');
            setDsrs(prev => prev.map(d => d.id === dsrId ? { ...d, notes: [...d.notes, newNote] } : d));
            if (selectedDSR && selectedDSR.id === dsrId) {
                setSelectedDSR(prev => prev ? { ...prev, notes: [...prev.notes, newNote] } : null);
            }
        } catch (err: any) {
            setError('Failed to add note: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const { sortedData, requestSort, sortConfig } = useSort(dsrs, { key: 'submissionDate', direction: 'descending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 10);

    return (
        <Card title="Data Subject Requests" className="col-span-full">
            <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search by User ID, Request Type, Status, Details..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Request Type"
                    options={[{ value: 'Access', label: 'Access' }, { value: 'Erasure', label: 'Erasure' }, { value: 'Rectification', label: 'Rectification' }, { value: 'Portability', label: 'Portability' }, { value: 'Objection', label: 'Objection' }, { value: 'Restriction', label: 'Restriction' }]}
                    selectedValue={filterType}
                    onChange={setFilterType}
                />
                <FilterDropdown
                    label="Status"
                    options={[{ value: 'Pending', label: 'Pending' }, { value: 'In Progress', label: 'In Progress' }, { value: 'Completed', label: 'Completed' }, { value: 'Rejected', label: 'Rejected' }, { value: 'On Hold', label: 'On Hold' }]}
                    selectedValue={filterStatus}
                    onChange={setFilterStatus}
                />
                <FilterDropdown
                    label="Priority"
                    options={[{ value: 'Low', label: 'Low' }, { value: 'Medium', label: 'Medium' }, { value: 'High', label: 'High' }, { value: 'Urgent', label: 'Urgent' }]}
                    selectedValue={filterPriority}
                    onChange={setFilterPriority}
                />
            </div>
            {isLoading && <p className="text-white text-center py-4">Loading DSRs...</p>}
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'userId', label: 'User ID', sortable: true },
                    { key: 'requestType', label: 'Type', sortable: true },
                    { key: 'status', label: 'Status', sortable: true },
                    { key: 'priority', label: 'Priority', sortable: true },
                    { key: 'submissionDate', label: 'Submitted', sortable: true },
                    { key: 'dueDate', label: 'Due Date', sortable: true },
                    { key: 'actions', label: 'Actions', className: 'w-28 text-center' },
                ]}
                data={currentData}
                renderRow={(dsr: DataSubjectRequest) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{dsr.userId}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{dsr.requestType}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full
                                ${dsr.status === 'Completed' ? 'bg-green-100 text-green-800' :
                                dsr.status === 'In Progress' ? 'bg-yellow-100 text-yellow-800' :
                                dsr.status === 'Pending' ? 'bg-blue-100 text-blue-800' :
                                dsr.status === 'On Hold' ? 'bg-purple-100 text-purple-800' :
                                'bg-red-100 text-red-800'}`
                            }>
                                {dsr.status}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full
                                ${dsr.priority === 'Urgent' ? 'bg-red-700 text-white' :
                                dsr.priority === 'High' ? 'bg-orange-600 text-white' :
                                dsr.priority === 'Medium' ? 'bg-yellow-500 text-gray-900' :
                                'bg-gray-500 text-white'}`
                            }>
                                {dsr.priority}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(dsr.submissionDate).toLocaleDateString()}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                            {new Date(dsr.dueDate).toLocaleDateString()}
                            {new Date(dsr.dueDate) < new Date() && dsr.status !== 'Completed' && dsr.status !== 'Rejected' && <span className="ml-2 text-red-500 font-bold">(OVERDUE)</span>}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-center">
                            <button onClick={() => handleViewDetails(dsr)} className="text-cyan-500 hover:text-cyan-700 transition-colors duration-200">View Details</button>
                        </td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof DataSubjectRequest)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />

            <Modal isOpen={isDetailModalOpen} onClose={() => setIsDetailModalOpen(false)} title="Data Subject Request Details" size="3xl">
                {selectedDSR && (
                    <DSRDetailView
                        dsr={selectedDSR}
                        onUpdateDSR={handleUpdateDSR}
                        onAddNote={handleAddNote}
                        isLoading={isLoading}
                        error={error}
                    />
                )}
            </Modal>
        </Card>
    );
};

export const DSRDetailView: React.FC<{
    dsr: DataSubjectRequest;
    onUpdateDSR: (id: string, updates: Partial<DataSubjectRequest>, noteContent?: string) => Promise<void>;
    onAddNote: (id: string, noteContent: string) => Promise<void>;
    isLoading: boolean;
    error: string | null;
}> = ({ dsr, onUpdateDSR, onAddNote, isLoading, error }) => {
    const [newNoteContent, setNewNoteContent] = useState('');
    const [statusChangeNote, setStatusChangeNote] = useState('');
    const [selectedStatus, setSelectedStatus] = useState<DataSubjectRequest['status']>(dsr.status);
    const [selectedPriority, setSelectedPriority] = useState<DataSubjectRequest['priority']>(dsr.priority);
    const [assignedTo, setAssignedTo] = useState<string>(dsr.assignedTo || '');
    const [dueDate, setDueDate] = useState<string>(new Date(dsr.dueDate).toISOString().split('T')[0]);

    useEffect(() => {
        setSelectedStatus(dsr.status);
        setSelectedPriority(dsr.priority);
        setAssignedTo(dsr.assignedTo || '');
        setDueDate(new Date(dsr.dueDate).toISOString().split('T')[0]);
    }, [dsr]);

    const handleUpdateDetails = async () => {
        const updates: Partial<DataSubjectRequest> = {};
        let note = '';
        if (selectedStatus !== dsr.status) {
            updates.status = selectedStatus;
            note += `Status changed from ${dsr.status} to ${selectedStatus}. `;
        }
        if (selectedPriority !== dsr.priority) {
            updates.priority = selectedPriority;
            note += `Priority changed from ${dsr.priority} to ${selectedPriority}. `;
        }
        if (assignedTo !== dsr.assignedTo) {
            updates.assignedTo = assignedTo;
            note += `Assigned to ${assignedTo || 'Unassigned'}. `;
        }
        if (dueDate !== new Date(dsr.dueDate).toISOString().split('T')[0]) {
            updates.dueDate = new Date(dueDate).toISOString();
            note += `Due date changed to ${new Date(dueDate).toLocaleDateString()}. `;
        }

        if (Object.keys(updates).length > 0) {
            await onUpdateDSR(dsr.id, updates, statusChangeNote ? note + statusChangeNote : note.trim());
            setStatusChangeNote('');
        }
    };

    const handleNoteSubmit = async () => {
        if (newNoteContent.trim()) {
            await onAddNote(dsr.id, newNoteContent);
            setNewNoteContent('');
        }
    };

    const getStatusColor = (status: DataSubjectRequest['status']) => {
        switch (status) {
            case 'Completed': return 'text-green-400';
            case 'In Progress': return 'text-yellow-400';
            case 'Pending': return 'text-blue-400';
            case 'On Hold': return 'text-purple-400';
            case 'Rejected': return 'text-red-400';
            default: return 'text-gray-400';
        }
    };

    const getPriorityColor = (priority: DataSubjectRequest['priority']) => {
        switch (priority) {
            case 'Urgent': return 'bg-red-700 text-white';
            case 'High': return 'bg-orange-600 text-white';
            case 'Medium': return 'bg-yellow-500 text-gray-900';
            case 'Low': return 'bg-gray-500 text-white';
            default: return 'bg-gray-700 text-white';
        }
    };

    return (
        <div className="space-y-6 text-white">
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <p><strong>User ID:</strong> {dsr.userId}</p>
                <p><strong>Request Type:</strong> {dsr.requestType}</p>
                <p><strong>Status:</strong> <span className={`font-semibold ${getStatusColor(dsr.status)}`}>{dsr.status}</span></p>
                <p><strong>Priority:</strong> <span className={`font-semibold px-2 py-1 rounded-full text-xs ${getPriorityColor(dsr.priority)}`}>{dsr.priority}</span></p>
                <p><strong>Submission Date:</strong> {new Date(dsr.submissionDate).toLocaleString()}</p>
                <p><strong>Due Date:</strong> {new Date(dsr.dueDate).toLocaleDateString()} {new Date(dsr.dueDate) < new Date() && dsr.status !== 'Completed' && dsr.status !== 'Rejected' && <span className="ml-2 text-red-500">(OVERDUE)</span>}</p>
                <p className="md:col-span-2"><strong>Completion Date:</strong> {dsr.completionDate ? new Date(dsr.completionDate).toLocaleString() : 'N/A'}</p>
            </div>
            <div>
                <p className="font-semibold mb-2">Details:</p>
                <p className="p-3 bg-gray-700/50 rounded text-sm whitespace-pre-line">{dsr.details}</p>
            </div>
            <div>
                <p className="font-semibold mb-2">Requested Data Categories:</p>
                <div className="flex flex-wrap gap-2">
                    {dsr.requestedDataCategories.map(cat => (
                        <span key={cat} className="px-3 py-1 bg-gray-700 rounded-full text-xs">{cat}</span>
                    ))}
                </div>
            </div>

            <div className="space-y-4 pt-4 border-t border-gray-700">
                <h4 className="text-lg font-semibold">Update Request Details</h4>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <FilterDropdown
                        label="Status"
                        options={[{ value: 'Pending', label: 'Pending' }, { value: 'In Progress', label: 'In Progress' }, { value: 'Completed', label: 'Completed' }, { value: 'Rejected', label: 'Rejected' }, { value: 'On Hold', label: 'On Hold' }]}
                        selectedValue={selectedStatus}
                        onChange={setSelectedStatus}
                        includeAllOption={false}
                    />
                    <FilterDropdown
                        label="Priority"
                        options={[{ value: 'Low', label: 'Low' }, { value: 'Medium', label: 'Medium' }, { value: 'High', label: 'High' }, { value: 'Urgent', label: 'Urgent' }]}
                        selectedValue={selectedPriority}
                        onChange={setSelectedPriority}
                        includeAllOption={false}
                    />
                    <div>
                        <label htmlFor="assignedTo" className="block text-sm font-medium text-gray-300 mb-1">Assigned To</label>
                        <input
                            type="text"
                            id="assignedTo"
                            value={assignedTo}
                            onChange={(e) => setAssignedTo(e.target.value)}
                            placeholder="Assignee ID or Name"
                            className="w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"
                        />
                    </div>
                    <div>
                        <label htmlFor="dueDate" className="block text-sm font-medium text-gray-300 mb-1">Due Date</label>
                        <input
                            type="date"
                            id="dueDate"
                            value={dueDate}
                            onChange={(e) => setDueDate(e.target.value)}
                            className="w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"
                        />
                    </div>
                </div>
                <div className="col-span-full">
                    <label htmlFor="statusNote" className="block text-sm font-medium text-gray-300 mb-1">Add Note for Update (Optional)</label>
                    <textarea
                        id="statusNote"
                        value={statusChangeNote}
                        onChange={(e) => setStatusChangeNote(e.target.value)}
                        placeholder="Explain changes or additional details..."
                        rows={2}
                        className="w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"
                    ></textarea>
                </div>
                <button onClick={handleUpdateDetails} disabled={isLoading}
                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-white font-medium disabled:opacity-50 transition-colors duration-200">
                    {isLoading ? 'Updating...' : 'Save Changes'}
                </button>
            </div>

            <div className="space-y-4 pt-4 border-t border-gray-700">
                <h4 className="text-lg font-semibold">Notes & Audit Trail</h4>
                <div className="max-h-60 overflow-y-auto bg-gray-700/30 p-4 rounded-md space-y-3">
                    {dsr.notes.length === 0 ? (
                        <p className="text-gray-400">No notes for this request yet.</p>
                    ) : (
                        dsr.notes.map(note => (
                            <div key={note.id} className="border-b border-gray-600 pb-3 last:border-b-0 last:pb-0">
                                <p className="text-xs text-gray-400"><strong>{note.authorId}</strong> on {new Date(note.timestamp).toLocaleString()}</p>
                                <p className="text-sm">{note.content}</p>
                            </div>
                        ))
                    )}
                </div>
                <div className="flex space-x-3">
                    <input
                        type="text"
                        placeholder="Add a new note..."
                        value={newNoteContent}
                        onChange={(e) => setNewNoteContent(e.target.value)}
                        className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500"
                    />
                    <button onClick={handleNoteSubmit} disabled={isLoading || !newNoteContent.trim()}
                            className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-white font-medium disabled:opacity-50 transition-colors duration-200">
                        Add Note
                    </button>
                </div>
            </div>
            {dsr.attachments && dsr.attachments.length > 0 && (
                <div className="space-y-2 pt-4 border-t border-gray-700">
                    <h4 className="text-lg font-semibold">Attachments</h4>
                    <div className="flex flex-wrap gap-2">
                        {dsr.attachments.map((url, index) => (
                            <a key={index} href={url} target="_blank" rel="noopener noreferrer" className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded-md text-white text-sm">
                                Attachment {index + 1}
                            </a>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
};

export const AuditLogViewer: React.FC = () => {
    const [logs, setLogs] = useState<AuditLogEntry[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterEntityType, setFilterEntityType] = useState('All');
    const [filterAction, setFilterAction] = useState('All');

    const fetchLogs = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const filters: any = { search: debouncedSearchTerm };
            if (filterEntityType !== 'All') filters.entityType = filterEntityType;
            if (filterAction !== 'All') filters.action = filterAction;
            const response = await mockApi.fetchAuditLogs(filters);
            setLogs(response.data);
        } catch (err: any) {
            setError('Failed to fetch audit logs: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    }, [debouncedSearchTerm, filterEntityType, filterAction]);

    useEffect(() => {
        fetchLogs();
    }, [fetchLogs]);

    const { sortedData, requestSort, sortConfig } = useSort(logs, { key: 'timestamp', direction: 'descending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 15);

    return (
        <Card title="Audit Logs" className="col-span-full">
            <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search by User ID, Action, Details, Entity ID..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Entity Type"
                    options={[{ value: 'ConsentRecord', label: 'Consent Record' }, { value: 'ConsentPolicy', label: 'Consent Policy' }, { value: 'DataSubjectRequest', label: 'DSR' }, { value: 'System', label: 'System' }]}
                    selectedValue={filterEntityType}
                    onChange={setFilterEntityType}
                />
                <FilterDropdown
                    label="Action Type"
                    options={[
                        { value: 'CONSENT_GRANTED', label: 'Consent Granted' },
                        { value: 'CONSENT_REVOKED', label: 'Consent Revoked' },
                        { value: 'POLICY_CREATED', label: 'Policy Created' },
                        { value: 'POLICY_UPDATED', label: 'Policy Updated' },
                        { value: 'POLICY_DELETED', label: 'Policy Deleted' },
                        { value: 'DSR_RECEIVED', label: 'DSR Received' },
                        { value: 'DSR_STATUS_CHANGE', label: 'DSR Status Change' },
                        { value: 'DSR_NOTE_ADDED', label: 'DSR Note Added' },
                        { value: 'DSR_UPDATED', label: 'DSR Updated' },
                    ]}
                    selectedValue={filterAction}
                    onChange={setFilterAction}
                />
            </div>
            {isLoading && <p className="text-white text-center py-4">Loading audit logs...</p>}
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'timestamp', label: 'Timestamp', sortable: true, className: 'w-1/6' },
                    { key: 'userId', label: 'User ID', sortable: true, className: 'w-1/12' },
                    { key: 'action', label: 'Action', sortable: true, className: 'w-1/6' },
                    { key: 'entityType', label: 'Entity Type', sortable: true, className: 'w-1/12' },
                    { key: 'entityId', label: 'Entity ID', className: 'w-1/12' },
                    { key: 'details', label: 'Details', className: 'w-auto' },
                ]}
                data={currentData}
                renderRow={(log: AuditLogEntry) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(log.timestamp).toLocaleString()}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.userId}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.action}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.entityType}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.entityId}</td>
                        <td className="px-6 py-4 text-sm text-gray-300 max-w-md break-words">{log.details}</td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof AuditLogEntry)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />
        </Card>
    );
};

export const ComplianceReporting: React.FC = () => {
    const [trendData, setTrendData] = useState<ConsentTrendData[]>([]);
    const [isLoadingTrends, setIsLoadingTrends] = useState(false);
    const [trendError, setTrendError] = useState<string | null>(null);
    const [timeframe, setTimeframe] = useState<'week' | 'month' | 'quarter' | 'year'>('month');

    const fetchTrendData = useCallback(async () => {
        setIsLoadingTrends(true);
        setTrendError(null);
        try {
            const data = await mockApi.fetchConsentTrendData(timeframe);
            setTrendData(data);
        } catch (err: any) {
            setTrendError('Failed to fetch trend data: ' + err.message);
        } finally {
            setIsLoadingTrends(false);
        }
    }, [timeframe]);

    useEffect(() => {
        fetchTrendData();
    }, [fetchTrendData]);

    const [complianceReport, setComplianceReport] = useState<string>('');
    const [isGeneratingReport, setIsGeneratingReport] = useState(false);
    const [reportError, setReportError] = useState<string | null>(null);

    const generateComplianceReport = async () => {
        setIsGeneratingReport(true);
        setReportError(null);
        try {
            await mockDelay(1500); // Simulate report generation time

            const totalActiveConsents = MOCK_CONSENT_RECORDS_DATA.filter(r => r.status === 'Granted').length;
            const totalRevokedConsents = MOCK_CONSENT_RECORDS_DATA.filter(r => r.status === 'Revoked').length;
            const totalDSRsReceivedLast30Days = MOCK_DATA_SUBJECT_REQUESTS.filter(d => (new Date().getTime() - new Date(d.submissionDate).getTime()) < 30 * 24 * 60 * 60 * 1000).length;
            const dsrsCompletedLast30Days = MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.status === 'Completed' && d.completionDate && (new Date().getTime() - new Date(d.completionDate).getTime()) < 30 * 24 * 60 * 60 * 1000).length;
            const outstandingErasureDSRs = MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.requestType === 'Erasure' && d.status !== 'Completed' && d.status !== 'Rejected').length;
            const outstandingAccessDSRs = MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.requestType === 'Access' && d.status !== 'Completed' && d.status !== 'Rejected').length;

            const reportContent = `
## GDPR / CCPA Compliance Report - ${new Date().toLocaleDateString()}

### I. Overall Consent Status
*   Total Active Consents: ${totalActiveConsents}
*   Total Revoked Consents: ${totalRevokedConsents}
*   Consent Rate: ${totalActiveConsents + totalRevokedConsents > 0 ? ((totalActiveConsents / (totalActiveConsents + totalRevokedConsents)) * 100).toFixed(2) : 0}%

### II. Data Subject Request (DSR) Summary
*   Total DSRs Received (Last 30 days): ${totalDSRsReceivedLast30Days}
*   DSRs Completed (Last 30 days): ${dsrsCompletedLast30Days}
*   Average Resolution Time (Completed DSRs, Last 30 days): ${
                MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.status === 'Completed' && d.completionDate && (new Date().getTime() - new Date(d.completionDate).getTime()) < 30 * 24 * 60 * 60 * 1000)
                    .map(d => (new Date(d.completionDate!).getTime() - new Date(d.submissionDate).getTime()) / (1000 * 60 * 60 * 24))
                    .reduce((sum, days, _, arr) => sum + days / arr.length, 0)
                    .toFixed(1)
            } days

#### Outstanding DSRs
*   Erasure Requests: ${outstandingErasureDSRs}
*   Access Requests: ${outstandingAccessDSRs}
*   Overdue DSRs: ${MOCK_DATA_SUBJECT_REQUESTS.filter(d => new Date(d.dueDate) < new Date() && d.status !== 'Completed' && d.status !== 'Rejected').length}

### III. Policy Adherence Overview
*   Number of Active Consent Policies: ${MOCK_CONSENT_POLICIES.filter(p => p.isActive).length}
*   Policies with Third-Party Sharing: ${MOCK_CONSENT_POLICIES.filter(p => p.thirdPartySharing).length}
*   Policies with Automated Decision-Making: ${MOCK_CONSENT_POLICIES.filter(p => p.isAutomatedDecisionMaking).length}
*   Policies Due for Review (Next 30 days): ${MOCK_CONSENT_POLICIES.filter(p => p.nextReviewAt && (new Date(p.nextReviewAt).getTime() - new Date().getTime()) < 30 * 24 * 60 * 60 * 1000 && new Date(p.nextReviewAt) > new Date()).length}

### IV. Potential Risks & Recommendations (AI-Assisted)
*   **Risk:** Manual DSR processing is becoming a bottleneck.
    *   **Recommendation:** Investigate automation tools for DSR intake and data retrieval. Implement DSR workflow management software.
*   **Risk:** High volume of data sharing for 'Marketing' consent type without clear, granular user choices.
    *   **Recommendation:** Review 'Marketing' consent flows to ensure transparency and opt-in specificity. Consider separate consent for different marketing channels.
*   **Risk:** Data retention periods in 'Essential Service Data Policy' are long, consider anonymization strategies.
    *   **Recommendation:** Implement anonymization or pseudonymization for historical service data where direct identification is no longer necessary, or explore tiered retention based on data sensitivity.
*   **Risk:** Policies not regularly reviewed could lead to outdated compliance.
    *   **Recommendation:** Ensure policy review cycles are strictly adhered to and integrate automated reminders for policy owners.

### V. Audit Trail Summary
*   Last Major Policy Change: ${MOCK_CONSENT_POLICIES.sort((a,b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())[0]?.name || 'N/A'} on ${new Date(MOCK_CONSENT_POLICIES.sort((a,b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())[0]?.updatedAt || '').toLocaleDateString()}
*   Total Audit Log Entries (Last 90 days): ${MOCK_AUDIT_LOG.filter(l => (new Date().getTime() - new Date(l.timestamp).getTime()) < 90 * 24 * 60 * 60 * 1000).length}
*   No critical security audit findings related to consent management.

This report is a snapshot of current compliance posture. Regular reviews and updates are recommended.
            `;
            setComplianceReport(reportContent.trim());
        } catch (err: any) {
            setReportError('Failed to generate report: ' + err.message);
        } finally {
            setIsGeneratingReport(false);
        }
    };

    return (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 col-span-full">
            <Card title="Consent & Opt-Out Trends">
                <div className="flex justify-end space-x-2 mb-4">
                    {(['week', 'month', 'quarter', 'year'] as const).map(tf => (
                        <button
                            key={tf}
                            onClick={() => setTimeframe(tf)}
                            className={`px-3 py-1 text-sm rounded-md ${timeframe === tf ? 'bg-cyan-600' : 'bg-gray-700 hover:bg-gray-600'} text-white transition-colors duration-200`}
                        >
                            {tf.charAt(0).toUpperCase() + tf.slice(1)}
                        </button>
                    ))}
                </div>
                {isLoadingTrends && <p className="text-white text-center py-4">Loading trends...</p>}
                {trendError && <div className="p-3 bg-red-800 text-white rounded mb-4">{trendError}</div>}
                {!isLoadingTrends && !trendError && trendData.length > 0 ? (
                    <ResponsiveContainer width="100%" height={300}>
                        <LineChart data={trendData} margin={{ top: 5, right: 20, left: -20, bottom: 5 }}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#4a5568" />
                            <XAxis dataKey="date" tickFormatter={(dateStr) => new Date(dateStr).toLocaleDateString()} stroke="#cbd5e0" />
                            <YAxis stroke="#cbd5e0" />
                            <Tooltip contentStyle={{ backgroundColor: '#2d3748', border: 'none', borderRadius: '4px' }} itemStyle={{ color: '#cbd5e0' }} labelStyle={{ color: '#fff' }} />
                            <Legend />
                            <Line type="monotone" dataKey="newConsents" stroke="#06b6d4" name="New Consents" strokeWidth={2} activeDot={{ r: 8 }} />
                            <Line type="monotone" dataKey="optOuts" stroke="#ef4444" name="Opt-Outs/Revocations" strokeWidth={2} activeDot={{ r: 8 }} />
                        </LineChart>
                    </ResponsiveContainer>
                ) : (
                    !isLoadingTrends && !trendError && <p className="text-gray-400 text-center py-4">No trend data available for this period.</p>
                )}
            </Card>

            <Card title="Compliance Report Generator">
                <p className="text-gray-300 mb-4">Generate a comprehensive report on current consent and DSR compliance status.</p>
                <button
                    onClick={generateComplianceReport}
                    disabled={isGeneratingReport}
                    className="w-full py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg font-medium disabled:opacity-50 transition-colors duration-200"
                >
                    {isGeneratingReport ? 'Generating Report...' : 'Generate Compliance Report'}
                </button>
                {reportError && <div className="p-3 bg-red-800 text-white rounded mt-4">{reportError}</div>}
                {complianceReport && (
                    <div className="mt-6 space-y-3">
                        <h3 className="text-lg font-semibold text-white">Latest Compliance Report</h3>
                        <div className="bg-gray-700/50 p-4 rounded max-h-96 overflow-y-auto text-sm text-gray-300 whitespace-pre-line">
                            {complianceReport}
                        </div>
                        <button onClick={() => alert('Download functionality not implemented in mock.')} className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors duration-200">Download Report (Mock)</button>
                    </div>
                )}
            </Card>
        </div>
    );
};

export const DataCategoryManagement: React.FC = () => {
    const [categories, setCategories] = useState<DataCategoryDefinition[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterSensitive, setFilterSensitive] = useState('All');

    const [isFormModalOpen, setIsFormModalOpen] = useState(false);
    const [editingCategory, setEditingCategory] = useState<DataCategoryDefinition | null>(null);

    const fetchCategories = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const filters: any = { search: debouncedSearchTerm };
            if (filterSensitive !== 'All') {
                filters.sensitive = filterSensitive;
            }
            const response = await mockApi.fetchDataCategoryDefinitions(filters);
            setCategories(response.data);
        } catch (err: any) {
            setError('Failed to fetch data categories: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    }, [debouncedSearchTerm, filterSensitive]);

    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    const handleCreateCategory = () => {
        setEditingCategory(null);
        setIsFormModalOpen(true);
    };

    const handleEditCategory = (category: DataCategoryDefinition) => {
        setEditingCategory(category);
        setIsFormModalOpen(true);
    };

    const handleDeleteCategory = async (id: string) => {
        if (!confirm('Are you sure you want to delete this data category?')) return;
        setIsLoading(true);
        setError(null);
        try {
            await mockApi.deleteDataCategoryDefinition(id);
            await fetchCategories();
            MOCK_AUDIT_LOG.push({
                id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                timestamp: new Date().toISOString(),
                userId: 'admin_user',
                action: 'DATA_CATEGORY_DELETED',
                entityType: 'System',
                entityId: id,
                details: `Data category ${id} deleted.`,
            });
        } catch (err: any) {
            setError('Failed to delete data category: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleCategoryFormSubmit = async (categoryData: DataCategoryDefinition) => {
        setIsLoading(true);
        setError(null);
        try {
            if (editingCategory) {
                await mockApi.updateDataCategoryDefinition(categoryData.id, categoryData);
                MOCK_AUDIT_LOG.push({
                    id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                    timestamp: new Date().toISOString(),
                    userId: 'admin_user',
                    action: 'DATA_CATEGORY_UPDATED',
                    entityType: 'System',
                    entityId: categoryData.id,
                    details: `Data category "${categoryData.name}" updated.`,
                });
            } else {
                await mockApi.createDataCategoryDefinition(categoryData);
                MOCK_AUDIT_LOG.push({
                    id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                    timestamp: new Date().toISOString(),
                    userId: 'admin_user',
                    action: 'DATA_CATEGORY_CREATED',
                    entityType: 'System',
                    entityId: categoryData.id, // This would be the new ID from the API
                    details: `New data category "${categoryData.name}" created.`,
                });
            }
            setIsFormModalOpen(false);
            setEditingCategory(null);
            await fetchCategories();
        } catch (err: any) {
            setError('Failed to save data category: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const { sortedData, requestSort, sortConfig } = useSort(categories, { key: 'name', direction: 'ascending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 10);

    return (
        <Card title="Data Category Definitions" className="col-span-full">
            <div className="flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search categories by name, description..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Sensitive Data"
                    options={[{ value: 'true', label: 'Yes' }, { value: 'false', label: 'No' }]}
                    selectedValue={filterSensitive}
                    onChange={setFilterSensitive}
                    className="w-full md:w-auto"
                    allOptionLabel="All Sensitivity"
                />
                <button onClick={handleCreateCategory} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium w-full md:w-auto transition-colors duration-200">
                    + New Category
                </button>
            </div>
            {isLoading && <p className="text-white text-center py-4">Loading data categories...</p>}
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'name', label: 'Name', sortable: true },
                    { key: 'description', label: 'Description' },
                    { key: 'sensitive', label: 'Sensitive', sortable: true },
                    { key: 'examples', label: 'Examples' },
                    { key: 'actions', label: 'Actions', className: 'w-28 text-center' },
                ]}
                data={currentData}
                renderRow={(category: DataCategoryDefinition) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{category.name}</td>
                        <td className="px-6 py-4 text-sm text-gray-300 max-w-sm truncate">{category.description}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${category.sensitive ? 'bg-orange-100 text-orange-800' : 'bg-gray-100 text-gray-800'}`}>
                                {category.sensitive ? 'Yes' : 'No'}
                            </span>
                        </td>
                        <td className="px-6 py-4 text-sm text-gray-300 max-w-sm truncate">{category.examples.join(', ')}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-center">
                            <button onClick={() => handleEditCategory(category)} className="text-indigo-500 hover:text-indigo-700 mr-3 transition-colors duration-200">Edit</button>
                            <button onClick={() => handleDeleteCategory(category.id)} className="text-red-500 hover:text-red-700 transition-colors duration-200">Delete</button>
                        </td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof DataCategoryDefinition)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />

            <Modal isOpen={isFormModalOpen} onClose={() => setIsFormModalOpen(false)} title={editingCategory ? "Edit Data Category" : "Create New Data Category"} size="md">
                <DataCategoryForm
                    category={editingCategory}
                    onSubmit={handleCategoryFormSubmit}
                    onCancel={() => setIsFormModalOpen(false)}
                    isLoading={isLoading}
                />
            </Modal>
        </Card>
    );
};

export const DataCategoryForm: React.FC<{
    category: DataCategoryDefinition | null;
    onSubmit: (categoryData: DataCategoryDefinition) => void;
    onCancel: () => void;
    isLoading: boolean;
}> = ({ category, onSubmit, onCancel, isLoading }) => {
    const [formData, setFormData] = useState<DataCategoryDefinition>(category || {
        id: '', name: '', description: '', sensitive: false, examples: [],
    });

    useEffect(() => {
        setFormData(category || {
            id: '', name: '', description: '', sensitive: false, examples: [],
        });
    }, [category]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    const handleExamplesChange = (value: string) => {
        setFormData(prev => ({
            ...prev,
            examples: value.split(',').map(s => s.trim()).filter(s => s.length > 0)
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSubmit(formData);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-white">
            <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-300">Category Name</label>
                <input type="text" id="name" name="name" value={formData.name} onChange={handleChange} required
                       className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-300">Description</label>
                <textarea id="description" name="description" value={formData.description} onChange={handleChange} rows={3} required
                          className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
            </div>
            <div>
                <label htmlFor="examples" className="block text-sm font-medium text-gray-300">Examples (comma-separated)</label>
                <input type="text" id="examples" name="examples" value={formData.examples.join(', ')} onChange={(e) => handleExamplesChange(e.target.value)}
                       className="mt-1 block w-full bg-gray-700/50 border border-gray-600 rounded-md shadow-sm p-2 text-white focus:ring-cyan-500 focus:border-cyan-500" />
            </div>
            <div className="flex items-center space-x-2">
                <input type="checkbox" id="sensitive" name="sensitive" checked={formData.sensitive} onChange={handleChange}
                       className="h-4 w-4 text-cyan-600 focus:ring-cyan-500 border-gray-600 rounded bg-gray-700/50" />
                <label htmlFor="sensitive" className="text-sm font-medium text-gray-300">Is Sensitive Data</label>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white font-medium transition-colors duration-200">Cancel</button>
                <button type="submit" disabled={isLoading} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-white font-medium disabled:opacity-50 transition-colors duration-200">
                    {isLoading ? 'Saving...' : (category ? 'Update Category' : 'Create Category')}
                </button>
            </div>
        </form>
    );
};

export const ThirdPartyIntegrationManagement: React.FC = () => {
    const [integrations, setIntegrations] = useState<ThirdPartyIntegration[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const [filterStatus, setFilterStatus] = useState('All');

    const fetchIntegrations = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const filters: any = { search: debouncedSearchTerm };
            if (filterStatus !== 'All') {
                filters.status = filterStatus;
            }
            const response = await mockApi.fetchThirdPartyIntegrations(filters);
            setIntegrations(response.data);
        } catch (err: any) {
            setError('Failed to fetch integrations: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    }, [debouncedSearchTerm, filterStatus]);

    useEffect(() => {
        fetchIntegrations();
    }, [fetchIntegrations]);

    const handleUpdateIntegration = async (integrationId: string, updates: Partial<ThirdPartyIntegration>) => {
        setIsLoading(true);
        setError(null);
        try {
            const updated = await mockApi.updateThirdPartyIntegration(integrationId, updates);
            setIntegrations(prev => prev.map(i => i.id === integrationId ? updated : i));
            MOCK_AUDIT_LOG.push({
                id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                timestamp: new Date().toISOString(),
                userId: 'admin_user',
                action: 'THIRD_PARTY_UPDATED',
                entityType: 'System',
                entityId: integrationId,
                details: `Third-party integration "${updated.name}" updated.`,
            });
        } catch (err: any) {
            setError('Failed to update integration: ' + err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const { sortedData, requestSort, sortConfig } = useSort(integrations, { key: 'name', direction: 'ascending' });
    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(sortedData, 10);

    return (
        <Card title="Third-Party Integrations" className="col-span-full">
            <div className="flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
                <input
                    type="text"
                    placeholder="Search integrations by name, description, regions..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-cyan-500"
                />
                <FilterDropdown
                    label="Status"
                    options={[{ value: 'Active', label: 'Active' }, { value: 'Inactive', label: 'Inactive' }, { value: 'Pending Review', label: 'Pending Review' }]}
                    selectedValue={filterStatus}
                    onChange={setFilterStatus}
                    className="w-full md:w-auto"
                />
            </div>
            {isLoading && <p className="text-white text-center py-4">Loading integrations...</p>}
            {error && <div className="p-3 bg-red-800 text-white rounded mb-4">{error}</div>}
            <Table
                headers={[
                    { key: 'name', label: 'Name', sortable: true },
                    { key: 'description', label: 'Description' },
                    { key: 'dataCategoriesShared', label: 'Data Shared' },
                    { key: 'regions', label: 'Regions' },
                    { key: 'contractSigned', label: 'Contract', sortable: true },
                    { key: 'dpaSigned', label: 'DPA', sortable: true },
                    { key: 'status', label: 'Status', sortable: true },
                    { key: 'lastReviewedAt', label: 'Last Reviewed', sortable: true },
                    { key: 'actions', label: 'Actions', className: 'w-24 text-center' },
                ]}
                data={currentData}
                renderRow={(integration: ThirdPartyIntegration) => (
                    <>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{integration.name}</td>
                        <td className="px-6 py-4 text-sm text-gray-300 max-w-xs truncate">{integration.description}</td>
                        <td className="px-6 py-4 text-sm text-gray-300 max-w-xs truncate">{integration.dataCategoriesShared.join(', ')}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{integration.regions.join(', ')}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${integration.contractSigned ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                {integration.contractSigned ? 'Yes' : 'No'}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${integration.dpaSigned ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                {integration.dpaSigned ? 'Yes' : 'No'}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${integration.status === 'Active' ? 'bg-green-100 text-green-800' : integration.status === 'Inactive' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}`}>
                                {integration.status}
                            </span>
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(integration.lastReviewedAt).toLocaleDateString()}</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-center">
                            <button onClick={() => handleUpdateIntegration(integration.id, { status: integration.status === 'Active' ? 'Inactive' : 'Active' })} className="text-indigo-500 hover:text-indigo-700 transition-colors duration-200">
                                {integration.status === 'Active' ? 'Deactivate' : 'Activate'}
                            </button>
                        </td>
                    </>
                )}
                onSort={(key) => requestSort(key as keyof ThirdPartyIntegration)}
                sortConfig={sortConfig}
            />
            <Pagination currentPage={currentPage} maxPage={maxPage} next={next} prev={prev} jump={jump} />
        </Card>
    );
};


export const AIComplianceAssistant: React.FC<{
    onAssess: (prompt: string) => Promise<string>;
    isLoading: boolean;
    assessment: string;
    onClear: () => void;
}> = ({ onAssess, isLoading, assessment, onClear }) => {
    const [prompt, setPrompt] = useState("Collecting user location data for fraud prevention.");
    const [aiPurpose, setAiPurpose] = useState<'general' | 'policy_check'>('general');
    const [selectedPolicyId, setSelectedPolicyId] = useState<string>('');
    const [policies, setPolicies] = useState<ConsentPolicy[]>([]);
    const [isLoadingPolicies, setIsLoadingPolicies] = useState(false);
    const [policiesError, setPoliciesError] = useState<string | null>(null);

    const fetchPoliciesForSelect = useCallback(async () => {
        setIsLoadingPolicies(true);
        setPoliciesError(null);
        try {
            const response = await mockApi.fetchConsentPolicies({ isActive: true });
            setPolicies(response.data);
            if (response.data.length > 0 && !selectedPolicyId) {
                setSelectedPolicyId(response.data[0].id); // Auto-select first active policy
            }
        } catch (err: any) {
            setPoliciesError('Failed to load policies: ' + err.message);
        } finally {
            setIsLoadingPolicies(false);
        }
    }, [selectedPolicyId]);

    useEffect(() => {
        fetchPoliciesForSelect();
    }, [fetchPoliciesForSelect]);

    const currentPolicy = useMemo(() => policies.find(p => p.id === selectedPolicyId), [policies, selectedPolicyId]);

    const handleAssessClick = async () => {
        if (aiPurpose === 'policy_check' && !currentPolicy) {
            alert('Please select a policy to perform a policy compliance check.');
            return;
        }
        let fullPrompt = "";
        if (aiPurpose === 'general') {
            fullPrompt = `As a privacy expert AI, conduct a brief, high-level privacy impact assessment for this data collection activity: "${prompt}". Highlight potential risks and suggest mitigations. Focus on general privacy principles.`;
        } else { // policy_check
            fullPrompt = `As a privacy expert AI, evaluate the following data collection activity: "${prompt}" against the provided consent policy details for ${currentPolicy?.name || 'an unspecified policy'}:\n\n`;
            if (currentPolicy) {
                fullPrompt += `Policy Name: ${currentPolicy.name}\nDescription: ${currentPolicy.description}\nData Categories: ${currentPolicy.dataCategories.join(', ')}\nLegal Basis: ${currentPolicy.legalBasis}\nRetention Period: ${currentPolicy.retentionPeriod}\nRegions: ${currentPolicy.regions.join(', ')}\nPurpose: ${currentPolicy.purpose}\nThird-Party Sharing: ${currentPolicy.thirdPartySharing ? 'Yes' + (currentPolicy.thirdPartyList.length > 0 ? ` (${currentPolicy.thirdPartyList.join(', ')})` : '') : 'No'}\nAutomated Decision Making: ${currentPolicy.isAutomatedDecisionMaking ? 'Yes' + (currentPolicy.automatedDecisionDetails ? ` (${currentPolicy.automatedDecisionDetails})` : '') : 'No'}\n\n`;
            }
            fullPrompt += `Specifically, identify any potential compliance gaps, risks, or areas of non-adherence for the data collection activity against this policy. Suggest concrete improvements to align the activity with the policy.`;
        }
        await onAssess(fullPrompt);
    };

    return (
        <Card title="AI Privacy & Compliance Assistant">
            <p className="text-gray-300 mb-4">Leverage AI to perform privacy impact assessments or check data activities against specific consent policies.</p>
            <div className="flex mb-4 space-x-4">
                <label className="inline-flex items-center cursor-pointer">
                    <input
                        type="radio"
                        className="form-radio h-4 w-4 text-cyan-600 border-gray-600 bg-gray-700/50"
                        name="aiPurpose"
                        value="general"
                        checked={aiPurpose === 'general'}
                        onChange={() => { setAiPurpose('general'); onClear(); }}
                    />
                    <span className="ml-2 text-white text-sm">General PIA (Privacy Impact Assessment)</span>
                </label>
                <label className="inline-flex items-center cursor-pointer">
                    <input
                        type="radio"
                        className="form-radio h-4 w-4 text-cyan-600 border-gray-600 bg-gray-700/50"
                        name="aiPurpose"
                        value="policy_check"
                        checked={aiPurpose === 'policy_check'}
                        onChange={() => { setAiPurpose('policy_check'); onClear(); }}
                    />
                    <span className="ml-2 text-white text-sm">Policy Compliance Check</span>
                </label>
            </div>

            {aiPurpose === 'policy_check' && (
                <div className="mb-4">
                    <label htmlFor="policy-select" className="block text-sm font-medium text-gray-300 mb-1">Select Policy to Check Against (Active policies only):</label>
                    {isLoadingPolicies ? (
                        <p className="text-gray-400">Loading policies...</p>
                    ) : policiesError ? (
                        <p className="text-red-400">{policiesError}</p>
                    ) : (
                        <select
                            id="policy-select"
                            value={selectedPolicyId}
                            onChange={(e) => setSelectedPolicyId(e.target.value)}
                            className="w-full bg-gray-700/50 text-white border border-gray-600 rounded-md py-2 px-3 focus:outline-none focus:ring-1 focus:ring-cyan-500 appearance-none bg-no-repeat bg-right-center pr-8"
                            style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%239CA3AF' d='M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z'/%3E%3C/svg%3E")`, backgroundSize: '1.5em 1.5em' }}
                        >
                            <option value="">-- Select an Active Policy --</option>
                            {policies.map(p => (
                                <option key={p.id} value={p.id}>{p.name} (v{p.version})</option>
                            ))}
                        </select>
                    )}
                    {selectedPolicyId && currentPolicy && <p className="text-xs text-gray-400 mt-1">Selected: {currentPolicy.name} ({currentPolicy.legalBasis})</p>}
                    {aiPurpose === 'policy_check' && !selectedPolicyId && !isLoadingPolicies && (
                        <p className="text-red-400 text-sm mt-1">Please select an active policy for compliance checking.</p>
                    )}
                </div>
            )}

            <div className="space-y-4">
                <div>
                    <label htmlFor="ai-prompt" className="block text-sm font-medium text-gray-300 mb-1">Describe Data Collection Activity:</label>
                    <textarea
                        id="ai-prompt"
                        value={prompt}
                        onChange={e => setPrompt(e.target.value)}
                        className="w-full h-24 bg-gray-700/50 p-2 rounded border border-gray-600 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500"
                        placeholder="e.g., Collecting user location data for fraud prevention. Note: this data is collected via GPS on mobile app, updated every 5 minutes, stored for 6 months."
                    />
                </div>
                <button
                    onClick={handleAssessClick}
                    disabled={isLoading || (aiPurpose === 'policy_check' && !selectedPolicyId)}
                    className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg font-medium disabled:opacity-50 transition-colors duration-200"
                >
                    {isLoading ? 'Assessing...' : 'Initiate Assessment'}
                </button>
                {assessment && (
                    <div className="mt-6 space-y-3">
                        <h3 className="text-lg font-semibold text-white">AI Assessment Report</h3>
                        <div className="min-h-[10rem] max-h-60 overflow-y-auto bg-gray-700/50 p-4 rounded text-sm text-gray-300 whitespace-pre-line">
                            {assessment}
                        </div>
                        <button onClick={onClear} className="w-full py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-medium transition-colors duration-200">Clear Assessment</button>
                    </div>
                )}
            </div>
        </Card>
    );
};

// --- Main ConsentManagementView Integration ---
const TABS = {
    DASHBOARD: 'Dashboard',
    RECORDS: 'Consent Records',
    POLICIES: 'Consent Policies',
    DSRS: 'DSR Requests',
    AUDIT: 'Audit Log',
    REPORTS: 'Reports',
    DATA_CATEGORIES: 'Data Categories',
    THIRD_PARTIES: 'Third-Parties',
} as const;

type TabKey = typeof TABS[keyof typeof TABS];

const ConsentManagementView: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("ConsentManagementView must be within DataProvider");

    const { consentRecords } = context;
    const [activeTab, setActiveTab] = useState<TabKey>(TABS.DASHBOARD);
    const [isAssessorOpen, setAssessorOpen] = useState(false);
    const [aiPrompt, setAiPrompt] = useState("Collecting user location data for fraud prevention."); // Renamed to avoid conflict
    const [aiAssessment, setAiAssessment] = useState(''); // Renamed to avoid conflict
    const [isLoadingAI, setIsLoadingAI] = useState(false);

    // Update MOCK_CONSENT_RECORDS_DATA with the actual context records
    useEffect(() => {
        MOCK_CONSENT_RECORDS_DATA = consentRecords;
    }, [consentRecords]);

    const chartData = useMemo(() => ([
        { name: 'Marketing', value: consentRecords.filter(r => r.consentType === 'Marketing' && r.status === 'Granted').length },
        { name: 'Data Sharing', value: consentRecords.filter(r => r.consentType === 'Data Sharing' && r.status === 'Granted').length },
        { name: 'Analytics', value: consentRecords.filter(r => r.consentType === 'Analytics' && r.status === 'Granted').length },
        { name: 'Essential', value: consentRecords.filter(r => r.consentType === 'Essential' && r.status === 'Granted').length },
    ].filter(item => item.value > 0)), [consentRecords]);

    const COLORS = ['#06b6d4', '#8b5cf6', '#10b981', '#f59e0b']; // Cyan, Purple, Green, Amber

    const handleAssess = async (promptText: string) => {
        setIsLoadingAI(true); setAiAssessment('');
        try {
            const ai = new GoogleGenAI({apiKey: process.env.NEXT_PUBLIC_API_KEY as string}); // Using NEXT_PUBLIC_API_KEY for client-side
            const model = ai.getGenerativeModel({ model: 'gemini-pro' }); // gemini-2.5-flash not available via getGenerativeModel directly, using gemini-pro for wider availability
            const result = await model.generateContent(promptText);
            const response = await result.response;
            setAiAssessment(response.text);
        } catch(err) {
            console.error("AI assessment error:", err);
            setAiAssessment("Error performing AI assessment. Please check API key and try again. " + (err as Error).message);
        } finally { setIsLoadingAI(false); }
    };

    const handleClearAIAssessment = useCallback(() => {
        setAiAssessment('');
        setAiPrompt("Collecting user location data for fraud prevention.");
    }, []);

    return (
        <>
            <div className="space-y-6">
                 <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6">
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-4 sm:mb-0">Consent Management Dashboard</h2>
                    <button onClick={() => setAssessorOpen(true)} className="px-5 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium transition-colors duration-200">
                        AI Privacy Impact Assessment
                    </button>
                </div>
                <nav className="flex space-x-1 sm:space-x-2 border-b border-gray-700 text-sm overflow-x-auto pb-2 -mb-2">
                    {Object.values(TABS).map((tab) => (
                        <button
                            key={tab}
                            onClick={() => setActiveTab(tab)}
                            className={`px-4 py-2 rounded-t-lg font-medium ${activeTab === tab ? 'bg-gray-700 text-white border-b-2 border-cyan-500' : 'text-gray-400 hover:text-white hover:bg-gray-700'}`}
                        >
                            {tab}
                        </button>
                    ))}
                </nav>

                <div className="pt-4">
                    {activeTab === TABS.DASHBOARD && (
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <Card title="Current Consent Rates">
                                {chartData.length > 0 ? (
                                    <ResponsiveContainer width="100%" height={300}>
                                        <PieChart>
                                            <Pie data={chartData} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={100} fill="#8884d8" label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}>
                                                {chartData.map((e,i) => <Cell key={`cell-${i}`} fill={COLORS[i % COLORS.length]} />)}
                                            </Pie>
                                            <Legend layout="vertical" align="right" verticalAlign="middle" wrapperStyle={{ paddingLeft: '20px', color: '#fff' }} />
                                            <Tooltip contentStyle={{ backgroundColor: '#2d3748', border: 'none', borderRadius: '4px' }} itemStyle={{ color: '#cbd5e0' }} labelStyle={{ color: '#fff' }} />
                                        </PieChart>
                                    </ResponsiveContainer>
                                ) : (
                                    <p className="text-gray-400 text-center py-4">No consent data available.</p>
                                )}
                            </Card>
                            <Card title="Recent Consent Changes">
                                {consentRecords.length > 0 ? (
                                    <div className="space-y-3 max-h-72 overflow-y-auto pr-2">
                                        {consentRecords.slice(0, 10).map(r => ( // Show top 10 recent changes
                                            <p key={r.id} className="text-sm text-gray-300">
                                                <span className="font-semibold">{r.userId}</span> {r.status} <span className="font-semibold">{r.consentType}</span> consent. <span className="text-gray-500 text-xs">({new Date(r.timestamp).toLocaleString()})</span>
                                            </p>
                                        ))}
                                    </div>
                                ) : (
                                    <p className="text-gray-400 text-center py-4">No recent consent changes.</p>
                                )}
                            </Card>
                            {/* Additional dashboard cards can be added here, e.g., DSR status summary, Policy status overview */}
                            <Card title="Data Subject Request Summary" className="col-span-1">
                                <div className="space-y-3 text-gray-300">
                                    <p><strong>Total DSRs:</strong> {MOCK_DATA_SUBJECT_REQUESTS.length}</p>
                                    <p><strong>Pending:</strong> {MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.status === 'Pending').length}</p>
                                    <p><strong>In Progress:</strong> {MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.status === 'In Progress').length}</p>
                                    <p><strong>Completed:</strong> {MOCK_DATA_SUBJECT_REQUESTS.filter(d => d.status === 'Completed').length}</p>
                                    <p><strong>Overdue:</strong> {MOCK_DATA_SUBJECT_REQUESTS.filter(d => new Date(d.dueDate) < new Date() && d.status !== 'Completed' && d.status !== 'Rejected').length}</p>
                                </div>
                                <div className="mt-4">
                                    <button onClick={() => setActiveTab(TABS.DSRS)} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-medium w-full transition-colors duration-200">
                                        View All DSRs
                                    </button>
                                </div>
                            </Card>
                            <Card title="Policy Overview" className="col-span-1">
                                <div className="space-y-3 text-gray-300">
                                    <p><strong>Total Policies:</strong> {MOCK_CONSENT_POLICIES.length}</p>
                                    <p><strong>Active Policies:</strong> {MOCK_CONSENT_POLICIES.filter(p => p.isActive).length}</p>
                                    <p><strong>Policies with Third-Party Sharing:</strong> {MOCK_CONSENT_POLICIES.filter(p => p.thirdPartySharing).length}</p>
                                    <p><strong>Policies Due for Review:</strong> {MOCK_CONSENT_POLICIES.filter(p => p.nextReviewAt && (new Date(p.nextReviewAt).getTime() - new Date().getTime()) < 30 * 24 * 60 * 60 * 1000 && new Date(p.nextReviewAt) > new Date()).length}</p>
                                </div>
                                <div className="mt-4">
                                    <button onClick={() => setActiveTab(TABS.POLICIES)} className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium w-full transition-colors duration-200">
                                        Manage Policies
                                    </button>
                                </div>
                            </Card>
                        </div>
                    )}
                    {activeTab === TABS.RECORDS && <ConsentRecordsManagement />}
                    {activeTab === TABS.POLICIES && <ConsentPoliciesManagement />}
                    {activeTab === TABS.DSRS && <DataSubjectRequestsManagement />}
                    {activeTab === TABS.AUDIT && <AuditLogViewer />}
                    {activeTab === TABS.REPORTS && <ComplianceReporting />}
                    {activeTab === TABS.DATA_CATEGORIES && <DataCategoryManagement />}
                    {activeTab === TABS.THIRD_PARTIES && <ThirdPartyIntegrationManagement />}
                </div>
            </div>

            <Modal isOpen={isAssessorOpen} onClose={() => setAssessorOpen(false)} title="AI Privacy Impact Assessment" size="2xl">
                <AIComplianceAssistant
                    onAssess={handleAssess}
                    isLoading={isLoadingAI}
                    assessment={aiAssessment}
                    onClear={handleClearAIAssessment}
                />
            </Modal>
        </>
    );
};

export default ConsentManagementView;

--- FILE: DisclosuresView.tsx ---

// components/views/megadashboard/regulation/DisclosuresView.tsx
import React, { useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";
import classNames from 'classnames'; // Assuming classNames is available or can be added. If not, I'll inline the logic.

// --- Global Type Definitions (for a real-world application) ---
export interface RegulatoryDisclosure {
    id: string;
    title: string;
    jurisdiction: string;
    filingDate: string; // ISO date string
    status: 'Draft' | 'Pending Review' | 'Approved' | 'Filed' | 'Rejected';
    type: 'Financial' | 'Environmental' | 'Data Breach' | 'Governance' | 'Product Safety' | 'Other';
    summary: string;
    fullContent: string;
    lastEditedBy: string;
    lastEditedDate: string; // ISO date string
    version: number;
    associatedRisks: string[]; // IDs of associated risks
    documents: DocumentAttachment[];
    reviewHistory: DisclosureReview[];
    filingScheduleId?: string;
    complianceChecks: ComplianceCheckResult[];
    tags: string[];
    sentimentAnalysis?: SentimentAnalysisResult;
    keywords?: string[];
    audience: 'Public' | 'Regulators' | 'Internal';
    legalReviewStatus?: 'Not Started' | 'In Progress' | 'Approved' | 'Revisions Required';
    isConfidential: boolean;
    language: string;
}

export interface DocumentAttachment {
    id: string;
    name: string;
    url: string;
    type: 'PDF' | 'DOCX' | 'TXT' | 'JSON' | 'CSV';
    uploadedBy: string;
    uploadedDate: string; // ISO date string
    description?: string;
    version?: number;
}

export interface DisclosureReview {
    id: string;
    reviewerId: string;
    reviewerName: string;
    reviewDate: string; // ISO date string
    status: 'Approved' | 'Revisions Required' | 'Commented';
    comments: string;
}

export interface ComplianceRule {
    id: string;
    name: string;
    description: string;
    jurisdiction: string;
    effectiveDate: string; // ISO date string
    ruleText: string;
    categories: string[]; // e.g., ['Data Privacy', 'Financial Reporting']
    severity: 'Low' | 'Medium' | 'High' | 'Critical';
    referenceUrl?: string;
    lastUpdated: string;
    version: number;
}

export interface ComplianceCheckResult {
    ruleId: string;
    ruleName: string;
    status: 'Pass' | 'Fail' | 'Warning' | 'Not Applicable';
    details: string;
    checkedDate: string; // ISO date string
    severity: 'Low' | 'Medium' | 'High' | 'Critical';
    automated: boolean;
}

export interface Risk {
    id: string;
    name: string;
    description: string;
    category: 'Operational' | 'Financial' | 'Compliance' | 'Strategic' | 'Reputational';
    likelihood: 'Low' | 'Medium' | 'High';
    impact: 'Low' | 'Medium' | 'High';
    mitigationStrategy: string;
    status: 'Active' | 'Mitigated' | 'Closed';
    lastUpdated: string; // ISO date string
    relatedRegulations?: string[]; // IDs of related regulations/rules
}

export interface UserProfile {
    id: string;
    name: string;
    email: string;
    role: 'Admin' | 'Legal' | 'Compliance' | 'Editor' | 'Viewer';
    department: string;
}

export interface FilingSchedule {
    id: string;
    disclosureId: string;
    title: string;
    deadline: string; // ISO date string
    jurisdiction: string;
    status: 'Upcoming' | 'Submitted' | 'Overdue';
    remindersSent: number;
    assignedTo: string; // User ID
    notes?: string;
}

export interface AuditLogEntry {
    id: string;
    timestamp: string; // ISO date string
    userId: string;
    userName: string;
    action: string; // e.g., 'CREATED', 'UPDATED', 'DELETED', 'REVIEWED', 'FILED'
    entityType: 'Disclosure' | 'ComplianceRule' | 'FilingSchedule' | 'Document';
    entityId: string;
    details: string;
    previousValue?: any;
    newValue?: any;
}

export interface AIMetadata {
    model: string;
    temperature: number;
    timestamp: string;
    promptTokens: number;
    completionTokens: number;
    responseId: string;
}

export interface SentimentAnalysisResult {
    overallSentiment: 'Positive' | 'Negative' | 'Neutral' | 'Mixed';
    confidence: number;
    breakdown?: {
        positive: number;
        negative: number;
        neutral: number;
    };
    keywords?: { text: string; sentiment: 'Positive' | 'Negative' | 'Neutral' }[];
}

export interface TranslationResult {
    originalText: string;
    translatedText: string;
    targetLanguage: string;
    sourceLanguage: string;
    aiMetadata: AIMetadata;
}

// --- Mock Data (for demonstration purposes, in a real app these would come from an API) ---
const MOCK_USERS: UserProfile[] = [
    { id: 'usr_001', name: 'Alice Smith', email: 'alice@example.com', role: 'Admin', department: 'Executive' },
    { id: 'usr_002', name: 'Bob Johnson', email: 'bob@example.com', role: 'Legal', department: 'Legal' },
    { id: 'usr_003', name: 'Charlie Brown', email: 'charlie@example.com', role: 'Compliance', department: 'Compliance' },
    { id: 'usr_004', name: 'Diana Prince', email: 'diana@example.com', role: 'Editor', department: 'PR' },
];

const MOCK_RISKS: Risk[] = [
    {
        id: 'risk_001', name: 'GDPR Non-Compliance', description: 'Potential fines and reputational damage from GDPR violations.',
        category: 'Compliance', likelihood: 'Medium', impact: 'High', mitigationStrategy: 'Regular audits, employee training, robust data protection measures.',
        status: 'Active', lastUpdated: '2023-10-26T10:00:00Z', relatedRegulations: ['GDPR', 'CCPA']
    },
    {
        id: 'risk_002', name: 'Supply Chain Disruption', description: 'Interruption of critical supplies due to geopolitical events or natural disasters.',
        category: 'Operational', likelihood: 'Medium', impact: 'Medium', mitigationStrategy: 'Diversify suppliers, maintain buffer inventory, contingency planning.',
        status: 'Active', lastUpdated: '2023-09-15T14:30:00Z'
    },
    {
        id: 'risk_003', name: 'Data Breach', description: 'Unauthorized access to sensitive customer data.',
        category: 'Reputational', likelihood: 'Medium', impact: 'Critical', mitigationStrategy: 'Enhanced cybersecurity, employee awareness, incident response plan.',
        status: 'Active', lastUpdated: '2023-11-01T09:00:00Z'
    }
];

const MOCK_COMPLIANCE_RULES: ComplianceRule[] = [
    {
        id: 'rule_gdpr', name: 'GDPR Article 33', description: 'Notification of a personal data breach to the supervisory authority.',
        jurisdiction: 'EU', effectiveDate: '2018-05-25', ruleText: 'In the case of a personal data breach, the controller shall without undue delay and, where feasible, not later than 72 hours after having become aware of it, notify the personal data breach to the supervisory authority competent in accordance with Article 55, unless the personal data breach is unlikely to result in a risk to the rights and freedoms of natural persons.',
        categories: ['Data Privacy', 'Data Breach'], severity: 'Critical', referenceUrl: 'https://gdpr-info.eu/art-33-gdpr/', lastUpdated: '2023-01-01T00:00:00Z', version: 1
    },
    {
        id: 'rule_sec_10b', name: 'SEC Rule 10b-5', description: 'Prohibits any act or omission resulting in fraud or deceit in connection with the purchase or sale of any security.',
        jurisdiction: 'US', effectiveDate: '1942-05-21', ruleText: 'It shall be unlawful for any person, directly or indirectly, by the use of any means or instrumentality of interstate commerce, or of the mails or of any facility of any national securities exchange...',
        categories: ['Financial', 'Securities'], severity: 'Critical', referenceUrl: 'https://www.sec.gov/rules/final/34-32304.txt', lastUpdated: '2023-01-01T00:00:00Z', version: 1
    }
];

const MOCK_DISCLOSURES: RegulatoryDisclosure[] = [
    {
        id: 'disc_001', title: 'Q3 2023 Earnings Report', jurisdiction: 'SEC (US)', filingDate: '2023-11-15', status: 'Filed',
        type: 'Financial', summary: 'Quarterly financial performance disclosure.', fullContent: 'Detailed financial statements, management discussion and analysis...',
        lastEditedBy: 'Alice Smith', lastEditedDate: '2023-11-14T18:00:00Z', version: 1, associatedRisks: [], documents: [], reviewHistory: [], complianceChecks: [], tags: ['Earnings', 'Financial'], audience: 'Public', isConfidential: false, language: 'en',
    },
    {
        id: 'disc_002', title: 'Minor Data Breach Notification', jurisdiction: 'ICO (UK)', filingDate: '2023-10-20', status: 'Approved',
        type: 'Data Breach', summary: 'Notification to ICO regarding a minor data breach affecting 500 users, no PII exposed.', fullContent: 'On October 18, 2023, we identified unauthorized access to a non-sensitive internal database...',
        lastEditedBy: 'Bob Johnson', lastEditedDate: '2023-10-19T10:30:00Z', version: 2, associatedRisks: ['risk_001', 'risk_003'], documents: [], reviewHistory: [], complianceChecks: [{
            ruleId: 'rule_gdpr', ruleName: 'GDPR Article 33', status: 'Pass', details: 'Breach reported within 72 hours. No high risk to data subjects.',
            checkedDate: '2023-10-19T11:00:00Z', severity: 'High', automated: true
        }], tags: ['Data Breach', 'GDPR'], sentimentAnalysis: { overallSentiment: 'Neutral', confidence: 0.8 }, keywords: ['data breach', 'notification', 'ICO'], audience: 'Regulators', legalReviewStatus: 'Approved', isConfidential: false, language: 'en',
    },
    {
        id: 'disc_003', title: 'Environmental Impact Statement for New Plant', jurisdiction: 'EPA (US)', filingDate: '2024-03-01', status: 'Draft',
        type: 'Environmental', summary: 'Draft statement assessing environmental impact of proposed new manufacturing plant.', fullContent: 'This document details the potential environmental effects, proposed mitigation strategies, and compliance with local and federal environmental regulations...',
        lastEditedBy: 'Charlie Brown', lastEditedDate: '2023-12-01T14:00:00Z', version: 1, associatedRisks: ['risk_002'], documents: [], reviewHistory: [], complianceChecks: [], tags: ['Environment', 'EPA'], audience: 'Public', isConfidential: false, language: 'en',
    }
];

// --- Utility Functions (many more would exist in a full application) ---
export const formatDate = (dateString: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric',
    });
};

export const formatDateTime = (dateString: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
    });
};

export const generateUniqueId = (prefix: string = 'id_') => `${prefix}${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

export const getStatusColorClass = (status: string) => {
    switch (status) {
        case 'Approved':
        case 'Filed':
        case 'Pass':
        case 'Mitigated':
        case 'Submitted':
            return 'text-green-400';
        case 'Pending Review':
        case 'Warning':
        case 'Upcoming':
            return 'text-yellow-400';
        case 'Rejected':
        case 'Fail':
        case 'Overdue':
        case 'Critical':
        case 'Revisions Required':
            return 'text-red-400';
        case 'Draft':
        case 'In Progress':
        default:
            return 'text-blue-400';
    }
};

export const capitalizeFirstLetter = (string: string) => string.charAt(0).toUpperCase() + string.slice(1);

// --- AI Service Wrapper (expanded) ---
export class AIComplianceService {
    private genAI: GoogleGenAI;
    private apiKey: string;
    private defaultModel: string;

    constructor(apiKey: string, defaultModel: string = 'gemini-1.5-flash') {
        if (!apiKey) throw new Error("API Key for Google GenAI is not provided.");
        this.apiKey = apiKey;
        this.genAI = new GoogleGenAI({ apiKey });
        this.defaultModel = defaultModel;
    }

    private async generateContent(prompt: string, model: string = this.defaultModel): Promise<string> {
        try {
            const aiModel = this.genAI.getGenerativeModel({ model });
            const result = await aiModel.generateContent(prompt);
            return result.response.text();
        } catch (error) {
            console.error(`Error calling AI model ${model}:`, error);
            throw new Error(`Failed to generate content: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    /**
     * Drafts a public disclosure statement.
     * @param eventDescription - Description of the event to disclose.
     * @param tone - 'Professional', 'Urgent', 'Sympathetic', 'Formal'.
     * @param targetAudience - 'General Public', 'Regulators', 'Investors'.
     * @param guidelines - Specific legal/company guidelines to adhere to.
     */
    public async draftDisclosure(
        eventDescription: string,
        tone: string = 'Professional',
        targetAudience: string = 'General Public',
        guidelines: string = ''
    ): Promise<{ draft: string; aiMetadata: AIMetadata }> {
        const prompt = `You are a legal and public relations AI. Draft a concise, professional public disclosure statement for the following event: "${eventDescription}".
        Target audience: ${targetAudience}. Tone: ${tone}. Adhere to these additional guidelines if provided: ${guidelines}.
        The output should be the disclosure text only.`;
        const startTime = Date.now();
        const responseText = await this.generateContent(prompt);
        const endTime = Date.now();
        // Mocking token count and response ID
        const aiMetadata: AIMetadata = {
            model: this.defaultModel,
            temperature: 0.7, // Example
            timestamp: new Date().toISOString(),
            promptTokens: Math.ceil(prompt.length / 4), // Rough estimate
            completionTokens: Math.ceil(responseText.length / 4), // Rough estimate
            responseId: generateUniqueId('aires_'),
        };
        return { draft: responseText, aiMetadata };
    }

    /**
     * Analyzes the sentiment of a given text.
     */
    public async analyzeSentiment(text: string): Promise<{ result: SentimentAnalysisResult; aiMetadata: AIMetadata }> {
        const prompt = `Analyze the sentiment of the following text and provide a JSON object with overallSentiment (Positive, Negative, Neutral, Mixed), confidence (0-1), and optionally breakdown for positive/negative/neutral percentages and relevant keywords with their sentiment.
        Text: "${text}"`;
        const startTime = Date.now();
        const responseText = await this.generateContent(prompt, 'gemini-1.5-pro'); // Use a more capable model for analysis
        const endTime = Date.now();
        const aiMetadata: AIMetadata = {
            model: 'gemini-1.5-pro',
            temperature: 0.2,
            timestamp: new Date().toISOString(),
            promptTokens: Math.ceil(prompt.length / 4),
            completionTokens: Math.ceil(responseText.length / 4),
            responseId: generateUniqueId('aisent_'),
        };
        try {
            const result = JSON.parse(responseText);
            // Basic validation for sentiment result structure
            if (!result.overallSentiment || !result.confidence) {
                throw new Error("Invalid sentiment analysis response structure.");
            }
            return { result, aiMetadata };
        } catch (e) {
            console.warn("AI sentiment analysis returned non-JSON or invalid structure, returning default.", e);
            return {
                result: { overallSentiment: 'Neutral', confidence: 0.5, breakdown: { positive: 0, negative: 0, neutral: 100 } },
                aiMetadata
            };
        }
    }

    /**
     * Checks a disclosure against specific compliance rules.
     * @param disclosureContent - The full content of the disclosure.
     * @param rules - An array of ComplianceRule objects to check against.
     */
    public async performComplianceCheck(
        disclosureContent: string,
        rules: ComplianceRule[]
    ): Promise<{ checks: ComplianceCheckResult[]; aiMetadata: AIMetadata }> {
        const rulePrompts = rules.map(rule => `- Rule Name: ${rule.name}\n  Rule ID: ${rule.id}\n  Rule Text: ${rule.ruleText}\n  Severity: ${rule.severity}`).join('\n');
        const prompt = `You are an expert compliance AI. Review the following disclosure content against the provided compliance rules.
        For each rule, determine if the disclosure content 'Passes', 'Fails', or has a 'Warning'. Provide details for each check.
        Respond with a JSON array of objects, each containing ruleId, ruleName, status ('Pass'|'Fail'|'Warning'), details, and severity.
        
        Disclosure Content:
        "${disclosureContent}"
        
        Compliance Rules to check:
        ${rulePrompts}
        `;
        const startTime = Date.now();
        const responseText = await this.generateContent(prompt, 'gemini-1.5-pro');
        const endTime = Date.now();
        const aiMetadata: AIMetadata = {
            model: 'gemini-1.5-pro',
            temperature: 0.3,
            timestamp: new Date().toISOString(),
            promptTokens: Math.ceil(prompt.length / 4),
            completionTokens: Math.ceil(responseText.length / 4),
            responseId: generateUniqueId('aicompl_'),
        };
        try {
            const checks: ComplianceCheckResult[] = JSON.parse(responseText).map((check: any) => ({
                ...check,
                checkedDate: new Date().toISOString(),
                automated: true,
            }));
            // Basic validation
            if (!Array.isArray(checks) || !checks.every(c => c.ruleId && c.status)) {
                throw new Error("Invalid compliance check response structure.");
            }
            return { checks, aiMetadata };
        } catch (e) {
            console.warn("AI compliance check returned non-JSON or invalid structure, returning defaults.", e);
            return {
                checks: rules.map(r => ({
                    ruleId: r.id, ruleName: r.name, status: 'Warning', details: 'AI check failed or returned invalid data. Manual review required.',
                    checkedDate: new Date().toISOString(), severity: r.severity, automated: true,
                })),
                aiMetadata
            };
        }
    }

    /**
     * Translates disclosure content to a target language.
     */
    public async translateDisclosure(text: string, targetLanguage: string): Promise<{ result: TranslationResult; aiMetadata: AIMetadata }> {
        const prompt = `Translate the following text into ${targetLanguage}. Provide the original text, translated text, target language, and source language in a JSON object.
        Text: "${text}"`;
        const startTime = Date.now();
        const responseText = await this.generateContent(prompt, 'gemini-1.5-flash');
        const endTime = Date.now();
        const aiMetadata: AIMetadata = {
            model: 'gemini-1.5-flash',
            temperature: 0.5,
            timestamp: new Date().toISOString(),
            promptTokens: Math.ceil(prompt.length / 4),
            completionTokens: Math.ceil(responseText.length / 4),
            responseId: generateUniqueId('aitrans_'),
        };
        try {
            const result: TranslationResult = JSON.parse(responseText);
            if (!result.translatedText || !result.targetLanguage) {
                throw new Error("Invalid translation response structure.");
            }
            return { result, aiMetadata };
        } catch (e) {
            console.warn("AI translation failed or returned invalid structure, returning original text.", e);
            return {
                result: {
                    originalText: text,
                    translatedText: `[Translation to ${targetLanguage} failed or incomplete: ${text}]`,
                    targetLanguage: targetLanguage,
                    sourceLanguage: 'en', // Assuming source is English by default
                    aiMetadata: aiMetadata
                },
                aiMetadata
            };
        }
    }

    /**
     * Summarizes a long regulatory document or text.
     */
    public async summarizeDocument(documentContent: string, length: 'short' | 'medium' | 'long' = 'medium'): Promise<{ summary: string; aiMetadata: AIMetadata }> {
        const prompt = `Summarize the following document content. The summary should be ${length}.
        Document Content: "${documentContent}"`;
        const startTime = Date.now();
        const responseText = await this.generateContent(prompt, 'gemini-1.5-pro');
        const endTime = Date.now();
        const aiMetadata: AIMetadata = {
            model: 'gemini-1.5-pro',
            temperature: 0.4,
            timestamp: new Date().toISOString(),
            promptTokens: Math.ceil(prompt.length / 4),
            completionTokens: Math.ceil(responseText.length / 4),
            responseId: generateUniqueId('aisum_'),
        };
        return { summary: responseText, aiMetadata };
    }
}

// --- Custom Hooks (to manage complex state and logic) ---
export const useDisclosureManagement = (initialDisclosures: RegulatoryDisclosure[], initialUsers: UserProfile[]) => {
    const [disclosures, setDisclosures] = useState<RegulatoryDisclosure[]>(initialDisclosures);
    const [selectedDisclosure, setSelectedDisclosure] = useState<RegulatoryDisclosure | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    const [isAdding, setIsAdding] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [filterStatus, setFilterStatus] = useState<string>('All');
    const [filterType, setFilterType] = useState<string>('All');
    const [currentPage, setCurrentPage] = useState(1);
    const disclosuresPerPage = 10;

    const allUsers = initialUsers; // Assuming users are static or fetched elsewhere

    const filteredDisclosures = useMemo(() => {
        let filtered = disclosures;
        if (searchTerm) {
            filtered = filtered.filter(d =>
                d.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                d.summary.toLowerCase().includes(searchTerm.toLowerCase()) ||
                d.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
            );
        }
        if (filterStatus !== 'All') {
            filtered = filtered.filter(d => d.status === filterStatus);
        }
        if (filterType !== 'All') {
            filtered = filtered.filter(d => d.type === filterType);
        }
        return filtered;
    }, [disclosures, searchTerm, filterStatus, filterType]);

    const paginatedDisclosures = useMemo(() => {
        const startIndex = (currentPage - 1) * disclosuresPerPage;
        return filteredDisclosures.slice(startIndex, startIndex + disclosuresPerPage);
    }, [filteredDisclosures, currentPage, disclosuresPerPage]);

    const totalPages = useMemo(() => Math.ceil(filteredDisclosures.length / disclosuresPerPage), [filteredDisclosures, disclosuresPerPage]);

    const addDisclosure = useCallback((newDisclosure: RegulatoryDisclosure) => {
        setDisclosures(prev => [...prev, newDisclosure]);
        setSelectedDisclosure(newDisclosure);
        setIsAdding(false);
    }, []);

    const updateDisclosure = useCallback((updatedDisclosure: RegulatoryDisclosure) => {
        setDisclosures(prev => prev.map(d => d.id === updatedDisclosure.id ? updatedDisclosure : d));
        setSelectedDisclosure(updatedDisclosure);
        setIsEditing(false);
    }, []);

    const deleteDisclosure = useCallback((id: string) => {
        setDisclosures(prev => prev.filter(d => d.id !== id));
        setSelectedDisclosure(null);
    }, []);

    const getDisclosureById = useCallback((id: string) => {
        return disclosures.find(d => d.id === id);
    }, [disclosures]);

    return {
        disclosures,
        filteredDisclosures,
        paginatedDisclosures,
        selectedDisclosure,
        setSelectedDisclosure,
        isEditing,
        setIsEditing,
        isAdding,
        setIsAdding,
        searchTerm,
        setSearchTerm,
        filterStatus,
        setFilterStatus,
        filterType,
        setFilterType,
        currentPage,
        setCurrentPage,
        totalPages,
        addDisclosure,
        updateDisclosure,
        deleteDisclosure,
        getDisclosureById,
        allUsers,
    };
};

export const useAuditLog = (initialLogs: AuditLogEntry[]) => {
    const [auditLogs, setAuditLogs] = useState<AuditLogEntry[]>(initialLogs);

    const addLogEntry = useCallback((entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) => {
        const newLog: AuditLogEntry = {
            id: generateUniqueId('log_'),
            timestamp: new Date().toISOString(),
            ...entry,
        };
        setAuditLogs(prev => [newLog, ...prev]);
    }, []);

    return { auditLogs, addLogEntry };
};

// --- Generic UI Components (many more would exist in a component library) ---

// Reusable Modal Component
export const Modal: React.FC<{ isOpen: boolean; onClose: () => void; title: string; children: React.ReactNode; className?: string }> = ({ isOpen, onClose, title, children, className }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className={classNames("bg-gray-800 rounded-lg shadow-2xl max-w-3xl w-full max-h-[90vh] flex flex-col", className)} onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">&times;</button>
                </div>
                <div className="p-6 flex-grow overflow-y-auto">
                    {children}
                </div>
            </div>
        </div>
    );
};

export const InputField: React.FC<{ label: string; id: string; value: string; onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void; type?: string; placeholder?: string; required?: boolean; rows?: number }> = ({ label, id, value, onChange, type = 'text', placeholder, required = false, rows = 3 }) => (
    <div className="flex flex-col">
        <label htmlFor={id} className="text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
        {type === 'textarea' ? (
            <textarea
                id={id}
                value={value}
                onChange={onChange}
                placeholder={placeholder}
                required={required}
                rows={rows}
                className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
            />
        ) : (
            <input
                type={type}
                id={id}
                value={value}
                onChange={onChange}
                placeholder={placeholder}
                required={required}
                className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
            />
        )}
    </div>
);

export const SelectField: React.FC<{ label: string; id: string; value: string; onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void; options: { value: string; label: string }[]; required?: boolean }> = ({ label, id, value, onChange, options, required = false }) => (
    <div className="flex flex-col">
        <label htmlFor={id} className="text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
        <select
            id={id}
            value={value}
            onChange={onChange}
            required={required}
            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
        >
            {options.map(option => (
                <option key={option.value} value={option.value}>{option.label}</option>
            ))}
        </select>
    </div>
);

export const CheckboxField: React.FC<{ label: string; id: string; checked: boolean; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void }> = ({ label, id, checked, onChange }) => (
    <div className="flex items-center space-x-2">
        <input
            type="checkbox"
            id={id}
            checked={checked}
            onChange={onChange}
            className="h-4 w-4 text-cyan-600 rounded border-gray-600 bg-gray-700/50 focus:ring-cyan-500"
        />
        <label htmlFor={id} className="text-sm text-gray-300">{label}</label>
    </div>
);

export const Button: React.FC<{ onClick: () => void; children: React.ReactNode; primary?: boolean; disabled?: boolean; className?: string }> = ({ onClick, children, primary = true, disabled = false, className }) => (
    <button
        onClick={onClick}
        disabled={disabled}
        className={classNames(
            "px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200",
            primary ? "bg-cyan-600 hover:bg-cyan-700 text-white" : "bg-gray-700 hover:bg-gray-600 text-gray-200 border border-gray-600",
            disabled ? "opacity-50 cursor-not-allowed" : "",
            className
        )}
    >
        {children}
    </button>
);

export const Tabs: React.FC<{ tabs: { id: string; label: string; content: React.ReactNode }[]; activeTab: string; onChange: (tabId: string) => void }> = ({ tabs, activeTab, onChange }) => (
    <div>
        <div className="border-b border-gray-700">
            <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                {tabs.map(tab => (
                    <button
                        key={tab.id}
                        onClick={() => onChange(tab.id)}
                        className={classNames(
                            activeTab === tab.id
                                ? 'border-cyan-500 text-cyan-400'
                                : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-300',
                            'whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200'
                        )}
                        aria-current={activeTab === tab.id ? 'page' : undefined}
                    >
                        {tab.label}
                    </button>
                ))}
            </nav>
        </div>
        <div className="pt-4">
            {tabs.find(tab => tab.id === activeTab)?.content}
        </div>
    </div>
);

// --- Disclosure Sub-Components ---

export const DisclosureForm: React.FC<{
    disclosure: RegulatoryDisclosure;
    onChange: (field: keyof RegulatoryDisclosure, value: any) => void;
    onSave: () => void;
    onCancel: () => void;
    isLoading?: boolean;
    isNew?: boolean;
    users: UserProfile[];
    risks: Risk[];
    auditLoggers: {
        addLogEntry: (entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) => void;
    };
}> = ({ disclosure, onChange, onSave, onCancel, isLoading = false, isNew = false, users, risks, auditLoggers }) => {
    const { addLogEntry } = auditLoggers;

    const handleSave = () => {
        onSave();
        addLogEntry({
            userId: 'usr_001', // Mock current user
            userName: 'Alice Smith',
            action: isNew ? 'CREATED' : 'UPDATED',
            entityType: 'Disclosure',
            entityId: disclosure.id,
            details: isNew ? `Created new disclosure: ${disclosure.title}` : `Updated disclosure: ${disclosure.title}`,
            newValue: disclosure
        });
    };

    const statusOptions = ['Draft', 'Pending Review', 'Approved', 'Filed', 'Rejected'].map(s => ({ value: s, label: s }));
    const typeOptions = ['Financial', 'Environmental', 'Data Breach', 'Governance', 'Product Safety', 'Other'].map(t => ({ value: t, label: t }));
    const audienceOptions = ['Public', 'Regulators', 'Internal'].map(a => ({ value: a, label: a }));
    const legalReviewOptions = ['Not Started', 'In Progress', 'Approved', 'Revisions Required'].map(s => ({ value: s, label: s }));
    const languageOptions = [{ value: 'en', label: 'English' }, { value: 'es', label: 'Spanish' }, { value: 'fr', label: 'French' }];

    const selectedRiskIds = disclosure.associatedRisks || [];
    const handleRiskChange = (riskId: string, isChecked: boolean) => {
        let newRisks = new Set(selectedRiskIds);
        if (isChecked) {
            newRisks.add(riskId);
        } else {
            newRisks.delete(riskId);
        }
        onChange('associatedRisks', Array.from(newRisks));
    };

    return (
        <div className="space-y-4">
            <InputField label="Title" id="title" value={disclosure.title} onChange={e => onChange('title', e.target.value)} required />
            <InputField label="Jurisdiction" id="jurisdiction" value={disclosure.jurisdiction} onChange={e => onChange('jurisdiction', e.target.value)} required />
            <InputField label="Filing Date" id="filingDate" type="date" value={disclosure.filingDate ? disclosure.filingDate.split('T')[0] : ''} onChange={e => onChange('filingDate', e.target.value)} />
            <SelectField label="Status" id="status" value={disclosure.status} onChange={e => onChange('status', e.target.value)} options={statusOptions} />
            <SelectField label="Type" id="type" value={disclosure.type} onChange={e => onChange('type', e.target.value)} options={typeOptions} />
            <SelectField label="Audience" id="audience" value={disclosure.audience} onChange={e => onChange('audience', e.target.value)} options={audienceOptions} />
            <SelectField label="Legal Review Status" id="legalReviewStatus" value={disclosure.legalReviewStatus || 'Not Started'} onChange={e => onChange('legalReviewStatus', e.target.value)} options={legalReviewOptions} />
            <SelectField label="Language" id="language" value={disclosure.language} onChange={e => onChange('language', e.target.value)} options={languageOptions} />
            <InputField label="Summary" id="summary" type="textarea" value={disclosure.summary} onChange={e => onChange('summary', e.target.value)} rows={4} />
            <InputField label="Full Content" id="fullContent" type="textarea" value={disclosure.fullContent} onChange={e => onChange('fullContent', e.target.value)} rows={10} required />
            <InputField label="Tags (comma-separated)" id="tags" value={disclosure.tags.join(', ')} onChange={e => onChange('tags', e.target.value.split(',').map(tag => tag.trim()))} placeholder="e.g., Financial, ESG, Data Breach" />
            <CheckboxField label="Confidential" id="isConfidential" checked={disclosure.isConfidential} onChange={e => onChange('isConfidential', e.target.checked)} />

            <div>
                <h4 className="text-md font-semibold text-gray-300 mb-2">Associated Risks</h4>
                <div className="grid grid-cols-2 gap-2 max-h-40 overflow-y-auto pr-2">
                    {risks.map(risk => (
                        <CheckboxField
                            key={risk.id}
                            id={`risk-${risk.id}`}
                            label={risk.name}
                            checked={selectedRiskIds.includes(risk.id)}
                            onChange={(e) => handleRiskChange(risk.id, e.target.checked)}
                        />
                    ))}
                </div>
            </div>

            <div className="flex justify-end space-x-4 mt-6">
                <Button onClick={onCancel} primary={false}>Cancel</Button>
                <Button onClick={handleSave} disabled={isLoading || !disclosure.title || !disclosure.fullContent}>
                    {isLoading ? (isNew ? 'Adding...' : 'Saving...') : (isNew ? 'Add Disclosure' : 'Save Changes')}
                </Button>
            </div>
        </div>
    );
};


export const DisclosureDetails: React.FC<{
    disclosure: RegulatoryDisclosure;
    onEdit: () => void;
    onDelete: (id: string) => void;
    onUpdateStatus: (id: string, newStatus: RegulatoryDisclosure['status']) => void;
    aiService: AIComplianceService;
    onUpdateDisclosure: (updatedDisc: RegulatoryDisclosure) => void;
    complianceRules: ComplianceRule[];
    auditLoggers: {
        addLogEntry: (entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) => void;
    };
}> = ({ disclosure, onEdit, onDelete, onUpdateStatus, aiService, onUpdateDisclosure, complianceRules, auditLoggers }) => {
    const [activeTab, setActiveTab] = useState('overview');
    const [isTranslating, setIsTranslating] = useState(false);
    const [translatedContent, setTranslatedContent] = useState('');
    const [targetLanguage, setTargetLanguage] = useState('es');
    const [isCheckingCompliance, setIsCheckingCompliance] = useState(false);
    const [isAnalyzingSentiment, setIsAnalyzingSentiment] = useState(false);
    const { addLogEntry } = auditLoggers;

    const handleUpdateStatus = (newStatus: RegulatoryDisclosure['status']) => {
        onUpdateStatus(disclosure.id, newStatus);
        addLogEntry({
            userId: 'usr_001',
            userName: 'Alice Smith',
            action: 'STATUS_UPDATE',
            entityType: 'Disclosure',
            entityId: disclosure.id,
            details: `Updated status of disclosure '${disclosure.title}' to ${newStatus}`,
            previousValue: disclosure.status,
            newValue: newStatus
        });
    };

    const handleTranslate = async () => {
        setIsTranslating(true);
        setTranslatedContent('');
        try {
            const { result, aiMetadata } = await aiService.translateDisclosure(disclosure.fullContent, targetLanguage);
            setTranslatedContent(result.translatedText);
            addLogEntry({
                userId: 'usr_001',
                userName: 'Alice Smith',
                action: 'AI_TRANSLATION',
                entityType: 'Disclosure',
                entityId: disclosure.id,
                details: `Translated disclosure '${disclosure.title}' to ${targetLanguage} using AI.`,
                newValue: { translatedText: result.translatedText, aiMetadata }
            });
        } catch (error) {
            console.error("Translation failed:", error);
            setTranslatedContent("Translation failed. Please try again.");
        } finally {
            setIsTranslating(false);
        }
    };

    const handlePerformComplianceCheck = async () => {
        setIsCheckingCompliance(true);
        try {
            const rulesToCheck = complianceRules.filter(rule => disclosure.tags.some(tag => rule.categories.includes(tag)));
            if (rulesToCheck.length === 0) {
                alert('No relevant compliance rules found for this disclosure based on its tags.');
                return;
            }
            const { checks, aiMetadata } = await aiService.performComplianceCheck(disclosure.fullContent, rulesToCheck);
            const updatedDisclosure = { ...disclosure, complianceChecks: checks };
            onUpdateDisclosure(updatedDisclosure);
            addLogEntry({
                userId: 'usr_001',
                userName: 'Alice Smith',
                action: 'AI_COMPLIANCE_CHECK',
                entityType: 'Disclosure',
                entityId: disclosure.id,
                details: `Performed AI compliance check on disclosure '${disclosure.title}'.`,
                newValue: { complianceChecks: checks, aiMetadata }
            });
        } catch (error) {
            console.error("Compliance check failed:", error);
            alert("Failed to perform compliance check. See console for details.");
        } finally {
            setIsCheckingCompliance(false);
        }
    };

    const handleAnalyzeSentiment = async () => {
        setIsAnalyzingSentiment(true);
        try {
            const { result, aiMetadata } = await aiService.analyzeSentiment(disclosure.fullContent);
            const updatedDisclosure = { ...disclosure, sentimentAnalysis: result };
            onUpdateDisclosure(updatedDisclosure);
            addLogEntry({
                userId: 'usr_001',
                userName: 'Alice Smith',
                action: 'AI_SENTIMENT_ANALYSIS',
                entityType: 'Disclosure',
                entityId: disclosure.id,
                details: `Performed AI sentiment analysis on disclosure '${disclosure.title}'.`,
                newValue: { sentimentAnalysis: result, aiMetadata }
            });
        } catch (error) {
            console.error("Sentiment analysis failed:", error);
            alert("Failed to perform sentiment analysis. See console for details.");
        } finally {
            setIsAnalyzingSentiment(false);
        }
    };

    const tabs = [
        { id: 'overview', label: 'Overview', content: (
            <div className="space-y-3 text-gray-300 text-sm">
                <p><strong>Type:</strong> {disclosure.type}</p>
                <p><strong>Jurisdiction:</strong> {disclosure.jurisdiction}</p>
                <p><strong>Filing Date:</strong> {formatDate(disclosure.filingDate)}</p>
                <p><strong>Status:</strong> <span className={getStatusColorClass(disclosure.status)}>{disclosure.status}</span></p>
                <p><strong>Audience:</strong> {disclosure.audience}</p>
                <p><strong>Language:</strong> {disclosure.language}</p>
                <p><strong>Confidential:</strong> {disclosure.isConfidential ? 'Yes' : 'No'}</p>
                <p><strong>Last Edited By:</strong> {disclosure.lastEditedBy} on {formatDateTime(disclosure.lastEditedDate)} (v{disclosure.version})</p>
                <p><strong>Tags:</strong> {disclosure.tags.join(', ')}</p>
                <div className="mt-4 p-3 bg-gray-700/50 rounded-md">
                    <h4 className="font-semibold text-white mb-2">Summary</h4>
                    <p>{disclosure.summary}</p>
                </div>
                <div className="mt-4 p-3 bg-gray-700/50 rounded-md">
                    <h4 className="font-semibold text-white mb-2">Full Content</h4>
                    <pre className="whitespace-pre-wrap font-sans text-gray-200">{disclosure.fullContent}</pre>
                </div>
            </div>
        )},
        { id: 'compliance', label: 'Compliance Checks', content: (
            <div className="space-y-4">
                <Button onClick={handlePerformComplianceCheck} disabled={isCheckingCompliance}>
                    {isCheckingCompliance ? 'Checking...' : 'Run AI Compliance Check'}
                </Button>
                {disclosure.complianceChecks && disclosure.complianceChecks.length > 0 ? (
                    <div className="space-y-2">
                        {disclosure.complianceChecks.map((check, idx) => (
                            <div key={idx} className="p-3 bg-gray-700/50 rounded-md">
                                <p className="text-white text-md font-semibold">{check.ruleName} (<span className={getStatusColorClass(check.status)}>{check.status}</span>)</p>
                                <p className="text-gray-400 text-sm">Severity: {check.severity} | Checked: {formatDateTime(check.checkedDate)}</p>
                                <p className="text-gray-300 text-sm mt-1">{check.details}</p>
                            </div>
                        ))}
                    </div>
                ) : (
                    <p className="text-gray-400">No compliance checks performed yet.</p>
                )}
            </div>
        )},
        { id: 'sentiment', label: 'Sentiment Analysis', content: (
            <div className="space-y-4">
                <Button onClick={handleAnalyzeSentiment} disabled={isAnalyzingSentiment}>
                    {isAnalyzingSentiment ? 'Analyzing...' : 'Run AI Sentiment Analysis'}
                </Button>
                {disclosure.sentimentAnalysis ? (
                    <div className="p-3 bg-gray-700/50 rounded-md text-gray-300">
                        <p><strong>Overall Sentiment:</strong> <span className={getStatusColorClass(disclosure.sentimentAnalysis.overallSentiment === 'Positive' ? 'Approved' : disclosure.sentimentAnalysis.overallSentiment === 'Negative' ? 'Rejected' : 'Draft')}>{disclosure.sentimentAnalysis.overallSentiment}</span> (Confidence: {(disclosure.sentimentAnalysis.confidence * 100).toFixed(0)}%)</p>
                        {disclosure.sentimentAnalysis.breakdown && (
                            <div className="mt-2 text-sm">
                                <p>Positive: {disclosure.sentimentAnalysis.breakdown.positive}%</p>
                                <p>Negative: {disclosure.sentimentAnalysis.breakdown.negative}%</p>
                                <p>Neutral: {disclosure.sentimentAnalysis.breakdown.neutral}%</p>
                            </div>
                        )}
                        {disclosure.sentimentAnalysis.keywords && disclosure.sentimentAnalysis.keywords.length > 0 && (
                            <div className="mt-2">
                                <h5 className="font-semibold text-white">Keywords:</h5>
                                <ul className="list-disc list-inside text-sm">
                                    {disclosure.sentimentAnalysis.keywords.map((kw, idx) => (
                                        <li key={idx}><span className={getStatusColorClass(kw.sentiment === 'Positive' ? 'Approved' : kw.sentiment === 'Negative' ? 'Rejected' : 'Draft')}>{kw.text}</span> ({kw.sentiment})</li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                ) : (
                    <p className="text-gray-400">No sentiment analysis performed yet.</p>
                )}
            </div>
        )},
        { id: 'translation', label: 'Translation', content: (
            <div className="space-y-4">
                <div className="flex items-end space-x-2">
                    <SelectField
                        label="Target Language"
                        id="targetLanguage"
                        value={targetLanguage}
                        onChange={e => setTargetLanguage(e.target.value)}
                        options={[{ value: 'es', label: 'Spanish' }, { value: 'fr', label: 'French' }, { value: 'de', label: 'German' }, { value: 'zh', label: 'Chinese' }]}
                    />
                    <Button onClick={handleTranslate} disabled={isTranslating}>
                        {isTranslating ? 'Translating...' : 'Translate Content'}
                    </Button>
                </div>
                {translatedContent && (
                    <Card title={`Translated Content (${targetLanguage})`}>
                        <div className="min-h-[10rem] max-h-60 overflow-y-auto text-sm text-gray-300 whitespace-pre-line">{translatedContent}</div>
                    </Card>
                )}
            </div>
        )},
        { id: 'reviews', label: 'Review History', content: (
            <div className="space-y-3">
                {disclosure.reviewHistory && disclosure.reviewHistory.length > 0 ? (
                    disclosure.reviewHistory.map(review => (
                        <div key={review.id} className="p-3 bg-gray-700/50 rounded-md text-gray-300">
                            <p className="font-semibold text-white">{review.reviewerName} - <span className={getStatusColorClass(review.status)}>{review.status}</span></p>
                            <p className="text-xs text-gray-400">{formatDateTime(review.reviewDate)}</p>
                            <p className="mt-1 text-sm">{review.comments}</p>
                        </div>
                    ))
                ) : (
                    <p className="text-gray-400">No review history available.</p>
                )}
            </div>
        )},
        { id: 'documents', label: 'Documents', content: (
            <div className="space-y-3">
                {disclosure.documents && disclosure.documents.length > 0 ? (
                    <ul className="list-disc list-inside text-gray-300">
                        {disclosure.documents.map(doc => (
                            <li key={doc.id}>
                                <a href={doc.url} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">
                                    {doc.name}
                                </a> ({doc.type}) - {formatDate(doc.uploadedDate)} by {doc.uploadedBy}
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p className="text-gray-400">No documents attached.</p>
                )}
                {/* Add document upload functionality here */}
            </div>
        )},
        { id: 'audit', label: 'Audit Log', content: (
            <AuditLogTable filterEntityId={disclosure.id} filterEntityType="Disclosure" />
        )},
    ];

    return (
        <Card title={disclosure.title} className="p-0">
            <div className="p-4 flex justify-between items-center border-b border-gray-700">
                <div className="flex space-x-2">
                    <Button onClick={onEdit}>Edit</Button>
                    <Button onClick={() => onDelete(disclosure.id)} primary={false} className="bg-red-700 hover:bg-red-800 border-red-700">Delete</Button>
                </div>
                <div className="flex space-x-2">
                    <SelectField
                        label=""
                        id="status-update"
                        value={disclosure.status}
                        onChange={e => handleUpdateStatus(e.target.value as RegulatoryDisclosure['status'])}
                        options={[
                            { value: 'Draft', label: 'Draft' },
                            { value: 'Pending Review', label: 'Pending Review' },
                            { value: 'Approved', label: 'Approved' },
                            { value: 'Filed', label: 'Filed' },
                            { value: 'Rejected', label: 'Rejected' },
                        ]}
                    />
                </div>
            </div>
            <div className="p-4">
                <Tabs tabs={tabs} activeTab={activeTab} onChange={setActiveTab} />
            </div>
        </Card>
    );
};

export const AuditLogTable: React.FC<{ filterEntityId?: string; filterEntityType?: AuditLogEntry['entityType'] }> = ({ filterEntityId, filterEntityType }) => {
    const { auditLogs } = useContext(DataContext); // Assuming DataContext also holds auditLogs now
    if (!auditLogs) return <p className="text-gray-400">Audit logs not available.</p>;

    const filteredLogs = useMemo(() => {
        let logs = auditLogs;
        if (filterEntityId) {
            logs = logs.filter(log => log.entityId === filterEntityId && log.entityType === filterEntityType);
        }
        return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    }, [auditLogs, filterEntityId, filterEntityType]);

    const [currentPage, setCurrentPage] = useState(1);
    const logsPerPage = 10;
    const paginatedLogs = useMemo(() => {
        const startIndex = (currentPage - 1) * logsPerPage;
        return filteredLogs.slice(startIndex, startIndex + logsPerPage);
    }, [filteredLogs, currentPage, logsPerPage]);

    const totalPages = Math.ceil(filteredLogs.length / logsPerPage);

    return (
        <div className="space-y-4">
            <h3 className="text-lg font-semibold text-white">Audit Log</h3>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Timestamp</th>
                            <th scope="col" className="px-6 py-3">User</th>
                            <th scope="col" className="px-6 py-3">Action</th>
                            <th scope="col" className="px-6 py-3">Entity Type</th>
                            <th scope="col" className="px-6 py-3">Entity ID</th>
                            <th scope="col" className="px-6 py-3">Details</th>
                        </tr>
                    </thead>
                    <tbody>
                        {paginatedLogs.length > 0 ? (
                            paginatedLogs.map(log => (
                                <tr key={log.id} className="bg-gray-800/50 border-b border-gray-700 hover:bg-gray-700/50">
                                    <td className="px-6 py-4 whitespace-nowrap">{formatDateTime(log.timestamp)}</td>
                                    <td className="px-6 py-4">{log.userName}</td>
                                    <td className="px-6 py-4"><span className={getStatusColorClass(log.action === 'DELETED' ? 'Rejected' : log.action === 'CREATED' ? 'Approved' : 'Draft')}>{capitalizeFirstLetter(log.action.replace('_', ' '))}</span></td>
                                    <td className="px-6 py-4">{log.entityType}</td>
                                    <td className="px-6 py-4">{log.entityId}</td>
                                    <td className="px-6 py-4 max-w-xs overflow-hidden text-ellipsis">{log.details}</td>
                                </tr>
                            ))
                        ) : (
                            <tr><td colSpan={6} className="px-6 py-4 text-center text-gray-500">No audit log entries found.</td></tr>
                        )}
                    </tbody>
                </table>
            </div>
            {totalPages > 1 && (
                <Pagination currentPage={currentPage} totalPages={totalPages} onPageChange={setCurrentPage} />
            )}
        </div>
    );
};

export const Pagination: React.FC<{ currentPage: number; totalPages: number; onPageChange: (page: number) => void }> = ({ currentPage, totalPages, onPageChange }) => {
    const pages = Array.from({ length: totalPages }, (_, i) => i + 1);

    return (
        <nav className="flex items-center justify-between border-t border-gray-700 px-4 py-3 sm:px-6">
            <div className="flex flex-1 justify-between sm:hidden">
                <Button onClick={() => onPageChange(currentPage - 1)} disabled={currentPage === 1}>Previous</Button>
                <Button onClick={() => onPageChange(currentPage + 1)} disabled={currentPage === totalPages}>Next</Button>
            </div>
            <div className="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
                <div>
                    <p className="text-sm text-gray-400">
                        Page <span className="font-medium">{currentPage}</span> of{' '}
                        <span className="font-medium">{totalPages}</span>
                    </p>
                </div>
                <div>
                    <nav className="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
                        <button
                            onClick={() => onPageChange(currentPage - 1)}
                            disabled={currentPage === 1}
                            className="relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-700 hover:bg-gray-700 focus:z-20 focus:outline-offset-0 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <span className="sr-only">Previous</span>
                            <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" />
                            </svg>
                        </button>
                        {pages.map(page => (
                            <button
                                key={page}
                                onClick={() => onPageChange(page)}
                                aria-current={page === currentPage ? 'page' : undefined}
                                className={classNames(
                                    'relative inline-flex items-center px-4 py-2 text-sm font-semibold focus:z-20',
                                    page === currentPage
                                        ? 'z-10 bg-cyan-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-cyan-600'
                                        : 'text-gray-400 ring-1 ring-inset ring-gray-700 hover:bg-gray-700 focus:outline-offset-0'
                                )}
                            >
                                {page}
                            </button>
                        ))}
                        <button
                            onClick={() => onPageChange(currentPage + 1)}
                            disabled={currentPage === totalPages}
                            className="relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-700 hover:bg-gray-700 focus:z-20 focus:outline-offset-0 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <span className="sr-only">Next</span>
                            <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fillRule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clipRule="evenodd" />
                            </svg>
                        </button>
                    </nav>
                </div>
            </div>
        </nav>
    );
};

export const FilingScheduleComponent: React.FC<{
    schedules: FilingSchedule[];
    onAdd: (schedule: FilingSchedule) => void;
    onUpdate: (schedule: FilingSchedule) => void;
    onDelete: (id: string) => void;
    disclosures: RegulatoryDisclosure[];
    users: UserProfile[];
    auditLoggers: {
        addLogEntry: (entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) => void;
    };
}> = ({ schedules, onAdd, onUpdate, onDelete, disclosures, users, auditLoggers }) => {
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentSchedule, setCurrentSchedule] = useState<FilingSchedule | null>(null);
    const { addLogEntry } = auditLoggers;

    const handleAddClick = () => {
        setCurrentSchedule({
            id: generateUniqueId('sched_'),
            disclosureId: '',
            title: '',
            deadline: '',
            jurisdiction: '',
            status: 'Upcoming',
            remindersSent: 0,
            assignedTo: users[0]?.id || '', // Default to first user
            notes: '',
        });
        setIsModalOpen(true);
    };

    const handleEditClick = (schedule: FilingSchedule) => {
        setCurrentSchedule(schedule);
        setIsModalOpen(true);
    };

    const handleSave = () => {
        if (currentSchedule) {
            if (schedules.find(s => s.id === currentSchedule.id)) {
                onUpdate(currentSchedule);
                addLogEntry({
                    userId: 'usr_001',
                    userName: 'Alice Smith',
                    action: 'UPDATED',
                    entityType: 'FilingSchedule',
                    entityId: currentSchedule.id,
                    details: `Updated filing schedule: ${currentSchedule.title}`,
                    newValue: currentSchedule
                });
            } else {
                onAdd(currentSchedule);
                addLogEntry({
                    userId: 'usr_001',
                    userName: 'Alice Smith',
                    action: 'CREATED',
                    entityType: 'FilingSchedule',
                    entityId: currentSchedule.id,
                    details: `Created filing schedule: ${currentSchedule.title}`,
                    newValue: currentSchedule
                });
            }
            setIsModalOpen(false);
            setCurrentSchedule(null);
        }
    };

    const handleChange = (field: keyof FilingSchedule, value: any) => {
        setCurrentSchedule(prev => prev ? { ...prev, [field]: value } : null);
    };

    const disclosureOptions = disclosures.map(d => ({ value: d.id, label: d.title }));
    const userOptions = users.map(u => ({ value: u.id, label: u.name }));
    const statusOptions = ['Upcoming', 'Submitted', 'Overdue'].map(s => ({ value: s, label: s }));

    return (
        <Card title="Filing Schedules">
            <div className="flex justify-end mb-4">
                <Button onClick={handleAddClick}>Add New Schedule</Button>
            </div>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Title</th>
                            <th scope="col" className="px-6 py-3">Disclosure</th>
                            <th scope="col" className="px-6 py-3">Deadline</th>
                            <th scope="col" className="px-6 py-3">Jurisdiction</th>
                            <th scope="col" className="px-6 py-3">Assigned To</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {schedules.length > 0 ? (
                            schedules.map(schedule => (
                                <tr key={schedule.id} className="bg-gray-800/50 border-b border-gray-700 hover:bg-gray-700/50">
                                    <td className="px-6 py-4 text-white">{schedule.title}</td>
                                    <td className="px-6 py-4">{disclosures.find(d => d.id === schedule.disclosureId)?.title || 'N/A'}</td>
                                    <td className="px-6 py-4">{formatDate(schedule.deadline)}</td>
                                    <td className="px-6 py-4">{schedule.jurisdiction}</td>
                                    <td className="px-6 py-4">{users.find(u => u.id === schedule.assignedTo)?.name || 'N/A'}</td>
                                    <td className="px-6 py-4"><span className={getStatusColorClass(schedule.status)}>{schedule.status}</span></td>
                                    <td className="px-6 py-4 flex space-x-2">
                                        <Button onClick={() => handleEditClick(schedule)} primary={false} className="py-1 px-3">Edit</Button>
                                        <Button onClick={() => {
                                            onDelete(schedule.id);
                                            addLogEntry({
                                                userId: 'usr_001',
                                                userName: 'Alice Smith',
                                                action: 'DELETED',
                                                entityType: 'FilingSchedule',
                                                entityId: schedule.id,
                                                details: `Deleted filing schedule: ${schedule.title}`,
                                                previousValue: schedule
                                            });
                                        }} primary={false} className="py-1 px-3 bg-red-700 hover:bg-red-800 border-red-700">Delete</Button>
                                    </td>
                                </tr>
                            ))
                        ) : (
                            <tr><td colSpan={7} className="px-6 py-4 text-center text-gray-500">No filing schedules found.</td></tr>
                        )}
                    </tbody>
                </table>
            </div>

            <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title={currentSchedule?.id ? "Edit Filing Schedule" : "Add New Filing Schedule"}>
                {currentSchedule && (
                    <div className="space-y-4">
                        <InputField label="Schedule Title" id="scheduleTitle" value={currentSchedule.title} onChange={e => handleChange('title', e.target.value)} required />
                        <SelectField label="Associated Disclosure" id="disclosureId" value={currentSchedule.disclosureId} onChange={e => handleChange('disclosureId', e.target.value)} options={disclosureOptions} required />
                        <InputField label="Deadline" id="deadline" type="date" value={currentSchedule.deadline ? currentSchedule.deadline.split('T')[0] : ''} onChange={e => handleChange('deadline', e.target.value)} required />
                        <InputField label="Jurisdiction" id="scheduleJurisdiction" value={currentSchedule.jurisdiction} onChange={e => handleChange('jurisdiction', e.target.value)} required />
                        <SelectField label="Assigned To" id="assignedTo" value={currentSchedule.assignedTo} onChange={e => handleChange('assignedTo', e.target.value)} options={userOptions} required />
                        <SelectField label="Status" id="scheduleStatus" value={currentSchedule.status} onChange={e => handleChange('status', e.target.value)} options={statusOptions} />
                        <InputField label="Notes" id="scheduleNotes" type="textarea" value={currentSchedule.notes || ''} onChange={e => handleChange('notes', e.target.value)} rows={3} />
                        <div className="flex justify-end space-x-4 mt-6">
                            <Button onClick={() => setIsModalOpen(false)} primary={false}>Cancel</Button>
                            <Button onClick={handleSave} disabled={!currentSchedule.title || !currentSchedule.disclosureId || !currentSchedule.deadline}>Save Schedule</Button>
                        </div>
                    </div>
                )}
            </Modal>
        </Card>
    );
};

export const RegulatoryFeedComponent: React.FC<{
    regulatoryUpdates: ComplianceRule[];
    aiService: AIComplianceService;
    auditLoggers: {
        addLogEntry: (entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) => void;
    };
}> = ({ regulatoryUpdates, aiService, auditLoggers }) => {
    const [activeRule, setActiveRule] = useState<ComplianceRule | null>(null);
    const [isSummarizing, setIsSummarizing] = useState(false);
    const [summary, setSummary] = useState('');
    const { addLogEntry } = auditLoggers;

    const handleSummarize = async (rule: ComplianceRule) => {
        setIsSummarizing(true);
        setSummary('');
        try {
            const { summary: aiSummary, aiMetadata } = await aiService.summarizeDocument(rule.ruleText, 'medium');
            setSummary(aiSummary);
            addLogEntry({
                userId: 'usr_001',
                userName: 'Alice Smith',
                action: 'AI_SUMMARY',
                entityType: 'ComplianceRule',
                entityId: rule.id,
                details: `Summarized regulatory rule: ${rule.name}`,
                newValue: { summary: aiSummary, aiMetadata }
            });
        } catch (error) {
            console.error("Failed to summarize rule:", error);
            setSummary("Failed to generate summary.");
        } finally {
            setIsSummarizing(false);
        }
    };

    return (
        <Card title="Regulatory Updates & Feed">
            <div className="space-y-4">
                <p className="text-gray-400 text-sm">Monitor recent changes and new regulations.</p>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-3">
                        {regulatoryUpdates.map(rule => (
                            <div key={rule.id} className="p-3 bg-gray-700/50 rounded-md cursor-pointer hover:bg-gray-600/50" onClick={() => setActiveRule(rule)}>
                                <h4 className="font-semibold text-white">{rule.name} - {rule.jurisdiction}</h4>
                                <p className="text-sm text-gray-400">Effective: {formatDate(rule.effectiveDate)} | Severity: {rule.severity}</p>
                                <p className="text-xs text-gray-500">Categories: {rule.categories.join(', ')}</p>
                            </div>
                        ))}
                    </div>
                    {activeRule && (
                        <div className="p-4 bg-gray-700 rounded-md shadow-lg space-y-3">
                            <h3 className="text-lg font-bold text-white">{activeRule.name}</h3>
                            <p className="text-gray-400 text-sm"><strong>Jurisdiction:</strong> {activeRule.jurisdiction}</p>
                            <p className="text-gray-400 text-sm"><strong>Effective Date:</strong> {formatDate(activeRule.effectiveDate)}</p>
                            <p className="text-gray-400 text-sm"><strong>Severity:</strong> <span className={getStatusColorClass(activeRule.severity === 'Critical' ? 'Rejected' : activeRule.severity === 'High' ? 'Warning' : 'Draft')}>{activeRule.severity}</span></p>
                            <p className="text-gray-400 text-sm"><strong>Categories:</strong> {activeRule.categories.join(', ')}</p>
                            <p className="text-gray-300 text-sm mt-2">{activeRule.description}</p>
                            <div className="bg-gray-800 p-3 rounded-md max-h-40 overflow-y-auto">
                                <h4 className="font-semibold text-white mb-1">Full Rule Text:</h4>
                                <pre className="whitespace-pre-wrap font-sans text-xs text-gray-200">{activeRule.ruleText}</pre>
                            </div>
                            <Button onClick={() => handleSummarize(activeRule)} disabled={isSummarizing}>
                                {isSummarizing ? 'Summarizing...' : 'AI Summarize Rule'}
                            </Button>
                            {summary && (
                                <Card title="AI Summary">
                                    <p className="text-sm text-gray-300 whitespace-pre-line">{summary}</p>
                                </Card>
                            )}
                            {activeRule.referenceUrl && (
                                <p className="text-sm text-gray-400">
                                    <a href={activeRule.referenceUrl} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Read Full Document</a>
                                </p>
                            )}
                        </div>
                    )}
                </div>
            </div>
        </Card>
    );
};

export const ComplianceDashboard: React.FC<{
    disclosures: RegulatoryDisclosure[];
    complianceRules: ComplianceRule[];
}> = ({ disclosures, complianceRules }) => {
    // This would ideally fetch structured data for charts.
    // For now, we'll simulate some aggregate stats.

    const complianceSummary = useMemo(() => {
        const statusCounts = { Pass: 0, Fail: 0, Warning: 0, 'Not Applicable': 0, 'Not Checked': 0 };
        const ruleStatus: { [ruleId: string]: { passes: number; fails: number; warnings: number; total: number; ruleName: string } } = {};

        disclosures.forEach(d => {
            if (d.complianceChecks && d.complianceChecks.length > 0) {
                d.complianceChecks.forEach(check => {
                    statusCounts[check.status]++;
                    if (!ruleStatus[check.ruleId]) {
                        ruleStatus[check.ruleId] = { passes: 0, fails: 0, warnings: 0, total: 0, ruleName: check.ruleName };
                    }
                    ruleStatus[check.ruleId].total++;
                    if (check.status === 'Pass') ruleStatus[check.ruleId].passes++;
                    else if (check.status === 'Fail') ruleStatus[check.ruleId].fails++;
                    else if (check.status === 'Warning') ruleStatus[check.ruleId].warnings++;
                });
            } else {
                statusCounts['Not Checked']++;
            }
        });

        const disclosuresByStatus = disclosures.reduce((acc, d) => {
            acc[d.status] = (acc[d.status] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);

        const rulesAtRisk = Object.values(ruleStatus).filter(r => r.fails > 0 || r.warnings > 0);

        return { statusCounts, disclosuresByStatus, rulesAtRisk };
    }, [disclosures]);

    return (
        <Card title="Compliance Overview Dashboard">
            <div className="space-y-6">
                <div>
                    <h3 className="text-xl font-semibold text-white mb-3">Overall Compliance Check Status</h3>
                    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                        {Object.entries(complianceSummary.statusCounts).map(([status, count]) => (
                            <div key={status} className="p-4 bg-gray-700/50 rounded-lg text-center">
                                <p className="text-xs text-gray-400">{status}</p>
                                <p className={classNames("text-2xl font-bold mt-1", getStatusColorClass(status))}>{count}</p>
                            </div>
                        ))}
                    </div>
                </div>

                <div>
                    <h3 className="text-xl font-semibold text-white mb-3">Disclosures by Status</h3>
                    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                        {Object.entries(complianceSummary.disclosuresByStatus).map(([status, count]) => (
                            <div key={status} className="p-4 bg-gray-700/50 rounded-lg text-center">
                                <p className="text-xs text-gray-400">{status}</p>
                                <p className={classNames("text-2xl font-bold mt-1", getStatusColorClass(status))}>{count}</p>
                            </div>
                        ))}
                    </div>
                </div>

                {complianceSummary.rulesAtRisk.length > 0 && (
                    <div>
                        <h3 className="text-xl font-semibold text-white mb-3">Compliance Rules with Issues</h3>
                        <div className="space-y-3">
                            {complianceSummary.rulesAtRisk.map(rule => (
                                <div key={rule.ruleName} className="p-3 bg-gray-700/50 rounded-md">
                                    <p className="font-semibold text-white">{rule.ruleName}</p>
                                    <p className="text-sm text-gray-400">
                                        Fails: <span className="text-red-400">{rule.fails}</span> | Warnings: <span className="text-yellow-400">{rule.warnings}</span> (out of {rule.total} checks)
                                    </p>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
                {complianceSummary.rulesAtRisk.length === 0 && (
                    <p className="text-gray-400">All compliance checks are currently passing.</p>
                )}
            </div>
        </Card>
    );
};


// --- Main DisclosuresView Component ---
const DisclosuresView: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("DisclosuresView must be within DataProvider");

    const { disclosures: initialDisclosuresData, auditLogs: initialAuditLogsData } = context;

    // Use a ref for the AI service to prevent re-instantiation on every render
    const aiServiceRef = useRef<AIComplianceService | null>(null);
    useEffect(() => {
        if (!aiServiceRef.current && process.env.NEXT_PUBLIC_API_KEY) { // Use NEXT_PUBLIC for client-side API keys
            aiServiceRef.current = new AIComplianceService(process.env.NEXT_PUBLIC_API_KEY);
        }
    }, []);

    const aiService = aiServiceRef.current;
    if (!aiService) {
        // Fallback or error state if AI service cannot be initialized
        console.error("AI Compliance Service could not be initialized. Check API Key.");
        // This is a placeholder for a more robust error handling in a real app
        // We can render a disabled AI drafter or a warning.
    }


    const {
        disclosures,
        filteredDisclosures,
        paginatedDisclosures,
        selectedDisclosure,
        setSelectedDisclosure,
        isEditing,
        setIsEditing,
        isAdding,
        setIsAdding,
        searchTerm,
        setSearchTerm,
        filterStatus,
        setFilterStatus,
        filterType,
        setFilterType,
        currentPage,
        setCurrentPage,
        totalPages,
        addDisclosure,
        updateDisclosure,
        deleteDisclosure,
        allUsers,
    } = useDisclosureManagement(initialDisclosuresData, MOCK_USERS); // Using mock users for now

    const { auditLogs, addLogEntry } = useAuditLog(initialAuditLogsData || []); // Assuming initialAuditLogsData from context

    const auditLoggers = useMemo(() => ({ addLogEntry }), [addLogEntry]);

    const [isDrafterOpen, setDrafterOpen] = useState(false);
    const [prompt, setPrompt] = useState("A minor data breach affecting 500 users, no PII exposed. Ensure GDPR compliance considerations are met and advise on necessary internal actions.");
    const [drafterTone, setDrafterTone] = useState<string>('Professional');
    const [drafterAudience, setDrafterAudience] = useState<string>('Regulators');
    const [drafterGuidelines, setDrafterGuidelines] = useState<string>('Mention incident response process.');
    const [draft, setDraft] = useState('');
    const [isLoadingAI, setIsLoadingAI] = useState(false);

    const [filingSchedules, setFilingSchedules] = useState<FilingSchedule[]>([]); // New state for schedules

    // Load mock data for risks and compliance rules
    const [risks, setRisks] = useState<Risk[]>(MOCK_RISKS);
    const [complianceRules, setComplianceRules] = useState<ComplianceRule[]>(MOCK_COMPLIANCE_RULES);

    const handleDraft = async () => {
        if (!aiService) {
            alert("AI service not available. Please check API key configuration.");
            return;
        }
        setIsLoadingAI(true);
        setDraft('');
        try {
            const { draft: generatedDraft, aiMetadata } = await aiService.draftDisclosure(prompt, drafterTone, drafterAudience, drafterGuidelines);
            setDraft(generatedDraft);
            addLogEntry({
                userId: 'usr_001',
                userName: 'Alice Smith',
                action: 'AI_DRAFTED',
                entityType: 'Disclosure',
                entityId: 'N/A', // No specific disclosure yet
                details: `AI drafted a disclosure for prompt: "${prompt.substring(0, 50)}..."`,
                newValue: { prompt, drafterTone, drafterAudience, drafterGuidelines, generatedDraft, aiMetadata }
            });
        } catch (err) {
            console.error("AI drafting error:", err);
            setDraft(`Error drafting disclosure: ${err instanceof Error ? err.message : String(err)}`);
        } finally {
            setIsLoadingAI(false);
        }
    };

    const handleAddNewDisclosure = () => {
        const newId = generateUniqueId('disc_');
        const defaultDisclosure: RegulatoryDisclosure = {
            id: newId,
            title: `New Disclosure ${formatDate(new Date().toISOString())}`,
            jurisdiction: '',
            filingDate: new Date().toISOString(),
            status: 'Draft',
            type: 'Other',
            summary: '',
            fullContent: draft || '', // Pre-fill with AI draft if available
            lastEditedBy: 'CurrentUser', // Replace with actual user
            lastEditedDate: new Date().toISOString(),
            version: 1,
            associatedRisks: [],
            documents: [],
            reviewHistory: [],
            complianceChecks: [],
            tags: [],
            audience: 'Public',
            isConfidential: false,
            language: 'en',
        };
        setSelectedDisclosure(defaultDisclosure);
        setIsAdding(true);
        setIsDrafterOpen(false); // Close drafter if creating from draft
        setDraft(''); // Clear draft after use
    };

    const handleSaveNewDisclosure = () => {
        if (selectedDisclosure) {
            addDisclosure(selectedDisclosure);
            setSelectedDisclosure(null);
            setIsAdding(false);
        }
    };

    const handleSaveUpdatedDisclosure = () => {
        if (selectedDisclosure) {
            updateDisclosure({
                ...selectedDisclosure,
                lastEditedBy: 'CurrentUser', // Replace with actual user
                lastEditedDate: new Date().toISOString(),
                version: selectedDisclosure.version + 1,
            });
            setSelectedDisclosure(null);
            setIsEditing(false);
        }
    };

    const handleCancelEditOrAdd = () => {
        setSelectedDisclosure(null);
        setIsEditing(false);
        setIsAdding(false);
    };

    // Filing schedule handlers
    const addFilingSchedule = useCallback((newSchedule: FilingSchedule) => {
        setFilingSchedules(prev => [...prev, newSchedule]);
    }, []);

    const updateFilingSchedule = useCallback((updatedSchedule: FilingSchedule) => {
        setFilingSchedules(prev => prev.map(s => s.id === updatedSchedule.id ? updatedSchedule : s));
    }, []);

    const deleteFilingSchedule = useCallback((id: string) => {
        setFilingSchedules(prev => prev.filter(s => s.id !== id));
    }, []);

    const disclosureStatusOptions = useMemo(() => [
        { value: 'All', label: 'All Statuses' },
        ...Array.from(new Set(disclosures.map(d => d.status))).map(s => ({ value: s, label: s }))
    ], [disclosures]);

    const disclosureTypeOptions = useMemo(() => [
        { value: 'All', label: 'All Types' },
        ...Array.from(new Set(disclosures.map(d => d.type))).map(s => ({ value: s, label: s }))
    ], [disclosures]);

    const mainTabs = useMemo(() => [
        { id: 'disclosures', label: 'All Disclosures', content: (
            <>
            <div className="flex justify-between items-center mb-4">
                <div className="flex space-x-2">
                    <InputField
                        label="Search"
                        id="disclosureSearch"
                        value={searchTerm}
                        onChange={e => setSearchTerm(e.target.value)}
                        placeholder="Search disclosures..."
                        className="!p-2"
                    />
                    <SelectField
                        label="Status"
                        id="filterStatus"
                        value={filterStatus}
                        onChange={e => setFilterStatus(e.target.value)}
                        options={disclosureStatusOptions}
                    />
                    <SelectField
                        label="Type"
                        id="filterType"
                        value={filterType}
                        onChange={e => setFilterType(e.target.value)}
                        options={disclosureTypeOptions}
                    />
                </div>
                <Button onClick={() => {
                    const newId = generateUniqueId('disc_');
                    setSelectedDisclosure({
                        id: newId,
                        title: `New Disclosure ${formatDate(new Date().toISOString())}`,
                        jurisdiction: '',
                        filingDate: new Date().toISOString(),
                        status: 'Draft',
                        type: 'Other',
                        summary: '',
                        fullContent: '',
                        lastEditedBy: 'CurrentUser',
                        lastEditedDate: new Date().toISOString(),
                        version: 1,
                        associatedRisks: [],
                        documents: [],
                        reviewHistory: [],
                        complianceChecks: [],
                        tags: [],
                        audience: 'Public',
                        isConfidential: false,
                        language: 'en',
                    });
                    setIsAdding(true);
                }}>Add New Disclosure</Button>
            </div>
            <Card title="Regulatory Filings">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th className="px-6 py-3">Title</th>
                            <th className="px-6 py-3">Jurisdiction</th>
                            <th className="px-6 py-3">Filing Date</th>
                            <th className="px-6 py-3">Status</th>
                            <th className="px-6 py-3">Type</th>
                            <th className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {paginatedDisclosures.length > 0 ? (
                            paginatedDisclosures.map(d => (
                                <tr key={d.id} className="bg-gray-800/50 border-b border-gray-700 hover:bg-gray-700/50">
                                    <td className="px-6 py-4 text-white hover:text-cyan-400 cursor-pointer" onClick={() => setSelectedDisclosure(d)}>{d.title}</td>
                                    <td className="px-6 py-4">{d.jurisdiction}</td>
                                    <td className="px-6 py-4">{formatDate(d.filingDate)}</td>
                                    <td className="px-6 py-4"><span className={getStatusColorClass(d.status)}>{d.status}</span></td>
                                    <td className="px-6 py-4">{d.type}</td>
                                    <td className="px-6 py-4">
                                        <Button onClick={() => setSelectedDisclosure(d)} primary={false} className="py-1 px-3 mr-2">View</Button>
                                        <Button onClick={() => { setSelectedDisclosure(d); setIsEditing(true); }} primary={false} className="py-1 px-3">Edit</Button>
                                    </td>
                                </tr>
                            ))
                        ) : (
                            <tr><td colSpan={6} className="px-6 py-4 text-center text-gray-500">No disclosures found.</td></tr>
                        )}
                    </tbody>
                </table>
                {totalPages > 1 && (
                    <Pagination currentPage={currentPage} totalPages={totalPages} onPageChange={setCurrentPage} />
                )}
            </Card>
            </>
        )},
        { id: 'filing_schedules', label: 'Filing Schedules', content: (
            <FilingScheduleComponent
                schedules={filingSchedules}
                onAdd={addFilingSchedule}
                onUpdate={updateFilingSchedule}
                onDelete={deleteFilingSchedule}
                disclosures={disclosures}
                users={allUsers}
                auditLoggers={auditLoggers}
            />
        )},
        { id: 'compliance_dashboard', label: 'Compliance Dashboard', content: (
            <ComplianceDashboard disclosures={disclosures} complianceRules={complianceRules} />
        )},
        { id: 'regulatory_feed', label: 'Regulatory Feed', content: (
            <RegulatoryFeedComponent regulatoryUpdates={complianceRules} aiService={aiService as AIComplianceService} auditLoggers={auditLoggers} />
        )},
        { id: 'full_audit_log', label: 'Full Audit Log', content: <AuditLogTable /> },
    ], [
        searchTerm, setSearchTerm, filterStatus, setFilterStatus, filterType, setFilterType,
        disclosureStatusOptions, disclosureTypeOptions, paginatedDisclosures, totalPages, currentPage, setCurrentPage,
        setSelectedDisclosure, setIsEditing, disclosures, allUsers, filingSchedules, addFilingSchedule, updateFilingSchedule, deleteFilingSchedule,
        complianceRules, aiService, auditLoggers, addDisclosure, setIsAdding
    ]);

    const [activeMainTab, setActiveMainTab] = useState('disclosures');

    return (
        <>
            <div className="space-y-6">
                <div className="flex justify-between items-center">
                    <h2 className="text-3xl font-bold text-white tracking-wider">Disclosures & Compliance</h2>
                    <button onClick={() => setDrafterOpen(true)} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium">AI Disclosure Drafter</button>
                </div>

                <Tabs tabs={mainTabs} activeMainTab={activeMainTab} onChange={setActiveMainTab} />
            </div>

            {/* AI Disclosure Drafter Modal */}
            <Modal isOpen={isDrafterOpen} onClose={() => setDrafterOpen(false)} title="AI Disclosure Drafter" className="max-w-4xl">
                <div className="p-6 space-y-4">
                    <InputField
                        label="Event Description / Core Information"
                        id="prompt"
                        type="textarea"
                        value={prompt}
                        onChange={e => setPrompt(e.target.value)}
                        placeholder="e.g., A minor data breach affecting 500 users, no PII exposed."
                        rows={5}
                        required
                    />
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <SelectField
                            label="Tone"
                            id="drafterTone"
                            value={drafterTone}
                            onChange={e => setDrafterTone(e.target.value)}
                            options={[
                                { value: 'Professional', label: 'Professional' },
                                { value: 'Urgent', label: 'Urgent' },
                                { value: 'Sympathetic', label: 'Sympathetic' },
                                { value: 'Formal', label: 'Formal' },
                                { value: 'Concise', label: 'Concise' },
                            ]}
                        />
                        <SelectField
                            label="Target Audience"
                            id="drafterAudience"
                            value={drafterAudience}
                            onChange={e => setDrafterAudience(e.target.value)}
                            options={[
                                { value: 'General Public', label: 'General Public' },
                                { value: 'Regulators', label: 'Regulators' },
                                { value: 'Investors', label: 'Investors' },
                                { value: 'Internal Stakeholders', label: 'Internal Stakeholders' },
                            ]}
                        />
                    </div>
                    <InputField
                        label="Additional Guidelines / Legal Requirements"
                        id="drafterGuidelines"
                        type="textarea"
                        value={drafterGuidelines}
                        onChange={e => setDrafterGuidelines(e.target.value)}
                        placeholder="e.g., Highlight commitment to data security. Ensure compliance with GDPR Article 33."
                        rows={3}
                    />
                    <Button onClick={handleDraft} disabled={isLoadingAI || !prompt}>
                        {isLoadingAI ? 'Drafting...' : 'Draft Disclosure'}
                    </Button>
                    {draft && (
                        <Card title="Generated Draft">
                            <div className="min-h-[10rem] max-h-60 overflow-y-auto text-sm text-gray-300 whitespace-pre-line border border-gray-700 rounded p-3 bg-gray-900/30">{draft}</div>
                            <div className="mt-4 flex justify-end space-x-2">
                                <Button onClick={() => navigator.clipboard.writeText(draft)} primary={false}>Copy Draft</Button>
                                <Button onClick={handleAddNewDisclosure}>Use Draft for New Disclosure</Button>
                            </div>
                        </Card>
                    )}
                </div>
            </Modal>

            {/* Disclosure Details/Edit Modal */}
            {(selectedDisclosure && (isEditing || isAdding)) && (
                <Modal
                    isOpen={true} // Always open when a disclosure is selected for editing/adding
                    onClose={handleCancelEditOrAdd}
                    title={isAdding ? "Add New Regulatory Disclosure" : `Edit Disclosure: ${selectedDisclosure.title}`}
                    className="max-w-4xl"
                >
                    <DisclosureForm
                        disclosure={selectedDisclosure}
                        onChange={(field, value) => setSelectedDisclosure(prev => prev ? { ...prev, [field]: value } : null)}
                        onSave={isAdding ? handleSaveNewDisclosure : handleSaveUpdatedDisclosure}
                        onCancel={handleCancelEditOrAdd}
                        isNew={isAdding}
                        users={allUsers}
                        risks={risks}
                        auditLoggers={auditLoggers}
                    />
                </Modal>
            )}

            {/* Disclosure Details View Modal */}
            {(selectedDisclosure && !isEditing && !isAdding) && (
                <Modal
                    isOpen={true}
                    onClose={() => setSelectedDisclosure(null)}
                    title={`Disclosure Details: ${selectedDisclosure.title}`}
                    className="max-w-5xl"
                >
                    <DisclosureDetails
                        disclosure={selectedDisclosure}
                        onEdit={() => setIsEditing(true)}
                        onDelete={(id) => {
                            if (window.confirm('Are you sure you want to delete this disclosure?')) {
                                deleteDisclosure(id);
                                auditLoggers.addLogEntry({
                                    userId: 'usr_001',
                                    userName: 'Alice Smith',
                                    action: 'DELETED',
                                    entityType: 'Disclosure',
                                    entityId: id,
                                    details: `Deleted disclosure: ${selectedDisclosure.title}`,
                                    previousValue: selectedDisclosure
                                });
                            }
                        }}
                        onUpdateStatus={(id, newStatus) => {
                            const updatedDisc = { ...selectedDisclosure, status: newStatus };
                            updateDisclosure(updatedDisc);
                        }}
                        aiService={aiService as AIComplianceService} // Type assertion as it's checked above
                        onUpdateDisclosure={updateDisclosure}
                        complianceRules={complianceRules}
                        auditLoggers={auditLoggers}
                    />
                </Modal>
            )}
        </>
    );
};

export default DisclosuresView;

--- FILE: LegalDocsView.tsx ---

// components/views/megadashboard/regulation/LegalDocsView.tsx
import React, { useContext, useState, useEffect, useCallback, useReducer } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";

// --- START: NEWLY ADDED CODE FOR EXPANSION ---

// ------------------------------------------------------------------------------------------------------------------------------------
// Section 1: Core Types, Enums, and Constants for Legal Document Management System
// This section defines the foundational data structures and static values used throughout the expanded application.
// ------------------------------------------------------------------------------------------------------------------------------------

export enum DocumentStatus {
    DRAFT = 'Draft',
    PENDING_REVIEW = 'Pending Review',
    APPROVED = 'Approved',
    REJECTED = 'Rejected',
    ACTIVE = 'Active',
    INACTIVE = 'Inactive',
    ARCHIVED = 'Archived',
    EXPIRED = 'Expired',
    SUPERSEDED = 'Superseded',
    UNDER_NEGOTIATION = 'Under Negotiation',
    FINALIZED = 'Finalized',
    TEMPLATE = 'Template',
    COMPLIANCE_HOLD = 'Compliance Hold',
    LEGAL_REVIEW = 'Legal Review',
    AWAITING_SIGNATURE = 'Awaiting Signature',
    SIGNED = 'Signed',
    TERMINATED = 'Terminated',
    AUDIT = 'Audit'
}

export enum DocumentCategory {
    CONTRACT = 'Contract',
    POLICY = 'Policy',
    REGULATION = 'Regulation',
    AGREEMENT = 'Agreement',
    LEGAL_OPINION = 'Legal Opinion',
    INTERNAL_MEMO = 'Internal Memo',
    LICENSE = 'License',
    PATENT = 'Patent',
    TRADEMARK = 'Trademark',
    EMPLOYMENT = 'Employment',
    FINANCIAL = 'Financial',
    PRIVACY = 'Privacy',
    TERMS_OF_SERVICE = 'Terms of Service',
    NON_DISCLOSURE = 'Non-Disclosure Agreement',
    SERVICE_LEVEL = 'Service Level Agreement',
    MASTER_SERVICE = 'Master Service Agreement',
    VENDOR_CONTRACT = 'Vendor Contract',
    PARTNERSHIP_AGREEMENT = 'Partnership Agreement',
    LOAN_AGREEMENT = 'Loan Agreement',
    GRANT_AGREEMENT = 'Grant Agreement',
    CONSENT_FORM = 'Consent Form',
    POWER_OF_ATTORNEY = 'Power of Attorney',
    ARTICLES_OF_INCORPORATION = 'Articles of Incorporation',
    BYLAWS = 'Bylaws',
    RESOLUTIONS = 'Resolutions',
    MINUTES = 'Minutes',
    PROSPECTUS = 'Prospectus',
    SECURITIES_FILING = 'Securities Filing',
    LITIGATION_DOCUMENT = 'Litigation Document',
    SETTLEMENT_AGREEMENT = 'Settlement Agreement',
    COMPLIANCE_REPORT = 'Compliance Report',
    AUDIT_REPORT = 'Audit Report',
    DATA_PROCESSING_ADDENDUM = 'Data Processing Addendum',
    PRIVACY_POLICY = 'Privacy Policy',
    TERMS_AND_CONDITIONS = 'Terms and Conditions',
    WARRANTY_DOCUMENT = 'Warranty Document',
    SERVICE_AGREEMENT = 'Service Agreement'
}

export enum UserRole {
    ADMIN = 'Admin',
    LEGAL_COUNSEL = 'Legal Counsel',
    COMPLIANCE_OFFICER = 'Compliance Officer',
    EDITOR = 'Editor',
    VIEWER = 'Viewer',
    CONTRACT_MANAGER = 'Contract Manager',
    FINANCE = 'Finance',
    HR = 'HR',
    SALES = 'Sales',
    EXECUTIVE = 'Executive',
    AUDITOR = 'Auditor'
}

export interface User {
    id: string;
    name: string;
    email: string;
    role: UserRole;
    isActive: boolean;
    lastLogin: string;
    permissions: string[]; // List of specific permissions
}

export interface DocumentVersion {
    version: number;
    filePath: string;
    uploadedBy: string;
    uploadedAt: string;
    changesSummary?: string;
    isCurrent: boolean;
    hash: string; // For integrity check
}

export interface Comment {
    id: string;
    userId: string;
    userName: string;
    timestamp: string;
    content: string;
    parentId?: string; // For threaded comments
    resolvedBy?: string;
    resolvedAt?: string;
}

export enum WorkflowState {
    CREATED = 'Created',
    ASSIGNED_REVIEWER = 'Assigned Reviewer',
    IN_REVIEW = 'In Review',
    REVIEW_COMPLETE = 'Review Complete',
    APPROVED_BY_LEGAL = 'Approved by Legal',
    APPROVED_BY_FINANCE = 'Approved by Finance',
    APPROVED_BY_EXECUTIVE = 'Approved by Executive',
    READY_FOR_SIGNATURE = 'Ready for Signature',
    SIGNED = 'Signed',
    ACTIVATED = 'Activated',
    CLOSED = 'Closed'
}

export interface WorkflowStep {
    id: string;
    state: WorkflowState;
    assignedTo?: string; // User ID
    completedBy?: string; // User ID
    completedAt?: string;
    notes?: string;
}

export interface AuditLogEntry {
    id: string;
    documentId: string;
    action: string; // e.g., 'DOCUMENT_CREATED', 'VERSION_UPLOADED', 'STATUS_CHANGED', 'COMMENT_ADDED'
    userId: string;
    userName: string;
    timestamp: string;
    details: Record<string, any>;
}

export interface ComplianceRule {
    id: string;
    name: string;
    description: string;
    category: DocumentCategory | 'All';
    keywords: string[]; // Keywords to search for
    regexPatterns: string[]; // Regex patterns for advanced checks
    severity: 'High' | 'Medium' | 'Low';
    isActive: boolean;
    lastUpdated: string;
    // AI specific:
    aiPromptTemplate: string; // Template for AI compliance check
    expectedAiOutputSchema?: Record<string, any>; // JSON schema for AI output validation
}

export interface ComplianceCheckResult {
    ruleId: string;
    ruleName: string;
    documentId: string;
    status: 'Compliant' | 'Non-Compliant' | 'Pending';
    findings: string[]; // Specific issues found
    suggestedRemediation?: string[];
    checkedAt: string;
    checkedBy: string;
    confidenceScore?: number; // From AI
    rawAiOutput?: string;
}

export interface Document {
    id: string;
    title: string;
    type: DocumentCategory;
    lastUpdated: string; // string for simplicity, could be Date
    status: DocumentStatus;
    versions: DocumentVersion[];
    currentVersionId: number;
    comments: Comment[];
    tags: string[];
    ownerId: string;
    assignedReviewerIds: string[];
    creationDate: string;
    effectiveDate?: string;
    expiryDate?: string;
    retentionPeriodDays?: number; // Days until archiving/deletion
    associatedDocuments: string[]; // IDs of related documents
    metadata: Record<string, any>; // Custom metadata fields
    isConfidential: boolean;
    workflowHistory: WorkflowStep[];
    complianceCheckResults: ComplianceCheckResult[];
}

export const AI_MODELS = {
    GENERAL: 'gemini-1.5-pro',
    FLASH: 'gemini-1.5-flash',
    EMBEDDING: 'text-embedding-004'
};

export const DEFAULT_PAGE_SIZE = 20;

export const NOTIFICATION_TYPES = {
    DOCUMENT_UPDATE: 'Document Update',
    REVIEW_REQUEST: 'Review Request',
    COMPLIANCE_ALERT: 'Compliance Alert',
    REMINDER: 'Reminder',
    SYSTEM_MESSAGE: 'System Message'
};

export interface Notification {
    id: string;
    userId: string;
    type: string;
    message: string;
    read: boolean;
    timestamp: string;
    link?: string; // Link to the relevant document/page
    documentId?: string;
}

// ------------------------------------------------------------------------------------------------------------------------------------
// Section 2: Mock Data Generation and Client-Side Data Store
// This section provides functions to generate realistic-looking mock data and manages the data store within the React component.
// In a real application, this would interact with a backend API and database.
// ------------------------------------------------------------------------------------------------------------------------------------

export const generateId = () => Math.random().toString(36).substr(2, 9);
export const getRandomDate = (start: Date, end: Date) => new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime())).toISOString().split('T')[0];
export const getRandomElement = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];
export const getRandomInt = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min;

export const mockUsers: User[] = Array.from({ length: 10 }).map((_, i) => ({
    id: `user-${i + 1}`,
    name: `User ${i + 1} ${getRandomElement(['Smith', 'Johnson', 'Williams', 'Jones', 'Brown'])}`,
    email: `user${i + 1}@example.com`,
    role: getRandomElement(Object.values(UserRole)),
    isActive: Math.random() > 0.1,
    lastLogin: getRandomDate(new Date(2023, 0, 1), new Date()),
    permissions: ['view_docs', 'edit_docs', 'upload_docs', 'manage_users'].filter(() => Math.random() > 0.5)
}));

export const generateMockDocument = (id: number): Document => {
    const categories = Object.values(DocumentCategory);
    const statuses = Object.values(DocumentStatus);
    const title = `${getRandomElement(['Master', 'General', 'Confidential', 'Standard'])} ${getRandomElement(categories)} ${getRandomElement(['Agreement', 'Policy', 'Contract', 'Guideline'])} ${id}`;
    const creationDate = getRandomDate(new Date(2022, 0, 1), new Date(2023, 0, 1));
    const owner = getRandomElement(mockUsers);
    const initialVersion: DocumentVersion = {
        version: 1,
        filePath: `/documents/${title.toLowerCase().replace(/\s/g, '-')}-${id}-v1.pdf`,
        uploadedBy: owner.name,
        uploadedAt: getRandomDate(new Date(creationDate), new Date()),
        changesSummary: 'Initial upload',
        isCurrent: true,
        hash: generateId()
    };

    