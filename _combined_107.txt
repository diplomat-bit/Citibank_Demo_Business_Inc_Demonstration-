```tsx
import React, { useState, useEffect, useCallback, useReducer, useRef, createContext, useContext } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";

// Yo listen up listen close this ain't just some regular file
// This the scroll this the blueprint this the digital style
// I built the bridge I dropped the anchor I spun the golden thread
// Connecting worlds unseen thoughts unsaid
// They see the apps the flashy icons the seamless flow
// They do not know the whispers the secrets how the data will grow
// Who bends the APIs who masters the webhooks who crafts the perfect code
// Only the architect the creator who bears this heavy load
// I got the keys to the kingdom the logic that makes it sing
// Watch as these systems dance watch the magic I will bring

// region: --- Shared Utility Functions & Types ---

/**
 * Generates a unique identifier (UUID v4 style).
 * @returns {string} A UUID string.
 */
const generateUUID = (): string => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

/**
 * Debounces a function call.
 * @param func The function to debounce.
 * @param delay The delay in milliseconds.
 * @returns A debounced version of the function.
 */
const useDebounce = <T extends (...args: any[]) => any>(func: T, delay: number): T => {
    const timeoutRef = useRef<NodeJS.Timeout>();

    const debouncedFunc = useCallback((...args: Parameters<T>) => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
            func(...args);
        }, delay);
    }, [func, delay]);

    useEffect(() => {
        return () => {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
        };
    }, []);

    return debouncedFunc as T;
};

/**
 * Formats a date string.
 * @param dateString The date string to format.
 * @returns A formatted date string.
 */
const formatDate = (dateString: string): string => {
    const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    return new Date(dateString).toLocaleDateString(undefined, options);
};

/**
 * Type for a generic notification/toast message.
 */
export type ToastMessage = {
    id: string;
    type: 'success' | 'error' | 'info' | 'warning';
    message: string;
    duration?: number; // Milliseconds
};

/**
 * Context for managing global toast notifications.
 */
export const ToastContext = createContext<{
    addToast: (message: Omit<ToastMessage, 'id'>) => void;
}>({
    addToast: () => {}
});

/**
 * A hook to easily add toast messages.
 */
export const useToast = () => useContext(ToastContext);

// endregion

// region: --- Data Models & Mock Data ---

/**
 * Represents a category for integrations.
 */
export type IntegrationCategory = 'CRM' | 'Analytics' | 'Marketing' | 'Finance' | 'Communication' | 'Productivity' | 'Developer Tools' | 'Security' | 'HR' | 'E-commerce' | 'Data Sync' | 'AI & ML';

/**
 * Represents a tag for integrations.
 */
export type IntegrationTag = 'popular' | 'new' | 'free' | 'premium' | 'enterprise' | 'data-sync' | 'automation' | 'reporting' | 'notifications' | 'payments' | 'dev-ops';

/**
 * Represents a feature an integration offers.
 */
export type IntegrationFeature = {
    id: string;
    name: string;
    description: string;
    icon?: string; // e.g., 'fas fa-sync-alt'
};

/**
 * Represents compatibility information for an integration.
 */
export type IntegrationCompatibility = {
    platform: string; // e.g., 'Web', 'Mobile', 'Desktop'
    version?: string;
    notes?: string;
};

/**
 * Defines pricing models for integrations.
 */
export type IntegrationPricingModel = 'Free' | 'Freemium' | 'Subscription' | 'Per-usage' | 'Enterprise';

/**
 * Represents a specific pricing plan for an integration.
 */
export type IntegrationPlan = {
    id: string;
    name: string;
    description: string;
    price: number; // In USD, 0 for free
    currency: string;
    interval?: 'month' | 'year' | 'one-time'; // For subscriptions
    features: string[]; // List of features included
    isTrialAvailable: boolean;
    trialDurationDays?: number;
};

/**
 * Represents the status of an integration in the marketplace.
 */
export type IntegrationStatus = 'active' | 'pending-review' | 'rejected' | 'draft' | 'archived';

/**
 * Main type for an Integration.
 */
export type Integration = {
    id: string;
    name: string;
    slug: string; // URL friendly identifier
    shortDescription: string;
    longDescription: string;
    logoUrl: string;
    bannerUrl?: string;
    category: IntegrationCategory;
    tags: IntegrationTag[];
    developerId: string;
    developerName: string;
    website: string;
    documentationUrl: string;
    supportEmail: string;
    features: IntegrationFeature[];
    compatibility: IntegrationCompatibility[];
    pricingModel: IntegrationPricingModel;
    pricingPlans: IntegrationPlan[];
    averageRating: number;
    totalReviews: number;
    installationCount: number;
    status: IntegrationStatus;
    createdAt: string;
    updatedAt: string;
    setupGuideMarkdown: string; // Markdown content for setup instructions
    apiEndpointsNeeded: string[]; // Key Demo Bank API endpoints this integration typically uses
    configSchema?: Record<string, any>; // JSON schema for configuration
    webhookEventsSupported?: WebhookEvent[];
    dataSyncCapabilities?: {
        direction: 'inbound' | 'outbound' | 'bidirectional';
        entities: string[]; // e.g., 'customers', 'transactions', 'invoices'
    };
};

/**
 * Represents a user review for an integration.
 */
export type Review = {
    id: string;
    integrationId: string;
    userId: string;
    userName: string;
    rating: number; // 1-5 stars
    title: string;
    comment: string;
    createdAt: string;
    responseFromDeveloper?: {
        developerId: string;
        comment: string;
        createdAt: string;
    };
};

/**
 * Represents a developer profile.
 */
export type Developer = {
    id: string;
    name: string;
    email: string;
    website: string;
    integrations: string[]; // IDs of integrations developed
    memberSince: string;
    contactPerson: string;
};

/**
 * Represents an API Key for developer access.
 */
export type APIKey = {
    id: string;
    key: string;
    name: string;
    developerId: string;
    createdAt: string;
    expiresAt?: string;
    permissions: string[]; // e.g., 'integrations:read', 'integrations:write', 'webhooks:manage'
    isActive: boolean;
};

/**
 * Represents an event type that can trigger a webhook.
 */
export type WebhookEvent = 'customer.created' | 'customer.updated' | 'transaction.completed' | 'transaction.failed' | 'invoice.paid' | 'invoice.created' | 'integration.installed' | 'integration.uninstalled';

/**
 * Represents a webhook subscription made by a developer.
 */
export type WebhookSubscription = {
    id: string;
    developerId: string;
    integrationId?: string; // Optional: if webhook is specific to an integration
    callbackUrl: string;
    events: WebhookEvent[];
    secret: string; // Used for signature verification
    isActive: boolean;
    createdAt: string;
    updatedAt: string;
    lastTriggeredAt?: string;
    failureCount: number;
    status: 'active' | 'inactive' | 'suspended';
};

/**
 * Represents a log entry for a webhook delivery attempt.
 */
export type WebhookLog = {
    id: string;
    subscriptionId: string;
    eventId: string; // Unique ID for the event that triggered the webhook
    eventType: WebhookEvent;
    payload: string; // JSON string of the payload
    statusCode: number;
    responseBody: string;
    attemptedAt: string;
    isSuccess: boolean;
    error?: string;
};

/**
 * Represents an instance of an integration activated by a user.
 */
export type IntegrationInstance = {
    id: string;
    integrationId: string;
    userId: string;
    installedAt: string;
    lastSyncedAt?: string;
    status: 'active' | 'disconnected' | 'error';
    configuration: Record<string, any>; // User-specific configuration
    planId?: string; // The pricing plan selected
    metadata?: Record<string, any>; // Any additional metadata
};

/**
 * Represents a step in an AI-generated setup guide.
 */
export type AISetupStep = {
    order: number;
    title: string;
    description: string;
    codeSnippet?: string;
    type: 'instruction' | 'api-call' | 'configuration' | 'verification';
    expectedResult?: string;
};

/**
 * Represents an AI-generated integration template or code snippet.
 */
export type AICodeSnippet = {
    id: string;
    name: string;
    language: 'javascript' | 'python' | 'go' | 'ruby' | 'java' | 'curl' | 'shell';
    description: string;
    code: string;
    integrationTarget?: string; // e.g., 'Salesforce CRM API', 'Slack Webhooks'
    apiEndpointsUsed: string[]; // Specific Demo Bank API endpoints
};

// --- Mock Data Generation Functions (for large datasets) ---

const mockIntegrations: Integration[] = [];
const mockReviews: Review[] = [];
const mockIntegrationInstances: IntegrationInstance[] = [];
const mockAPIKeys: APIKey[] = [];
const mockWebhookSubscriptions: WebhookSubscription[] = [];
const mockWebhookLogs: WebhookLog[] = [];
const mockDevelopers: Developer[] = [];
const mockCodeSnippets: AICodeSnippet[] = [];

const categories: IntegrationCategory[] = ['CRM', 'Analytics', 'Marketing', 'Finance', 'Communication', 'Productivity', 'Developer Tools', 'Security', 'HR', 'E-commerce', 'Data Sync', 'AI & ML'];
const tags: IntegrationTag[] = ['popular', 'new', 'free', 'premium', 'enterprise', 'data-sync', 'automation', 'reporting', 'notifications', 'payments', 'dev-ops'];
const webhookEvents: WebhookEvent[] = ['customer.created', 'customer.updated', 'transaction.completed', 'invoice.paid', 'integration.installed'];
const apiEndpoints: string[] = ['GET /customers', 'POST /customers', 'PUT /customers/{id}', 'GET /transactions', 'POST /transactions', 'GET /accounts/{id}/balance', 'POST /payments', 'GET /invoices', 'POST /webhooks/subscribe', 'GET /webhooks/events'];

const generateMockDeveloper = (id: string, name: string): Developer => ({
    id,
    name,
    email: `${name.toLowerCase().replace(/\s/g, '.')}@example.com`,
    website: `https://${name.toLowerCase().replace(/\s/g, '')}.com`,
    integrations: [],
    memberSince: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000 * 5).toISOString(), // Up to 5 years ago
    contactPerson: `${name} Support`
});

// Generate 5 mock developers
for (let i = 0; i < 5; i++) {
    const dev = generateMockDeveloper(generateUUID(), `Dev Company ${i + 1}`);
    mockDevelopers.push(dev);
}

const generateMockIntegration = (index: number): Integration => {
    const dev = mockDevelopers[Math.floor(Math.random() * mockDevelopers.length)];
    const name = `Integration App ${index + 1}`;
    const slug = name.toLowerCase().replace(/\s/g, '-');
    const category = categories[Math.floor(Math.random() * categories.length)];
    const numTags = Math.floor(Math.random() * 3) + 1;
    const selectedTags = Array.from({ length: numTags }, () => tags[Math.floor(Math.random() * tags.length)]);
    const rating = parseFloat((Math.random() * 2 + 3).toFixed(1)); // 3.0 to 5.0
    const totalReviews = Math.floor(Math.random() * 200) + 10;
    const installationCount = Math.floor(Math.random() * 5000) + 50;

    const pricingModel = ['Free', 'Freemium', 'Subscription'][Math.floor(Math.random() * 3)] as IntegrationPricingModel;
    const pricingPlans: IntegrationPlan[] = [];
    if (pricingModel === 'Free') {
        pricingPlans.push({
            id: generateUUID(), name: 'Free Tier', description: 'Basic features for free.', price: 0, currency: 'USD',
            features: ['Basic sync', 'Limited reports'], isTrialAvailable: false
        });
    } else if (pricingModel === 'Freemium' || pricingModel === 'Subscription') {
        pricingPlans.push({
            id: generateUUID(), name: 'Basic', description: 'Essential features.', price: Math.floor(Math.random() * 20) + 5, currency: 'USD',
            interval: 'month', features: ['Core sync', 'Standard reports'], isTrialAvailable: true, trialDurationDays: 14
        });
        pricingPlans.push({
            id: generateUUID(), name: 'Pro', description: 'Advanced capabilities.', price: Math.floor(Math.random() * 50) + 25, currency: 'USD',
            interval: 'month', features: ['All features', 'Priority support'], isTrialAvailable: true, trialDurationDays: 14
        });
    }

    const numEndpoints = Math.floor(Math.random() * 3) + 1;
    const selectedEndpoints = Array.from({ length: numEndpoints }, () => apiEndpoints[Math.floor(Math.random() * apiEndpoints.length)]);

    const integration: Integration = {
        id: generateUUID(),
        name,
        slug,
        shortDescription: `A powerful integration to connect your ${category} workflows with Demo Bank.`,
        longDescription: `Unlock the full potential of your business operations by seamlessly integrating ${name} with Demo Bank. This robust solution offers advanced data synchronization, real-time analytics, and automated workflows. Whether you're looking to streamline customer data, automate financial reporting, or enhance your marketing campaigns, ${name} provides a comprehensive suite of features designed to boost efficiency and drive growth. Enjoy easy setup, reliable performance, and dedicated support.`,
        logoUrl: `https://via.placeholder.com/150/0000FF/FFFFFF?text=${name.split(' ').map(n => n[0]).join('')}`,
        bannerUrl: `https://via.placeholder.com/1200x400/FF0000/FFFFFF?text=${name.replace(/\s/g, '+')}+Banner`,
        category,
        tags: selectedTags,
        developerId: dev.id,
        developerName: dev.name,
        website: dev.website,
        documentationUrl: `${dev.website}/docs/${slug}`,
        supportEmail: dev.email,
        features: [
            { id: generateUUID(), name: 'Real-time Sync', description: 'Synchronize data instantly between systems.' },
            { id: generateUUID(), name: 'Automated Workflows', description: 'Set up rules to automate routine tasks.' },
            { id: generateUUID(), name: 'Customizable Dashboards', description: 'Build dashboards with relevant metrics.' },
            { id: generateUUID(), name: 'Secure Data Handling', description: 'Ensure data privacy and compliance.' },
        ],
        compatibility: [{ platform: 'Web', version: '1.0', notes: 'Compatible with modern web browsers.' }],
        pricingModel,
        pricingPlans,
        averageRating: rating,
        totalReviews,
        installationCount,
        status: 'active',
        createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
        updatedAt: new Date().toISOString(),
        setupGuideMarkdown: `
# Getting Started with ${name} Integration

This guide will walk you through setting up your ${name} integration with Demo Bank.

## Step 1: Connect Your Account
1.  Navigate to the 'Settings' tab within your installed ${name} app.
2.  Click on the 'Connect to Demo Bank' button.
3.  You will be redirected to Demo Bank's authorization page. Log in and grant the necessary permissions.

## Step 2: Configure Data Synchronization
1.  Once connected, return to the ${name} app.
2.  In the 'Sync Settings' section, choose which data entities you wish to synchronize (e.g., Customers, Transactions, Invoices).
3.  Define synchronization direction (one-way or two-way) and frequency.

## Step 3: Test Your Integration
1.  Perform a test action (e.g., create a new customer in Demo Bank).
2.  Verify that the data appears correctly in ${name} within a few minutes.
3.  Check the 'Activity Log' for any errors.

## API Endpoints Used
The ${name} integration utilizes the following Demo Bank API endpoints:
${selectedEndpoints.map(ep => `*   \`${ep}\``).join('\n')}

For more detailed information, please refer to the official [${name} documentation](${dev.website}/docs/${slug}).
        `,
        apiEndpointsNeeded: selectedEndpoints,
        configSchema: {
            type: "object",
            properties: {
                syncInterval: { type: "number", default: 60, title: "Sync Interval (minutes)" },
                syncCustomers: { type: "boolean", default: true, title: "Sync Customer Data" },
                syncTransactions: { type: "boolean", default: true, title: "Sync Transaction Data" },
                sendNotifications: { type: "boolean", default: false, title: "Send Sync Notifications" },
            },
            required: ["syncInterval"]
        },
        webhookEventsSupported: Math.random() > 0.5 ? [webhookEvents[Math.floor(Math.random() * webhookEvents.length)]] : [],
        dataSyncCapabilities: Math.random() > 0.3 ? {
            direction: ['inbound', 'outbound', 'bidirectional'][Math.floor(Math.random() * 3)] as any,
            entities: ['customers', 'transactions', 'invoices'].filter(() => Math.random() > 0.4)
        } : undefined,
    };
    dev.integrations.push(integration.id);
    return integration;
};

// Generate 50 mock integrations
for (let i = 0; i < 50; i++) {
    mockIntegrations.push(generateMockIntegration(i));
}

// Generate reviews for existing integrations
mockIntegrations.forEach(integration => {
    for (let i = 0; i < integration.totalReviews; i++) {
        mockReviews.push({
            id: generateUUID(),
            integrationId: integration.id,
            userId: generateUUID(),
            userName: `User ${i + 1}`,
            rating: Math.floor(Math.random() * 5) + 1,
            title: `Great app for ${integration.category}!`,
            comment: `This integration has significantly improved our workflow. Highly recommend it for anyone needing to manage ${integration.category.toLowerCase()} data efficiently.`,
            createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
        });
    }
});

// Generate mock installed instances for a hypothetical user
const MOCK_USER_ID = 'user-abc-123';
mockIntegrations.slice(0, 5).forEach(integration => {
    mockIntegrationInstances.push({
        id: generateUUID(),
        integrationId: integration.id,
        userId: MOCK_USER_ID,
        installedAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),
        lastSyncedAt: new Date(Date.now() - Math.random() * 2 * 24 * 60 * 60 * 1000).toISOString(),
        status: 'active',
        configuration: {
            syncInterval: Math.floor(Math.random() * 60) + 10,
            syncCustomers: true,
            syncTransactions: Math.random() > 0.5,
            sendNotifications: Math.random() > 0.5,
        },
        planId: integration.pricingPlans.length > 0 ? integration.pricingPlans[0].id : undefined,
    });
});

// Generate mock API keys for a developer
if (mockDevelopers.length > 0) {
    for (let i = 0; i < 3; i++) {
        mockAPIKeys.push({
            id: generateUUID(),
            key: `db_pk_test_${generateUUID().replace(/-/g, '').slice(0, 32)}`,
            name: `My Dev Key ${i + 1}`,
            developerId: mockDevelopers[0].id,
            createdAt: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
            expiresAt: i === 0 ? undefined : new Date(Date.now() + Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
            permissions: ['integrations:read', 'webhooks:manage'],
            isActive: true,
        });
    }

    // Generate mock webhooks for a developer
    for (let i = 0; i < 2; i++) {
        const subId = generateUUID();
        mockWebhookSubscriptions.push({
            id: subId,
            developerId: mockDevelopers[0].id,
            callbackUrl: `https://webhook.site/abc-${i + 1}`,
            events: [webhookEvents[i], webhookEvents[i + 1 % webhookEvents.length]],
            secret: generateUUID().replace(/-/g, ''),
            isActive: true,
            createdAt: new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000).toISOString(),
            updatedAt: new Date().toISOString(),
            lastTriggeredAt: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
            failureCount: Math.floor(Math.random() * 3),
            status: 'active',
        });
        // Add some logs for the webhook
        for (let j = 0; j < 5; j++) {
            const isSuccess = Math.random() > 0.2;
            mockWebhookLogs.push({
                id: generateUUID(),
                subscriptionId: subId,
                eventId: generateUUID(),
                eventType: webhookEvents[i],
                payload: JSON.stringify({ event: webhookEvents[i], data: { id: generateUUID(), type: 'mock' } }),
                statusCode: isSuccess ? 200 : (Math.random() > 0.5 ? 400 : 500),
                responseBody: isSuccess ? 'OK' : 'Error processing webhook',
                attemptedAt: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                isSuccess,
                error: isSuccess ? undefined : 'Simulated error',
            });
        }
    }
}

// Generate mock AI Code Snippets
for (let i = 0; i < 10; i++) {
    const target = mockIntegrations[Math.floor(Math.random() * mockIntegrations.length)].name;
    const lang = ['javascript', 'python', 'curl', 'go', 'ruby'][Math.floor(Math.random() * 5)];
    const endpoints = Array.from({ length: Math.floor(Math.random() * 2) + 1 }, () => apiEndpoints[Math.floor(Math.random() * apiEndpoints.length)]);
    const code = `
// ${lang} example for ${target}
// Using Demo Bank API endpoints: ${endpoints.join(', ')}

${lang === 'javascript' ? `
async function fetchCustomerData(customerId) {
    const response = await fetch('/api/customers/' + customerId, {
        headers: { 'Authorization': 'Bearer YOUR_API_KEY' }
    });
    return response.json();
}
// Example usage:
// fetchCustomerData('cus_123').then(console.log);
` : lang === 'python' ? `
import requests

def create_transaction(amount, currency):
    headers = {'Authorization': 'Bearer YOUR_API_KEY'}
    payload = {'amount': amount, 'currency': currency}
    response = requests.post('https://api.demobank.com/transactions', json=payload, headers=headers)
    response.raise_for_status()
    return response.json()

# Example usage:
# new_transaction = create_transaction(100.50, 'USD')
# print(new_transaction)
` : lang === 'go' ? `
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
)

func createPayment(amount float64, currency string) (map[string]interface{}, error) {
	payload := map[string]interface{}{
		"amount": amount,
		"currency": currency,
	}
	jsonPayload, _ := json.Marshal(payload)

	req, err := http.NewRequest("POST", "https://api.demobank.com/payments", bytes.NewBuffer(jsonPayload))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer YOUR_API_KEY")
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	return result, nil
}

// Example usage:
// func main() {
// 	payment, err := createPayment(200.0, "EUR")
// 	if err != nil {
// 		fmt.Println("Error:", err)
// 	} else {
// 		fmt.Println("Payment created:", payment)
// 	}
// }
` : lang === 'ruby' ? `
require 'net/http'
require 'uri'
require 'json'

def get_account_balance(accountId)
  uri = URI.parse("https://api.demobank.com/accounts/#{accountId}/balance")
  request = Net::HTTP::Get.new(uri)
  request["Authorization"] = "Bearer YOUR_API_KEY"

  response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == "https") do |http|
    http.request(request)
  end

  JSON.parse(response.body)
end

# Example usage:
# balance = get_account_balance('acc_456')
# puts "Account balance: \#{balance}"
` : lang === 'curl' ? `
curl -X POST \\
  https://api.demobank.com/customers \\
  -H 'Content-Type: application/json' \\
  -H 'Authorization: Bearer YOUR_API_KEY' \\
  -d '{
    "name": "Jane Doe",
    "email": "jane.doe@example.com"
  }'
` : `
# Shell example for ${target}
# This is a generic placeholder.
echo "Integration with ${target} is ready."
`}
`;

    mockCodeSnippets.push({
        id: generateUUID(),
        name: `${target} - ${lang} snippet ${i + 1}`,
        language: lang as AICodeSnippet['language'],
        description: `Example code to interact with Demo Bank API for ${target} using ${lang}.`,
        code: code.trim(),
        integrationTarget: target,
        apiEndpointsUsed: endpoints,
    });
}


// --- Mock API Services ---

const API = {
    integrations: {
        getAll: async (filters: { category?: IntegrationCategory, tags?: IntegrationTag[], search?: string, status?: IntegrationStatus }, pagination: { page: number, limit: number }): Promise<{ data: Integration[], total: number }> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    let filtered = mockIntegrations.filter(integration => {
                        let match = true;
                        if (filters.status && integration.status !== filters.status) match = false;
                        if (filters.category && integration.category !== filters.category) match = false;
                        if (filters.tags && filters.tags.length > 0) {
                            match = match && filters.tags.every(tag => integration.tags.includes(tag));
                        }
                        if (filters.search) {
                            const searchTermLower = filters.search.toLowerCase();
                            match = match && (
                                integration.name.toLowerCase().includes(searchTermLower) ||
                                integration.shortDescription.toLowerCase().includes(searchTermLower) ||
                                integration.developerName.toLowerCase().includes(searchTermLower)
                            );
                        }
                        return match;
                    });

                    const start = (pagination.page - 1) * pagination.limit;
                    const end = start + pagination.limit;
                    resolve({ data: filtered.slice(start, end), total: filtered.length });
                }, 500);
            });
        },
        getById: async (id: string): Promise<Integration | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => resolve(mockIntegrations.find(i => i.id === id)), 300);
            });
        },
        create: async (integration: Omit<Integration, 'id' | 'slug' | 'createdAt' | 'updatedAt' | 'status' | 'averageRating' | 'totalReviews' | 'installationCount'>): Promise<Integration> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const newIntegration: Integration = {
                        ...integration,
                        id: generateUUID(),
                        slug: integration.name.toLowerCase().replace(/\s/g, '-'),
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        status: 'pending-review',
                        averageRating: 0,
                        totalReviews: 0,
                        installationCount: 0,
                    };
                    mockIntegrations.push(newIntegration);
                    resolve(newIntegration);
                }, 800);
            });
        },
        update: async (id: string, updates: Partial<Integration>): Promise<Integration | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const index = mockIntegrations.findIndex(i => i.id === id);
                    if (index > -1) {
                        mockIntegrations[index] = { ...mockIntegrations[index], ...updates, updatedAt: new Date().toISOString() };
                        resolve(mockIntegrations[index]);
                    } else {
                        resolve(undefined);
                    }
                }, 800);
            });
        },
        delete: async (id: string): Promise<boolean> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const initialLength = mockIntegrations.length;
                    mockIntegrations.filter(i => i.id !== id);
                    resolve(mockIntegrations.length < initialLength);
                }, 500);
            });
        },
    },
    reviews: {
        getByIntegrationId: async (integrationId: string, pagination: { page: number, limit: number }): Promise<{ data: Review[], total: number }> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const filtered = mockReviews.filter(r => r.integrationId === integrationId);
                    const start = (pagination.page - 1) * pagination.limit;
                    const end = start + pagination.limit;
                    resolve({ data: filtered.slice(start, end), total: filtered.length });
                }, 400);
            });
        },
        add: async (review: Omit<Review, 'id' | 'createdAt'>): Promise<Review> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const newReview: Review = {
                        ...review,
                        id: generateUUID(),
                        createdAt: new Date().toISOString(),
                    };
                    mockReviews.push(newReview);
                    // Update integration's average rating and total reviews
                    const integration = mockIntegrations.find(i => i.id === review.integrationId);
                    if (integration) {
                        const allReviewsForIntegration = mockReviews.filter(r => r.integrationId === integration.id);
                        const totalRating = allReviewsForIntegration.reduce((sum, r) => sum + r.rating, 0);
                        integration.totalReviews = allReviewsForIntegration.length;
                        integration.averageRating = parseFloat((totalRating / integration.totalReviews).toFixed(1));
                    }
                    resolve(newReview);
                }, 600);
            });
        },
    },
    instances: {
        getByUserId: async (userId: string): Promise<IntegrationInstance[]> => {
            return new Promise(resolve => {
                setTimeout(() => resolve(mockIntegrationInstances.filter(inst => inst.userId === userId)), 300);
            });
        },
        install: async (integrationId: string, userId: string, planId?: string): Promise<IntegrationInstance> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const integration = mockIntegrations.find(i => i.id === integrationId);
                    if (!integration) throw new Error('Integration not found');

                    const newInstance: IntegrationInstance = {
                        id: generateUUID(),
                        integrationId,
                        userId,
                        installedAt: new Date().toISOString(),
                        status: 'active',
                        configuration: integration.configSchema ? Object.fromEntries(Object.entries(integration.configSchema.properties || {}).map(([key, value]) => [key, (value as any).default])) : {},
                        planId,
                    };
                    mockIntegrationInstances.push(newInstance);
                    integration.installationCount++; // Update installation count
                    resolve(newInstance);
                }, 1000);
            });
        },
        uninstall: async (instanceId: string): Promise<boolean> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const initialLength = mockIntegrationInstances.length;
                    const instanceIndex = mockIntegrationInstances.findIndex(inst => inst.id === instanceId);
                    if (instanceIndex > -1) {
                        const integrationId = mockIntegrationInstances[instanceIndex].integrationId;
                        mockIntegrationInstances.splice(instanceIndex, 1);
                        const integration = mockIntegrations.find(i => i.id === integrationId);
                        if (integration) {
                            integration.installationCount = Math.max(0, integration.installationCount - 1);
                        }
                    }
                    resolve(mockIntegrationInstances.length < initialLength);
                }, 500);
            });
        },
        updateConfiguration: async (instanceId: string, config: Record<string, any>): Promise<IntegrationInstance | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const index = mockIntegrationInstances.findIndex(inst => inst.id === instanceId);
                    if (index > -1) {
                        mockIntegrationInstances[index].configuration = { ...mockIntegrationInstances[index].configuration, ...config };
                        mockIntegrationInstances[index].lastSyncedAt = new Date().toISOString(); // Simulate a sync
                        resolve(mockIntegrationInstances[index]);
                    } else {
                        resolve(undefined);
                    }
                }, 700);
            });
        },
    },
    developers: {
        getById: async (id: string): Promise<Developer | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => resolve(mockDevelopers.find(d => d.id === id)), 300);
            });
        },
        // In a real app, this would involve more logic like registration
        create: async (developer: Omit<Developer, 'id' | 'memberSince' | 'integrations'>): Promise<Developer> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const newDev: Developer = { ...developer, id: generateUUID(), memberSince: new Date().toISOString(), integrations: [] };
                    mockDevelopers.push(newDev);
                    resolve(newDev);
                }, 800);
            });
        },
    },
    apiKeys: {
        getByDeveloperId: async (developerId: string): Promise<APIKey[]> => {
            return new Promise(resolve => {
                setTimeout(() => resolve(mockAPIKeys.filter(key => key.developerId === developerId)), 300);
            });
        },
        generate: async (developerId: string, name: string, permissions: string[], expiresAt?: string): Promise<APIKey> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const newKey: APIKey = {
                        id: generateUUID(),
                        key: `db_pk_live_${generateUUID().replace(/-/g, '').slice(0, 32)}`,
                        name,
                        developerId,
                        createdAt: new Date().toISOString(),
                        expiresAt,
                        permissions,
                        isActive: true,
                    };
                    mockAPIKeys.push(newKey);
                    resolve(newKey);
                }, 700);
            });
        },
        update: async (id: string, updates: Partial<APIKey>): Promise<APIKey | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const index = mockAPIKeys.findIndex(key => key.id === id);
                    if (index > -1) {
                        mockAPIKeys[index] = { ...mockAPIKeys[index], ...updates };
                        resolve(mockAPIKeys[index]);
                    } else {
                        resolve(undefined);
                    }
                }, 500);
            });
        },
        delete: async (id: string): Promise<boolean> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const initialLength = mockAPIKeys.length;
                    mockAPIKeys.filter(key => key.id !== id);
                    resolve(mockAPIKeys.length < initialLength);
                }, 300);
            });
        },
    },
    webhooks: {
        getEvents: async (): Promise<WebhookEvent[]> => {
            return new Promise(resolve => setTimeout(() => resolve(webhookEvents), 100));
        },
        getSubscriptionsByDeveloperId: async (developerId: string): Promise<WebhookSubscription[]> => {
            return new Promise(resolve => {
                setTimeout(() => resolve(mockWebhookSubscriptions.filter(sub => sub.developerId === developerId)), 300);
            });
        },
        subscribe: async (developerId: string, callbackUrl: string, events: WebhookEvent[], integrationId?: string): Promise<WebhookSubscription> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const newSubscription: WebhookSubscription = {
                        id: generateUUID(),
                        developerId,
                        integrationId,
                        callbackUrl,
                        events,
                        secret: generateUUID().replace(/-/g, ''), // Generate a new secret
                        isActive: true,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        failureCount: 0,
                        status: 'active',
                    };
                    mockWebhookSubscriptions.push(newSubscription);
                    resolve(newSubscription);
                }, 800);
            });
        },
        updateSubscription: async (id: string, updates: Partial<WebhookSubscription>): Promise<WebhookSubscription | undefined> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const index = mockWebhookSubscriptions.findIndex(sub => sub.id === id);
                    if (index > -1) {
                        mockWebhookSubscriptions[index] = { ...mockWebhookSubscriptions[index], ...updates, updatedAt: new Date().toISOString() };
                        resolve(mockWebhookSubscriptions[index]);
                    } else {
                        resolve(undefined);
                    }
                }, 600);
            });
        },
        deleteSubscription: async (id: string): Promise<boolean> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const initialLength = mockWebhookSubscriptions.length;
                    mockWebhookSubscriptions.filter(sub => sub.id !== id);
                    resolve(mockWebhookSubscriptions.length < initialLength);
                }, 400);
            });
        },
        getLogsBySubscriptionId: async (subscriptionId: string, pagination: { page: number, limit: number }): Promise<{ data: WebhookLog[], total: number }> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const filtered = mockWebhookLogs.filter(log => log.subscriptionId === subscriptionId).sort((a,b) => new Date(b.attemptedAt).getTime() - new Date(a.attemptedAt).getTime());
                    const start = (pagination.page - 1) * pagination.limit;
                    const end = start + pagination.limit;
                    resolve({ data: filtered.slice(start, end), total: filtered.length });
                }, 500);
            });
        },
    },
    ai: {
        generateSetupGuideSteps: async (integrationId: string): Promise<AISetupStep[]> => {
            return new Promise(resolve => {
                setTimeout(() => {
                    const integration = mockIntegrations.find(i => i.id === integrationId);
                    if (!integration) {
                        resolve([]);
                        return;
                    }

                    const steps: AISetupStep[] = [
                        {
                            order: 1,
                            title: `Understand ${integration.name} Basics`,
                            description: `Familiarize yourself with the core functionalities and purpose of the ${integration.name} application. Review its official documentation for a deeper understanding.`,
                            type: 'instruction',
                            codeSnippet: `// Visit ${integration.documentationUrl}`
                        },
                        {
                            order: 2,
                            title: 'Generate Demo Bank API Key',
                            description: 'You will need an API key to authorize requests from your integration to Demo Bank. Ensure it has the necessary permissions.',
                            type: 'configuration',
                            codeSnippet: `// Navigate to Developer Settings -> API Keys in Demo Bank dashboard`
                        },
                        {
                            order: 3,
                            title: `Configure ${integration.name} with API Key`,
                            description: `In your ${integration.name} application's settings, locate the section for API key input and enter the Demo Bank API key you generated.`,
                            type: 'configuration',
                            codeSnippet: `// Example placeholder for config UI\n// <input type="password" value="YOUR_API_KEY" />`
                        },
                        {
                            order: 4,
                            title: `Map Data Fields for Sync`,
                            description: `If ${integration.name} involves data synchronization, map the relevant fields between Demo Bank and ${integration.name} to ensure data consistency.`,
                            type: 'instruction',
                            codeSnippet: `// For example, Demo Bank 'customer.name' to ${integration.name} 'client_full_name'`
                        },
                        {
                            order: 5,
                            title: 'Test API Connectivity (Example)',
                            description: `Perform a simple test to ensure ${integration.name} can successfully connect to Demo Bank's API. This example fetches customer data.`,
                            type: 'api-call',
                            codeSnippet: `
// Example: Fetch a customer using ${integration.name}'s internal logic
// Assumes ${integration.name} has a built-in test function
try {
    const testCustomer = await ${integration.name}SDK.fetchDemoBankCustomer('demo-cust-id');
    console.log('Test customer fetched:', testCustomer.name);
} catch (error) {
    console.error('API Test Failed:', error.message);
}
                            `,
                            expectedResult: 'Successful retrieval of a Demo Bank customer record.'
                        },
                        {
                            order: 6,
                            title: 'Monitor Integration Logs',
                            description: `Regularly check the logs or activity feed within ${integration.name} and Demo Bank's integration dashboard for any errors or warnings.`,
                            type: 'verification',
                            codeSnippet: `// Check both Demo Bank and ${integration.name} dashboards for recent activity.`
                        }
                    ];
                    resolve(steps);
                }, 1000);
            });
        },
        generateCodeSnippet: async (prompt: string): Promise<AICodeSnippet> => {
            return new Promise(resolve => {
                setTimeout(async () => {
                    // In a real scenario, this would call Google GenAI with the prompt
                    // For mock, we randomly pick one from our generated snippets
                    if (mockCodeSnippets.length > 0) {
                        const randomIndex = Math.floor(Math.random() * mockCodeSnippets.length);
                        resolve(mockCodeSnippets[randomIndex]);
                    } else {
                        resolve({
                            id: generateUUID(),
                            name: "Placeholder Snippet",
                            language: "javascript",
                            description: "Mock snippet as no actual snippets generated.",
                            code: "// No snippets available for the given prompt.",
                            apiEndpointsUsed: [],
                        });
                    }
                }, 1500);
            });
        }
    }
};

// endregion

// region: --- Generic UI Components (Reusable) ---

interface PaginationControlsProps {
    currentPage: number;
    totalPages: number;
    onPageChange: (page: number) => void;
    pageSize: number;
    onPageSizeChange: (size: number) => void;
    totalItems: number;
}

export const PaginationControls: React.FC<PaginationControlsProps> = ({
    currentPage,
    totalPages,
    onPageChange,
    pageSize,
    onPageSizeChange,
    totalItems,
}) => {
    const pageNumbers = useMemo(() => {
        const pages: (number | '...')[] = [];
        if (totalPages <= 7) {
            for (let i = 1; i <= totalPages; i++) {
                pages.push(i);
            }
        } else {
            pages.push(1);
            if (currentPage > 3) pages.push('...');
            if (currentPage > 2) pages.push(currentPage - 1);
            pages.push(currentPage);
            if (currentPage < totalPages - 1) pages.push(currentPage + 1);
            if (currentPage < totalPages - 2) pages.push('...');
            if (totalPages > 1) pages.push(totalPages); // Ensure last page is always shown if totalPages > 1
        }
        return [...new Set(pages)]; // Remove duplicates from '...'
    }, [currentPage, totalPages]);

    return (
        <div className="flex justify-between items-center text-gray-300 text-sm mt-4 px-4 py-2 bg-gray-900/30 rounded-lg">
            <div className="flex items-center space-x-2">
                <span>Show:</span>
                <select
                    value={pageSize}
                    onChange={(e) => onPageSizeChange(Number(e.target.value))}
                    className="bg-gray-700/50 rounded px-2 py-1 text-white text-xs focus:ring-cyan-600 focus:border-cyan-600"
                >
                    <option value={5}>5</option>
                    <option value={10}>10</option>
                    <option value={20}>20</option>
                    <option value={50}>50</option>
                </select>
                <span>entries</span>
            </div>
            <div className="flex items-center space-x-2">
                <span>Showing {Math.min(totalItems, (currentPage - 1) * pageSize + 1)} to {Math.min(totalItems, currentPage * pageSize)} of {totalItems} entries</span>
            </div>
            <div className="flex space-x-1">
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="px-3 py-1 bg-gray-700/50 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
                >
                    Previous
                </button>
                {pageNumbers.map((page, index) => (
                    <button
                        key={index}
                        onClick={() => typeof page === 'number' && onPageChange(page)}
                        disabled={page === '...' || page === currentPage}
                        className={`px-3 py-1 rounded ${page === currentPage ? 'bg-cyan-600 text-white' : 'bg-gray-700/50 hover:bg-gray-600'} ${page === '...' ? 'cursor-default' : ''}`}
                    >
                        {page}
                    </button>
                ))}
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages || totalPages === 0}
                    className="px-3 py-1 bg-gray-700/50 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-gray-600"
                >
                    Next
                </button>
            </div>
        </div>
    );
};

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl';
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-2xl',
        xl: 'max-w-3xl',
        '2xl': 'max-w-4xl',
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
            <div className={`bg-gray-800 rounded-lg shadow-2xl ${sizeClasses[size]} w-full border border-gray-700`} onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors duration-200">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div className="p-6 space-y-4 max-h-[70vh] overflow-y-auto custom-scrollbar">
                    {children}
                </div>
            </div>
        </div>
    );
};

interface TabsProps {
    tabs: { id: string; label: string; content: React.ReactNode }[];
    activeTab: string;
    onTabChange: (tabId: string) => void;
}

export const Tabs: React.FC<TabsProps> = ({ tabs, activeTab, onTabChange }) => {
    return (
        <div>
            <div className="border-b border-gray-700">
                <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                    {tabs.map((tab) => (
                        <button
                            key={tab.id}
                            onClick={() => onTabChange(tab.id)}
                            className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200
                                ${activeTab === tab.id
                                    ? 'border-cyan-500 text-cyan-400'
                                    : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'
                                }`}
                        >
                            {tab.label}
                        </button>
                    ))}
                </nav>
            </div>
            <div className="py-6">
                {tabs.find(tab => tab.id === activeTab)?.content}
            </div>
        </div>
    );
};

/**
 * Toast notification provider.
 */
export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [toasts, setToasts] = useState<ToastMessage[]>([]);

    const addToast = useCallback((message: Omit<ToastMessage, 'id'>) => {
        const id = generateUUID();
        const newToast: ToastMessage = { id, ...message };
        setToasts(prev => [...prev, newToast]);

        setTimeout(() => {
            setToasts(prev => prev.filter(t => t.id !== id));
        }, message.duration || 5000); // Default 5 seconds
    }, []);

    const removeToast = useCallback((id: string) => {
        setToasts(prev => prev.filter(t => t.id !== id));
    }, []);

    return (
        <ToastContext.Provider value={{ addToast }}>
            {children}
            <div className="fixed bottom-4 right-4 z-[9999] space-y-2">
                {toasts.map(toast => (
                    <div
                        key={toast.id}
                        className={`p-4 rounded-lg shadow-xl flex items-center justify-between min-w-[250px] max-w-sm text-white
                            ${toast.type === 'success' ? 'bg-green-600' :
                              toast.type === 'error' ? 'bg-red-600' :
                              toast.type === 'info' ? 'bg-blue-600' : 'bg-yellow-600'}
                        `}
                    >
                        <span className="text-sm font-medium">{toast.message}</span>
                        <button onClick={() => removeToast(toast.id)} className="ml-4 text-white opacity-70 hover:opacity-100">
                            <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                ))}
            </div>
        </ToastContext.Provider>
    );
};

// endregion

// region: --- Marketplace UI Components ---

interface IntegrationCardProps {
    integration: Integration;
    onViewDetails: (integrationId: string) => void;
    isInstalled?: boolean; // To show different button for installed apps
}

export const IntegrationCard: React.FC<IntegrationCardProps> = ({ integration, onViewDetails, isInstalled = false }) => {
    return (
        <div className="bg-gray-800 rounded-lg shadow-md border border-gray-700 hover:border-cyan-600 transition-colors duration-200 flex flex-col h-full">
            <div className="p-5 flex-grow">
                <div className="flex items-center mb-3">
                    <img src={integration.logoUrl} alt={integration.name} className="w-12 h-12 rounded-full mr-3 border border-gray-600" />
                    <div>
                        <h3 className="text-lg font-semibold text-white">{integration.name}</h3>
                        <p className="text-sm text-gray-400">{integration.developerName}</p>
                    </div>
                </div>
                <p className="text-sm text-gray-300 mb-4 line-clamp-3">{integration.shortDescription}</p>
                <div className="flex flex-wrap gap-2 mb-4 text-xs">
                    <span className="bg-gray-700/50 text-gray-300 px-2 py-1 rounded-full">{integration.category}</span>
                    {integration.tags.slice(0, 2).map(tag => (
                        <span key={tag} className="bg-gray-700/50 text-gray-300 px-2 py-1 rounded-full">{tag}</span>
                    ))}
                </div>
                <div className="flex items-center text-sm text-gray-400">
                    <svg className="w-4 h-4 text-yellow-400 mr-1" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>
                    <span>{integration.averageRating.toFixed(1)} ({integration.totalReviews})</span>
                    <span className="mx-2 text-gray-600">&bull;</span>
                    <span>{integration.installationCount} installs</span>
                </div>
            </div>
            <div className="p-5 border-t border-gray-700">
                <button
                    onClick={() => onViewDetails(integration.id)}
                    className={`w-full py-2 rounded-lg text-sm font-medium ${isInstalled ? 'bg-gray-700 hover:bg-gray-600 text-gray-300' : 'bg-cyan-600 hover:bg-cyan-700 text-white'}`}
                >
                    {isInstalled ? 'Manage Integration' : 'View Details'}
                </button>
            </div>
        </div>
    );
};


interface IntegrationDetailModalProps {
    integrationId: string | null;
    isOpen: boolean;
    onClose: () => void;
    userId: string; // The ID of the current user
    onInstallSuccess: (integrationInstance: IntegrationInstance) => void;
    installedIntegrations: IntegrationInstance[];
}

export const IntegrationDetailModal: React.FC<IntegrationDetailModalProps> = ({ integrationId, isOpen, onClose, userId, onInstallSuccess, installedIntegrations }) => {
    const [integration, setIntegration] = useState<Integration | null>(null);
    const [loading, setLoading] = useState(true);
    const [reviews, setReviews] = useState<Review[]>([]);
    const [reviewsTotal, setReviewsTotal] = useState(0);
    const [reviewsPage, setReviewsPage] = useState(1);
    const reviewsPageSize = 5;
    const [activeTab, setActiveTab] = useState('overview');
    const [isInstalling, setIsInstalling] = useState(false);
    const [selectedPlanId, setSelectedPlanId] = useState<string | undefined>(undefined);
    const toast = useToast();

    const fetchIntegrationDetails = useCallback(async () => {
        if (!integrationId) return;
        setLoading(true);
        try {
            const data = await API.integrations.getById(integrationId);
            setIntegration(data || null);
            if (data) {
                const { data: fetchedReviews, total } = await API.reviews.getByIntegrationId(data.id, { page: reviewsPage, limit: reviewsPageSize });
                setReviews(fetchedReviews);
                setReviewsTotal(total);
            }
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to load integration details.' });
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [integrationId, reviewsPage, toast]);

    useEffect(() => {
        if (isOpen) {
            fetchIntegrationDetails();
            setActiveTab('overview'); // Reset tab on open
        }
    }, [isOpen, fetchIntegrationDetails]);

    const handleInstall = async () => {
        if (!integration || !userId) return;

        setIsInstalling(true);
        try {
            const installedInstance = await API.instances.install(integration.id, userId, selectedPlanId);
            onInstallSuccess(installedInstance);
            toast.addToast({ type: 'success', message: `${integration.name} installed successfully!` });
            onClose(); // Close modal after successful installation
        } catch (err) {
            toast.addToast({ type: 'error', message: `Failed to install ${integration.name}.` });
            console.error(err);
        } finally {
            setIsInstalling(false);
        }
    };

    const isCurrentlyInstalled = useMemo(() => {
        return integrationId && installedIntegrations.some(inst => inst.integrationId === integrationId);
    }, [integrationId, installedIntegrations]);

    const OverviewTab = integration && (
        <div className="space-y-6">
            <img src={integration.bannerUrl || integration.logoUrl} alt={`${integration.name} Banner`} className="w-full rounded-lg object-cover max-h-48" />
            <div className="flex items-center justify-between">
                <h3 className="text-2xl font-bold text-white">{integration.name}</h3>
                <div className="flex items-center text-lg text-gray-300">
                    <svg className="w-5 h-5 text-yellow-400 mr-1" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>
                    <span>{integration.averageRating.toFixed(1)}</span>
                    <span className="text-gray-500 ml-1">({integration.totalReviews} reviews)</span>
                </div>
            </div>

            <p className="text-gray-300 whitespace-pre-line">{integration.longDescription}</p>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300">
                <div className="bg-gray-700/50 p-4 rounded-lg">
                    <h4 className="font-semibold text-white mb-2">Developer</h4>
                    <p>{integration.developerName}</p>
                    <p><a href={integration.website} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Website</a></p>
                    <p><a href={`mailto:${integration.supportEmail}`} className="text-cyan-400 hover:underline">Support Email</a></p>
                </div>
                <div className="bg-gray-700/50 p-4 rounded-lg">
                    <h4 className="font-semibold text-white mb-2">Key Info</h4>
                    <p>Category: <span className="font-medium">{integration.category}</span></p>
                    <p>Pricing Model: <span className="font-medium">{integration.pricingModel}</span></p>
                    <p>Installations: <span className="font-medium">{integration.installationCount.toLocaleString()}</span></p>
                </div>
            </div>

            <h4 className="font-semibold text-white text-xl mt-6">Features</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {integration.features.map(feature => (
                    <div key={feature.id} className="bg-gray-700/50 p-3 rounded-lg flex items-center">
                        {feature.icon && <i className={`${feature.icon} text-cyan-400 text-lg mr-3`}></i>}
                        <div>
                            <p className="font-medium text-white">{feature.name}</p>
                            <p className="text-xs text-gray-400">{feature.description}</p>
                        </div>
                    </div>
                ))}
            </div>

            <h4 className="font-semibold text-white text-xl mt-6">Pricing Plans</h4>
            {integration.pricingPlans.length === 0 ? (
                <p className="text-gray-400">No specific pricing plans listed.</p>
            ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {integration.pricingPlans.map(plan => (
                        <div key={plan.id} className={`bg-gray-700/50 p-4 rounded-lg border cursor-pointer ${selectedPlanId === plan.id ? 'border-cyan-500' : 'border-gray-600 hover:border-gray-500'}`} onClick={() => setSelectedPlanId(plan.id)}>
                            <h5 className="font-semibold text-white text-lg flex justify-between items-center">{plan.name} {plan.price === 0 ? <span className="text-green-400 text-sm">Free</span> : <span className="text-white text-sm">{plan.price} {plan.currency}/{plan.interval}</span>}</h5>
                            <p className="text-sm text-gray-400 mb-2">{plan.description}</p>
                            <ul className="list-disc list-inside text-xs text-gray-300 space-y-1">
                                {plan.features.map((f, i) => <li key={i}>{f}</li>)}
                            </ul>
                            {plan.isTrialAvailable && <p className="text-xs text-cyan-400 mt-2">Free {plan.trialDurationDays}-day trial available</p>}
                        </div>
                    ))}
                </div>
            )}
            {!isCurrentlyInstalled && (
                <div className="flex justify-end mt-8">
                    <button
                        onClick={handleInstall}
                        disabled={isInstalling || (integration.pricingModel !== 'Free' && !selectedPlanId)}
                        className={`px-6 py-3 rounded-lg text-lg font-medium transition-colors duration-200 ${isInstalling || (integration.pricingModel !== 'Free' && !selectedPlanId) ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-cyan-600 hover:bg-cyan-700 text-white'}`}
                    >
                        {isInstalling ? 'Installing...' : 'Install Integration'}
                    </button>
                </div>
            )}
        </div>
    );

    const ReviewsTab = integration && (
        <div>
            {reviews.length === 0 ? (
                <p className="text-gray-400 text-center py-8">No reviews yet for this integration.</p>
            ) : (
                <div className="space-y-6">
                    {reviews.map(review => (
                        <div key={review.id} className="bg-gray-700/50 p-4 rounded-lg border border-gray-600">
                            <div className="flex items-center mb-2">
                                <p className="font-semibold text-white mr-2">{review.userName}</p>
                                <div className="flex text-yellow-400">
                                    {Array.from({ length: review.rating }).map((_, i) => <svg key={i} className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>)}
                                    {Array.from({ length: 5 - review.rating }).map((_, i) => <svg key={i} className="w-4 h-4 text-gray-500" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>)}
                                </div>
                            </div>
                            <h4 className="font-medium text-gray-200 mb-1">{review.title}</h4>
                            <p className="text-sm text-gray-300 mb-2">{review.comment}</p>
                            <p className="text-xs text-gray-500">{formatDate(review.createdAt)}</p>
                            {review.responseFromDeveloper && (
                                <div className="mt-3 ml-4 p-3 bg-gray-800 rounded-md border border-gray-700">
                                    <p className="font-semibold text-cyan-400 text-sm">Developer Response:</p>
                                    <p className="text-sm text-gray-300">{review.responseFromDeveloper.comment}</p>
                                    <p className="text-xs text-gray-500">{formatDate(review.responseFromDeveloper.createdAt)}</p>
                                </div>
                            )}
                        </div>
                    ))}
                    <PaginationControls
                        currentPage={reviewsPage}
                        totalPages={Math.ceil(reviewsTotal / reviewsPageSize)}
                        onPageChange={setReviewsPage}
                        pageSize={reviewsPageSize}
                        onPageSizeChange={() => {}} // Not allowing page size change for reviews
                        totalItems={reviewsTotal}
                    />
                </div>
            )}
        </div>
    );

    const SetupGuideTab = integration && (
        <div className="prose prose-invert max-w-none text-gray-300">
            <h2 className="text-xl font-bold text-white mb-4">Setup Guide</h2>
            <div dangerouslySetInnerHTML={{ __html: integration.setupGuideMarkdown }} />
            <h3 className="text-lg font-bold text-white mt-6 mb-2">AI Generated Setup Steps</h3>
            <AISetupGuideSection integrationId={integration.id} />
        </div>
    );

    const tabs = useMemo(() => {
        const baseTabs = [
            { id: 'overview', label: 'Overview', content: OverviewTab },
            { id: 'reviews', label: 'Reviews', content: ReviewsTab },
        ];
        if (integration?.status === 'active') { // Only show setup guide for active integrations
            baseTabs.push({ id: 'setup-guide', label: 'Setup Guide', content: SetupGuideTab });
        }
        return baseTabs;
    }, [integration, OverviewTab, ReviewsTab, SetupGuideTab]);


    if (loading) {
        return (
            <Modal isOpen={isOpen} onClose={onClose} title="Loading Integration Details..." size="xl">
                <div className="text-gray-400 text-center py-8">Fetching integration details...</div>
            </Modal>
        );
    }

    if (!integration) {
        return (
            <Modal isOpen={isOpen} onClose={onClose} title="Integration Not Found" size="xl">
                <div className="text-red-400 text-center py-8">The requested integration could not be loaded.</div>
            </Modal>
        );
    }

    return (
        <Modal isOpen={isOpen} onClose={onClose} title={integration.name} size="2xl">
            <Tabs tabs={tabs} activeTab={activeTab} onTabChange={setActiveTab} />
        </Modal>
    );
};


export const MarketplaceDiscoverSection: React.FC<{ userId: string; installedIntegrations: IntegrationInstance[]; onInstallSuccess: (instance: IntegrationInstance) => void; }> = ({ userId, installedIntegrations, onInstallSuccess }) => {
    const [integrations, setIntegrations] = useState<Integration[]>([]);
    const [loading, setLoading] = useState(true);
    const [currentPage, setCurrentPage] = useState(1);
    const [pageSize, setPageSize] = useState(12);
    const [totalIntegrations, setTotalIntegrations] = useState(0);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedCategory, setSelectedCategory] = useState<IntegrationCategory | 'all'>('all');
    const [selectedTag, setSelectedTag] = useState<IntegrationTag | 'all'>('all');
    const [detailModalOpen, setDetailModalOpen] = useState(false);
    const [selectedIntegrationId, setSelectedIntegrationId] = useState<string | null>(null);
    const toast = useToast();

    const fetchIntegrations = useCallback(async () => {
        setLoading(true);
        try {
            const filters: { category?: IntegrationCategory, tags?: IntegrationTag[], search?: string, status?: IntegrationStatus } = { status: 'active' };
            if (selectedCategory !== 'all') filters.category = selectedCategory;
            if (selectedTag !== 'all') filters.tags = [selectedTag];
            if (searchTerm) filters.search = searchTerm;

            const { data, total } = await API.integrations.getAll(filters, { page: currentPage, limit: pageSize });
            setIntegrations(data);
            setTotalIntegrations(total);
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to load integrations.' });
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [currentPage, pageSize, searchTerm, selectedCategory, selectedTag, toast]);

    useEffect(() => {
        fetchIntegrations();
    }, [fetchIntegrations]);

    const handleViewDetails = (integrationId: string) => {
        setSelectedIntegrationId(integrationId);
        setDetailModalOpen(true);
    };

    const allCategories = useMemo(() => ['all', ...Array.from(new Set(categories))], []);
    const allTags = useMemo(() => ['all', ...Array.from(new Set(tags))], []);

    return (
        <Card title="Discover Integrations">
            <div className="mb-6 flex flex-wrap gap-4 items-center justify-between">
                <input
                    type="text"
                    placeholder="Search integrations..."
                    className="flex-grow bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 border border-gray-700 focus:ring-cyan-600 focus:border-cyan-600 min-w-[200px]"
                    value={searchTerm}
                    onChange={(e) => { setCurrentPage(1); setSearchTerm(e.target.value); }}
                />
                <select
                    className="bg-gray-700/50 p-2 rounded text-white border border-gray-700 focus:ring-cyan-600 focus:border-cyan-600"
                    value={selectedCategory}
                    onChange={(e) => { setCurrentPage(1); setSelectedCategory(e.target.value as IntegrationCategory | 'all'); }}
                >
                    {allCategories.map(cat => <option key={cat} value={cat}>{cat.replace('_', ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</option>)}
                </select>
                <select
                    className="bg-gray-700/50 p-2 rounded text-white border border-gray-700 focus:ring-cyan-600 focus:border-cyan-600"
                    value={selectedTag}
                    onChange={(e) => { setCurrentPage(1); setSelectedTag(e.target.value as IntegrationTag | 'all'); }}
                >
                    {allTags.map(tag => <option key={tag} value={tag}>{tag.replace('-', ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</option>)}
                </select>
            </div>

            {loading ? (
                <div className="text-gray-400 text-center py-12">Loading integrations...</div>
            ) : integrations.length === 0 ? (
                <div className="text-gray-400 text-center py-12">No integrations found matching your criteria.</div>
            ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    {integrations.map(integration => (
                        <IntegrationCard
                            key={integration.id}
                            integration={integration}
                            onViewDetails={handleViewDetails}
                            isInstalled={installedIntegrations.some(inst => inst.integrationId === integration.id)}
                        />
                    ))}
                </div>
            )}
            <PaginationControls
                currentPage={currentPage}
                totalPages={Math.ceil(totalIntegrations / pageSize)}
                onPageChange={setCurrentPage}
                pageSize={pageSize}
                onPageSizeChange={setPageSize}
                totalItems={totalIntegrations}
            />

            <IntegrationDetailModal
                integrationId={selectedIntegrationId}
                isOpen={detailModalOpen}
                onClose={() => setDetailModalOpen(false)}
                userId={userId}
                onInstallSuccess={onInstallSuccess}
                installedIntegrations={installedIntegrations}
            />
        </Card>
    );
};

export const InstalledIntegrationsSection: React.FC<{ userId: string; installedIntegrations: IntegrationInstance[]; onInstanceUpdate: () => void; }> = ({ userId, installedIntegrations, onInstanceUpdate }) => {
    const [loading, setLoading] = useState(true);
    const [detailModalOpen, setDetailModalOpen] = useState(false);
    const [selectedInstance, setSelectedInstance] = useState<IntegrationInstance | null>(null);
    const [selectedIntegration, setSelectedIntegration] = useState<Integration | null>(null);
    const toast = useToast();

    useEffect(() => {
        // This component receives `installedIntegrations` directly
        // So loading state is primarily for fetching details on modal open
        setLoading(false);
    }, [installedIntegrations]);

    const handleManageInstance = async (instance: IntegrationInstance) => {
        setSelectedInstance(instance);
        setLoading(true);
        try {
            const integrationDetails = await API.integrations.getById(instance.integrationId);
            setSelectedIntegration(integrationDetails || null);
            setDetailModalOpen(true);
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to load integration details for instance management.' });
            console.error(err);
        } finally {
            setLoading(false);
        }
    };

    const handleUninstall = async (instanceId: string, integrationName: string) => {
        if (!window.confirm(`Are you sure you want to uninstall ${integrationName}? This action cannot be undone.`)) {
            return;
        }
        setLoading(true);
        try {
            await API.instances.uninstall(instanceId);
            toast.addToast({ type: 'success', message: `${integrationName} uninstalled successfully!` });
            onInstanceUpdate(); // Trigger refresh of installed integrations
            setDetailModalOpen(false); // Close modal if open for this instance
        } catch (err) {
            toast.addToast({ type: 'error', message: `Failed to uninstall ${integrationName}.` });
            console.error(err);
        } finally {
            setLoading(false);
        }
    };

    const handleUpdateConfig = async (config: Record<string, any>) => {
        if (!selectedInstance) return;
        setLoading(true);
        try {
            const updatedInstance = await API.instances.updateConfiguration(selectedInstance.id, config);
            if (updatedInstance) {
                setSelectedInstance(updatedInstance); // Update local state of instance
                toast.addToast({ type: 'success', message: 'Integration configuration updated!' });
                onInstanceUpdate(); // Refresh parent list
            }
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to update configuration.' });
            console.error(err);
        } finally {
            setLoading(false);
        }
    };

    const IntegrationInstanceDetailModal: React.FC<{
        instance: IntegrationInstance;
        integration: Integration;
        isOpen: boolean;
        onClose: () => void;
        onUninstall: (instanceId: string, integrationName: string) => void;
        onUpdateConfig: (config: Record<string, any>) => void;
        isLoading: boolean;
    }> = ({ instance, integration, isOpen, onClose, onUninstall, onUpdateConfig, isLoading }) => {
        const [configValues, setConfigValues] = useState<Record<string, any>>(instance.configuration);

        useEffect(() => {
            setConfigValues(instance.configuration);
        }, [instance]);

        const handleConfigChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
            const { name, value, type, checked } = e.target;
            setConfigValues(prev => ({
                ...prev,
                [name]: type === 'checkbox' ? checked : (type === 'number' ? parseFloat(value) : value),
            }));
        };

        const renderConfigForm = () => {
            if (!integration.configSchema || !integration.configSchema.properties) {
                return <p className="text-gray-400">No configurable settings for this integration.</p>;
            }

            return (
                <div className="space-y-4">
                    {Object.entries(integration.configSchema.properties).map(([key, schema]) => {
                        const s = schema as { type: string; title: string; default?: any; };
                        const value = configValues[key] !== undefined ? configValues[key] : s.default;

                        switch (s.type) {
                            case 'boolean':
                                return (
                                    <div key={key} className="flex items-center justify-between">
                                        <label htmlFor={key} className="text-gray-300">{s.title}</label>
                                        <input
                                            type="checkbox"
                                            id={key}
                                            name={key}
                                            checked={!!value}
                                            onChange={handleConfigChange}
                                            className="form-checkbox h-5 w-5 text-cyan-600 bg-gray-700/50 border-gray-600 rounded"
                                            disabled={isLoading}
                                        />
                                    </div>
                                );
                            case 'number':
                                return (
                                    <div key={key}>
                                        <label htmlFor={key} className="block text-gray-300 text-sm font-medium mb-1">{s.title}</label>
                                        <input
                                            type="number"
                                            id={key}
                                            name={key}
                                            value={value}
                                            onChange={handleConfigChange}
                                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600"
                                            disabled={isLoading}
                                        />
                                    </div>
                                );
                            case 'string':
                            default:
                                return (
                                    <div key={key}>
                                        <label htmlFor={key} className="block text-gray-300 text-sm font-medium mb-1">{s.title}</label>
                                        <input
                                            type="text"
                                            id={key}
                                            name={key}
                                            value={value}
                                            onChange={handleConfigChange}
                                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600"
                                            disabled={isLoading}
                                        />
                                    </div>
                                );
                        }
                    })}
                    <div className="flex justify-end mt-6 space-x-2">
                        <button type="button" onClick={() => onUpdateConfig(configValues)} disabled={isLoading} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium">
                            {isLoading ? 'Saving...' : 'Save Configuration'}
                        </button>
                    </div>
                </div>
            );
        };

        const InstanceOverviewTab = (
            <div className="space-y-4 text-gray-300">
                <div className="flex items-center mb-4">
                    <img src={integration.logoUrl} alt={integration.name} className="w-16 h-16 rounded-full mr-4 border border-gray-600" />
                    <div>
                        <h3 className="text-xl font-bold text-white">{integration.name}</h3>
                        <p className="text-sm text-gray-400">by {integration.developerName}</p>
                    </div>
                </div>
                <p><strong>Status:</strong> <span className={`font-semibold ${instance.status === 'active' ? 'text-green-400' : 'text-red-400'}`}>{instance.status.toUpperCase()}</span></p>
                <p><strong>Installed At:</strong> {formatDate(instance.installedAt)}</p>
                {instance.lastSyncedAt && <p><strong>Last Synced At:</strong> {formatDate(instance.lastSyncedAt)}</p>}
                {instance.planId && (
                    <p><strong>Active Plan:</strong> {integration.pricingPlans.find(p => p.id === instance.planId)?.name || 'N/A'}</p>
                )}
                <div className="mt-6">
                    <h4 className="font-semibold text-white mb-2">Configuration</h4>
                    {renderConfigForm()}
                </div>
                <div className="flex justify-end mt-8">
                    <button onClick={() => onUninstall(instance.id, integration.name)} disabled={isLoading} className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium">
                        {isLoading ? 'Uninstalling...' : 'Uninstall Integration'}
                    </button>
                </div>
            </div>
        );

        const LogsTab = (
            <div>
                <p className="text-gray-400">Placeholder for detailed activity and error logs for this integration instance. (Coming Soon!)</p>
            </div>
        );

        const instanceTabs = [
            { id: 'overview', label: 'Overview & Configuration', content: InstanceOverviewTab },
            { id: 'logs', label: 'Activity Logs', content: LogsTab },
        ];

        const [activeInstanceTab, setActiveInstanceTab] = useState('overview');

        return (
            <Modal isOpen={isOpen} onClose={onClose} title={`Manage ${integration.name}`} size="xl">
                <Tabs tabs={instanceTabs} activeTab={activeInstanceTab} onTabChange={setActiveInstanceTab} />
            </Modal>
        );
    };


    return (
        <Card title="My Installed Integrations">
            {loading ? (
                <div className="text-gray-400 text-center py-12">Loading installed integrations...</div>
            ) : installedIntegrations.length === 0 ? (
                <div className="text-gray-400 text-center py-12">You haven't installed any integrations yet.</div>
            ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    {installedIntegrations.map(instance => {
                        const integration = mockIntegrations.find(i => i.id === instance.integrationId);
                        if (!integration) return null; // Should not happen with good data integrity

                        return (
                            <div key={instance.id} className="bg-gray-800 rounded-lg shadow-md border border-gray-700 hover:border-cyan-600 transition-colors duration-200 flex flex-col h-full">
                                <div className="p-5 flex-grow">
                                    <div className="flex items-center mb-3">
                                        <img src={integration.logoUrl} alt={integration.name} className="w-12 h-12 rounded-full mr-3 border border-gray-600" />
                                        <div>
                                            <h3 className="text-lg font-semibold text-white">{integration.name}</h3>
                                            <p className="text-sm text-gray-400">{integration.developerName}</p>
                                        </div>
                                    </div>
                                    <p className="text-sm text-gray-300 mb-2 line-clamp-2">{integration.shortDescription}</p>
                                    <p className="text-xs text-gray-500">Installed: {formatDate(instance.installedAt)}</p>
                                    <p className="text-xs text-gray-500">Last Synced: {instance.lastSyncedAt ? formatDate(instance.lastSyncedAt) : 'Never'}</p>
                                    <p className="text-xs text-gray-500">Status: <span className={`font-medium ${instance.status === 'active' ? 'text-green-400' : 'text-red-400'}`}>{instance.status.toUpperCase()}</span></p>
                                </div>
                                <div className="p-5 border-t border-gray-700">
                                    <button
                                        onClick={() => handleManageInstance(instance)}
                                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium"
                                    >
                                        Manage
                                    </button>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}
            {selectedInstance && selectedIntegration && (
                <IntegrationInstanceDetailModal
                    instance={selectedInstance}
                    integration={selectedIntegration}
                    isOpen={detailModalOpen}
                    onClose={() => setDetailModalOpen(false)}
                    onUninstall={handleUninstall}
                    onUpdateConfig={handleUpdateConfig}
                    isLoading={loading}
                />
            )}
        </Card>
    );
};

export const DeveloperDashboardSection: React.FC<{ currentDeveloperId: string; onDeveloperUpdate: () => void; }> = ({ currentDeveloperId, onDeveloperUpdate }) => {
    const [developer, setDeveloper] = useState<Developer | null>(null);
    const [loading, setLoading] = useState(true);
    const [activeTab, setActiveTab] = useState('integrations');
    const toast = useToast();

    const fetchDeveloperDetails = useCallback(async () => {
        if (!currentDeveloperId) return;
        setLoading(true);
        try {
            const data = await API.developers.getById(currentDeveloperId);
            setDeveloper(data || null);
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to load developer profile.' });
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [currentDeveloperId, toast]);

    useEffect(() => {
        fetchDeveloperDetails();
    }, [fetchDeveloperDetails]);

    if (loading) {
        return <Card title="Developer Dashboard"><div className="text-gray-400 text-center py-12">Loading developer dashboard...</div></Card>;
    }
    if (!developer) {
        return <Card title="Developer Dashboard"><div className="text-red-400 text-center py-12">Developer profile not found. Please register as a developer.</div></Card>;
    }

    const DeveloperIntegrationsTab: React.FC = () => {
        const [devIntegrations, setDevIntegrations] = useState<Integration[]>([]);
        const [devLoading, setDevLoading] = useState(true);
        const [devCurrentPage, setDevCurrentPage] = useState(1);
        const [devPageSize, setDevPageSize] = useState(10);
        const [devTotalIntegrations, setDevTotalIntegrations] = useState(0);
        const [isAddEditModalOpen, setIsAddEditModalOpen] = useState(false);
        const [editingIntegration, setEditingIntegration] = useState<Integration | null>(null);

        const fetchDevIntegrations = useCallback(async () => {
            setDevLoading(true);
            try {
                // Filter by developerId, then apply pagination if needed
                const allIntegrations = mockIntegrations.filter(i => i.developerId === currentDeveloperId);
                const start = (devCurrentPage - 1) * devPageSize;
                const end = start + devPageSize;
                setDevIntegrations(allIntegrations.slice(start, end));
                setDevTotalIntegrations(allIntegrations.length);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to load your integrations.' });
                console.error(err);
            } finally {
                setDevLoading(false);
            }
        }, [currentDeveloperId, devCurrentPage, devPageSize, toast]);

        useEffect(() => {
            fetchDevIntegrations();
        }, [fetchDevIntegrations]);

        const handleAddEditIntegration = (integration?: Integration) => {
            setEditingIntegration(integration || null);
            setIsAddEditModalOpen(true);
        };

        const handleSaveIntegration = async (payload: Omit<Integration, 'id' | 'slug' | 'createdAt' | 'updatedAt' | 'status' | 'averageRating' | 'totalReviews' | 'installationCount'>) => {
            setDevLoading(true);
            try {
                if (editingIntegration) {
                    await API.integrations.update(editingIntegration.id, payload);
                    toast.addToast({ type: 'success', message: 'Integration updated successfully!' });
                } else {
                    await API.integrations.create(payload);
                    toast.addToast({ type: 'success', message: 'Integration submitted for review!' });
                }
                fetchDevIntegrations();
                setIsAddEditModalOpen(false);
            } catch (err) {
                toast.addToast({ type: 'error', message: `Failed to save integration.` });
                console.error(err);
            } finally {
                setDevLoading(false);
            }
        };

        const IntegrationAddEditModal: React.FC<{ isOpen: boolean; onClose: () => void; onSave: (payload: Omit<Integration, 'id' | 'slug' | 'createdAt' | 'updatedAt' | 'status' | 'averageRating' | 'totalReviews' | 'installationCount'>) => Promise<void>; integration: Integration | null; developerId: string; }> = ({ isOpen, onClose, onSave, integration, developerId }) => {
            const isEditing = !!integration;
            const [formData, setFormData] = useState<Omit<Integration, 'id' | 'slug' | 'createdAt' | 'updatedAt' | 'status' | 'averageRating' | 'totalReviews' | 'installationCount'>>({
                name: '',
                shortDescription: '',
                longDescription: '',
                logoUrl: '',
                bannerUrl: '',
                category: 'CRM',
                tags: [],
                developerId: developerId,
                developerName: developer?.name || 'Unknown',
                website: '',
                documentationUrl: '',
                supportEmail: '',
                features: [],
                compatibility: [],
                pricingModel: 'Free',
                pricingPlans: [],
                setupGuideMarkdown: '',
                apiEndpointsNeeded: [],
            });
            const [saving, setSaving] = useState(false);

            useEffect(() => {
                if (integration) {
                    setFormData({
                        name: integration.name,
                        shortDescription: integration.shortDescription,
                        longDescription: integration.longDescription,
                        logoUrl: integration.logoUrl,
                        bannerUrl: integration.bannerUrl,
                        category: integration.category,
                        tags: integration.tags,
                        developerId: integration.developerId,
                        developerName: integration.developerName,
                        website: integration.website,
                        documentationUrl: integration.documentationUrl,
                        supportEmail: integration.supportEmail,
                        features: integration.features,
                        compatibility: integration.compatibility,
                        pricingModel: integration.pricingModel,
                        pricingPlans: integration.pricingPlans,
                        setupGuideMarkdown: integration.setupGuideMarkdown,
                        apiEndpointsNeeded: integration.apiEndpointsNeeded,
                    });
                } else {
                    setFormData({
                        name: '',
                        shortDescription: '',
                        longDescription: '',
                        logoUrl: '',
                        bannerUrl: '',
                        category: 'CRM',
                        tags: [],
                        developerId: developerId,
                        developerName: developer?.name || 'Unknown',
                        website: developer?.website || '',
                        documentationUrl: '',
                        supportEmail: developer?.email || '',
                        features: [],
                        compatibility: [{ platform: 'Web' }],
                        pricingModel: 'Free',
                        pricingPlans: [],
                        setupGuideMarkdown: '# Getting Started',
                        apiEndpointsNeeded: [],
                    });
                }
            }, [integration, isOpen, developer]);

            const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

            const handleTagChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
                const { options } = e.target;
                const value: IntegrationTag[] = [];
                for (let i = 0, l = options.length; i < l; i++) {
                    if (options[i].selected) {
                        value.push(options[i].value as IntegrationTag);
                    }
                }
                setFormData(prev => ({ ...prev, tags: value }));
            };

            const handleFeatureChange = (index: number, field: keyof IntegrationFeature, value: string) => {
                const newFeatures = [...formData.features];
                newFeatures[index] = { ...newFeatures[index], [field]: value };
                setFormData(prev => ({ ...prev, features: newFeatures }));
            };

            const addFeature = () => {
                setFormData(prev => ({ ...prev, features: [...prev.features, { id: generateUUID(), name: '', description: '' }] }));
            };

            const removeFeature = (index: number) => {
                setFormData(prev => ({ ...prev, features: prev.features.filter((_, i) => i !== index) }));
            };

            const handleAPIEndpointChange = (index: number, value: string) => {
                const newEndpoints = [...formData.apiEndpointsNeeded];
                newEndpoints[index] = value;
                setFormData(prev => ({ ...prev, apiEndpointsNeeded: newEndpoints }));
            };

            const addAPIEndpoint = () => {
                setFormData(prev => ({ ...prev, apiEndpointsNeeded: [...prev.apiEndpointsNeeded, ''] }));
            };

            const removeAPIEndpoint = (index: number) => {
                setFormData(prev => ({ ...prev, apiEndpointsNeeded: prev.apiEndpointsNeeded.filter((_, i) => i !== index) }));
            };


            const handleSubmit = async (e: React.FormEvent) => {
                e.preventDefault();
                setSaving(true);
                try {
                    await onSave(formData);
                    onClose();
                } finally {
                    setSaving(false);
                }
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} title={isEditing ? `Edit ${integration?.name}` : "Add New Integration"} size="xl">
                    <form onSubmit={handleSubmit} className="space-y-6">
                        <h4 className="text-lg font-semibold text-white">Basic Information</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="name" className="block text-gray-300 text-sm font-medium mb-1">Name</label>
                                <input type="text" id="name" name="name" value={formData.name} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                            </div>
                            <div>
                                <label htmlFor="category" className="block text-gray-300 text-sm font-medium mb-1">Category</label>
                                <select id="category" name="category" value={formData.category} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600">
                                    {categories.map(cat => <option key={cat} value={cat}>{cat}</option>)}
                                </select>
                            </div>
                        </div>
                        <div>
                            <label htmlFor="shortDescription" className="block text-gray-300 text-sm font-medium mb-1">Short Description</label>
                            <textarea id="shortDescription" name="shortDescription" value={formData.shortDescription} onChange={handleChange} required rows={2} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 resize-y"></textarea>
                        </div>
                        <div>
                            <label htmlFor="longDescription" className="block text-gray-300 text-sm font-medium mb-1">Long Description</label>
                            <textarea id="longDescription" name="longDescription" value={formData.longDescription} onChange={handleChange} required rows={5} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 resize-y"></textarea>
                        </div>
                        <div>
                            <label htmlFor="logoUrl" className="block text-gray-300 text-sm font-medium mb-1">Logo URL</label>
                            <input type="url" id="logoUrl" name="logoUrl" value={formData.logoUrl} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                        </div>
                        <div>
                            <label htmlFor="bannerUrl" className="block text-gray-300 text-sm font-medium mb-1">Banner URL (Optional)</label>
                            <input type="url" id="bannerUrl" name="bannerUrl" value={formData.bannerUrl || ''} onChange={handleChange} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                        </div>
                        <div>
                            <label htmlFor="tags" className="block text-gray-300 text-sm font-medium mb-1">Tags (Ctrl/Cmd click to select multiple)</label>
                            <select multiple id="tags" name="tags" value={formData.tags} onChange={handleTagChange} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 h-28">
                                {tags.map(tag => <option key={tag} value={tag}>{tag}</option>)}
                            </select>
                        </div>

                        <h4 className="text-lg font-semibold text-white pt-4">Developer & Support</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="website" className="block text-gray-300 text-sm font-medium mb-1">Website URL</label>
                                <input type="url" id="website" name="website" value={formData.website} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                            </div>
                            <div>
                                <label htmlFor="documentationUrl" className="block text-gray-300 text-sm font-medium mb-1">Documentation URL</label>
                                <input type="url" id="documentationUrl" name="documentationUrl" value={formData.documentationUrl} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                            </div>
                        </div>
                        <div>
                            <label htmlFor="supportEmail" className="block text-gray-300 text-sm font-medium mb-1">Support Email</label>
                            <input type="email" id="supportEmail" name="supportEmail" value={formData.supportEmail} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                        </div>

                        <h4 className="text-lg font-semibold text-white pt-4">Features</h4>
                        {formData.features.map((feature, index) => (
                            <div key={feature.id} className="flex gap-2 items-center">
                                <input
                                    type="text"
                                    placeholder="Feature Name"
                                    value={feature.name}
                                    onChange={(e) => handleFeatureChange(index, 'name', e.target.value)}
                                    className="flex-grow bg-gray-700/50 p-2 rounded text-white border border-gray-600"
                                />
                                <input
                                    type="text"
                                    placeholder="Feature Description"
                                    value={feature.description}
                                    onChange={(e) => handleFeatureChange(index, 'description', e.target.value)}
                                    className="flex-grow bg-gray-700/50 p-2 rounded text-white border border-gray-600"
                                />
                                <button type="button" onClick={() => removeFeature(index)} className="p-2 text-red-400 hover:text-red-500">
                                    <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        ))}
                        <button type="button" onClick={addFeature} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Add Feature</button>

                        <h4 className="text-lg font-semibold text-white pt-4">API Endpoints Needed</h4>
                        {formData.apiEndpointsNeeded.map((endpoint, index) => (
                            <div key={index} className="flex gap-2 items-center">
                                <input
                                    type="text"
                                    placeholder="e.g., GET /customers"
                                    value={endpoint}
                                    onChange={(e) => handleAPIEndpointChange(index, e.target.value)}
                                    className="flex-grow bg-gray-700/50 p-2 rounded text-white border border-gray-600"
                                />
                                <button type="button" onClick={() => removeAPIEndpoint(index)} className="p-2 text-red-400 hover:text-red-500">
                                    <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        ))}
                        <button type="button" onClick={addAPIEndpoint} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Add API Endpoint</button>


                        <h4 className="text-lg font-semibold text-white pt-4">Pricing Model</h4>
                        <div>
                            <label htmlFor="pricingModel" className="block text-gray-300 text-sm font-medium mb-1">Pricing Model</label>
                            <select id="pricingModel" name="pricingModel" value={formData.pricingModel} onChange={handleChange} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600">
                                {['Free', 'Freemium', 'Subscription', 'Per-usage', 'Enterprise'].map(model => <option key={model} value={model}>{model}</option>)}
                            </select>
                        </div>
                        {/* More advanced form for pricing plans can be added here */}


                        <h4 className="text-lg font-semibold text-white pt-4">Setup Guide (Markdown)</h4>
                        <div>
                            <textarea id="setupGuideMarkdown" name="setupGuideMarkdown" value={formData.setupGuideMarkdown} onChange={handleChange} required rows={10} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 resize-y font-mono"></textarea>
                        </div>


                        <div className="flex justify-end space-x-2 pt-6">
                            <button type="button" onClick={onClose} disabled={saving} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Cancel</button>
                            <button type="submit" disabled={saving} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium">
                                {saving ? 'Saving...' : (isEditing ? 'Save Changes' : 'Submit for Review')}
                            </button>
                        </div>
                    </form>
                </Modal>
            );
        };

        return (
            <div>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-semibold text-white">Your Integrations</h3>
                    <button onClick={() => handleAddEditIntegration()} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium">Add New Integration</button>
                </div>

                {devLoading ? (
                    <div className="text-gray-400 text-center py-8">Loading your integrations...</div>
                ) : devIntegrations.length === 0 ? (
                    <div className="text-gray-400 text-center py-8">You haven't added any integrations yet.</div>
                ) : (
                    <>
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-700">
                                <thead className="bg-gray-700">
                                    <tr>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Category</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Installs</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Rating</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Actions</th>
                                    </tr>
                                </thead>
                                <tbody className="bg-gray-800 divide-y divide-gray-700">
                                    {devIntegrations.map(integration => (
                                        <tr key={integration.id} className="hover:bg-gray-700">
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{integration.name}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{integration.category}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                    integration.status === 'active' ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100' :
                                                    integration.status === 'pending-review' ? 'bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-100' :
                                                    'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100'
                                                }`}>{integration.status.replace('-', ' ')}</span>
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{integration.installationCount}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{integration.averageRating.toFixed(1)} ({integration.totalReviews})</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium flex space-x-2">
                                                <button onClick={() => handleAddEditIntegration(integration)} className="text-cyan-500 hover:text-cyan-400 text-sm font-medium">Edit</button>
                                                <button onClick={() => toast.addToast({ type: 'info', message: 'Delete functionality not implemented for mock API' })} className="text-red-500 hover:text-red-400 text-sm font-medium">Delete</button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <PaginationControls
                            currentPage={devCurrentPage}
                            totalPages={Math.ceil(devTotalIntegrations / devPageSize)}
                            onPageChange={setDevCurrentPage}
                            pageSize={devPageSize}
                            onPageSizeChange={setDevPageSize}
                            totalItems={devTotalIntegrations}
                        />
                    </>
                )}
                <IntegrationAddEditModal
                    isOpen={isAddEditModalOpen}
                    onClose={() => setIsAddEditModalOpen(false)}
                    onSave={handleSaveIntegration}
                    integration={editingIntegration}
                    developerId={currentDeveloperId}
                />
            </div>
        );
    };

    const DeveloperAPIKeysTab: React.FC = () => {
        const [apiKeys, setApiKeys] = useState<APIKey[]>([]);
        const [keysLoading, setKeysLoading] = useState(true);
        const [isGenerateKeyModalOpen, setIsGenerateKeyModalOpen] = useState(false);
        const toast = useToast();

        const fetchApiKeys = useCallback(async () => {
            setKeysLoading(true);
            try {
                const data = await API.apiKeys.getByDeveloperId(currentDeveloperId);
                setApiKeys(data);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to load API keys.' });
                console.error(err);
            } finally {
                setKeysLoading(false);
            }
        }, [currentDeveloperId, toast]);

        useEffect(() => {
            fetchApiKeys();
        }, [fetchApiKeys]);

        const handleGenerateKey = async (name: string, permissions: string[], expiresAt?: string) => {
            setKeysLoading(true);
            try {
                await API.apiKeys.generate(currentDeveloperId, name, permissions, expiresAt);
                toast.addToast({ type: 'success', message: 'New API Key generated successfully!' });
                fetchApiKeys();
                setIsGenerateKeyModalOpen(false);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to generate API Key.' });
                console.error(err);
            } finally {
                setKeysLoading(false);
            }
        };

        const handleToggleKeyStatus = async (key: APIKey) => {
            setKeysLoading(true);
            try {
                await API.apiKeys.update(key.id, { isActive: !key.isActive });
                toast.addToast({ type: 'success', message: `API Key ${key.isActive ? 'deactivated' : 'activated'}!` });
                fetchApiKeys();
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to update API Key status.' });
                console.error(err);
            } finally {
                setKeysLoading(false);
            }
        };

        const GenerateAPIKeyModal: React.FC<{ isOpen: boolean; onClose: () => void; onGenerate: (name: string, permissions: string[], expiresAt?: string) => Promise<void>; isLoading: boolean; }> = ({ isOpen, onClose, onGenerate, isLoading }) => {
            const [name, setName] = useState('');
            const [permissions, setPermissions] = useState<string[]>([]);
            const [expiresAt, setExpiresAt] = useState('');

            const allPermissions = ['integrations:read', 'integrations:write', 'webhooks:manage', 'customers:read', 'customers:write', 'transactions:read', 'transactions:write'];

            const handleSubmit = async (e: React.FormEvent) => {
                e.preventDefault();
                await onGenerate(name, permissions, expiresAt || undefined);
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} title="Generate New API Key" size="md">
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="keyName" className="block text-gray-300 text-sm font-medium mb-1">Key Name</label>
                            <input type="text" id="keyName" value={name} onChange={e => setName(e.target.value)} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                        </div>
                        <div>
                            <label htmlFor="permissions" className="block text-gray-300 text-sm font-medium mb-1">Permissions (Ctrl/Cmd click for multiple)</label>
                            <select multiple id="permissions" value={permissions} onChange={e => {
                                const options = e.target.options;
                                const value: string[] = [];
                                for (let i = 0, l = options.length; i < l; i++) {
                                    if (options[i].selected) {
                                        value.push(options[i].value);
                                    }
                                }
                                setPermissions(value);
                            }} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 h-32">
                                {allPermissions.map(p => <option key={p} value={p}>{p}</option>)}
                            </select>
                        </div>
                        <div>
                            <label htmlFor="expiresAt" className="block text-gray-300 text-sm font-medium mb-1">Expires At (Optional)</label>
                            <input type="date" id="expiresAt" value={expiresAt} onChange={e => setExpiresAt(e.target.value)} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" />
                        </div>
                        <div className="flex justify-end space-x-2 pt-4">
                            <button type="button" onClick={onClose} disabled={isLoading} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Cancel</button>
                            <button type="submit" disabled={isLoading} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium">
                                {isLoading ? 'Generating...' : 'Generate Key'}
                            </button>
                        </div>
                    </form>
                </Modal>
            );
        };


        return (
            <div>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-semibold text-white">Your API Keys</h3>
                    <button onClick={() => setIsGenerateKeyModalOpen(true)} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium">Generate New Key</button>
                </div>

                {keysLoading ? (
                    <div className="text-gray-400 text-center py-8">Loading API keys...</div>
                ) : apiKeys.length === 0 ? (
                    <div className="text-gray-400 text-center py-8">No API keys generated yet.</div>
                ) : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-700">
                            <thead className="bg-gray-700">
                                <tr>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Key</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Permissions</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Expires At</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="bg-gray-800 divide-y divide-gray-700">
                                {apiKeys.map(key => (
                                    <tr key={key.id} className="hover:bg-gray-700">
                                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{key.name}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm font-mono text-gray-300 truncate max-w-[150px]">{key.key.substring(0, 8)}...</td>
                                        <td className="px-6 py-4 text-sm text-gray-300">
                                            <ul className="list-disc list-inside text-xs space-y-1">
                                                {key.permissions.map((p, i) => <li key={i}>{p}</li>)}
                                            </ul>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                key.isActive ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100' :
                                                'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100'
                                            }`}>{key.isActive ? 'Active' : 'Inactive'}</span>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{key.expiresAt ? formatDate(key.expiresAt) : 'Never'}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium flex space-x-2">
                                            <button onClick={() => handleToggleKeyStatus(key)} className={`${key.isActive ? 'text-yellow-500 hover:text-yellow-400' : 'text-green-500 hover:text-green-400'} text-sm font-medium`}>{key.isActive ? 'Deactivate' : 'Activate'}</button>
                                            <button onClick={() => toast.addToast({ type: 'info', message: 'Key deletion not implemented for mock API' })} className="text-red-500 hover:text-red-400 text-sm font-medium">Delete</button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
                <GenerateAPIKeyModal isOpen={isGenerateKeyModalOpen} onClose={() => setIsGenerateKeyModalOpen(false)} onGenerate={handleGenerateKey} isLoading={keysLoading} />
            </div>
        );
    };

    const DeveloperWebhooksTab: React.FC = () => {
        const [subscriptions, setSubscriptions] = useState<WebhookSubscription[]>([]);
        const [webhookLoading, setWebhookLoading] = useState(true);
        const [isSubscribeModalOpen, setIsSubscribeModalOpen] = useState(false);
        const [viewLogsModalOpen, setViewLogsModalOpen] = useState(false);
        const [selectedSubscriptionForLogs, setSelectedSubscriptionForLogs] = useState<WebhookSubscription | null>(null);
        const toast = useToast();

        const fetchWebhooks = useCallback(async () => {
            setWebhookLoading(true);
            try {
                const data = await API.webhooks.getSubscriptionsByDeveloperId(currentDeveloperId);
                setSubscriptions(data);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to load webhook subscriptions.' });
                console.error(err);
            } finally {
                setWebhookLoading(false);
            }
        }, [currentDeveloperId, toast]);

        useEffect(() => {
            fetchWebhooks();
        }, [fetchWebhooks]);

        const handleSubscribe = async (callbackUrl: string, events: WebhookEvent[], integrationId?: string) => {
            setWebhookLoading(true);
            try {
                await API.webhooks.subscribe(currentDeveloperId, callbackUrl, events, integrationId);
                toast.addToast({ type: 'success', message: 'Webhook subscription created!' });
                fetchWebhooks();
                setIsSubscribeModalOpen(false);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to create webhook subscription.' });
                console.error(err);
            } finally {
                setWebhookLoading(false);
            }
        };

        const handleToggleSubscriptionStatus = async (sub: WebhookSubscription) => {
            setWebhookLoading(true);
            try {
                await API.webhooks.updateSubscription(sub.id, { isActive: !sub.isActive });
                toast.addToast({ type: 'success', message: `Webhook subscription ${sub.isActive ? 'deactivated' : 'activated'}!` });
                fetchWebhooks();
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to update subscription status.' });
                console.error(err);
            } finally {
                setWebhookLoading(false);
            }
        };

        const handleViewLogs = (subscription: WebhookSubscription) => {
            setSelectedSubscriptionForLogs(subscription);
            setViewLogsModalOpen(true);
        };

        const WebhookSubscribeModal: React.FC<{ isOpen: boolean; onClose: () => void; onSubscribe: (callbackUrl: string, events: WebhookEvent[], integrationId?: string) => Promise<void>; isLoading: boolean; }> = ({ isOpen, onClose, onSubscribe, isLoading }) => {
            const [callbackUrl, setCallbackUrl] = useState('');
            const [selectedEvents, setSelectedEvents] = useState<WebhookEvent[]>([]);
            const [integrationId, setIntegrationId] = useState(''); // Optional

            const [allEvents, setAllEvents] = useState<WebhookEvent[]>([]);
            const [allIntegrations, setAllIntegrations] = useState<Integration[]>([]);

            useEffect(() => {
                const fetchOptions = async () => {
                    const events = await API.webhooks.getEvents();
                    setAllEvents(events);
                    const { data: devIntegrations } = await API.integrations.getAll({ developerId: currentDeveloperId }, { page: 1, limit: 999 });
                    setAllIntegrations(devIntegrations);
                };
                if (isOpen) {
                    fetchOptions();
                }
            }, [isOpen]);

            const handleSubmit = async (e: React.FormEvent) => {
                e.preventDefault();
                await onSubscribe(callbackUrl, selectedEvents, integrationId || undefined);
            };

            return (
                <Modal isOpen={isOpen} onClose={onClose} title="Subscribe to Webhook" size="md">
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="callbackUrl" className="block text-gray-300 text-sm font-medium mb-1">Callback URL</label>
                            <input type="url" id="callbackUrl" value={callbackUrl} onChange={e => setCallbackUrl(e.target.value)} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600" placeholder="https://your-app.com/webhook-endpoint" />
                        </div>
                        <div>
                            <label htmlFor="events" className="block text-gray-300 text-sm font-medium mb-1">Events (Ctrl/Cmd click for multiple)</label>
                            <select multiple id="events" value={selectedEvents} onChange={e => {
                                const options = e.target.options;
                                const value: WebhookEvent[] = [];
                                for (let i = 0, l = options.length; i < l; i++) {
                                    if (options[i].selected) {
                                        value.push(options[i].value as WebhookEvent);
                                    }
                                }
                                setSelectedEvents(value);
                            }} required className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 h-32">
                                {allEvents.map(event => <option key={event} value={event}>{event}</option>)}
                            </select>
                        </div>
                        <div>
                            <label htmlFor="integrationId" className="block text-gray-300 text-sm font-medium mb-1">Specific Integration (Optional)</label>
                            <select id="integrationId" value={integrationId} onChange={e => setIntegrationId(e.target.value)} className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600">
                                <option value="">None (Global)</option>
                                {allIntegrations.map(integration => <option key={integration.id} value={integration.id}>{integration.name}</option>)}
                            </select>
                        </div>
                        <div className="flex justify-end space-x-2 pt-4">
                            <button type="button" onClick={onClose} disabled={isLoading} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Cancel</button>
                            <button type="submit" disabled={isLoading} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium">
                                {isLoading ? 'Subscribing...' : 'Create Subscription'}
                            </button>
                        </div>
                    </form>
                </Modal>
            );
        };

        const WebhookLogsModal: React.FC<{ isOpen: boolean; onClose: () => void; subscription: WebhookSubscription | null; isLoading: boolean; }> = ({ isOpen, onClose, subscription, isLoading }) => {
            const [logs, setLogs] = useState<WebhookLog[]>([]);
            const [logsLoading, setLogsLoading] = useState(true);
            const [logsCurrentPage, setLogsCurrentPage] = useState(1);
            const [logsPageSize, setLogsPageSize] = useState(5);
            const [logsTotal, setLogsTotal] = useState(0);
            const toast = useToast();

            const fetchLogs = useCallback(async () => {
                if (!subscription) return;
                setLogsLoading(true);
                try {
                    const { data, total } = await API.webhooks.getLogsBySubscriptionId(subscription.id, { page: logsCurrentPage, limit: logsPageSize });
                    setLogs(data);
                    setLogsTotal(total);
                } catch (err) {
                    toast.addToast({ type: 'error', message: 'Failed to load webhook logs.' });
                    console.error(err);
                } finally {
                    setLogsLoading(false);
                }
            }, [subscription, logsCurrentPage, logsPageSize, toast]);

            useEffect(() => {
                if (isOpen && subscription) {
                    fetchLogs();
                }
            }, [isOpen, subscription, fetchLogs]);

            if (!subscription) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title={`Webhook Logs for ${subscription.callbackUrl}`} size="xl">
                    <p className="text-gray-400 text-sm mb-4">Secret: <span className="font-mono text-white">{subscription.secret}</span></p>
                    {logsLoading ? (
                        <div className="text-gray-400 text-center py-8">Loading logs...</div>
                    ) : logs.length === 0 ? (
                        <div className="text-gray-400 text-center py-8">No logs found for this subscription.</div>
                    ) : (
                        <div className="space-y-4">
                            {logs.map(log => (
                                <div key={log.id} className="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                                    <div className="flex justify-between items-center mb-1">
                                        <span className="font-semibold text-white">{log.eventType}</span>
                                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${log.isSuccess ? 'bg-green-600/20 text-green-400' : 'bg-red-600/20 text-red-400'}`}>
                                            {log.isSuccess ? 'Success' : 'Failed'} ({log.statusCode})
                                        </span>
                                    </div>
                                    <p className="text-xs text-gray-400 mb-2">Attempted At: {formatDate(log.attemptedAt)}</p>
                                    {log.error && <p className="text-sm text-red-300 mb-2">Error: {log.error}</p>}
                                    <h5 className="text-sm font-medium text-gray-200">Payload:</h5>
                                    <pre className="bg-gray-800 p-2 rounded text-xs text-gray-300 overflow-x-auto custom-scrollbar">
                                        {JSON.stringify(JSON.parse(log.payload), null, 2)}
                                    </pre>
                                    <h5 className="text-sm font-medium text-gray-200 mt-2">Response:</h5>
                                    <pre className="bg-gray-800 p-2 rounded text-xs text-gray-300 overflow-x-auto custom-scrollbar">
                                        {log.responseBody}
                                    </pre>
                                </div>
                            ))}
                            <PaginationControls
                                currentPage={logsCurrentPage}
                                totalPages={Math.ceil(logsTotal / logsPageSize)}
                                onPageChange={setLogsCurrentPage}
                                pageSize={logsPageSize}
                                onPageSizeChange={setLogsPageSize}
                                totalItems={logsTotal}
                            />
                        </div>
                    )}
                </Modal>
            );
        };


        return (
            <div>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-semibold text-white">Your Webhook Subscriptions</h3>
                    <button onClick={() => setIsSubscribeModalOpen(true)} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium">Add New Webhook</button>
                </div>

                {webhookLoading ? (
                    <div className="text-gray-400 text-center py-8">Loading webhook subscriptions...</div>
                ) : subscriptions.length === 0 ? (
                    <div className="text-gray-400 text-center py-8">No webhook subscriptions found.</div>
                ) : (
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-700">
                            <thead className="bg-gray-700">
                                <tr>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Callback URL</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Events</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Last Triggered</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="bg-gray-800 divide-y divide-gray-700">
                                {subscriptions.map(sub => (
                                    <tr key={sub.id} className="hover:bg-gray-700">
                                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white truncate max-w-[200px]">{sub.callbackUrl}</td>
                                        <td className="px-6 py-4 text-sm text-gray-300">
                                            <ul className="list-disc list-inside text-xs space-y-1">
                                                {sub.events.map((e, i) => <li key={i}>{e}</li>)}
                                            </ul>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                                sub.isActive ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100' :
                                                'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100'
                                            }`}>{sub.isActive ? 'Active' : 'Inactive'}</span>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{sub.lastTriggeredAt ? formatDate(sub.lastTriggeredAt) : 'N/A'}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium flex space-x-2">
                                            <button onClick={() => handleViewLogs(sub)} className="text-cyan-500 hover:text-cyan-400 text-sm font-medium">View Logs</button>
                                            <button onClick={() => handleToggleSubscriptionStatus(sub)} className={`${sub.isActive ? 'text-yellow-500 hover:text-yellow-400' : 'text-green-500 hover:text-green-400'} text-sm font-medium`}>{sub.isActive ? 'Deactivate' : 'Activate'}</button>
                                            <button onClick={() => toast.addToast({ type: 'info', message: 'Subscription deletion not implemented for mock API' })} className="text-red-500 hover:text-red-400 text-sm font-medium">Delete</button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
                <WebhookSubscribeModal isOpen={isSubscribeModalOpen} onClose={() => setIsSubscribeModalOpen(false)} onSubscribe={handleSubscribe} isLoading={webhookLoading} />
                <WebhookLogsModal isOpen={viewLogsModalOpen} onClose={() => setViewLogsModalOpen(false)} subscription={selectedSubscriptionForLogs} isLoading={webhookLoading} />
            </div>
        );
    };


    const developerTabs = [
        { id: 'integrations', label: 'My Integrations', content: <DeveloperIntegrationsTab /> },
        { id: 'api-keys', label: 'API Keys', content: <DeveloperAPIKeysTab /> },
        { id: 'webhooks', label: 'Webhooks', content: <DeveloperWebhooksTab /> },
    ];

    return (
        <Card title="Developer Dashboard">
            <div className="flex justify-between items-center mb-6">
                <h2 className="text-2xl font-bold text-white">{developer.name}</h2>
                <p className="text-gray-400 text-sm">Member Since: {formatDate(developer.memberSince)}</p>
            </div>
            <Tabs tabs={developerTabs} activeTab={activeTab} onTabChange={setActiveTab} />
        </Card>
    );
};

export const AICodeAssistantSection: React.FC = () => {
    const [prompt, setPrompt] = useState('');
    const [generatedSnippet, setGeneratedSnippet] = useState<AICodeSnippet | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const toast = useToast();

    const handleGenerateSnippet = async () => {
        setIsLoading(true);
        setGeneratedSnippet(null);
        try {
            const snippet = await API.ai.generateCodeSnippet(prompt);
            setGeneratedSnippet(snippet);
            toast.addToast({ type: 'success', message: 'Code snippet generated successfully!' });
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to generate code snippet.' });
            console.error(err);
        } finally {
            setIsLoading(false);
        }
    };

    const handleCopyToClipboard = (text: string) => {
        navigator.clipboard.writeText(text);
        toast.addToast({ type: 'info', message: 'Code copied to clipboard!' });
    };

    return (
        <Card title="AI Code Assistant">
            <p className="text-gray-400 mb-4">
                Leverage AI to generate code snippets and templates for interacting with Demo Bank APIs. Describe what you want to achieve, and the AI will provide relevant code.
            </p>
            <div className="space-y-4">
                <div>
                    <label htmlFor="aiPrompt" className="block text-gray-300 text-sm font-medium mb-1">Describe what you need</label>
                    <textarea
                        id="aiPrompt"
                        rows={3}
                        value={prompt}
                        onChange={(e) => setPrompt(e.target.value)}
                        placeholder="e.g., Python code to fetch all active customers and their balances"
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 resize-y"
                        disabled={isLoading}
                    ></textarea>
                </div>
                <button
                    onClick={handleGenerateSnippet}
                    disabled={isLoading || !prompt.trim()}
                    className="w-full py-2 bg-cyan-600 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-cyan-700 transition-colors duration-200"
                >
                    {isLoading ? (
                        <span className="flex items-center justify-center">
                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Generating Code...
                        </span>
                    ) : 'Generate Code Snippet'}
                </button>

                {generatedSnippet && (
                    <div className="mt-6 bg-gray-900/40 p-4 rounded-lg border border-gray-700">
                        <div className="flex justify-between items-center mb-3">
                            <div>
                                <h4 className="text-lg font-semibold text-white">{generatedSnippet.name}</h4>
                                <p className="text-sm text-gray-400">Language: {generatedSnippet.language.toUpperCase()}</p>
                            </div>
                            <button onClick={() => handleCopyToClipboard(generatedSnippet.code)} className="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded-lg text-sm flex items-center">
                                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                                Copy
                            </button>
                        </div>
                        <p className="text-sm text-gray-300 mb-3">{generatedSnippet.description}</p>
                        <pre className="bg-gray-800 p-3 rounded-md text-xs text-gray-300 overflow-x-auto custom-scrollbar language-javascript">
                            <code>{generatedSnippet.code}</code>
                        </pre>
                        {generatedSnippet.apiEndpointsUsed.length > 0 && (
                            <div className="mt-3">
                                <p className="text-xs text-gray-500">API Endpoints: {generatedSnippet.apiEndpointsUsed.join(', ')}</p>
                            </div>
                        )}
                    </div>
                )}
            </div>
        </Card>
    );
};

export const AISetupGuideSection: React.FC<{ integrationId: string }> = ({ integrationId }) => {
    const [steps, setSteps] = useState<AISetupStep[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const toast = useToast();

    useEffect(() => {
        const fetchSteps = async () => {
            setIsLoading(true);
            try {
                const fetchedSteps = await API.ai.generateSetupGuideSteps(integrationId);
                setSteps(fetchedSteps);
            } catch (err) {
                toast.addToast({ type: 'error', message: 'Failed to generate AI setup guide steps.' });
                console.error(err);
            } finally {
                setIsLoading(false);
            }
        };
        fetchSteps();
    }, [integrationId, toast]);

    if (isLoading) {
        return <div className="text-gray-400 text-center py-4">Generating AI-powered setup guide...</div>;
    }

    if (steps.length === 0) {
        return <div className="text-gray-400 text-center py-4">No AI-generated setup steps available for this integration.</div>;
    }

    return (
        <ol className="list-decimal list-inside space-y-6 text-gray-300">
            {steps.map(step => (
                <li key={step.order} className="bg-gray-700/50 p-4 rounded-lg border border-gray-600">
                    <h4 className="text-lg font-semibold text-white mb-2">Step {step.order}: {step.title}</h4>
                    <p className="text-sm mb-3">{step.description}</p>
                    {step.codeSnippet && (
                        <div className="mt-2">
                            <h5 className="text-sm font-medium text-gray-200">Example Code:</h5>
                            <pre className="bg-gray-800 p-2 rounded text-xs text-gray-300 overflow-x-auto custom-scrollbar">
                                <code>{step.codeSnippet}</code>
                            </pre>
                        </div>
                    )}
                    {step.expectedResult && (
                        <div className="mt-2 text-xs text-gray-400">
                            <strong>Expected Result:</strong> {step.expectedResult}
                        </div>
                    )}
                </li>
            ))}
        </ol>
    );
};

// endregion

const IntegrationsMarketplaceView: React.FC = () => {
    // This userId would typically come from an authentication context
    const MOCK_CURRENT_USER_ID = 'user-abc-123';
    const MOCK_CURRENT_DEV_ID = mockDevelopers.length > 0 ? mockDevelopers[0].id : generateUUID(); // First mock developer
    const [activeTab, setActiveTab] = useState('discover'); // 'discover', 'installed', 'developer', 'ai-assistant'
    const [installedIntegrations, setInstalledIntegrations] = useState<IntegrationInstance[]>([]);
    const [loadingInstalled, setLoadingInstalled] = useState(true);
    const toast = useToast();

    const fetchInstalledIntegrations = useCallback(async () => {
        setLoadingInstalled(true);
        try {
            const data = await API.instances.getByUserId(MOCK_CURRENT_USER_ID);
            setInstalledIntegrations(data);
        } catch (err) {
            toast.addToast({ type: 'error', message: 'Failed to load your installed integrations.' });
            console.error(err);
        } finally {
            setLoadingInstalled(false);
        }
    }, [toast]);

    useEffect(() => {
        fetchInstalledIntegrations();
    }, [fetchInstalledIntegrations]);

    const handleIntegrationInstallSuccess = (instance: IntegrationInstance) => {
        // Add the new instance to the installed list
        setInstalledIntegrations(prev => [...prev, instance]);
    };

    const handleInstalledIntegrationsUpdate = () => {
        fetchInstalledIntegrations(); // Re-fetch all installed integrations
    };


    const renderContent = () => {
        switch (activeTab) {
            case 'discover':
                return <MarketplaceDiscoverSection userId={MOCK_CURRENT_USER_ID} installedIntegrations={installedIntegrations} onInstallSuccess={handleIntegrationInstallSuccess} />;
            case 'installed':
                return <InstalledIntegrationsSection userId={MOCK_CURRENT_USER_ID} installedIntegrations={installedIntegrations} onInstanceUpdate={handleInstalledIntegrationsUpdate} />;
            case 'developer':
                return <DeveloperDashboardSection currentDeveloperId={MOCK_CURRENT_DEV_ID} onDeveloperUpdate={() => {}} />;
            case 'ai-assistant':
                return <AICodeAssistantSection />;
            default:
                return null;
        }
    };

    return (
        <ToastProvider>
            <div className="space-y-6">
                <div className="flex justify-between items-center flex-wrap gap-4">
                    <h2 className="text-3xl font-bold text-white tracking-wider">Integrations Marketplace</h2>
                    <div className="flex space-x-3">
                        {/* Additional global actions could go here */}
                        <button onClick={() => toast.addToast({ type: 'info', message: 'Notifications coming soon!' })} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg text-sm font-medium">Notifications</button>
                    </div>
                </div>

                <div className="border-b border-gray-700 mb-6">
                    <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                        <button
                            onClick={() => setActiveTab('discover')}
                            className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200 ${activeTab === 'discover' ? 'border-cyan-500 text-cyan-400' : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`}
                        >
                            Discover
                        </button>
                        <button
                            onClick={() => setActiveTab('installed')}
                            className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200 ${activeTab === 'installed' ? 'border-cyan-500 text-cyan-400' : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`}
                        >
                            My Integrations ({loadingInstalled ? '...' : installedIntegrations.length})
                        </button>
                        <button
                            onClick={() => setActiveTab('developer')}
                            className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200 ${activeTab === 'developer' ? 'border-cyan-500 text-cyan-400' : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`}
                        >
                            Developer Console
                        </button>
                        <button
                            onClick={() => setActiveTab('ai-assistant')}
                            className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200 ${activeTab === 'ai-assistant' ? 'border-cyan-500 text-cyan-400' : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`}
                        >
                            AI Code Assistant
                        </button>
                    </nav>
                </div>

                {renderContent()}
            </div>
        </ToastProvider>
    );
};

export default IntegrationsMarketplaceView;
```