
--- FILE: ApiKeysView.tsx ---

import React, { useState, useMemo, useEffect, useCallback } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";
import { BarChart, Bar, LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
import { MOCK_API_KEY_USAGE } from '../../../../data/megadashboard';

// --- New Types and Interfaces ---

/**
 * @interface ApiKey
 * @augments {id, name, key, createdAt} - Existing properties.
 * @property {string} [description] - A detailed description for the API key.
 * @property {string} environmentId - The ID of the environment (e.g., Development, Production) this key belongs to.
 * @property {string[]} assignedPolicies - A list of policy IDs applied to this key.
 * @property {string[]} scopes - A list of specific permissions (scopes) granted to this key.
 * @property {string[]} allowedIps - A list of IP addresses or CIDR blocks allowed to use this key.
 * @property {string} [expiresAt] - ISO string date when the key expires.
 * @property {'active' | 'revoked' | 'expired' | 'paused'} status - Current status of the API key.
 * @property {string} [lastUsedAt] - ISO string date of the last successful use.
 * @property {string} createdBy - The user ID or system that created the key.
 */
interface ApiKey {
    id: string;
    name: string;
    key: string;
    createdAt: string; // ISO string
    description?: string;
    environmentId?: string;
    assignedPolicies?: string[];
    scopes?: string[];
    allowedIps?: string[];
    expiresAt?: string; // ISO string
    status?: 'active' | 'revoked' | 'expired' | 'paused';
    lastUsedAt?: string; // ISO string
    createdBy?: string;
}

/**
 * @interface ApiKeyPolicy
 * Represents a set of rules and constraints that can be applied to one or more API keys.
 */
export interface ApiKeyPolicy {
    id: string;
    name: string;
    description: string;
    rules: {
        maxRequestsPerMin?: number;
        allowedIps?: string[];
        expiresAfterDays?: number;
        requiredScopes?: string[];
        rateLimitBurst?: number; // New rule: burst requests allowed
    }[];
    createdAt: string; // ISO string
    lastUpdated: string; // ISO string
    status: 'active' | 'inactive';
}

/**
 * @interface ApiKeyEnvironment
 * Defines a logical environment for API keys (e.g., Development, Staging, Production).
 */
export interface ApiKeyEnvironment {
    id: string;
    name: string; // e.g., "Development", "Staging", "Production"
    description: string;
    defaultPolicies: string[]; // IDs of default policies for this environment
}

/**
 * @interface ApiKeyUsageLog
 * Detailed log entry for each API call made using a specific API key.
 */
export interface ApiKeyUsageLog {
    id: string;
    apiKeyId: string;
    timestamp: string; // ISO string
    endpoint: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    status: number;
    latencyMs: number;
    dataSizeKb: number;
    userAgent: string;
    ipAddress: string;
    requestId: string;
    region: string; // New: geographic region of the request
}

/**
 * @interface Webhook
 * Configuration for a webhook endpoint to receive notifications about key events.
 */
export interface Webhook {
    id: string;
    name: string;
    url: string;
    events: ('key.created' | 'key.revoked' | 'key.expired' | 'usage.threshold_exceeded' | 'policy.violation')[];
    secret: string; // Secret for signing webhook payloads
    isActive: boolean;
    createdAt: string; // ISO string
    lastTriggeredAt?: string; // ISO string
}

/**
 * @interface AuditEvent
 * Records significant actions or changes within the API key management system.
 */
export interface AuditEvent {
    id: string;
    timestamp: string; // ISO string
    actor: string; // User ID or system responsible for the action
    action: string; // e.g., 'API_KEY_CREATED', 'API_KEY_REVOKED', 'POLICY_UPDATED'
    targetId: string; // ID of the affected resource (API key, policy, webhook)
    targetType: 'API_KEY' | 'POLICY' | 'WEBHOOK' | 'ENVIRONMENT' | 'SYSTEM';
    details: Record<string, any>; // JSON object with additional context (e.g., old/new values)
}

/**
 * @interface ServiceHealthMetric
 * Represents a health metric for an external service dependency.
 */
export interface ServiceHealthMetric {
    serviceName: string;
    status: 'operational' | 'degraded' | 'major_outage';
    lastChecked: string;
    message: string;
    latency?: number; // ms
}

/**
 * @interface UserAccessControl
 * Defines permissions for a specific user or role within the API key management.
 */
export interface UserAccessControl {
    userId: string;
    canViewAllKeys: boolean;
    canCreateKeys: boolean;
    canRevokeOwnKeys: boolean;
    canRevokeAllKeys: boolean;
    canEditOwnKeys: boolean;
    canEditAllKeys: boolean;
    canManagePolicies: boolean;
    canManageWebhooks: boolean;
    canViewAuditLogs: boolean;
    canAccessAiSuite: boolean;
}

// --- Utility Functions ---

/**
 * Generates a unique ID with an optional prefix.
 * @param {string} [prefix='id'] - The prefix for the ID.
 * @returns {string} A unique ID string.
 */
export const generateId = (prefix: string = 'id'): string => `${prefix}_${Math.random().toString(36).substr(2, 9)}`;

/**
 * Formats an ISO date string into a human-readable local date and time string.
 * @param {string} isoString - The ISO date string to format.
 * @returns {string} Formatted date and time string.
 */
export const formatTimestamp = (isoString: string): string => new Date(isoString).toLocaleString();

/**
 * Retrieves an environment variable by key, with a warning if not set.
 * @param {string} key - The environment variable key.
 * @returns {string} The value of the environment variable, or an empty string if not found.
 */
export const getEnvVariable = (key: string): string => {
    const value = process.env[key] || process.env[`NEXT_PUBLIC_${key}`]; // Support NEXT_PUBLIC for client-side
    if (!value) {
        console.warn(`Environment variable ${key} is not set.`);
        return '';
    }
    return value;
};

/**
 * Generates a cryptographically secure random string suitable for API keys or secrets.
 * @param {number} length - The desired length of the string.
 * @returns {string} A random string.
 */
export const generateSecureRandomString = (length: number): string => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    const randomBytes = new Uint8Array(length);
    if (typeof window !== 'undefined' && window.crypto) { // Use Web Crypto API in browser
        window.crypto.getRandomValues(randomBytes);
    } else { // Fallback for Node.js environments (simplified, should use 'crypto' module)
        for (let i = 0; i < length; i++) randomBytes[i] = Math.floor(Math.random() * 256);
    }
    for (let i = 0; i < length; i++) {
        result += chars[randomBytes[i] % chars.length];
    }
    return result;
};

// --- Mock Data Generators (Extensive for 10,000 lines) ---

/**
 * Generates a mock API key.
 * @param {number} index - Index for unique naming and variations.
 * @param {string[]} policyIds - Available policy IDs to assign.
 * @param {string[]} environmentIds - Available environment IDs.
 * @param {string[]} scopes - All available scopes.
 * @returns {ApiKey} A mock API key.
 */
const generateMockApiKey = (index: number, policyIds: string[], environmentIds: string[], scopes: string[]): ApiKey => {
    const isLive = index % 3 === 0;
    const keyType = isLive ? 'live' : 'test';
    const envId = environmentIds[Math.floor(Math.random() * environmentIds.length)];
    const numPolicies = Math.floor(Math.random() * 3); // 0 to 2 policies
    const assignedPolicies = policyIds.sort(() => 0.5 - Math.random()).slice(0, numPolicies);
    const numScopes = Math.floor(Math.random() * (scopes.length / 2)) + 1; // 1 to half total scopes
    const assignedScopes = scopes.sort(() => 0.5 - Math.random()).slice(0, numScopes);
    const hasExpiry = Math.random() < 0.6;
    const expiresAt = hasExpiry ? new Date(Date.now() + Math.floor(Math.random() * 365) * 24 * 60 * 60 * 1000).toISOString() : undefined;
    const keyStatus = Math.random() < 0.05 ? 'revoked' : (expiresAt && new Date(expiresAt) < new Date() ? 'expired' : 'active');
    const hasLastUsed = Math.random() < 0.9;
    const lastUsedAt = hasLastUsed ? new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000).toISOString() : undefined;
    const hasIps = Math.random() < 0.4;
    const allowedIps = hasIps ? Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}/32`) : [];

    return {
        id: generateId('key'),
        name: `Key ${index} - ${isLive ? 'Prod' : 'Dev'} Access`,
        key: `db_sk_${keyType}_${generateSecureRandomString(24)}`,
        createdAt: new Date(Date.now() - Math.floor(Math.random() * 365 * 24 * 60 * 60 * 1000)).toISOString(),
        description: `API key for ${isLive ? 'production' : 'development'} system ${index}.`,
        environmentId: envId,
        assignedPolicies: assignedPolicies,
        scopes: assignedScopes,
        allowedIps: allowedIps,
        expiresAt: expiresAt,
        status: keyStatus,
        lastUsedAt: lastUsedAt,
        createdBy: `user_${Math.floor(Math.random() * 50) + 1}`,
    };
};

export const generateMockApiKeys = (count: number, policyIds: string[], environmentIds: string[], scopes: string[]): ApiKey[] => {
    return Array.from({ length: count }, (_, i) => generateMockApiKey(i + 1, policyIds, environmentIds, scopes));
};

/**
 * Generates mock API usage logs for a given API key.
 * @param {string} apiKeyId - The ID of the API key.
 * @param {number} days - Number of days to generate logs for.
 * @param {number} minRequests - Minimum requests per day.
 * @param {number} maxRequests - Maximum requests per day.
 * @returns {ApiKeyUsageLog[]} An array of mock usage logs.
 */
export const generateMockUsageLogs = (apiKeyId: string, days: number = 7, minRequests: number = 50, maxRequests: number = 200): ApiKeyUsageLog[] => {
    const logs: ApiKeyUsageLog[] = [];
    const now = new Date();
    const endpoints = ['/transactions', '/users', '/payments', '/reports', '/events', '/products', '/integrations'];
    const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];
    const userAgents = ['Mozilla/5.0 (Node.js)', 'Java/11 HttpClient', 'Go-http-client/1.1', 'Python/requests', 'PostmanRuntime/7.29.0'];
    const regions = ['us-east-1', 'us-west-2', 'eu-central-1', 'ap-southeast-1'];

    for (let d = 0; d < days; d++) {
        const dayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - d);
        const numRequests = Math.floor(Math.random() * (maxRequests - minRequests + 1)) + minRequests;
        for (let i = 0; i < numRequests; i++) {
            const timestamp = new Date(dayStart.getTime() + Math.random() * 24 * 60 * 60 * 1000).toISOString();
            const status = Math.random() < 0.15 ? (Math.random() < 0.6 ? 400 + Math.floor(Math.random() * 10) : 500 + Math.floor(Math.random() * 5)) : 200;
            const latencyMs = Math.floor(Math.random() * 500) + 20;
            const dataSizeKb = Math.floor(Math.random() * 1000) / 10;
            logs.push({
                id: generateId('log'),
                apiKeyId,
                timestamp,
                endpoint: endpoints[Math.floor(Math.random() * endpoints.length)],
                method: methods[Math.floor(Math.random() * methods.length)] as any,
                status,
                latencyMs,
                dataSizeKb,
                userAgent: userAgents[Math.floor(Math.random() * userAgents.length)],
                ipAddress: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                requestId: generateId('req'),
                region: regions[Math.floor(Math.random() * regions.length)],
            });
        }
    }
    return logs;
};

/**
 * Generates mock API key policies.
 * @param {number} count - Number of policies to generate.
 * @returns {ApiKeyPolicy[]} An array of mock policies.
 */
export const generateMockPolicies = (count: number = 5): ApiKeyPolicy[] => {
    const policies: ApiKeyPolicy[] = [];
    for (let i = 0; i < count; i++) {
        const status = i % 2 === 0 ? 'active' : 'inactive';
        const rules = [{
            maxRequestsPerMin: 100 + i * 50,
            allowedIps: i % 2 === 0 ? [] : [`192.168.1.${i}`, `10.0.0.${i + 1}`],
            expiresAfterDays: i % 3 === 0 ? 90 : undefined,
            requiredScopes: i % 2 === 0 ? ['read:transactions', 'read:users'] : ['read:transactions', 'write:transactions', 'read:users', 'write:payments'],
            rateLimitBurst: 20 + i * 5,
        }];
        policies.push({
            id: generateId('policy'),
            name: `Policy ${i + 1} - ${status === 'active' ? 'Standard' : 'Restricted'}`,
            description: `A sample policy for various API key constraints. This policy is ${status}.`,
            rules: rules,
            createdAt: new Date(Date.now() - Math.floor(Math.random() * 365 * 24 * 60 * 60 * 1000)).toISOString(),
            lastUpdated: new Date().toISOString(),
            status: status,
        });
    }
    return policies;
};

/**
 * Generates mock API key environments.
 * @param {string[]} policyIds - Available policy IDs to set as defaults.
 * @returns {ApiKeyEnvironment[]} An array of mock environments.
 */
export const generateMockEnvironments = (policyIds: string[]): ApiKeyEnvironment[] => {
    return [
        { id: 'env_dev', name: 'Development', description: 'Keys for development environments', defaultPolicies: [policyIds[0]] },
        { id: 'env_stag', name: 'Staging', description: 'Keys for staging/testing environments', defaultPolicies: [policyIds[1]] },
        { id: 'env_prod', name: 'Production', description: 'Keys for live production systems', defaultPolicies: [policyIds[2], policyIds[3]] },
    ];
};

/**
 * Generates mock webhooks.
 * @param {number} count - Number of webhooks to generate.
 * @returns {Webhook[]} An array of mock webhooks.
 */
export const generateMockWebhooks = (count: number = 3): Webhook[] => {
    const webhooks: Webhook[] = [];
    const eventsOptions: Webhook['events'][] = [
        ['key.created', 'key.revoked'],
        ['usage.threshold_exceeded', 'policy.violation'],
        ['key.expired', 'usage.threshold_exceeded', 'key.created']
    ];
    for (let i = 0; i < count; i++) {
        webhooks.push({
            id: generateId('wh'),
            name: `Webhook ${i + 1}`,
            url: `https://example.com/webhook-endpoint/${generateSecureRandomString(12)}`,
            events: eventsOptions[i % eventsOptions.length],
            secret: generateSecureRandomString(32),
            isActive: i % 2 === 0,
            createdAt: new Date(Date.now() - Math.floor(Math.random() * 30 * 24 * 60 * 60 * 1000)).toISOString(),
            lastTriggeredAt: i % 3 === 0 ? new Date(Date.now() - Math.floor(Math.random() * 7 * 24 * 60 * 60 * 1000)).toISOString() : undefined,
        });
    }
    return webhooks;
};

/**
 * Generates mock audit events.
 * @param {number} count - Number of audit events to generate.
 * @param {string} [targetKeyId] - Optional API key ID to filter events by.
 * @returns {AuditEvent[]} An array of mock audit events.
 */
export const generateMockAuditEvents = (count: number = 200, targetKeyId?: string): AuditEvent[] => {
    const events: AuditEvent[] = [];
    const actions = [
        'API_KEY_CREATED', 'API_KEY_REVOKED', 'API_KEY_UPDATED_STATUS', 'API_KEY_UPDATED_SCOPES',
        'POLICY_CREATED', 'POLICY_UPDATED', 'POLICY_DELETED', 'POLICY_APPLIED_TO_KEY',
        'WEBHOOK_CREATED', 'WEBHOOK_UPDATED', 'WEBHOOK_DELETED', 'WEBHOOK_TRIGGERED',
        'USAGE_THRESHOLD_ALERT', 'ANOMALY_DETECTED', 'SYSTEM_HEALTH_CHECK'
    ];
    const targetTypes: AuditEvent['targetType'][] = ['API_KEY', 'POLICY', 'WEBHOOK', 'ENVIRONMENT', 'SYSTEM'];

    for (let i = 0; i < count; i++) {
        const randomAction = actions[Math.floor(Math.random() * actions.length)];
        const randomTargetType = targetTypes[Math.floor(Math.random() * targetTypes.length)];
        const targetId = targetKeyId && randomTargetType === 'API_KEY' ? targetKeyId : generateId('target');
        const actor = `user_${Math.floor(Math.random() * 50) + 1}` + (Math.random() < 0.1 ? ' (System)' : '');
        const timestamp = new Date(Date.now() - Math.floor(Math.random() * 30 * 24 * 60 * 60 * 1000)).toISOString();

        let details: Record<string, any> = {
            ipAddress: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
            userAgent: `AuditClient/1.0`,
        };

        if (randomAction.includes('UPDATED')) {
            details.oldValue = randomAction.includes('STATUS') ? (Math.random() < 0.5 ? 'active' : 'paused') : ['read:users'];
            details.newValue = randomAction.includes('STATUS') ? (Math.random() < 0.5 ? 'paused' : 'active') : ['read:users', 'write:users'];
            details.reason = 'Manual update via dashboard';
        } else if (randomAction.includes('CREATED')) {
            details.createdBy = actor;
            details.initialConfig = { name: `Item ${generateSecureRandomString(5)}` };
        } else if (randomAction.includes('ALERT') || randomAction.includes('DETECTED')) {
            details.alertType = 'High Request Rate';
            details.threshold = 1000;
            details.currentValue = 1250;
        }

        events.push({
            id: generateId('audit'),
            timestamp,
            actor,
            action: randomAction,
            targetId,
            targetType: randomTargetType,
            details,
        });
    }
    return events;
};

/**
 * Generates mock service health metrics.
 * @returns {ServiceHealthMetric[]} An array of mock health metrics.
 */
export const generateMockServiceHealth = (): ServiceHealthMetric[] => {
    const services = ['Authentication Service', 'Payment Gateway', 'Data Storage', 'Analytics Engine', 'Email Service'];
    const statuses = ['operational', 'degraded', 'major_outage'];
    return services.map(service => ({
        serviceName: service,
        status: statuses[Math.floor(Math.random() * statuses.length)] as any,
        lastChecked: new Date().toISOString(),
        message: Math.random() < 0.2 ? 'Minor latency spikes detected.' : 'All systems normal.',
        latency: Math.random() < 0.5 ? Math.floor(Math.random() * 200) + 50 : undefined,
    }));
};

const ALL_AVAILABLE_SCOPES: string[] = [
    'read:transactions', 'write:transactions', 'delete:transactions',
    'read:users', 'write:users', 'delete:users',
    'read:payments', 'write:payments', 'process:payments', 'refund:payments',
    'read:reports', 'generate:reports', 'configure:reports',
    'read:events', 'write:events', 'delete:events',
    'manage:webhooks', 'read:policies', 'write:policies', 'delete:policies',
    'manage:environments', 'manage:rbac', 'monitor:health', 'audit:logs'
];

// Initial state for data
const MOCK_POLICIES_DATA: ApiKeyPolicy[] = generateMockPolicies(10);
const MOCK_POLICY_IDS: string[] = MOCK_POLICIES_DATA.map(p => p.id);
const MOCK_ENVIRONMENTS_DATA: ApiKeyEnvironment[] = generateMockEnvironments(MOCK_POLICY_IDS);
const MOCK_ENVIRONMENT_IDS: string[] = MOCK_ENVIRONMENTS_DATA.map(e => e.id);
const INITIAL_MOCK_API_KEYS: ApiKey[] = generateMockApiKeys(100, MOCK_POLICY_IDS, MOCK_ENVIRONMENT_IDS, ALL_AVAILABLE_SCOPES); // Starting with 100 keys
let ALL_MOCK_USAGE_LOGS: ApiKeyUsageLog[] = [];
INITIAL_MOCK_API_KEYS.forEach(key => {
    ALL_MOCK_USAGE_LOGS = ALL_MOCK_USAGE_LOGS.concat(generateMockUsageLogs(key.id, 90, 100, 500)); // 90 days of data, 100-500 requests per day
});
export const INITIAL_MOCK_POLICIES: ApiKeyPolicy[] = MOCK_POLICIES_DATA;
export const INITIAL_MOCK_ENVIRONMENTS: ApiKeyEnvironment[] = MOCK_ENVIRONMENTS_DATA;
export const INITIAL_MOCK_WEBHOOKS: Webhook[] = generateMockWebhooks(5);
export const INITIAL_MOCK_AUDIT_EVENTS: AuditEvent[] = generateMockAuditEvents(500); // Global audit events
export const INITIAL_SERVICE_HEALTH: ServiceHealthMetric[] = generateMockServiceHealth();

// --- Reusable UI Components ---

/**
 * Generic Modal component for displaying content in a dialog box.
 */
interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl';
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
    }[size];

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[100]" onClick={onClose}>
            <div className={`bg-gray-800 rounded-lg shadow-2xl ${sizeClasses} w-full m-4 border border-gray-700`} onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors duration-200">&times;</button>
                </div>
                <div className="p-6 text-sm overflow-y-auto max-h-[80vh]">
                    {children}
                </div>
            </div>
        </div>
    );
};

/**
 * Simple Tooltip component for displaying hover information.
 */
interface TooltipProps {
    children: React.ReactNode;
    content: string;
    position?: 'top' | 'bottom' | 'left' | 'right';
}

export const Tooltip: React.FC<TooltipProps> = ({ children, content, position = 'top' }) => {
    const [isVisible, setIsVisible] = useState(false);
    const positionClasses = {
        top: 'bottom-full mb-2 left-1/2 -translate-x-1/2',
        bottom: 'top-full mt-2 left-1/2 -translate-x-1/2',
        left: 'right-full mr-2 top-1/2 -translate-y-1/2',
        right: 'left-full ml-2 top-1/2 -translate-y-1/2',
    }[position];

    return (
        <div className="relative inline-block"
            onMouseEnter={() => setIsVisible(true)}
            onMouseLeave={() => setIsVisible(false)}
        >
            {children}
            {isVisible && (
                <div className={`absolute z-50 px-3 py-1 bg-gray-700 text-white text-xs rounded shadow-lg ${positionClasses} whitespace-nowrap opacity-90 transition-opacity duration-200`}>
                    {content}
                </div>
            )}
        </div>
    );
};

/**
 * Custom hook for managing form state, validation, and submission.
 */
interface UseFormOptions<T> {
    initialValues: T;
    onSubmit: (values: T) => Promise<void>;
    onSuccess?: () => void;
    onError?: (error: any) => void;
    validationSchema?: (values: T) => Partial<Record<keyof T, string>>;
}

export const useForm = <T extends Record<string, any>>({
    initialValues,
    onSubmit,
    onSuccess,
    onError,
    validationSchema,
}: UseFormOptions<T>) => {
    const [values, setValues] = useState<T>(initialValues);
    const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [submitSuccess, setSubmitSuccess] = useState<boolean | null>(null);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type } = e.target;
        const finalValue = type === 'checkbox' ? (e.target as HTMLInputElement).checked : value;
        setValues(prev => ({ ...prev, [name]: finalValue }));
        if (errors[name as keyof T]) {
            setErrors(prev => {
                const newErrors = { ...prev };
                delete newErrors[name as keyof T];
                return newErrors;
            });
        }
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setErrors({});
        setSubmitSuccess(null);

        let validationErrors: Partial<Record<keyof T, string>> = {};
        if (validationSchema) {
            validationErrors = validationSchema(values);
            if (Object.keys(validationErrors).length > 0) {
                setErrors(validationErrors);
                setSubmitSuccess(false);
                return;
            }
        }

        setIsSubmitting(true);
        try {
            await onSubmit(values);
            setSubmitSuccess(true);
            onSuccess && onSuccess();
        } catch (error) {
            setSubmitSuccess(false);
            onError && onError(error);
            console.error("Form submission error:", error);
        } finally {
            setIsSubmitting(false);
        }
    };

    const resetForm = useCallback(() => {
        setValues(initialValues);
        setErrors({});
        setSubmitSuccess(null);
    }, [initialValues]);

    return {
        values,
        setValues,
        handleChange,
        handleSubmit,
        errors,
        isSubmitting,
        submitSuccess,
        resetForm,
    };
};

/**
 * @interface CreateApiKeyFormData
 * Form data structure for creating a new API key.
 */
interface CreateApiKeyFormData {
    name: string;
    description: string;
    environmentId: string;
    assignedPolicies: string[];
    expiresAfterDays?: number | '';
    allowedIps: string; // comma-separated string
    scopes: string[];
    generateTestKey: boolean;
    createdBy: string;
}

const initialCreateKeyValues: CreateApiKeyFormData = {
    name: '',
    description: '',
    environmentId: '',
    assignedPolicies: [],
    allowedIps: '',
    scopes: [],
    generateTestKey: false,
    createdBy: 'dashboard_user', // Default creator
};

const createKeyValidationSchema = (values: CreateApiKeyFormData) => {
    const errors: Partial<Record<keyof CreateApiKeyFormData, string>> = {};
    if (!values.name) errors.name = 'Key name is required.';
    if (values.name.length < 3) errors.name = 'Key name must be at least 3 characters.';
    if (!values.environmentId) errors.environmentId = 'Environment is required.';
    if (values.expiresAfterDays !== undefined && values.expiresAfterDays !== '' && (isNaN(Number(values.expiresAfterDays)) || Number(values.expiresAfterDays) < 1)) {
        errors.expiresAfterDays = 'Expiry days must be a positive number.';
    }
    if (values.allowedIps) {
        const invalidIps = values.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean).filter(ip => !/^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/.test(ip));
        if (invalidIps.length > 0) errors.allowedIps = 'Invalid IP address or CIDR format found.';
    }
    if (values.scopes.length === 0) errors.scopes = 'At least one scope is required.';
    return errors;
};

interface CreateApiKeyFormProps {
    isOpen: boolean;
    onClose: () => void;
    onKeyCreated: (key: ApiKey) => void;
    availablePolicies: ApiKeyPolicy[];
    availableEnvironments: ApiKeyEnvironment[];
    allAvailableScopes: string[];
}

/**
 * Form component for creating new API keys with advanced options.
 */
export const CreateApiKeyForm: React.FC<CreateApiKeyFormProps> = ({ isOpen, onClose, onKeyCreated, availablePolicies, availableEnvironments, allAvailableScopes }) => {
    const { values, handleChange, handleSubmit, errors, isSubmitting, submitSuccess, setValues, resetForm } = useForm<CreateApiKeyFormData>({
        initialValues: initialCreateKeyValues,
        onSubmit: async (formData) => {
            await new Promise(res => setTimeout(res, 1500)); // Simulate API call
            const prefix = formData.generateTestKey ? 'db_sk_test' : 'db_sk_live';
            const expiresAt = formData.expiresAfterDays ? new Date(Date.now() + Number(formData.expiresAfterDays) * 24 * 60 * 60 * 1000).toISOString() : undefined;
            const newKey: ApiKey = {
                id: generateId('key'),
                name: formData.name,
                key: `${prefix}_${generateSecureRandomString(24)}`,
                createdAt: new Date().toISOString(),
                description: formData.description,
                environmentId: formData.environmentId,
                assignedPolicies: formData.assignedPolicies,
                scopes: formData.scopes,
                allowedIps: formData.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean),
                expiresAt: expiresAt,
                status: 'active',
                createdBy: formData.createdBy,
            };
            onKeyCreated(newKey);
            resetForm(); // Reset after successful submission
            onClose();
        },
        validationSchema: createKeyValidationSchema,
    });

    useEffect(() => {
        if (!isOpen) {
            resetForm();
        }
    }, [isOpen, resetForm]);

    const handleIpChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setValues(prev => ({ ...prev, allowedIps: e.target.value }));
    };

    const handleScopeChange = (scope: string, isChecked: boolean) => {
        setValues(prev => {
            const currentScopes = new Set(prev.scopes);
            if (isChecked) {
                currentScopes.add(scope);
            } else {
                currentScopes.delete(scope);
            }
            return { ...prev, scopes: Array.from(currentScopes) };
        });
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Create New API Key" size="lg">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="name" className="block text-sm font-medium text-gray-300">Key Name</label>
                    <input type="text" id="name" name="name" value={values.name} onChange={handleChange}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500" />
                    {errors.name && <p className="mt-1 text-xs text-red-400">{errors.name}</p>}
                </div>
                <div>
                    <label htmlFor="description" className="block text-sm font-medium text-gray-300">Description</label>
                    <textarea id="description" name="description" value={values.description} onChange={handleChange} rows={2}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
                </div>
                <div>
                    <label htmlFor="environmentId" className="block text-sm font-medium text-gray-300">Environment</label>
                    <select id="environmentId" name="environmentId" value={values.environmentId} onChange={handleChange}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500">
                        <option value="">Select an environment</option>
                        {availableEnvironments.map(env => (
                            <option key={env.id} value={env.id}>{env.name}</option>
                        ))}
                    </select>
                    {errors.environmentId && <p className="mt-1 text-xs text-red-400">{errors.environmentId}</p>}
                </div>
                <div>
                    <label htmlFor="assignedPolicies" className="block text-sm font-medium text-gray-300">Assigned Policies</label>
                    <div className="mt-1 grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded-md border border-gray-600">
                        {availablePolicies.map(policy => (
                            <label key={policy.id} className="inline-flex items-center text-white text-sm cursor-pointer">
                                <input
                                    type="checkbox"
                                    name="assignedPolicies"
                                    value={policy.id}
                                    checked={values.assignedPolicies.includes(policy.id)}
                                    onChange={(e) => {
                                        if (e.target.checked) {
                                            setValues(prev => ({ ...prev, assignedPolicies: [...prev.assignedPolicies, policy.id] }));
                                        } else {
                                            setValues(prev => ({ ...prev, assignedPolicies: prev.assignedPolicies.filter(id => id !== policy.id) }));
                                        }
                                    }}
                                    className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                                />
                                <span className="ml-2">{policy.name}</span>
                            </label>
                        ))}
                    </div>
                </div>
                <div>
                    <label htmlFor="scopes" className="block text-sm font-medium text-gray-300">API Scopes/Permissions</label>
                    <div className="mt-1 grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded-md border border-gray-600">
                        {allAvailableScopes.map(scope => (
                            <label key={scope} className="inline-flex items-center text-white text-sm cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={values.scopes.includes(scope)}
                                    onChange={(e) => handleScopeChange(scope, e.target.checked)}
                                    className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                                />
                                <span className="ml-2">{scope}</span>
                            </label>
                        ))}
                    </div>
                    {errors.scopes && <p className="mt-1 text-xs text-red-400">{errors.scopes}</p>}
                </div>
                <div>
                    <label htmlFor="expiresAfterDays" className="block text-sm font-medium text-gray-300">Expires After (Days)</label>
                    <input type="number" id="expiresAfterDays" name="expiresAfterDays" value={values.expiresAfterDays} onChange={handleChange}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                        min="1" placeholder="Optional" />
                    {errors.expiresAfterDays && <p className="mt-1 text-xs text-red-400">{errors.expiresAfterDays}</p>}
                </div>
                <div>
                    <label htmlFor="allowedIps" className="block text-sm font-medium text-gray-300">Allowed IP Addresses (comma-separated)</label>
                    <textarea id="allowedIps" name="allowedIps" value={values.allowedIps} onChange={handleIpChange} rows={2}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                        placeholder="e.g., 192.168.1.1, 10.0.0.0/24"></textarea>
                    {errors.allowedIps && <p className="mt-1 text-xs text-red-400">{errors.allowedIps}</p>}
                </div>
                <div className="flex items-center">
                    <input type="checkbox" id="generateTestKey" name="generateTestKey" checked={values.generateTestKey} onChange={handleChange}
                        className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded" />
                    <label htmlFor="generateTestKey" className="ml-2 block text-sm text-gray-300">Generate Test Key (vs. Live Key)</label>
                </div>
                <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 transition duration-200">Cancel</button>
                    <button type="submit" disabled={isSubmitting} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md text-sm font-medium text-white disabled:opacity-50 transition duration-200">
                        {isSubmitting ? 'Creating...' : 'Create API Key'}
                    </button>
                </div>
                {submitSuccess === true && <p className="mt-2 text-sm text-green-400">API Key created successfully!</p>}
                {submitSuccess === false && <p className="mt-2 text-sm text-red-400">Failed to create API Key. Please check your inputs.</p>}
            </form>
        </Modal>
    );
};

/**
 * StatusBadge component for displaying API key status with appropriate colors.
 */
const StatusBadge: React.FC<{ status: ApiKey['status'] }> = ({ status }) => {
    const colorClass = {
        'active': 'bg-green-600',
        'revoked': 'bg-red-600',
        'expired': 'bg-yellow-600',
        'paused': 'bg-blue-600',
    }[status || 'active'] || 'bg-gray-500';
    return <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colorClass} text-white`}>{status?.toUpperCase() || 'UNKNOWN'}</span>;
};

/**
 * Detailed modal view for a single API Key, showing its attributes, usage, settings, and audit log.
 */
interface ApiKeyDetailModalProps {
    apiKey: ApiKey;
    isOpen: boolean;
    onClose: () => void;
    onRevoke: (keyId: string) => void;
    onUpdateKey: (updatedKey: ApiKey) => void; // New prop for updating key
    keyUsageLogs: ApiKeyUsageLog[];
    availablePolicies: ApiKeyPolicy[];
    availableEnvironments: ApiKeyEnvironment[];
    allAvailableScopes: string[];
}

export const ApiKeyDetailModal: React.FC<ApiKeyDetailModalProps> = ({
    apiKey,
    isOpen,
    onClose,
    onRevoke,
    onUpdateKey,
    keyUsageLogs,
    availablePolicies,
    availableEnvironments,
    allAvailableScopes
}) => {
    const [activeTab, setActiveTab] = useState<'details' | 'usage' | 'settings' | 'audit'>('details');
    const [isRevokeConfirmOpen, setRevokeConfirmOpen] = useState(false);
    const [editMode, setEditMode] = useState(false);

    // Derive or mock additional key details consistently
    const extendedKeyDetails = useMemo(() => {
        const env = availableEnvironments.find(e => e.id === apiKey.environmentId) || availableEnvironments[0] || { id: 'unknown_env', name: 'Unknown', description: 'N/A', defaultPolicies: [] };
        const assignedPolicies = availablePolicies.filter(p => apiKey.assignedPolicies?.includes(p.id)) || [];
        const status = apiKey.status || (apiKey.expiresAt && new Date(apiKey.expiresAt) < new Date() ? 'expired' : 'active');
        const scopes = apiKey.scopes || [];
        const allowedIps = apiKey.allowedIps || [];

        return {
            env,
            assignedPolicies,
            status,
            scopes,
            allowedIps
        };
    }, [apiKey, availableEnvironments, availablePolicies]);

    // Form state for editing key settings
    const [editValues, setEditValues] = useState<{
        name: string;
        description: string;
        status: ApiKey['status'];
        expiresAfterDays?: number | '';
        allowedIps: string;
        scopes: string[];
        assignedPolicies: string[];
    }>({
        name: apiKey.name,
        description: apiKey.description || '',
        status: extendedKeyDetails.status,
        expiresAfterDays: apiKey.expiresAt ? Math.ceil((new Date(apiKey.expiresAt).getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : '',
        allowedIps: extendedKeyDetails.allowedIps.join(', '),
        scopes: extendedKeyDetails.scopes,
        assignedPolicies: extendedKeyDetails.assignedPolicies.map(p => p.id),
    });

    useEffect(() => {
        // Reset edit values when opening a new key or switching to view mode
        if (isOpen && !editMode) {
            setEditValues({
                name: apiKey.name,
                description: apiKey.description || '',
                status: extendedKeyDetails.status,
                expiresAfterDays: apiKey.expiresAt ? Math.ceil((new Date(apiKey.expiresAt).getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : '',
                allowedIps: extendedKeyDetails.allowedIps.join(', '),
                scopes: extendedKeyDetails.scopes,
                assignedPolicies: extendedKeyDetails.assignedPolicies.map(p => p.id),
            });
        }
    }, [isOpen, editMode, apiKey, extendedKeyDetails]);

    const handleEditChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        // Handle number input specifically for expiresAfterDays
        if (name === 'expiresAfterDays') {
            setEditValues(prev => ({ ...prev, [name]: value === '' ? '' : Number(value) }));
        } else {
            setEditValues(prev => ({ ...prev, [name]: value }));
        }
    };

    const handleEditIpChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setEditValues(prev => ({ ...prev, allowedIps: e.target.value }));
    };

    const handleEditScopeChange = (scope: string, isChecked: boolean) => {
        setEditValues(prev => {
            const currentScopes = new Set(prev.scopes);
            if (isChecked) {
                currentScopes.add(scope);
            } else {
                currentScopes.delete(scope);
            }
            return { ...prev, scopes: Array.from(currentScopes) };
        });
    };

    const handleEditPolicyChange = (policyId: string, isChecked: boolean) => {
        setEditValues(prev => {
            const currentPolicies = new Set(prev.assignedPolicies);
            if (isChecked) {
                currentPolicies.add(policyId);
            } else {
                currentPolicies.delete(policyId);
            }
            return { ...prev, assignedPolicies: Array.from(currentPolicies) };
        });
    };

    const handleSaveSettings = async () => {
        // Basic validation for edit settings
        if (!editValues.name || editValues.name.length < 3) {
            alert("Key name must be at least 3 characters.");
            return;
        }
        if (editValues.expiresAfterDays !== undefined && editValues.expiresAfterDays !== '' && (isNaN(Number(editValues.expiresAfterDays)) || Number(editValues.expiresAfterDays) < 1)) {
            alert("Expiry days must be a positive number.");
            return;
        }
        if (editValues.allowedIps) {
            const invalidIps = editValues.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean).filter(ip => !/^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/.test(ip));
            if (invalidIps.length > 0) {
                alert('Invalid IP address or CIDR format found in Allowed IP Addresses.');
                return;
            }
        }
        if (editValues.scopes.length === 0) {
            alert("At least one scope is required.");
            return;
        }

        // Simulate API call to update key settings
        console.log("Saving key settings:", editValues);
        await new Promise(res => setTimeout(res, 1000));

        const updatedKey: ApiKey = {
            ...apiKey,
            name: editValues.name,
            description: editValues.description,
            status: editValues.status,
            expiresAt: editValues.expiresAfterDays ? new Date(Date.now() + Number(editValues.expiresAfterDays) * 24 * 60 * 60 * 1000).toISOString() : undefined,
            allowedIps: editValues.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean),
            scopes: editValues.scopes,
            assignedPolicies: editValues.assignedPolicies,
        };
        onUpdateKey(updatedKey); // Call the prop function to update the parent state
        setEditMode(false);
    };

    const handleRevoke = async () => {
        await new Promise(res => setTimeout(res, 500));
        onRevoke(apiKey.id);
        setRevokeConfirmOpen(false);
        onClose();
    };

    // Filter usage logs specific to this key, and prepare for charts
    const currentKeyUsage = useMemo(() => {
        const last7Days = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        return keyUsageLogs
            .filter(log => log.apiKeyId === apiKey.id && new Date(log.timestamp) > last7Days)
            .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
    }, [apiKey.id, keyUsageLogs]);

    const latencyData = useMemo(() => {
        const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return currentKeyUsage
            .filter(u => new Date(u.timestamp) > last24Hours)
            .map(u => ({ name: new Date(u.timestamp).toLocaleTimeString(), latency: u.latencyMs }))
            .slice(-50); // Limit data points for chart readability
    }, [currentKeyUsage]);

    const errorData = useMemo(() => {
        const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const errorCountsByEndpoint: { [key: string]: { name: string; errors: number } } = {};
        currentKeyUsage.filter(u => new Date(u.timestamp) > last24Hours).forEach(u => {
            if (u.status >= 400) {
                if (!errorCountsByEndpoint[u.endpoint]) {
                    errorCountsByEndpoint[u.endpoint] = { name: u.endpoint.split('/').pop() || 'Other', errors: 0 };
                }
                errorCountsByEndpoint[u.endpoint].errors++;
            }
        });
        return Object.values(errorCountsByEndpoint);
    }, [currentKeyUsage]);


    return (
        <Modal isOpen={isOpen} onClose={onClose} title={`API Key: ${apiKey.name}`} size="2xl">
            <div className="flex border-b border-gray-700 -mx-6 px-6">
                <button
                    onClick={() => setActiveTab('details')}
                    className={`py-2 px-4 text-sm font-medium ${activeTab === 'details' ? 'border-b-2 border-cyan-500 text-cyan-400' : 'text-gray-400 hover:text-white'} transition duration-200`}
                >Details</button>
                <button
                    onClick={() => setActiveTab('usage')}
                    className={`py-2 px-4 text-sm font-medium ${activeTab === 'usage' ? 'border-b-2 border-cyan-500 text-cyan-400' : 'text-gray-400 hover:text-white'} transition duration-200`}
                >Usage</button>
                <button
                    onClick={() => setActiveTab('settings')}
                    className={`py-2 px-4 text-sm font-medium ${activeTab === 'settings' ? 'border-b-2 border-cyan-500 text-cyan-400' : 'text-gray-400 hover:text-white'} transition duration-200`}
                >Settings</button>
                 <button
                    onClick={() => setActiveTab('audit')}
                    className={`py-2 px-4 text-sm font-medium ${activeTab === 'audit' ? 'border-b-2 border-cyan-500 text-cyan-400' : 'text-gray-400 hover:text-white'} transition duration-200`}
                >Audit Log</button>
            </div>

            <div className="mt-4 p-4 space-y-4 -mx-6">
                {activeTab === 'details' && (
                    <div className="space-y-4 px-6">
                        <h4 className="text-lg font-semibold text-white">General Information</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><p className="text-gray-400">Key ID:</p><p className="font-mono text-white break-all">{apiKey.id}</p></div>
                            <div><p className="text-gray-400">Key Name:</p><p className="text-white break-words">{apiKey.name}</p></div>
                            <div><p className="text-gray-400">Key Secret:</p>
                                <div className="flex items-center gap-2">
                                    <p className="font-mono text-cyan-300 break-all">{apiKey.key.substring(0, 8)}...<span className="text-gray-500">(hidden)</span></p>
                                    <Tooltip content="Copy to clipboard">
                                        <button onClick={() => navigator.clipboard.writeText(apiKey.key)} className="text-sm px-2 py-1 bg-gray-600 hover:bg-gray-700 rounded text-white">Copy</button>
                                    </Tooltip>
                                </div>
                            </div>
                            <div><p className="text-gray-400">Created At:</p><p className="text-white">{formatTimestamp(apiKey.createdAt)}</p></div>
                            <div><p className="text-gray-400">Status:</p><StatusBadge status={extendedKeyDetails.status} /></div>
                            <div><p className="text-gray-400">Environment:</p><p className="text-white">{extendedKeyDetails.env.name}</p></div>
                            {apiKey.expiresAt && <div><p className="text-gray-400">Expires On:</p><p className="text-white">{formatTimestamp(apiKey.expiresAt)}</p></div>}
                            {apiKey.lastUsedAt && <div><p className="text-gray-400">Last Used:</p><p className="text-white">{formatTimestamp(apiKey.lastUsedAt)}</p></div>}
                             <div><p className="text-gray-400">Created By:</p><p className="text-white">{apiKey.createdBy}</p></div>
                        </div>
                        <div className="mt-4">
                            <p className="text-gray-400">Description:</p>
                            <p className="text-white italic">{apiKey.description || 'No description provided.'}</p>
                        </div>
                        <h4 className="text-lg font-semibold text-white mt-6">Permissions & Policies</h4>
                        <div>
                            <p className="text-gray-400">Allowed Scopes:</p>
                            <div className="flex flex-wrap gap-2 mt-2">
                                {extendedKeyDetails.scopes.map(scope => (
                                    <span key={scope} className="px-2 py-0.5 rounded-full text-xs font-medium bg-blue-700 text-white">{scope}</span>
                                ))}
                                {extendedKeyDetails.scopes.length === 0 && <span className="text-gray-500 italic">No specific scopes assigned.</span>}
                            </div>
                        </div>
                        <div className="mt-4">
                            <p className="text-gray-400">Applied Policies:</p>
                            <div className="flex flex-wrap gap-2 mt-2">
                                {extendedKeyDetails.assignedPolicies.map(policy => (
                                    <span key={policy.id} className="px-2 py-0.5 rounded-full text-xs font-medium bg-purple-700 text-white">{policy.name}</span>
                                ))}
                                {extendedKeyDetails.assignedPolicies.length === 0 && <span className="text-gray-500 italic">No policies assigned.</span>}
                            </div>
                        </div>
                        {extendedKeyDetails.allowedIps.length > 0 && (
                            <div className="mt-4">
                                <p className="text-gray-400">IP Whitelist:</p>
                                <div className="flex flex-wrap gap-2 mt-2">
                                    {extendedKeyDetails.allowedIps.map(ip => (
                                        <span key={ip} className="px-2 py-0.5 rounded-full text-xs font-medium bg-yellow-700 text-white">{ip}</span>
                                    ))}
                                </div>
                            </div>
                        )}

                        <div className="mt-6 flex justify-end">
                            <button onClick={() => setRevokeConfirmOpen(true)} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md text-sm font-medium text-white transition duration-200">Revoke Key</button>
                        </div>
                    </div>
                )}

                {activeTab === 'usage' && (
                    <div className="space-y-4 px-6">
                        <h4 className="text-lg font-semibold text-white">Recent Usage Metrics (Last 24 Hours)</h4>
                        {currentKeyUsage.length > 0 ? (
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <Card title="Latency (Last Day)" className="!p-4">
                                    <ResponsiveContainer width="100%" height={180}>
                                        <LineChart data={latencyData}>
                                            <XAxis dataKey="name" fontSize={10} stroke="#9ca3af" />
                                            <YAxis stroke="#9ca3af" />
                                            <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', border: 'none', borderRadius: '4px' }} itemStyle={{ color: '#fff' }} labelStyle={{ color: '#9ca3af' }} />
                                            <Line type="monotone" dataKey="latency" name="Latency (ms)" stroke="#8884d8" dot={false} />
                                        </LineChart>
                                    </ResponsiveContainer>
                                </Card>
                                <Card title="Errors by Endpoint (Last Day)" className="!p-4">
                                    <ResponsiveContainer width="100%" height={180}>
                                        <BarChart data={errorData}>
                                            <XAxis dataKey="name" fontSize={10} stroke="#9ca3af" />
                                            <YAxis stroke="#9ca3af" />
                                            <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', border: 'none', borderRadius: '4px' }} itemStyle={{ color: '#fff' }} labelStyle={{ color: '#9ca3af' }} />
                                            <Bar dataKey="errors" fill="#ef4444" />
                                        </BarChart>
                                    </ResponsiveContainer>
                                </Card>
                            </div>
                        ) : (
                            <p className="text-gray-500 text-center py-4">No recent usage data available for this key.</p>
                        )}
                        <h4 className="text-lg font-semibold text-white mt-6">Detailed Usage Logs (Last 7 Days)</h4>
                        <div className="max-h-96 overflow-y-auto border border-gray-700 rounded-lg">
                            <table className="min-w-full divide-y divide-gray-700">
                                <thead className="bg-gray-700 sticky top-0">
                                    <tr>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Timestamp</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Method</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Endpoint</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Latency (ms)</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">IP Address</th>
                                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Region</th>
                                    </tr>
                                </thead>
                                <tbody className="bg-gray-800 divide-y divide-gray-700">
                                    {currentKeyUsage.length > 0 ? (
                                        currentKeyUsage.map((log) => (
                                            <tr key={log.id} className="hover:bg-gray-700 transition-colors duration-150">
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatTimestamp(log.timestamp)}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.method}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.endpoint}</td>
                                                <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${log.status >= 400 ? 'text-red-400' : 'text-green-400'}`}>{log.status}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.latencyMs}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.ipAddress}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.region}</td>
                                            </tr>
                                        ))
                                    ) : (
                                        <tr><td colSpan={7} className="text-center py-4 text-gray-500">No detailed logs for this key in the last 7 days.</td></tr>
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                )}

                {activeTab === 'settings' && (
                    <div className="space-y-4 px-6">
                        <h4 className="text-lg font-semibold text-white">Key Configuration</h4>
                        {editMode ? (
                            <div className="space-y-4">
                                <div>
                                    <label htmlFor="edit_name" className="block text-sm font-medium text-gray-300">Key Name</label>
                                    <input type="text" id="edit_name" name="name" value={editValues.name} onChange={handleEditChange}
                                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500" />
                                </div>
                                <div>
                                    <label htmlFor="edit_description" className="block text-sm font-medium text-gray-300">Description</label>
                                    <textarea id="edit_description" name="description" value={editValues.description} onChange={handleEditChange} rows={2}
                                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
                                </div>
                                <div>
                                    <label htmlFor="edit_status" className="block text-sm font-medium text-gray-300">Status</label>
                                    <select id="edit_status" name="status" value={editValues.status} onChange={handleEditChange}
                                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500">
                                        <option value="active">Active</option>
                                        <option value="paused">Paused</option>
                                        <option value="revoked">Revoked</option>
                                    </select>
                                </div>
                                <div>
                                    <label htmlFor="edit_expiresAfterDays" className="block text-sm font-medium text-gray-300">Expires After (Days, leave empty for no expiry)</label>
                                    <input type="number" id="edit_expiresAfterDays" name="expiresAfterDays" value={editValues.expiresAfterDays} onChange={handleEditChange}
                                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                                        min="1" placeholder="Optional" />
                                </div>
                                <div>
                                    <label htmlFor="edit_allowedIps" className="block text-sm font-medium text-gray-300">Allowed IP Addresses (comma-separated)</label>
                                    <textarea id="edit_allowedIps" name="allowedIps" value={editValues.allowedIps} onChange={handleEditIpChange} rows={2}
                                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                                        placeholder="e.g., 192.168.1.1, 10.0.0.0/24"></textarea>
                                </div>
                                <div>
                                    <p className="block text-sm font-medium text-gray-300">API Scopes/Permissions</p>
                                    <div className="mt-1 grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded-md border border-gray-600">
                                        {allAvailableScopes.map(scope => (
                                            <label key={scope} className="inline-flex items-center text-white text-sm cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={editValues.scopes.includes(scope)}
                                                    onChange={(e) => handleEditScopeChange(scope, e.target.checked)}
                                                    className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                                                />
                                                <span className="ml-2">{scope}</span>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                                <div>
                                    <p className="block text-sm font-medium text-gray-300">Assigned Policies</p>
                                    <div className="mt-1 grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded-md border border-gray-600">
                                        {availablePolicies.map(policy => (
                                            <label key={policy.id} className="inline-flex items-center text-white text-sm cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={editValues.assignedPolicies.includes(policy.id)}
                                                    onChange={(e) => handleEditPolicyChange(policy.id, e.target.checked)}
                                                    className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                                                />
                                                <span className="ml-2">{policy.name}</span>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                                <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
                                    <button type="button" onClick={() => setEditMode(false)} className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 transition duration-200">Cancel</button>
                                    <button type="button" onClick={handleSaveSettings} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium text-white transition duration-200">Save Changes</button>
                                </div>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div><p className="text-gray-400">Name:</p><p className="text-white">{apiKey.name}</p></div>
                                    <div><p className="text-gray-400">Status:</p><StatusBadge status={extendedKeyDetails.status} /></div>
                                    <div><p className="text-gray-400">Description:</p><p className="text-white italic">{apiKey.description || 'No description provided.'}</p></div>
                                    <div><p className="text-gray-400">Expiry:</p><p className="text-white">{apiKey.expiresAt ? `Expires on ${formatTimestamp(apiKey.expiresAt)}` : 'No expiry'}</p></div>
                                </div>
                                <div className="mt-4">
                                    <p className="text-gray-400">IP Whitelist:</p>
                                    <p className="text-white">{extendedKeyDetails.allowedIps.length > 0 ? extendedKeyDetails.allowedIps.join(', ') : 'None'}</p>
                                </div>
                                <div className="mt-4">
                                    <p className="text-gray-400">Active Scopes:</p>
                                    <p className="text-white">{extendedKeyDetails.scopes.length > 0 ? extendedKeyDetails.scopes.join(', ') : 'None'}</p>
                                </div>
                                <div className="mt-4">
                                    <p className="text-gray-400">Applied Policies:</p>
                                    <p className="text-white">{extendedKeyDetails.assignedPolicies.map(p => p.name).join(', ') || 'None'}</p>
                                </div>
                                <div className="flex justify-end">
                                    <button onClick={() => setEditMode(true)} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium text-white transition duration-200">Edit Settings</button>
                                </div>
                            </div>
                        )}
                    </div>
                )}
                {activeTab === 'audit' && (
                    <div className="px-6">
                         <ApiKeyAuditLog keyId={apiKey.id} isModal={true} />
                    </div>
                )}
            </div>

            <Modal isOpen={isRevokeConfirmOpen} onClose={() => setRevokeConfirmOpen(false)} title="Confirm Revocation" size="sm">
                <p className="text-red-300 mb-4">Are you sure you want to revoke API Key: <span className="font-bold">{apiKey.name}</span>?</p>
                <p className="text-sm text-gray-400">This action cannot be undone and will immediately disable the key, preventing any further API calls.</p>
                <div className="flex justify-end gap-3 mt-6">
                    <button type="button" onClick={() => setRevokeConfirmOpen(false)} className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 transition duration-200">Cancel</button>
                    <button type="button" onClick={handleRevoke} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md text-sm font-medium text-white transition duration-200">Revoke Key</button>
                </div>
            </Modal>
        </Modal>
    );
};

/**
 * Table component for displaying and managing API Key Policies.
 */
interface ApiKeyPoliciesTableProps {
    policies: ApiKeyPolicy[];
    onEditPolicy: (policy: ApiKeyPolicy) => void;
    onDeletePolicy: (policyId: string) => void;
    onCreateNewPolicy: () => void;
}

export const ApiKeyPoliciesTable: React.FC<ApiKeyPoliciesTableProps> = ({ policies, onEditPolicy, onDeletePolicy, onCreateNewPolicy }) => {
    const [filterText, setFilterText] = useState('');
    const [sortKey, setSortKey] = useState<keyof ApiKeyPolicy>('name');
    const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');

    const filteredAndSortedPolicies = useMemo(() => {
        let filtered = policies.filter(policy =>
            policy.name.toLowerCase().includes(filterText.toLowerCase()) ||
            policy.description.toLowerCase().includes(filterText.toLowerCase()) ||
            policy.id.toLowerCase().includes(filterText.toLowerCase())
        );

        return filtered.sort((a, b) => {
            const aValue = a[sortKey];
            const bValue = b[sortKey];

            if (typeof aValue === 'string' && typeof bValue === 'string') {
                return sortDirection === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
            }
            if (typeof aValue === 'number' && typeof bValue === 'number') {
                return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
            }
            // For complex types like 'rules' or 'createdAt' (string comparison)
            if (sortKey === 'createdAt' || sortKey === 'lastUpdated') {
                 return sortDirection === 'asc' ? new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime() : new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
            }
            return 0;
        });
    }, [policies, filterText, sortKey, sortDirection]);

    const handleSort = (key: keyof ApiKeyPolicy) => {
        if (sortKey === key) {
            setSortDirection(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortKey(key);
            setSortDirection('asc');
        }
    };

    const SortIcon: React.FC<{ active: boolean; direction: 'asc' | 'desc' }> = ({ active, direction }) => {
        if (!active) return <span className="ml-1 text-gray-500"></span>;
        return direction === 'asc' ? <span className="ml-1"></span> : <span className="ml-1"></span>;
    };

    return (
        <Card title="API Key Policies">
            <div className="flex justify-between items-center mb-4 flex-wrap gap-2">
                <input
                    type="text"
                    placeholder="Search policies..."
                    value={filterText}
                    onChange={(e) => setFilterText(e.target.value)}
                    className="flex-grow max-w-sm px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-cyan-500 focus:border-cyan-500 transition duration-200"
                />
                <button onClick={onCreateNewPolicy} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md text-sm font-medium text-white transition duration-200">
                    Create New Policy
                </button>
            </div>
            <div className="overflow-x-auto border border-gray-700 rounded-lg">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700 sticky top-0">
                        <tr>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('name')}>
                                Name <SortIcon active={sortKey === 'name'} direction={sortDirection} />
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                                Description
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('status')}>
                                Status <SortIcon active={sortKey === 'status'} direction={sortDirection} />
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                                Rules
                            </th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">
                                Actions
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {filteredAndSortedPolicies.length > 0 ? (
                            filteredAndSortedPolicies.map((policy) => (
                                <tr key={policy.id} className="hover:bg-gray-700 transition-colors duration-150">
                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{policy.name}</td>
                                    <td className="px-6 py-4 text-sm text-gray-300 max-w-xs truncate" title={policy.description}>{policy.description}</td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${policy.status === 'active' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                            {policy.status}
                                        </span>
                                    </td>
                                    <td className="px-6 py-4 text-sm text-gray-300">
                                        <ul className="list-disc list-inside space-y-1">
                                            {policy.rules.map((rule, idx) => (
                                                <li key={idx}>
                                                    {rule.maxRequestsPerMin && <Tooltip content={`Max ${rule.maxRequestsPerMin} req/min`}><span>Rate Limit</span></Tooltip>}
                                                    {rule.rateLimitBurst && ` (+${rule.rateLimitBurst} burst)`}
                                                    {rule.allowedIps && rule.allowedIps.length > 0 && ` | IPs: ${rule.allowedIps.join(', ')}`}
                                                    {rule.expiresAfterDays && ` | Expires: ${rule.expiresAfterDays} days`}
                                                    {rule.requiredScopes && rule.requiredScopes.length > 0 && ` | Scopes: ${rule.requiredScopes.join(', ')}`}
                                                </li>
                                            ))}
                                        </ul>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                        <button onClick={() => onEditPolicy(policy)} className="text-cyan-400 hover:text-cyan-300 mr-4 transition duration-200">Edit</button>
                                        <button onClick={() => onDeletePolicy(policy.id)} className="text-red-400 hover:text-red-300 transition duration-200">Delete</button>
                                    </td>
                                </tr>
                            ))
                        ) : (
                            <tr>
                                <td colSpan={5} className="px-6 py-4 text-center text-gray-500">No policies found.</td>
                            </tr>
                        )}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

/**
 * Form data for creating or editing an API Key Policy.
 */
interface PolicyFormData {
    name: string;
    description: string;
    status: 'active' | 'inactive';
    maxRequestsPerMin: number | '';
    allowedIps: string; // comma-separated string
    expiresAfterDays: number | '';
    requiredScopes: string[]; // array of scopes
    rateLimitBurst: number | '';
}

const initialPolicyFormData: PolicyFormData = {
    name: '',
    description: '',
    status: 'active',
    maxRequestsPerMin: '',
    allowedIps: '',
    expiresAfterDays: '',
    requiredScopes: [],
    rateLimitBurst: '',
};

const policyValidationSchema = (values: PolicyFormData) => {
    const errors: Partial<Record<keyof PolicyFormData, string>> = {};
    if (!values.name) errors.name = 'Policy name is required.';
    if (values.name.length < 3) errors.name = 'Policy name must be at least 3 characters.';
    if (values.maxRequestsPerMin !== '' && (isNaN(Number(values.maxRequestsPerMin)) || Number(values.maxRequestsPerMin) <= 0)) errors.maxRequestsPerMin = 'Max Requests Per Minute must be a positive number.';
    if (values.rateLimitBurst !== '' && (isNaN(Number(values.rateLimitBurst)) || Number(values.rateLimitBurst) < 0)) errors.rateLimitBurst = 'Rate Limit Burst must be a non-negative number.';
    if (values.expiresAfterDays !== '' && (isNaN(Number(values.expiresAfterDays)) || Number(values.expiresAfterDays) <= 0)) errors.expiresAfterDays = 'Expiry days must be a positive number.';
    if (values.allowedIps) {
        const invalidIps = values.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean).filter(ip => !/^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/.test(ip));
        if (invalidIps.length > 0) errors.allowedIps = 'Invalid IP address or CIDR format found.';
    }
    // No explicit error for scopes, as a policy could theoretically have no scopes defined.
    return errors;
};

interface ManagePolicyModalProps {
    isOpen: boolean;
    onClose: () => void;
    policyToEdit?: ApiKeyPolicy;
    onSave: (policy: ApiKeyPolicy) => void;
    allAvailableScopes: string[];
}

/**
 * Modal form for creating or editing an API Key Policy.
 */
export const ManagePolicyModal: React.FC<ManagePolicyModalProps> = ({ isOpen, onClose, policyToEdit, onSave, allAvailableScopes }) => {
    const initialValues = useMemo(() => {
        if (policyToEdit) {
            const rule = policyToEdit.rules[0] || {}; // Assuming one rule for simplicity
            return {
                name: policyToEdit.name,
                description: policyToEdit.description,
                status: policyToEdit.status,
                maxRequestsPerMin: rule.maxRequestsPerMin || '',
                allowedIps: rule.allowedIps?.join(', ') || '',
                expiresAfterDays: rule.expiresAfterDays || '',
                requiredScopes: rule.requiredScopes || [],
                rateLimitBurst: rule.rateLimitBurst || '',
            };
        }
        return initialPolicyFormData;
    }, [policyToEdit]);

    const { values, handleChange, handleSubmit, errors, isSubmitting, submitSuccess, setValues, resetForm } = useForm<PolicyFormData>({
        initialValues,
        onSubmit: async (formData) => {
            await new Promise(res => setTimeout(res, 1000)); // Simulate API call
            const newPolicy: ApiKeyPolicy = {
                id: policyToEdit?.id || generateId('policy'),
                name: formData.name,
                description: formData.description,
                status: formData.status,
                rules: [{
                    maxRequestsPerMin: formData.maxRequestsPerMin !== '' ? Number(formData.maxRequestsPerMin) : undefined,
                    allowedIps: formData.allowedIps ? formData.allowedIps.split(',').map(ip => ip.trim()).filter(Boolean) : undefined,
                    expiresAfterDays: formData.expiresAfterDays !== '' ? Number(formData.expiresAfterDays) : undefined,
                    requiredScopes: formData.requiredScopes.length > 0 ? formData.requiredScopes : undefined,
                    rateLimitBurst: formData.rateLimitBurst !== '' ? Number(formData.rateLimitBurst) : undefined,
                }],
                createdAt: policyToEdit?.createdAt || new Date().toISOString(),
                lastUpdated: new Date().toISOString(),
            };
            onSave(newPolicy);
            onClose(); // Close modal on success
        },
        validationSchema: policyValidationSchema,
        onSuccess: () => console.log("Policy saved successfully."),
        onError: (err) => console.error("Error saving policy:", err),
    });

    useEffect(() => {
        if (!isOpen) resetForm();
        else setValues(initialValues);
    }, [isOpen, initialValues, resetForm, setValues]);

    const handleScopeChange = (scope: string, isChecked: boolean) => {
        setValues(prev => {
            const currentScopes = new Set(prev.requiredScopes);
            if (isChecked) {
                currentScopes.add(scope);
            } else {
                currentScopes.delete(scope);
            }
            return { ...prev, requiredScopes: Array.from(currentScopes) };
        });
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title={policyToEdit ? 'Edit API Key Policy' : 'Create New API Key Policy'} size="lg">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="policyName" className="block text-sm font-medium text-gray-300">Policy Name</label>
                    <input type="text" id="policyName" name="name" value={values.name} onChange={handleChange}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500" />
                    {errors.name && <p className="mt-1 text-xs text-red-400">{errors.name}</p>}
                </div>
                <div>
                    <label htmlFor="policyDescription" className="block text-sm font-medium text-gray-300">Description</label>
                    <textarea id="policyDescription" name="description" value={values.description} onChange={handleChange} rows={2}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"></textarea>
                </div>
                <div>
                    <label htmlFor="policyStatus" className="block text-sm font-medium text-gray-300">Status</label>
                    <select id="policyStatus" name="status" value={values.status} onChange={handleChange}
                        className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500">
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                    </select>
                </div>
                <fieldset className="p-4 border border-gray-700 rounded-md space-y-3">
                    <legend className="text-md font-semibold text-white px-2">Policy Rules</legend>
                    <div>
                        <label htmlFor="maxRequestsPerMin" className="block text-sm font-medium text-gray-300">Max Requests Per Minute (Rate Limit)</label>
                        <input type="number" id="maxRequestsPerMin" name="maxRequestsPerMin" value={values.maxRequestsPerMin} onChange={handleChange}
                            className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                            placeholder="e.g., 1000" min="1" />
                        {errors.maxRequestsPerMin && <p className="mt-1 text-xs text-red-400">{errors.maxRequestsPerMin}</p>}
                    </div>
                    <div>
                        <label htmlFor="rateLimitBurst" className="block text-sm font-medium text-gray-300">Rate Limit Burst (requests allowed above limit momentarily)</label>
                        <input type="number" id="rateLimitBurst" name="rateLimitBurst" value={values.rateLimitBurst} onChange={handleChange}
                            className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                            placeholder="e.g., 200" min="0" />
                        {errors.rateLimitBurst && <p className="mt-1 text-xs text-red-400">{errors.rateLimitBurst}</p>}
                    </div>
                    <div>
                        <label htmlFor="allowedIps" className="block text-sm font-medium text-gray-300">Allowed IP Addresses (comma-separated)</label>
                        <textarea id="allowedIps" name="allowedIps" value={values.allowedIps} onChange={handleChange} rows={2}
                            className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                            placeholder="e.g., 192.168.1.1, 10.0.0.0/24"></textarea>
                        {errors.allowedIps && <p className="mt-1 text-xs text-red-400">{errors.allowedIps}</p>}
                    </div>
                    <div>
                        <label htmlFor="expiresAfterDays" className="block text-sm font-medium text-gray-300">Expires After (Days, leave empty for no expiry)</label>
                        <input type="number" id="expiresAfterDays" name="expiresAfterDays" value={values.expiresAfterDays} onChange={handleChange}
                            className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                            placeholder="e.g., 90" min="1" />
                        {errors.expiresAfterDays && <p className="mt-1 text-xs text-red-400">{errors.expiresAfterDays}</p>}
                    </div>
                    <div>
                        <p className="block text-sm font-medium text-gray-300">Required API Scopes</p>
                        <div className="mt-1 grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded-md border border-gray-600">
                            {allAvailableScopes.map(scope => (
                                <label key={scope} className="inline-flex items-center text-white text-sm cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={values.requiredScopes.includes(scope)}
                                        onChange={(e) => handleScopeChange(scope, e.target.checked)}
                                        className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                                    />
                                    <span className="ml-2">{scope}</span>
                                </label>
                            ))}
                        </div>
                    </div>
                </fieldset>

                <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 transition duration-200">Cancel</button>
                    <button type="submit" disabled={isSubmitting} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md text-sm font-medium text-white disabled:opacity-50 transition duration-200">
                        {isSubmitting ? 'Saving...' : 'Save Policy'}
                    </button>
                </div>
                {submitSuccess === true && <p className="mt-2 text-sm text-green-400">Policy saved successfully!</p>}
                {submitSuccess === false && <p className="mt-2 text-sm text-red-400">Failed to save policy. Please check your inputs.</p>}
            </form>
        </Modal>
    );
};

/**
 * Form for configuring a single Webhook.
 */
interface WebhookConfigurationFormProps {
    webhook?: Webhook;
    onSave: (webhook: Webhook) => void;
    onCancel: () => void;
    onDelete?: (id: string) => void;
}

interface WebhookFormData {
    name: string;
    url: string;
    events: Webhook['events'];
    isActive: boolean;
    secret: string;
}

const initialWebhookFormData: WebhookFormData = {
    name: '',
    url: '',
    events: ['key.created'],
    isActive: true,
    secret: generateSecureRandomString(32),
};

const webhookValidationSchema = (values: WebhookFormData) => {
    const errors: Partial<Record<keyof WebhookFormData, string>> = {};
    if (!values.name) errors.name = 'Webhook name is required.';
    if (!values.url || !/^https?:\/\/.+\..+/.test(values.url)) errors.url = 'Valid URL (starting with http/https) is required.';
    if (values.events.length === 0) errors.events = 'At least one event must be selected.';
    return errors;
};

export const WebhookConfigurationForm: React.FC<WebhookConfigurationFormProps> = ({ webhook, onSave, onCancel, onDelete }) => {
    const initialValues = useMemo(() => {
        if (webhook) {
            return {
                name: webhook.name,
                url: webhook.url,
                events: webhook.events,
                isActive: webhook.isActive,
                secret: webhook.secret,
            };
        }
        return initialWebhookFormData;
    }, [webhook]);

    const { values, handleChange, handleSubmit, errors, isSubmitting, submitSuccess, setValues, resetForm } = useForm<WebhookFormData>({
        initialValues,
        onSubmit: async (formData) => {
            await new Promise(res => setTimeout(res, 1000)); // Simulate API call
            const savedWebhook: Webhook = {
                id: webhook?.id || generateId('wh'),
                name: formData.name,
                url: formData.url,
                events: formData.events,
                secret: webhook?.secret || formData.secret,
                isActive: formData.isActive,
                createdAt: webhook?.createdAt || new Date().toISOString(),
                lastTriggeredAt: webhook?.lastTriggeredAt,
            };
            onSave(savedWebhook);
        },
        validationSchema: webhookValidationSchema,
        onSuccess: () => console.log("Webhook saved successfully."),
        onError: (err) => console.error("Error saving webhook:", err),
    });

    useEffect(() => {
        if (!webhook) {
            resetForm();
            setValues(prev => ({ ...prev, secret: generateSecureRandomString(32) }));
        } else {
            setValues(initialValues);
        }
    }, [webhook, initialValues, resetForm, setValues]);


    const allWebhookEvents: Webhook['events'][number][] = [
        'key.created',
        'key.revoked',
        'key.expired',
        'usage.threshold_exceeded',
        'policy.violation',
    ];

    const handleEventChange = (event: Webhook['events'][number], isChecked: boolean) => {
        setValues(prev => {
            const currentEvents = new Set(prev.events);
            if (isChecked) {
                currentEvents.add(event);
            } else {
                currentEvents.delete(event);
            }
            return { ...prev, events: Array.from(currentEvents) };
        });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label htmlFor="webhookName" className="block text-sm font-medium text-gray-300">Webhook Name</label>
                <input type="text" id="webhookName" name="name" value={values.name} onChange={handleChange}
                    className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500" />
                {errors.name && <p className="mt-1 text-xs text-red-400">{errors.name}</p>}
            </div>
            <div>
                <label htmlFor="webhookUrl" className="block text-sm font-medium text-gray-300">Target URL</label>
                <input type="url" id="webhookUrl" name="url" value={values.url} onChange={handleChange}
                    className="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm text-white focus:ring-cyan-500 focus:border-cyan-500"
                    placeholder="https://your-app.com/webhook-endpoint" />
                {errors.url && <p className="mt-1 text-xs text-red-400">{errors.url}</p>}
            </div>
            <div>
                <p className="block text-sm font-medium text-gray-300">Events to Trigger On</p>
                <div className="mt-1 grid grid-cols-2 gap-2 p-2 bg-gray-700 rounded-md border border-gray-600">
                    {allWebhookEvents.map(event => (
                        <label key={event} className="inline-flex items-center text-white text-sm cursor-pointer">
                            <input
                                type="checkbox"
                                checked={values.events.includes(event)}
                                onChange={(e) => handleEventChange(event, e.target.checked)}
                                className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded"
                            />
                            <span className="ml-2">{event}</span>
                        </label>
                    ))}
                </div>
                {errors.events && <p className="mt-1 text-xs text-red-400">{errors.events}</p>}
            </div>
            <div>
                <label htmlFor="webhookSecret" className="block text-sm font-medium text-gray-300">Webhook Secret</label>
                <div className="flex items-center gap-2 mt-1">
                    <input type="text" id="webhookSecret" name="secret" value={values.secret} readOnly
                        className="flex-grow bg-gray-900 border-gray-700 rounded-md shadow-sm text-cyan-300 font-mono text-sm focus:ring-cyan-500 focus:border-cyan-500" />
                    <Tooltip content="Copy to clipboard">
                        <button type="button" onClick={() => navigator.clipboard.writeText(values.secret)} className="px-3 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs text-white transition duration-200">Copy</button>
                    </Tooltip>
                    {!webhook && ( // Only show regenerate for new webhook or an explicit regenerate button for existing
                        <Tooltip content="Regenerate new secret">
                            <button type="button" onClick={() => setValues(prev => ({ ...prev, secret: generateSecureRandomString(32) }))} className="px-3 py-1 bg-gray-600 hover:bg-gray-700 rounded text-xs text-white transition duration-200">Regenerate</button>
                        </Tooltip>
                    )}
                </div>
                <p className="mt-1 text-xs text-gray-400">Use this secret to verify webhook payloads. It will be signed using HMAC-SHA256.</p>
            </div>
            <div className="flex items-center">
                <input type="checkbox" id="webhookIsActive" name="isActive" checked={values.isActive} onChange={handleChange}
                    className="form-checkbox h-4 w-4 text-cyan-600 transition duration-150 ease-in-out bg-gray-800 border-gray-600 rounded" />
                <label htmlFor="webhookIsActive" className="ml-2 block text-sm text-gray-300">Active</label>
            </div>
            <div className="flex justify-end gap-3 pt-4 border-t border-gray-700">
                {webhook && onDelete && (
                    <button type="button" onClick={() => onDelete(webhook.id)} className="px-4 py-2 text-sm font-medium text-red-400 rounded-md border border-red-600 hover:bg-red-700 transition duration-200">Delete Webhook</button>
                )}
                <button type="button" onClick={onCancel} className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 transition duration-200">Cancel</button>
                <button type="submit" disabled={isSubmitting} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md text-sm font-medium text-white disabled:opacity-50 transition duration-200">
                    {isSubmitting ? 'Saving...' : 'Save Webhook'}
                </button>
            </div>
            {submitSuccess === true && <p className="mt-2 text-sm text-green-400">Webhook saved successfully!</p>}
            {submitSuccess === false && <p className="mt-2 text-sm text-red-400">Failed to save webhook. Please check your inputs.</p>}
        </form>
    );
};

/**
 * Component for listing and managing Webhook Endpoints.
 */
interface WebhookListProps {
    webhooks: Webhook[];
    onEdit: (webhook: Webhook) => void;
    onDelete: (id: string) => void;
    onCreateNew: () => void;
}

export const WebhookList: React.FC<WebhookListProps> = ({ webhooks, onEdit, onDelete, onCreateNew }) => {
    return (
        <Card title="Webhook Endpoints">
            <div className="flex justify-end mb-4">
                <button onClick={onCreateNew} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-md text-sm font-medium text-white transition duration-200">
                    Create New Webhook
                </button>
            </div>
            <div className="overflow-x-auto border border-gray-700 rounded-lg">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700 sticky top-0">
                        <tr>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Name</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">URL</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Events</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Created</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Last Triggered</th>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {webhooks.length > 0 ? (
                            webhooks.map((webhook) => (
                                <tr key={webhook.id} className="hover:bg-gray-700 transition-colors duration-150">
                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{webhook.name}</td>
                                    <td className="px-6 py-4 text-sm text-cyan-400 truncate max-w-xs"><a href={webhook.url} target="_blank" rel="noopener noreferrer" className="hover:underline">{webhook.url}</a></td>
                                    <td className="px-6 py-4 text-sm text-gray-300">
                                        <div className="flex flex-wrap gap-1">
                                            {webhook.events.map(event => (
                                                <span key={event} className="px-2 py-0.5 rounded-full text-xs bg-gray-600 text-gray-200">{event.split('.')[0] === 'usage' ? 'Usage' : event.split('.')[1]}</span>
                                            ))}
                                        </div>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm">
                                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${webhook.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                            {webhook.isActive ? 'Active' : 'Inactive'}
                                        </span>
                                    </td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatTimestamp(webhook.createdAt)}</td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{webhook.lastTriggeredAt ? formatTimestamp(webhook.lastTriggeredAt) : 'Never'}</td>
                                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                        <button onClick={() => onEdit(webhook)} className="text-cyan-400 hover:text-cyan-300 mr-4 transition duration-200">Edit</button>
                                        <button onClick={() => onDelete(webhook.id)} className="text-red-400 hover:text-red-300 transition duration-200">Delete</button>
                                    </td>
                                </tr>
                            ))
                        ) : (
                            <tr>
                                <td colSpan={7} className="px-6 py-4 text-center text-gray-500">No webhooks configured.</td>
                            </tr>
                        )}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

/**
 * Component for displaying Audit logs, with optional filtering by API key.
 */
interface ApiKeyAuditLogProps {
    keyId?: string; // Optional: if provided, filter logs for this key
    isModal?: boolean; // If true, adjusts title/display for modal context
}

export const ApiKeyAuditLog: React.FC<ApiKeyAuditLogProps> = ({ keyId, isModal = false }) => {
    const [auditLogs, setAuditLogs] = useState<AuditEvent[]>([]);
    const [loading, setLoading] = useState(true);
    const [page, setPage] = useState(1);
    const [pageSize] = useState(10);
    const [totalPages, setTotalPages] = useState(1);
    const [filterActor, setFilterActor] = useState('');
    const [filterAction, setFilterAction] = useState('');

    useEffect(() => {
        setLoading(true);
        const fetchLogs = async () => {
            await new Promise(res => setTimeout(res, 500)); // Simulate API call delay
            let allLogs = INITIAL_MOCK_AUDIT_EVENTS;

            let filteredLogs = allLogs.filter(log => {
                let matches = true;
                if (keyId) {
                    matches = matches && log.targetId === keyId && log.targetType === 'API_KEY';
                }
                if (filterActor) {
                    matches = matches && log.actor.toLowerCase().includes(filterActor.toLowerCase());
                }
                if (filterAction) {
                    matches = matches && log.action.toLowerCase().includes(filterAction.toLowerCase());
                }
                return matches;
            });

            // Sort by timestamp descending
            filteredLogs = filteredLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

            const start = (page - 1) * pageSize;
            const end = start + pageSize;
            setAuditLogs(filteredLogs.slice(start, end));
            setTotalPages(Math.ceil(filteredLogs.length / pageSize));
            setLoading(false);
        };
        fetchLogs();
    }, [keyId, page, pageSize, filterActor, filterAction]);

    const handleFilterChange = (setter: React.Dispatch<React.SetStateAction<string>>, value: string) => {
        setter(value);
        setPage(1); // Reset to first page on filter change
    };

    return (
        <Card title={isModal ? `Audit Log for this Key` : "Global Audit Log"}>
            <div className="flex gap-4 mb-4 flex-wrap">
                <input
                    type="text"
                    placeholder="Filter by actor..."
                    value={filterActor}
                    onChange={(e) => handleFilterChange(setFilterActor, e.target.value)}
                    className="flex-1 min-w-[150px] px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-cyan-500 focus:border-cyan-500 transition duration-200"
                />
                <input
                    type="text"
                    placeholder="Filter by action..."
                    value={filterAction}
                    onChange={(e) => handleFilterChange(setFilterAction, e.target.value)}
                    className="flex-1 min-w-[150px] px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-cyan-500 focus:border-cyan-500 transition duration-200"
                />
            </div>
            <div className="max-h-96 overflow-y-auto border border-gray-700 rounded-lg">
                {loading ? (
                    <p className="text-gray-500 text-center py-8">Loading audit logs...</p>
                ) : (
                    <table className="min-w-full divide-y divide-gray-700">
                        <thead className="bg-gray-700 sticky top-0">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Timestamp</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actor</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Action</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Target</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Details</th>
                            </tr>
                        </thead>
                        <tbody className="bg-gray-800 divide-y divide-gray-700">
                            {auditLogs.length > 0 ? (
                                auditLogs.map((log) => (
                                    <tr key={log.id} className="hover:bg-gray-700 transition-colors duration-150">
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatTimestamp(log.timestamp)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-white">{log.actor}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-cyan-400">{log.action}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{log.targetType} ({log.targetId.substring(0, 8)}...)</td>
                                        <td className="px-6 py-4 text-sm text-gray-400 max-w-xs truncate">
                                            <Tooltip content={<pre className="text-xs">{JSON.stringify(log.details, null, 2)}</pre>} position="bottom">
                                                {JSON.stringify(log.details)}
                                            </Tooltip>
                                        </td>
                                    </tr>
                                ))
                            ) : (
                                <tr>
                                    <td colSpan={5} className="text-center py-4 text-gray-500">No audit events found.</td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                )}
            </div>
            <div className="flex justify-between items-center mt-4">
                <button
                    onClick={() => setPage(prev => Math.max(1, prev - 1))}
                    disabled={page === 1 || loading}
                    className="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white disabled:opacity-50 transition duration-200"
                >
                    Previous
                </button>
                <span className="text-sm text-gray-400">Page {page} of {totalPages}</span>
                <button
                    onClick={() => setPage(prev => Math.min(totalPages, prev + 1))}
                    disabled={page === totalPages || loading}
                    className="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white disabled:opacity-50 transition duration-200"
                >
                    Next
                </button>
            </div>
        </Card>
    );
};

/**
 * Component for displaying the health status of various services.
 */
export const ServiceHealthMonitor: React.FC = () => {
    const [healthMetrics, setHealthMetrics] = useState<ServiceHealthMetric[]>(INITIAL_SERVICE_HEALTH);
    const [loading, setLoading] = useState(false);

    const fetchHealth = async () => {
        setLoading(true);
        await new Promise(res => setTimeout(res, 1500)); // Simulate API call
        setHealthMetrics(generateMockServiceHealth()); // Regenerate mock data
        setLoading(false);
    };

    useEffect(() => {
        fetchHealth(); // Initial fetch
        const interval = setInterval(fetchHealth, 60000); // Refresh every minute
        return () => clearInterval(interval);
    }, []);

    const getStatusColor = (status: ServiceHealthMetric['status']) => {
        switch (status) {
            case 'operational': return 'text-green-500';
            case 'degraded': return 'text-yellow-500';
            case 'major_outage': return 'text-red-500';
            default: return 'text-gray-500';
        }
    };

    const getStatusIcon = (status: ServiceHealthMetric['status']) => {
        switch (status) {
            case 'operational': return '';
            case 'degraded': return '!';
            case 'major_outage': return '';
            default: return '?';
        }
    };

    return (
        <Card title="Service Health Monitor">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {healthMetrics.map(metric => (
                    <div key={metric.serviceName} className="flex items-center justify-between p-3 bg-gray-800/50 rounded-lg">
                        <div className="flex items-center">
                            <span className={`text-xl font-bold mr-3 ${getStatusColor(metric.status)}`}>{getStatusIcon(metric.status)}</span>
                            <div>
                                <p className="font-semibold text-white">{metric.serviceName}</p>
                                <p className={`text-xs ${getStatusColor(metric.status)}`}>{metric.status.replace('_', ' ').toUpperCase()}</p>
                            </div>
                        </div>
                        <div className="text-right">
                            <p className="text-xs text-gray-400">Last Checked: {formatTimestamp(metric.lastChecked)}</p>
                            {metric.latency && <p className="text-xs text-gray-400">Latency: {metric.latency}ms</p>}
                        </div>
                    </div>
                ))}
            </div>
            <div className="mt-4 text-center text-gray-500 text-xs">
                {loading ? 'Updating...' : `Last updated: ${new Date().toLocaleTimeString()}`}
            </div>
        </Card>
    );
};


/**
 * Expanded AI Security Suite with more features and descriptions.
 */
export const AiSecuritySuiteExpanded: React.FC<{ handleAiFeature: (type: string) => void }> = ({ handleAiFeature }) => {
    return (
        <Card title="AI Security Suite - Advanced Tools">
            <p className="text-gray-400 mb-4 text-sm">Leverage AI to enhance the security and management of your API keys. Select a tool below:</p>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <button onClick={() => handleAiFeature('audit')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Usage Log Auditor <span className="text-cyan-400 text-xs">(Enhanced)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Scan extensive usage logs for suspicious access patterns, sudden spikes, or unusual geographic activity.</p>
                </button>
                <button onClick={() => handleAiFeature('scope')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Permission Scoper <span className="text-cyan-400 text-xs">(Dynamic)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Generate least-privilege API key permissions based on a detailed natural language description of its intended use or actual observed usage.</p>
                </button>
                <button onClick={() => handleAiFeature('codegen')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Secure Code Generator <span className="text-cyan-400 text-xs">(Multi-Language)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Generate secure code snippets in Python, Node.js, Go, or Java for interacting with your API using best practices for key management.</p>
                </button>
                <button onClick={() => handleAiFeature('leak')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Public Leak Detector <span className="text-cyan-400 text-xs">(Proactive)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Simulate real-time monitoring of public code repositories and pastebins for exposed API keys or key patterns. Receive alerts on potential breaches.</p>
                </button>
                <button onClick={() => handleAiFeature('policySuggest')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Policy Suggester <span className="text-cyan-400 text-xs">(Automated)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Analyze usage patterns and compliance requirements to suggest new API key policies or improvements to existing ones.</p>
                </button>
                <button onClick={() => handleAiFeature('vulnerabilityScan')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Configuration Vulnerability Scan <span className="text-cyan-400 text-xs">(Deep Dive)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Identify misconfigurations or security weaknesses in your API key setup (e.g., overly broad permissions, missing expiry dates, weak policies).</p>
                </button>
                <button onClick={() => handleAiFeature('threatIntel')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Threat Intelligence Feed <span className="text-cyan-400 text-xs">(Real-time)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Integrate with external threat intelligence to assess the risk of certain IP addresses or user agents associated with key usage.</p>
                </button>
                <button onClick={() => handleAiFeature('remediationSuggest')} className="p-4 bg-gray-700/50 hover:bg-gray-700 rounded-lg text-left transition duration-200">
                    <h4 className="font-semibold text-white">Remediation Assistant <span className="text-cyan-400 text-xs">(Actionable)</span></h4>
                    <p className="text-xs text-gray-400 mt-1">Provide step-by-step guidance and automated actions to address identified security issues and improve key hygiene.</p>
                </button>
            </div>
        </Card>
    );
};

// --- Main ApiKeysView component (expanded) ---

export const ApiKeysView: React.FC = () => {
    const [keys, setKeys] = useState<ApiKey[]>(INITIAL_MOCK_API_KEYS);
    const [allUsageLogs] = useState<ApiKeyUsageLog[]>(ALL_MOCK_USAGE_LOGS);
    const [policies, setPolicies] = useState<ApiKeyPolicy[]>(INITIAL_MOCK_POLICIES);
    const [environments] = useState<ApiKeyEnvironment[]>(INITIAL_MOCK_ENVIRONMENTS);
    const [webhooks, setWebhooks] = useState<Webhook[]>(INITIAL_MOCK_WEBHOOKS);
    const [auditEvents] = useState<AuditEvent[]>(INITIAL_MOCK_AUDIT_EVENTS);

    const [newKey, setNewKey] = useState<string | null>(null);
    const [isGenerating, setIsGenerating] = useState(false);
    const [copySuccess, setCopySuccess] = useState('');

    const [isAiModalOpen, setAiModalOpen] = useState(false);
    const [aiResult, setAiResult] = useState('');
    const [isAiLoading, setIsAiLoading] = useState(false);
    const [selectedAiFeature, setSelectedAiFeature] = useState<string>('');

    const [isCreateKeyModalOpen, setCreateKeyModalOpen] = useState(false);
    const [selectedApiKey, setSelectedApiKey] = useState<ApiKey | null>(null);
    const [isPolicyModalOpen, setPolicyModalOpen] = useState(false);
    const [policyToEdit, setPolicyToEdit] = useState<ApiKeyPolicy | undefined>(undefined);
    const [isWebhookFormOpen, setWebhookFormOpen] = useState(false);
    const [webhookToEdit, setWebhookToEdit] = useState<Webhook | undefined>(undefined);

    const handleCreateKeySubmit = (newlyCreatedKey: ApiKey) => {
        setKeys(prev => [...prev, newlyCreatedKey]);
        setNewKey(newlyCreatedKey.key);
        setCreateKeyModalOpen(false);
        // Add audit event for key creation
        const audit = generateMockAuditEvent();
        audit.action = 'API_KEY_CREATED';
        audit.targetId = newlyCreatedKey.id;
        audit.targetType = 'API_KEY';
        audit.details = { name: newlyCreatedKey.name, environmentId: newlyCreatedKey.environmentId, createdBy: newlyCreatedKey.createdBy };
        auditEvents.push(audit); // Directly push to mock for simplicity
    };

    const handleGenerateClick = async () => {
        setIsGenerating(true);
        setCopySuccess('');
        await new Promise(res => setTimeout(res, 1000));
        const generated = `db_sk_live_${generateSecureRandomString(24)}`;
        const newQuickKey: ApiKey = {
            id: generateId('key'),
            name: 'Quick Generated Key',
            key: generated,
            createdAt: new Date().toISOString(),
            status: 'active',
            createdBy: 'dashboard_user (quick generate)',
            environmentId: 'env_dev',
            scopes: ['read:transactions', 'read:users'],
        };
        setNewKey(generated);
        setKeys(prev => [...prev, newQuickKey]);
        setIsGenerating(false);
         const audit = generateMockAuditEvent();
        audit.action = 'API_KEY_CREATED_QUICK';
        audit.targetId = newQuickKey.id;
        audit.targetType = 'API_KEY';
        audit.details = { name: newQuickKey.name, createdBy: newQuickKey.createdBy };
        auditEvents.push(audit);
    };

    const handleCopy = (key: string) => {
        navigator.clipboard.writeText(key).then(() => {
            setCopySuccess('Copied!');
            setTimeout(() => setCopySuccess(''), 2000);
        });
    };

    const handleRevokeKey = (keyId: string) => {
        setKeys(prev => prev.map(key => key.id === keyId ? { ...key, status: 'revoked', lastUsedAt: undefined } : key));
        setSelectedApiKey(null);
        const audit = generateMockAuditEvent();
        audit.action = 'API_KEY_REVOKED';
        audit.targetId = keyId;
        audit.targetType = 'API_KEY';
        audit.details = { revokedBy: 'dashboard_user' };
        auditEvents.push(audit);
    };

    const handleUpdateKey = (updatedKey: ApiKey) => {
        setKeys(prev => prev.map(key => key.id === updatedKey.id ? updatedKey : key));
        // Add audit event for key update
        const audit = generateMockAuditEvent();
        audit.action = 'API_KEY_UPDATED';
        audit.targetId = updated

--- FILE: ApiKeysView.tsx.md ---

# The Keys to the Kingdom

This is the chamber of the Royal Scribe, the place where the keys to the kingdom's knowledge are forged and granted. Each API key is not merely a token; it is a grant of limited authority, a key that unlocks a specific door to the vast library of the platform's data. To manage these keys is to command the flow of information itself.

---

### A Fable for the Builder: The Scribe's Workshop

(In an ancient kingdom, knowledge was power, and the library was the heart of that power. But not everyone could be allowed to wander its halls freely. The Royal Scribe's duty was to forge keys, each one enchanted to open only a specific room, for a specific purpose. This `ApiKeysView` is that Scribe's workshop.)

(When you 'Generate New Key', you are not just creating a string of characters. You are forging a new key to the kingdom. And as the Scribe, you have a powerful assistant: the 'AI Security Suite'. It is not just a guard; it is a master locksmith and a spymaster.)

(Its logic is 'Proactive Stewardship.' The 'Usage Log Auditor' is the spymaster, watching how each key is used. It looks for unusual patternsa key used from a strange land, a key used at an odd hourand alerts you to potential misuse. The 'Permission Scoper' is the master locksmith. You tell it who needs a key and why"a key for a read-only analytics dashboard"and it forges a key with the absolute minimum set of permissions required, a key that can read, but never write. This is the principle of least privilege, made manifest by the AI.)

(The 'Code Snippet Generator' is the Scribe's apprentice, automatically writing the instructions for how to use the key you have just forged. And the 'Public Leak Detector' is the kingdom's eyes and ears in the outside world, constantly scanning the public square to ensure no key has been carelessly dropped or stolen.)

(This transforms the act of managing API keys from a simple, technical task into a high-level strategic act of governance. It is a system that gives you not just the power to grant access, but the intelligence to grant it wisely and the vigilance to ensure it is never abused. You are the master of the keys, and the AI is your sworn protector of the kingdom's knowledge.)

---

### The Grand Archives of Key Management: An Elaborate Chronicle

The Scribe's workshop has grown. No longer a mere forge and a small guardhouse, it is now an expansive complex, a fortress of digital governance. The AI Security Suite has evolved into a vast network of sentient modules, each specializing in a different facet of key stewardship. This chronicle details the expanded capabilities, the deeper philosophies, and the intricate mechanisms that govern the keys to our digital kingdom.

#### I. The AI Security Suite: The Watchful Sentinels and Master Crafters

The AI Security Suite, once a powerful assistant, has become the very scaffolding of security for the kingdom's digital assets. Its modules operate in concert, providing an unparalleled layer of protection and intelligent key lifecycle management.

##### A. The Usage Log Auditor: The Spymaster's Deepest Gaze

The Spymaster, now known as the **Usage Log Auditor Prime**, employs not just pattern matching but advanced behavioral analytics and machine learning. Its gaze is far more penetrating.

*   **Adaptive Anomaly Detection Engine (AADE):** This isn't just looking for strange lands or odd hours. The AADE builds a unique behavioral profile for *each* key. It learns its typical rate of usage, the specific endpoints it interacts with, the size and nature of data it requests, the user agents it typically employs, and even the "personality" of its calls.
    *   **Temporal Deviation Analysis:** Beyond just "odd hours," it identifies deviations from a key's *learned* schedule. A key normally active during business hours that suddenly makes hundreds of calls at 3 AM from a new IP is flagged with high urgency.
    *   **Geospatial & Network Contextualization:** It integrates with kingdom-wide network intelligence. Is the IP address part of a known botnet? Does it originate from a region under cyber-siege? Is the ASN (Autonomous System Number) associated with legitimate cloud providers or suspicious proxies?
    *   **Rate & Volume Dynamics:** Instead of simple rate limiting, it detects *bursts* that exceed a key's learned maximum velocity, or a sustained, low-volume "drip" attack that might evade simpler defenses.
    *   **Endpoint Access Discrepancy:** A key with permissions for `/api/v1/read_data` suddenly attempting access to `/api/v1/admin/modify_user` will trigger an immediate high-severity alert, even if the attempt fails due to `Permission Scoper` restrictions. This indicates a potential attempt at privilege escalation or reconnaissance.
    *   **User Agent & Header Fingerprinting:** It learns the typical `User-Agent` strings, `Referer` headers, and other request metadata associated with a key. Any significant deviation can indicate a hijacked key or an unauthorized application.
    *   **Data Exfiltration Heuristics:** For keys capable of data retrieval, the AADE monitors the *volume and type* of data being accessed. An unusual spike in data transfer for a key usually fetching small analytical summaries might suggest an attempt to exfiltrate large datasets.
*   **Proactive Threat Intelligence Integration (PTI):** The Auditor is fed real-time threat intelligence from external watchtowers (global security feeds). If an IP address, a range, or even a specific attack vector is identified as hostile globally, and any key shows activity from it, the PTI flags it instantly. This includes compromised VPN endpoints, known TOR exit nodes, or IPs associated with recent CVE exploits.
*   **Automated Incident Triage & Scoring:** Each detected anomaly is not just an alert; it's a meticulously scored incident. A machine learning model assesses the severity based on multiple factors: the key's sensitivity, the data it accessed, the historical patterns of the calling entity, the geographic distance, the type of anomaly, and the current global threat level. Incidents are prioritized into Critical, High, Medium, Low, and Informational.
*   **Historical Behavior Baselines:** The Auditor maintains an immutable ledger of every key's historical performance. This baseline allows for robust long-term trend analysis, enabling the detection of slow, insidious changes in usage patterns that might indicate a compromised key being "tested" before a major attack.
*   **Self-Healing & Remediation Triggers:** The Auditor, upon detecting a critical anomaly, doesn't just alert. It can be configured to trigger automated responses:
    *   **Temporary Suspension:** A key showing highly suspicious activity can be temporarily deactivated for a review period.
    *   **Permission Downgrade:** If a key's legitimate use doesn't require certain permissions, but it repeatedly attempts to use them (even unsuccessfully), the system might suggest or automatically reduce its scope.
    *   **MFA Challenge:** For developer keys linked to user accounts, a suspicious login or key usage might trigger an MFA challenge for the associated developer before further actions are allowed.
    *   **Quarantine Environment:** In extreme cases, a key's requests can be routed to a sandboxed environment for further analysis, preventing actual data access while allowing observation of attack vectors.

##### B. The Permission Scoper: The Master Locksmith of Granular Authority

The **Permission Scoper Grandmaster** crafts keys with such precision that each is a unique artifact, opening only the exact doors required, and only in the exact manner prescribed. Its capabilities extend far beyond simple read/write.

*   **Attribute-Based Access Control (ABAC) Integration:** Permissions are not just tied to resources but to attributes of the request, the resource, and the user.
    *   **Resource Attributes:** A key might access `documents` but only `documents` tagged `project:alpha` and `status:approved`.
    *   **Caller Attributes:** A key generated for a specific `environment:staging` cannot access production data. A key for `region:EU` cannot access data from `region:US`.
    *   **Time-Based Conditions:** A key is only valid between 9 AM and 5 PM GMT.
    *   **IP-Based Restrictions:** The key is only valid if requests originate from a specific CIDR block (e.g., the corporate VPN).
    *   **Request Method Restrictions:** Allows `GET` and `POST` but not `DELETE` on a specific endpoint.
    *   **Data Masking/Redaction Policies:** Even if a key can read `user_profiles`, it might only be able to view non-PII fields. PII fields like `email` or `phone_number` are automatically masked or redacted based on the key's scope.
*   **Dynamic Scoping & Contextual Policies:** Permissions can adapt based on the *context* of the request.
    *   **Workflow-Driven Permissions:** A key used in a multi-step workflow might gain temporary additional permissions only after a specific previous step is completed (e.g., after an `order` is `placed`, a `fulfillment` key gains access to `shipping` endpoints for that specific order).
    *   **Rate Limiting by Endpoint/Method:** Granular rate limits for specific endpoints, not just overall key usage. A key might be allowed 1000 `GET /data` requests per minute but only 10 `POST /update_status` requests per minute.
*   **Policy-as-Code (PaC) Enforcement:** Key policies are defined using declarative languages (e.g., OPA Rego, YAML schemas) stored in version control. This ensures auditability, reproducibility, and prevents "drift" in key permissions.
*   **Inheritance & Hierarchical Scoping:**
    *   **Parent-Child Key Derivation:** A "master" key can issue "child" keys with a subset of its own permissions. If the parent key is revoked, all children are automatically revoked. This is ideal for delegating access to third-party integrations that themselves need to issue sub-keys.
    *   **Project/Team Scoping:** Keys can be associated with projects or teams, inheriting baseline permissions from the project and then further refined.
*   **Least Privilege Recommender (LPR):** A machine learning component that analyzes historical usage of a key and suggests reducing its permissions if it consistently doesn't utilize certain granted scopes. It identifies "over-privileged" keys and provides actionable recommendations.
*   **Permission Simulation Engine:** Before a key is generated or modified, the Scribe can use a simulation engine to test the exact access profile. "If I grant this key `read:users` and `write:products`, what happens if it tries to `delete:orders`?" The engine provides an immediate, definitive answer.

##### C. The Code Snippet Generator: The Apprentice's Masterful Quill

The Apprentice, now the **Omni-Lingual Code Snippet Architect**, generates not just basic examples but comprehensive integration kits tailored for diverse development environments.

*   **Multi-Language & Framework Support:** Generates snippets for a wide array of languages (Python, Node.js, Go, Java, Ruby, PHP, C#) and common frameworks/libraries (e.g., `requests` in Python, `fetch` in JavaScript, Spring WebClient in Java).
*   **SDK Integration Commands:** Provides direct commands or configuration files for integrating the API key with platform-specific SDKs, if applicable.
*   **Environment Variable Integration:** Snippets are designed to encourage best practices, prompting developers to store keys as environment variables or secrets, rather than hardcoding.
*   **Authentication Flow Examples:** Beyond just passing the key in a header, it provides examples for different authentication schemes supported by the platform (e.g., `Bearer` token for OAuth, custom schemes).
*   **OpenAPI/Swagger Definition Generation:** For complex APIs, it can generate or update OpenAPI specifications, including the security schemes for the newly issued key, making it immediately usable with tools like Postman or Insomnia.
*   **Terraform/CloudFormation Snippets for Secret Management:** For infrastructure-as-code users, it generates snippets to securely store and inject API keys into cloud environments (e.g., AWS Secrets Manager, HashiCorp Vault, Kubernetes Secrets).
*   **Interactive Tutorial Links:** For each key, it can link to context-sensitive interactive tutorials or documentation sections that explain the specific endpoints and data models accessible by that key's permissions.

##### D. The Public Leak Detector: The Kingdom's Eyes and Ears Beyond the Walls

The **Global Sentinel Leak Detector** operates with relentless vigilance, employing a vast network of informants and advanced surveillance techniques to find keys that escape the kingdom's secure walls.

*   **Multi-Vector Scanning:** Scans an exponentially wider range of public and dark web sources:
    *   **Code Repositories:** GitHub, GitLab, Bitbucket (public and private repos with appropriate integrations), and pastebins.
    *   **Public S3 Buckets & Cloud Storage:** Misconfigured public cloud storage.
    *   **Forums & Messaging Platforms:** Developer forums, Discord, Slack, IRC, Reddit, Stack Overflow, and private channels it can access.
    *   **Public Logs & Dumps:** Publicly accessible log files, database dumps, and compromised data caches.
    *   **CVE Databases & Exploit Kits:** Monitoring for vulnerabilities that could expose keys.
    *   **Deep Web & Dark Web Forums:** Using specialized indexing and natural language processing to detect mentions or sales of kingdom keys.
*   **Advanced Key Fingerprinting & Obfuscation Detection:** It doesn't just look for exact key strings. It uses entropy analysis, regex patterns, and machine learning models to identify API key *patterns* even if parts are masked, obfuscated, or embedded within larger strings. It can identify patterns even if a key is split into multiple parts.
*   **Proactive Credential Monitoring:** For enterprise clients, it can integrate with identity providers to monitor for compromised user credentials that might be linked to API key access.
*   **Rapid Remediation & Alerting Workflow:** Upon detection, the system triggers an immediate, multi-channel alert (SMS, email, PagerDuty, Slack) to the Scribe. It provides a direct link to the key's management page for instant revocation or rotation.
*   **False Positive Reduction:** Employs sophisticated heuristics and contextual analysis to minimize false positives, preventing "alert fatigue" for the Scribe. It learns from past remediations and Scribe feedback.
*   **Post-Mortem & Root Cause Analysis Integration:** After a leak is detected and remediated, the system guides the Scribe through a root cause analysis process, recording findings and recommending preventative measures.

#### II. The Lifecycle of a Key: From Genesis to Oblivion

The journey of an API key is a predefined path within the kingdom, governed by strict protocols and intelligent automation.

##### A. The Genesis Chamber: Forging a New Key

1.  **Intent & Purpose Declaration:** The Scribe must clearly state the key's purpose (e.g., "Third-party analytics integration," "Mobile app backend," "Internal reporting tool"). This declaration informs the Permission Scoper and Usage Log Auditor.
2.  **Permission Scoper Consultation:** The Scribe specifies required permissions. The Scoper then offers a "minimum viable permissions" recommendation, highlighting any potentially over-generous grants.
3.  **Policy & Constraint Application:**
    *   **Expiration Date:** Keys can be set to expire after a certain period (e.g., 90 days for temporary access, 1 year for production integrations). This encourages regular rotation.
    *   **Renewal Policy:** Automated renewal notifications and processes before expiration.
    *   **Access Origin Restrictions:** IP allowlists/denylists, geographic restrictions.
    *   **Rate Limiting Profiles:** Selection of predefined rate limit tiers (e.g., "bursty," "sustained-high," "low-volume").
    *   **Associated Identity:** Linking the key to a specific user, team, application, or service account within the kingdom's identity management system.
4.  **Generation & Encryption:** The key is generated using cryptographically secure random number generators (CSPRNG), encrypted at rest using KMS (Key Management Service) integration, and its hash is stored for integrity checks. The raw key is displayed *only once* at creation.
5.  **Metadata Tagging:** Rich metadata is attached: `owner`, `project`, `environment` (dev, staging, prod), `description`, `contact_email`, `compliance_tags` (e.g., `GDPR_relevant`, `HIPAA_data`).

##### B. The Active Watch: Monitoring and Governance

1.  **Real-time Activity Dashboard:** A live feed displaying key usage: requests per second, data transfer, error rates, top endpoints, geographical origin.
2.  **Alerting & Notification Engine:** Configurable alerts based on:
    *   Usage anomalies (from AADE).
    *   Approaching expiration dates.
    *   Rate limit breaches.
    *   Unsuccessful permission attempts (indicating potential misuse or misconfiguration).
    *   Leak detection (from Global Sentinel Leak Detector).
3.  **Key Health Score:** Each key is assigned a dynamic health score based on its usage patterns, security posture, and compliance with policies. A low score triggers further investigation.
4.  **Compliance Reporting:** Automated generation of reports demonstrating adherence to regulatory requirements (e.g., "List all keys accessing PII data," "Show all keys without IP restrictions").
5.  **Audit Trail of Modifications:** Every change to a key (permission updates, policy changes, status changes) is logged immutably, including who made the change and when.

##### C. The Sunset Protocols: Deactivation, Revocation, and Rotation

1.  **Graceful Deactivation:** Keys can be temporarily deactivated. Requests using a deactivated key receive a specific error code (e.g., 403 Forbidden - Key Deactivated) allowing for easy troubleshooting.
2.  **Instant Revocation:** For compromised or malicious keys, instant revocation is paramount. This immediately invalidates the key globally. The revocation is propagated through a high-speed, distributed key distribution system.
3.  **Scheduled Expiration & Renewal:** When a key approaches its expiration, automated notifications are sent. The Scribe can then renew the key, rotate it, or allow it to expire.
4.  **Key Rotation Enforcement:** For high-security keys, mandatory rotation policies can be enforced (e.g., every 90 days). The system can automate the creation of a new key and provide a grace period for the old key to remain active, facilitating a smooth transition.
5.  **Revocation List Distribution:** A secure, cryptographically signed revocation list is maintained and distributed to all API gateways and service meshes to ensure immediate enforcement across the kingdom.
6.  **"Break Glass" Procedure:** For extreme emergencies (e.g., a systemic security breach), a "panic button" allows for the instantaneous revocation of ALL API keys, with immediate alerts to all relevant Scribes and security personnel.

#### III. Developer Experience: Empowering the Builders

The Scribe understands that the keys are meant for builders. A robust API Key View is not just about security, but also about enabling developers to integrate seamlessly and securely.

##### A. Comprehensive Developer Portals

*   **Interactive Documentation:** Dynamic, API-key-aware documentation. When a developer selects their key, the documentation adapts to show only the endpoints and data they have access to, complete with personalized code snippets.
*   **Sandbox Environments:** Developers can test their integrations with a dedicated sandbox key that interacts with mocked or sample data, separate from production.
*   **Webhook Management:**
    *   **Event Subscription:** Developers can subscribe their applications to specific events (e.g., `order.created`, `user.updated`) and configure webhooks to receive real-time notifications, often secured with the API key or signed payloads.
    *   **Delivery Logs & Retries:** Detailed logs of webhook delivery attempts, status codes, and automatic retry mechanisms.
    *   **Secret Rotation for Webhooks:** Mechanism for rotating webhook secrets to ensure ongoing security of notification channels.
*   **SDKs and Libraries:** Comprehensive, officially supported SDKs for popular languages, abstracting away authentication and request signing complexities, automatically configured with generated API keys.
*   **Postman/Insomnia Collections:** Automatically generated and updated API collections that can be imported directly into popular API development environments, pre-configured with the developer's API keys and environments.
*   **Client Credential Flows (OAuth 2.0):** For applications that require user delegation, the system supports OAuth 2.0 client credentials grant, where the API key acts as the client ID/secret, enabling a secure token exchange.

##### B. Integrated Development Environment (IDE) Plugins

*   **Key Injection:** Plugins for popular IDEs (VS Code, IntelliJ) that can securely inject API keys into local development environments as environment variables, eliminating the need to copy-paste.
*   **Linting & Security Scans:** Real-time feedback within the IDE warning developers against hardcoding API keys, checking for insecure usage patterns, and suggesting best practices.
*   **Direct Access to Key Dashboards:** Developers can view usage stats, status, and associated documentation for their keys directly from their IDE.

#### IV. The Kingdom's Infrastructure: Underpinning the Scribe's Workshop

The underlying architecture supporting this advanced API Key View is a testament to resilience, scalability, and security.

##### A. Distributed Key Management System (DKMS)

*   **Microservices Architecture:** The API Key Management system is decomposed into several specialized microservices:
    *   `KeyGeneratorService`: Handles cryptographic key generation.
    *   `PolicyEnforcementService`: Manages and applies permission scopes and policies.
    *   `UsageTrackingService`: Ingests and processes all API usage logs.
    *   `AnomalyDetectionService`: Runs ML models on usage data.
    *   `KeyVaultService`: Securely stores encrypted key metadata and references to secrets.
    *   `NotificationService`: Handles all alerts and communications.
    *   `LeakDetectionService`: Orchestrates external scanning.
    *   `AuditLogService`: Maintains immutable records of all key events.
*   **Global Distribution & Edge Caching:** Keys are securely distributed and cached at edge locations globally (e.g., API Gateways, CDN edge functions) to minimize latency for policy enforcement and maximize resilience.
*   **Hardware Security Modules (HSMs) / Key Management Systems (KMS):** All master keys used to encrypt API keys at rest are secured within FIPS 140-2 Level 3 compliant HSMs or cloud KMS providers. This ensures that even if the underlying storage is compromised, the keys remain encrypted.
*   **Zero-Trust Network Access:** The internal services of the API Key Management system operate under a zero-trust model, with mTLS (mutual TLS) and stringent network policies applied between all components.

##### B. Data Backbone: Immutable Ledgers and Real-time Streams

*   **Immutable Audit Logs:** All key lifecycle events, permission changes, and critical security alerts are written to an append-only, tamper-evident ledger (e.g., blockchain-inspired ledger, or a highly secured Kafka/Kinesis stream to an immutable S3 bucket/blob storage). This satisfies stringent compliance requirements.
*   **Real-time Telemetry & Metrics:** API gateway logs, application logs, and security events are streamed in real-time to a central observability platform (e.g., Prometheus/Grafana, ELK Stack) for immediate monitoring and anomaly detection.
*   **Data Lake for Analytics:** A vast data lake collects all raw usage data, enabling long-term trend analysis, historical investigations, and training of new machine learning models for anomaly detection and permission recommendations.

##### C. Resilience and High Availability

*   **Multi-Region Deployment:** The entire API Key Management infrastructure is deployed across multiple geographic regions, with active-active configurations, ensuring continuous operation even in the event of a regional outage.
*   **Automated Failover & Disaster Recovery:** Sophisticated orchestration ensures automated failover of services and databases, with recovery point objectives (RPO) and recovery time objectives (RTO) measured in seconds to minutes.
*   **Chaos Engineering:** Regular "chaos day" exercises are conducted to deliberately introduce failures into the system, testing its resilience and identifying weak points before they become real problems.

#### V. The Scribe's Council: Collaboration and Delegation

Managing the kingdom's keys is a collaborative effort. The ApiKeysView supports complex organizational structures.

##### A. Role-Based Access Control (RBAC) for Key Management

*   **Granular Roles:** Defines roles like "Key Administrator" (full control), "Key Manager" (generate, revoke, modify), "Key Auditor" (read-only access to usage and audit logs), "Developer" (manage own keys within project scope), "Security Officer" (override and emergency revocation).
*   **Organizational Units (OUs) & Project Scopes:** Key management responsibilities can be delegated to specific teams or projects. A project lead can manage keys only for their project, while a global admin oversees all.

##### B. Approval Workflows for High-Risk Operations

*   **Multi-Party Approval:** For highly sensitive operations (e.g., generating a key with access to PII, granting administrative scopes, revoking a critical production key), a multi-party approval workflow can be enforced, requiring sign-off from multiple Scribes or security officers.
*   **Time-Limited Approvals:** Approvals can have an expiration time, ensuring timely review and preventing stale approval requests.
*   **Auditability of Approvals:** All approvals and rejections are meticulously logged in the immutable audit trail.

##### C. Integrated Communication Channels

*   **In-Platform Messaging:** Secure messaging system within the platform to discuss key requests, approvals, or security incidents directly.
*   **Integration with Collaboration Tools:** Direct integration with Slack, Microsoft Teams, Jira, etc., for alerts, incident management, and approval requests.

#### VI. Advanced Security Posture: Beyond the Basics

The kingdom's security is a continuous endeavor, requiring foresight and adaptive measures.

##### A. Quantum-Resistant Cryptography Readiness

*   **Hybrid Key Schemes:** Research and development into hybrid cryptographic schemes that combine classical and post-quantum algorithms, preparing the system for the eventual threat of quantum computers.
*   **Algorithm Agility:** The underlying crypto libraries are designed for algorithm agility, allowing for seamless updates to new, stronger, or quantum-resistant algorithms as they emerge.

##### B. Federated Identity and Decentralized Keys

*   **Verifiable Credentials (VCs) & DIDs (Decentralized Identifiers):** Exploring the use of decentralized identity paradigms where API keys are represented as VCs issued to DIDs, providing greater user control and verifiable trust.
*   **Self-Sovereign Identity (SSI) for API Access:** Allowing external services to present self-sovereign identities, with API access policies based on verifiable claims from their DIDs, reducing reliance on centralized key issuance.

##### C. AI-Driven Threat Hunting

*   **Predictive Analytics:** Beyond anomaly detection, the AI actively hunts for emerging threats by analyzing global threat intelligence, internal usage patterns, and behavioral economics, predicting potential attack vectors against API keys before they manifest.
*   **Scenario-Based Simulation:** Running "what if" scenarios to assess the impact of theoretical attacks on the API key ecosystem and identify vulnerabilities in the current policy framework.

#### VII. The Economic Nexus: Keys and the Kingdom's Prosperity

In a thriving kingdom, knowledge and access are also tied to prosperity. The API keys are not just about security but also about enabling business growth.

##### A. Monetization & Billing Integration

*   **Usage-Based Billing:** API key usage is directly integrated with the kingdom's billing system. Different keys or different permission scopes can be tied to different pricing tiers (e.g., premium data access, high-volume throughput).
*   **Tiered Access Models:** API keys can enforce tiered access, where certain features or higher rate limits are only available to keys belonging to specific subscription plans.
*   **Cost Attribution & Reporting:** Detailed reports on API usage costs per key, per project, per team, allowing for accurate internal chargebacks or client billing.
*   **Quota Management:** Beyond simple rate limits, API keys can be assigned quotas for specific resource consumption (e.g., number of records processed, amount of storage used), with alerts and automated actions upon nearing or exceeding quotas.

##### B. Business Intelligence & Strategic Insights

*   **API Product Analytics:** Aggregated, anonymized API key usage data provides valuable insights into API product adoption, feature popularity, and overall developer engagement, informing product roadmaps.
*   **Ecosystem Health Monitoring:** Observing the usage patterns of keys issued to partners and third-party developers helps gauge the health and growth of the platform's external ecosystem.
*   **Forecasting & Capacity Planning:** Historical usage data, coupled with growth projections, assists in forecasting future API traffic and planning infrastructure capacity.

#### VIII. The Scribe's Pledge: An Unwavering Commitment

The Royal Scribe, aided by the ever-evolving AI Security Suite, pledges unwavering commitment to the secure, intelligent, and efficient governance of the kingdom's keys. This `ApiKeysView` is not merely a tool; it is the embodiment of this pledge, a living, breathing system that adapts, protects, and empowers. It is the heart of access control, ensuring that the vast library of the platform's data remains both accessible to the worthy and impenetrable to the malicious. The keys, once simple tokens, have become conduits of trust, meticulously managed, and perpetually guarded.

This grand chronicle details the profound depth and breadth of the API Key Management system, transforming a critical technical function into a strategic cornerstone of the kingdom's digital sovereignty. Each line of code, each policy, each AI module is a brick in this fortress of knowledge, ensuring that the power of information serves its rightful masters, always and forever.

--- FILE: CliToolsView.tsx ---

import React, { useState, useEffect, useRef, useCallback, createContext, useContext } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";

// --- Global Context for CLI State (Simulated) ---
export interface CliContextType {
    executeCommand: (command: string) => Promise<CliCommandOutput>;
    history: CliCommand[];
    addCommandToHistory: (command: CliCommand) => void;
    currentWorkingDirectory: string;
    changeDirectory: (path: string) => void;
    notifications: CliNotification[];
    addNotification: (notification: Omit<CliNotification, 'id' | 'timestamp' | 'isRead'>) => void;
    markNotificationAsRead: (id: string) => void;
    unreadNotificationCount: number;
}

const CliContext = createContext<CliContextType | undefined>(undefined);

export const useCli = () => {
    const context = useContext(CliContext);
    if (context === undefined) {
        throw new Error('useCli must be used within a CliProvider');
    }
    return context;
};

// --- Data Models & Types ---

// 1. Core CLI entities
export interface CliCommand {
    id: string;
    command: string;
    timestamp: string;
    status: 'success' | 'error' | 'pending';
    output: string;
    durationMs: number;
    error?: string;
    contextPath?: string; // e.g., current working directory
    isAiGenerated?: boolean;
}

export interface CliCommandOutput {
    raw: string;
    parsed?: any; // JSON, table, etc.
    type: 'text' | 'json' | 'table' | 'error' | 'markdown' | 'chart' | 'clear';
    summary?: string;
    details?: string;
}

export interface CliScript {
    id: string;
    name: string;
    description: string;
    scriptContent: string; // The series of commands
    createdAt: string;
    updatedAt: string;
    tags: string[];
    author: string;
    isPublic: boolean;
    lastRun?: string;
    runCount: number;
    version: number;
}

export interface CliJob {
    id: string;
    scriptId: string;
    schedule: string; // e.g., "cron:0 0 * * *" or "once:YYYY-MM-DDTHH:MM:SS"
    status: 'scheduled' | 'running' | 'completed' | 'failed' | 'cancelled';
    lastRunAt?: string;
    nextRunAt?: string;
    logs: string[];
    createdAt: string;
    createdBy: string;
    repeatCount?: number;
    maxRetries: number;
    retryCount: number;
    description?: string;
    notificationEmails?: string[];
}

export interface CliPlugin {
    id: string;
    name: string;
    version: string;
    description: string;
    commands: string[]; // List of commands this plugin adds
    isActive: boolean;
    installationDate: string;
    settingsSchema: any; // JSON schema for plugin settings
    author: string;
    repoUrl?: string;
    documentationLink?: string;
}

// 2. AI related entities
export interface AiChatInteraction {
    id: string;
    timestamp: string;
    role: 'user' | 'assistant';
    content: string;
    commandGenerated?: string;
    followUpSuggestions?: string[];
}

export interface AiCommandSuggestion {
    command: string;
    confidence: number;
    explanation: string;
    parameters: { name: string, description: string, required: boolean }[];
}

export interface AiModelConfig {
    id: string;
    name: string;
    provider: string; // e.g., 'google', 'openai'
    modelId: string; // e.g., 'gemini-pro', 'gpt-4'
    description: string;
    isActive: boolean;
    costPerToken?: number;
}

// 3. System and Monitoring
export interface CliResourceMetric {
    timestamp: string;
    metricType: 'api_calls' | 'db_queries' | 'cpu_usage' | 'memory_usage' | 'network_io';
    value: number;
    unit: string;
    context: string; // e.g., "demobank payments list"
    tags?: string[];
}

export interface CliAuditLog {
    id: string;
    timestamp: string;
    userId: string;
    action: string; // e.g., "EXECUTE_COMMAND", "SAVE_SCRIPT", "SCHEDULE_JOB"
    targetId?: string; // e.g., command ID, script ID
    details: string;
    ipAddress: string;
    userAgent: string;
    success: boolean;
    error?: string;
    category: 'security' | 'operation' | 'configuration' | 'system';
}

export interface CliNotification {
    id: string;
    type: 'info' | 'warning' | 'error' | 'success';
    message: string;
    timestamp: string;
    isRead: boolean;
    link?: string;
    relatedJobId?: string;
    relatedCommandId?: string;
}

// 4. Component specific types
interface TerminalInputProps {
    onExecute: (command: string) => void;
    isLoading: boolean;
    commandHistory: string[];
    currentWorkingDirectory: string;
    autocompleteSuggestions: string[];
}

interface TerminalOutputProps {
    output: CliCommandOutput[];
    theme: string; // For dynamic styling based on theme
}

export interface CliSettingsData {
    aiModel: string;
    terminalTheme: 'dark' | 'light' | 'solarized-dark' | 'monokai';
    historyLimit: number;
    enableAutocomplete: boolean;
    notificationLevel: 'none' | 'info' | 'warning' | 'error';
    preferredOutputFormat: 'text' | 'json' | 'table';
    autoSaveScripts: boolean;
    defaultScriptTags: string[];
}

// --- Utility Functions (Embedded for line count) ---

/**
 * Generates a unique ID.
 * @returns A unique string.
 */
export const generateUniqueId = (prefix: string = 'id_'): string => `${prefix}${Math.random().toString(36).substr(2, 9)}_${Date.now()}`;

/**
 * Debounces a function call.
 * @param func The function to debounce.
 * @param delay The delay in milliseconds.
 * @returns A debounced version of the function.
 */
export const debounce = <T extends (...args: any[]) => any>(func: T, delay: number) => {
    let timeout: NodeJS.Timeout;
    return (...args: Parameters<T>): Promise<ReturnType<T>> => {
        return new Promise(resolve => {
            clearTimeout(timeout);
            timeout = setTimeout(() => resolve(func(...args)), delay);
        });
    };
};

/**
 * Throttle a function call.
 * @param func The function to throttle.
 * @param limit The time limit in milliseconds.
 * @returns A throttled version of the function.
 */
export const throttle = <T extends (...args: any[]) => any>(func: T, limit: number) => {
    let inThrottle: boolean;
    let lastResult: ReturnType<T>;
    return function (this: any, ...args: Parameters<T>) {
        if (!inThrottle) {
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
            lastResult = func.apply(this, args);
        }
        return lastResult;
    };
};

/**
 * Parses a CLI command string into components (command, subcommands, flags).
 * A more robust parser than the previous simple one.
 * @param commandString The full command string.
 * @returns An object containing parsed components.
 */
export const parseCliCommand = (commandString: string) => {
    const parts = commandString.trim().split(/(?<=^|\s)(?:(?:--?\w+(?:=\S+)?)|(?:'[^']*')|(?:"[^"]*")|(?:\S+))/g).filter(Boolean).map(p => p.trim());
    let command = '';
    const subcommands: string[] = [];
    const flags: { [key: string]: string | boolean } = {};
    const args: string[] = []; // positional arguments

    let isCommandPart = true;
    for (const part of parts) {
        if (part.startsWith('--')) {
            const [key, value] = part.substring(2).split('=');
            flags[key] = value !== undefined ? value : true;
            isCommandPart = false;
        } else if (part.startsWith('-')) { // single-dash short flags, assume no value unless next part isn't a flag
            const key = part.substring(1);
            flags[key] = true; // For now, assume boolean. In a full parser, would need to check definition.
            isCommandPart = false;
        } else if (isCommandPart) {
            if (!command) {
                command = part;
            } else {
                subcommands.push(part);
            }
        } else {
            // After flags, everything else is a positional argument
            args.push(part.replace(/^['"]|['"]$/g, '')); // Remove quotes from arguments
        }
    }

    return { command, subcommands, flags, args };
};

/**
 * Formats JSON output for display.
 * @param json The JSON object.
 * @param indent The indentation level.
 * @returns A formatted JSON string.
 */
export const formatJson = (json: any, indent: number = 2): string => {
    try {
        return JSON.stringify(json, null, indent);
    } catch (e) {
        return String(json);
    }
};

/**
 * Simple syntax highlighter for CLI commands.
 * Extended for more keywords and better flag detection.
 * @param text The command text.
 * @returns React nodes with styled spans.
 */
export const highlightCliSyntax = (text: string): React.ReactNode[] => {
    const parts: React.ReactNode[] = [];
    const keywords = ['demobank', 'payments', 'users', 'accounts', 'transactions', 'approve', 'list', 'create', 'update', 'delete', 'show', 'config', 'script', 'job', 'plugin', 'ai', 'audit', 'metrics', 'help', 'version', 'run', 'save', 'schedule', 'get', 'set', 'install', 'activate', 'deactivate'];
    const flagRegex = /(--?\w+)(?:=(?:(?:\"[^\"]*\")|(?:\'[^\']*\')|(?:\S+)))?/g; // Matches --flag=value or -f=value or --flag or -f
    const stringLiteralRegex = /"(.*?)"|'(.*?)'/g; // Matches "string" or 'string'

    let lastIndex = 0;
    const tokens: { value: string, type: 'keyword' | 'flag' | 'flag-value' | 'string' | 'text', index: number }[] = [];

    // Prioritize string literals
    let match;
    while ((match = stringLiteralRegex.exec(text)) !== null) {
        tokens.push({ value: match[0], type: 'string', index: match.index });
    }

    // Identify flags
    while ((match = flagRegex.exec(text)) !== null) {
        const fullMatch = match[0];
        const flagName = match[1];
        const flagValue = fullMatch.substring(flagName.length);
        tokens.push({ value: flagName, type: 'flag', index: match.index });
        if (flagValue) {
            tokens.push({ value: flagValue, type: 'flag-value', index: match.index + flagName.length });
        }
    }

    // Identify keywords
    const wordRegex = /\b\w+\b/g;
    while ((match = wordRegex.exec(text)) !== null) {
        if (keywords.includes(match[0])) {
            // Ensure this keyword isn't part of a flag or string already matched
            const isOverlap = tokens.some(token => token.index <= match.index && token.index + token.value.length > match.index);
            if (!isOverlap) {
                tokens.push({ value: match[0], type: 'keyword', index: match.index });
            }
        }
    }

    tokens.sort((a, b) => a.index - b.index);

    for (const token of tokens) {
        if (token.index > lastIndex) {
            parts.push(<span key={`text-${lastIndex}`} className="text-white">{text.substring(lastIndex, token.index)}</span>);
        }

        let className = 'text-white';
        if (token.type === 'keyword') className = 'text-purple-400 font-bold';
        else if (token.type === 'flag') className = 'text-blue-400';
        else if (token.type === 'flag-value') className = 'text-orange-400';
        else if (token.type === 'string') className = 'text-yellow-400';

        parts.push(<span key={`${token.type}-${token.index}`} className={className}>{token.value}</span>);
        lastIndex = token.index + token.value.length;
    }

    if (lastIndex < text.length) {
        parts.push(<span key={`text-${lastIndex}`} className="text-white">{text.substring(lastIndex)}</span>);
    }

    return parts;
};

/**
 * Simulates an API call to a backend service.
 * @param endpoint The API endpoint.
 * @param method The HTTP method.
 * @param body The request body.
 * @param delayMs Simulated network delay.
 * @returns A promise resolving to a simulated API response.
 */
const simulateApiCall = async (endpoint: string, method: string = 'GET', body?: any, delayMs: number = 300): Promise<any> => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log(`Simulating API call: ${method} ${endpoint}`, body);

            // Error scenarios
            if (endpoint.includes('/error')) {
                return resolve({ success: false, message: 'Simulated API error for requested endpoint.', status: 500 });
            }
            if (method === 'DELETE' && body?.id === 'non_existent') {
                return resolve({ success: false, message: 'Resource not found.', status: 404 });
            }

            // Authentication
            if (endpoint.includes('/auth/login')) {
                return resolve({ success: true, token: 'fake-jwt-token', user: { id: 'dev_user', name: 'Developer User', email: 'dev@demobank.com', role: 'admin' } });
            }

            // History
            if (endpoint.includes('/history')) {
                const dummyHistory: CliCommand[] = [
                    { id: generateUniqueId('h'), command: 'demobank payments list --status=pending', timestamp: new Date(Date.now() - 3600000).toISOString(), status: 'success', output: 'ID        AMOUNT\npo_001    100.00\npo_002    250.00', durationMs: 50, contextPath: '~' },
                    { id: generateUniqueId('h'), command: 'demobank payments approve po_001', timestamp: new Date(Date.now() - 1800000).toISOString(), status: 'success', output: ' Payment po_001 approved.', durationMs: 30, contextPath: '~' },
                    { id: generateUniqueId('h'), command: 'demobank users show dev_user', timestamp: new Date().toISOString(), status: 'success', output: formatJson({ id: 'dev_user', name: 'Developer User', email: 'dev@demobank.com', role: 'admin' }), durationMs: 70, contextPath: '~' },
                    { id: generateUniqueId('h'), command: 'demobank payments list --status=error', timestamp: new Date(Date.now() - 600000).toISOString(), status: 'error', output: 'Error: Invalid status value \'error\'.', durationMs: 45, error: 'Invalid status value', contextPath: '~' },
                ];
                return resolve({ success: true, data: dummyHistory, total: dummyHistory.length });
            }

            // Scripts
            if (endpoint.includes('/scripts')) {
                const dummyScripts: CliScript[] = [
                    { id: 's1', name: 'Approve Small Payments', description: 'Approves all pending payments under $100.', scriptContent: 'demobank payments list --status=pending --amount-lte=100 --json | jq \'.[] | .id\' | xargs -I {} demobank payments approve {}', createdAt: new Date(Date.now() - 86400000).toISOString(), updatedAt: new Date().toISOString(), tags: ['payments', 'automation'], author: 'dev_user', isPublic: false, runCount: 5, version: 1 },
                    { id: 's2', name: 'Daily User Report', description: 'Generates a report of active users.', scriptContent: 'demobank users list --active --json > active_users.json', createdAt: new Date(Date.now() - 2 * 86400000).toISOString(), updatedAt: new Date().toISOString(), tags: ['users', 'reporting'], author: 'dev_user', isPublic: true, runCount: 12, version: 2 },
                ];
                if (method === 'POST') {
                    return resolve({ success: true, message: 'Script created.', data: { ...body, id: generateUniqueId('s') } });
                }
                if (method === 'PUT' && body?.id) {
                    return resolve({ success: true, message: 'Script updated.', data: body });
                }
                if (method === 'DELETE') {
                    return resolve({ success: true, message: 'Script deleted.' });
                }
                return resolve({ success: true, data: dummyScripts, total: dummyScripts.length });
            }

            // Jobs
            if (endpoint.includes('/jobs')) {
                const dummyJobs: CliJob[] = [
                    { id: 'j1', scriptId: 's1', schedule: 'cron:0 1 * * *', status: 'scheduled', lastRunAt: new Date(Date.now() - 3 * 3600000).toISOString(), nextRunAt: new Date(Date.now() + 21 * 3600000).toISOString(), logs: ['Job created', 'Script s1 triggered', 'Script s1 completed successfully'], createdAt: new Date(Date.now() - 7 * 86400000).toISOString(), createdBy: 'dev_user', maxRetries: 3, retryCount: 0, description: 'Automated daily payment approval' },
                ];
                if (method === 'POST') {
                    return resolve({ success: true, message: 'Job scheduled.', data: { ...body, id: generateUniqueId('j') } });
                }
                if (endpoint.includes('/cancel')) {
                    return resolve({ success: true, message: 'Job cancelled.' });
                }
                return resolve({ success: true, data: dummyJobs, total: dummyJobs.length });
            }

            // Plugins
            if (endpoint.includes('/plugins')) {
                const dummyPlugins: CliPlugin[] = [
                    { id: 'p1', name: 'Reporting Toolkit', version: '1.2.0', description: 'Adds advanced reporting commands.', commands: ['demobank report daily', 'demobank report monthly'], isActive: true, installationDate: new Date(Date.now() - 30 * 86400000).toISOString(), settingsSchema: { type: 'object', properties: { format: { type: 'string', enum: ['pdf', 'csv'] } } }, author: 'Demobank Devs' },
                    { id: 'p2', name: 'User Management Extension', version: '0.9.1', description: 'Experimental commands for user lifecycle management.', commands: ['demobank user suspend', 'demobank user reactivate'], isActive: false, installationDate: new Date(Date.now() - 10 * 86400000).toISOString(), settingsSchema: {}, author: 'Community' },
                ];
                if (method === 'POST') {
                    return resolve({ success: true, message: 'Plugin installed.', data: { ...body, id: generateUniqueId('p') } });
                }
                if (endpoint.includes('/toggle')) {
                    return resolve({ success: true, message: `Plugin status updated for ${body.isActive ? 'active' : 'inactive'}.` });
                }
                return resolve({ success: true, data: dummyPlugins, total: dummyPlugins.length });
            }

            // Audit Logs
            if (endpoint.includes('/audit')) {
                const dummyAuditLogs: CliAuditLog[] = [
                    { id: generateUniqueId('a'), timestamp: new Date(Date.now() - 10000).toISOString(), userId: 'dev_user', action: 'EXECUTE_COMMAND', targetId: 'h3', details: 'demobank users show dev_user', ipAddress: '127.0.0.1', userAgent: 'Chrome', success: true, category: 'operation' },
                    { id: generateUniqueId('a'), timestamp: new Date(Date.now() - 20000).toISOString(), userId: 'dev_user', action: 'SAVE_SCRIPT', targetId: 's1', details: 'Script "Approve Small Payments" created', ipAddress: '127.0.0.1', userAgent: 'Chrome', success: true, category: 'configuration' },
                    { id: generateUniqueId('a'), timestamp: new Date(Date.now() - 30000).toISOString(), userId: 'dev_user', action: 'LOGIN', details: 'User logged in', ipAddress: '127.0.0.1', userAgent: 'Firefox', success: true, category: 'security' },
                ];
                return resolve({ success: true, data: dummyAuditLogs, total: dummyAuditLogs.length });
            }

            // Notifications
            if (endpoint.includes('/notifications')) {
                const dummyNotifications: CliNotification[] = [
                    { id: generateUniqueId('n'), type: 'info', message: 'Welcome to the new CLI Dashboard!', timestamp: new Date().toISOString(), isRead: false },
                    { id: generateUniqueId('n'), type: 'warning', message: 'Payment processing job failed for j1.', timestamp: new Date(Date.now() - 12 * 3600000).toISOString(), isRead: true, link: '/jobs/j1', relatedJobId: 'j1' },
                ];
                return resolve({ success: true, data: dummyNotifications, total: dummyNotifications.length });
            }

            // Metrics
            if (endpoint.includes('/metrics')) {
                const now = Date.now();
                const dummyMetrics: CliResourceMetric[] = [
                    { timestamp: new Date(now - 60000).toISOString(), metricType: 'api_calls', value: Math.floor(Math.random() * 50) + 10, unit: 'calls/min', context: 'demobank payments list' },
                    { timestamp: new Date(now - 60000).toISOString(), metricType: 'db_queries', value: Math.floor(Math.random() * 100) + 20, unit: 'queries/min', context: 'demobank payments list' },
                    { timestamp: new Date(now - 30000).toISOString(), metricType: 'cpu_usage', value: parseFloat((Math.random() * 50 + 10).toFixed(1)), unit: '%', context: 'system' },
                    { timestamp: new Date(now - 30000).toISOString(), metricType: 'memory_usage', value: parseFloat((Math.random() * 300 + 100).toFixed(1)), unit: 'MB', context: 'system' },
                ];
                return resolve({ success: true, data: dummyMetrics });
            }

            // Settings
            if (endpoint.includes('/settings')) {
                if (method === 'PUT') {
                    return resolve({ success: true, message: 'Settings updated successfully.', data: body });
                }
                const defaultSettings: CliSettingsData = {
                    aiModel: 'gemini-pro',
                    terminalTheme: 'dark',
                    historyLimit: 50,
                    enableAutocomplete: true,
                    notificationLevel: 'info',
                    preferredOutputFormat: 'text',
                    autoSaveScripts: true,
                    defaultScriptTags: ['utility'],
                };
                return resolve({ success: true, data: defaultSettings });
            }

            // Default success response
            resolve({ success: true, message: 'Simulated success', data: body });
        }, delayMs);
    });
};

/**
 * Simulates execution of a demobank CLI command.
 * @param command The command string.
 * @returns A promise resolving to CliCommandOutput.
 */
const simulateCliCommandExecution = async (command: string): Promise<CliCommandOutput> => {
    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 800)); // Simulate latency

    const commandLower = command.toLowerCase();
    let rawOutput: string;
    let parsedOutput: any | undefined;
    let outputType: CliCommandOutput['type'] = 'text';

    try {
        if (commandLower.includes('demobank payments list')) {
            const parsed = parseCliCommand(commandLower);
            const statusFilter = parsed.flags.status as string || 'pending';
            const amountLte = parsed.flags['amount-lte'] ? parseFloat(parsed.flags['amount-lte'] as string) : Infinity;
            const amountGte = parsed.flags['amount-gte'] ? parseFloat(parsed.flags['amount-gte'] as string) : -Infinity;
            const jsonFlag = parsed.flags.json === true;

            const payments = [
                { id: 'po_001', amount: 99.99, counterparty: 'Cloud Services Inc.', status: 'pending', created: '2023-01-01' },
                { id: 'po_002', amount: 250.00, counterparty: 'Supplier A', status: 'pending', created: '2023-01-05' },
                { id: 'po_003', amount: 1200.50, counterparty: 'Landlord Co.', status: 'approved', created: '2023-01-10' },
                { id: 'po_004', amount: 49.99, counterparty: 'Utility Co.', status: 'pending', created: '2023-01-15' },
                { id: 'po_005', amount: 500.00, counterparty: 'Vendor B', status: 'approved', created: '2023-01-20' },
                { id: 'po_006', amount: 75.00, counterparty: 'Telecom Ltd.', status: 'pending', created: '2023-01-22' },
            ];

            const filteredPayments = payments.filter(p =>
                (statusFilter === 'all' || p.status === statusFilter) &&
                p.amount >= amountGte &&
                p.amount <= amountLte
            );

            if (jsonFlag) {
                rawOutput = formatJson(filteredPayments);
                parsedOutput = filteredPayments;
                outputType = 'json';
            } else {
                rawOutput = 'ID        AMOUNT      COUNTERPARTY           STATUS    CREATED\n';
                rawOutput += '------------------------------------------------------------------\n';
                filteredPayments.forEach(p => {
                    rawOutput += `${p.id.padEnd(10)}${p.amount.toFixed(2).padEnd(12)}${p.counterparty.padEnd(23)}${p.status.padEnd(10)}${p.created}\n`;
                });
                outputType = 'table';
            }
        } else if (commandLower.includes('demobank payments approve')) {
            const idMatch = commandLower.match(/demobank payments approve (\w+)/);
            const paymentId = idMatch ? idMatch[1] : null;
            if (paymentId) {
                rawOutput = ` Payment order ${paymentId} approved.`;
            } else {
                rawOutput = `Error: Missing payment ID. Usage: demobank payments approve <payment_id>`;
                throw new Error(rawOutput);
            }
        } else if (commandLower.includes('demobank users show')) {
            const idMatch = commandLower.match(/demobank users show (\w+)/);
            const userId = idMatch ? idMatch[1] : 'dev_user';
            const user = {
                id: userId,
                name: userId === 'dev_user' ? 'Developer User' : 'Unknown User',
                email: `${userId}@demobank.com`,
                role: 'developer',
                status: 'active',
                lastLogin: new Date().toISOString(),
                permissions: ['payments:read', 'scripts:manage', 'jobs:view', `user:${userId}:manage`]
            };
            rawOutput = formatJson(user);
            parsedOutput = user;
            outputType = 'json';
        } else if (commandLower.includes('demobank config get')) {
            const keyMatch = commandLower.match(/demobank config get (\w+)/);
            const key = keyMatch ? keyMatch[1] : 'unknown';
            const config = {
                'api-endpoint': 'https://api.demobank.com/v1',
                'cli-version': '1.5.2',
                'default-currency': 'USD',
                'log-level': 'info',
                'region': 'us-east-1',
            };
            if (config[key as keyof typeof config]) {
                rawOutput = config[key as keyof typeof config];
            } else {
                rawOutput = `Error: Configuration key '${key}' not found.`;
                throw new Error(rawOutput);
            }
        } else if (commandLower.includes('demobank config set')) {
            const match = commandLower.match(/demobank config set (\w+)=(\S+)/);
            if (match) {
                const key = match[1];
                const value = match[2];
                rawOutput = `Configuration key '${key}' set to '${value}'. (Simulated)`;
            } else {
                rawOutput = `Error: Invalid usage. Usage: demobank config set <key>=<value>`;
                throw new Error(rawOutput);
            }
        } else if (commandLower.includes('ls') || commandLower.includes('dir')) {
            rawOutput = `scripts/\njobs/\nplugins/\nhistory.log\nconfig.json\nREADME.md\n`;
        } else if (commandLower.includes('cd')) {
            rawOutput = `Changed directory. (Simulated)`;
        } else if (commandLower.includes('help')) {
            rawOutput = `demobank CLI Help:
Available commands:
  payments     - Manage payment orders (list, approve, create, show).
  users        - Manage user accounts (list, create, show, update, delete).
  accounts     - Manage bank accounts.
  transactions - View transaction history.
  scripts      - Manage CLI scripts (list, save, run, delete).
  jobs         - Manage scheduled CLI jobs (list, schedule, cancel, show).
  config       - Manage CLI configuration (list, get, set, reset).
  plugins      - Manage CLI plugins (list, install, activate, deactivate, show).
  ai           - Interact with AI assistant (chat, generate, explain, debug).
  audit        - View audit logs (list, show, export).
  metrics      - View resource metrics (show, history).
  help         - Get help on commands.
  version      - Display CLI version.

Use 'demobank <command> --help' for more details.`;
        } else if (commandLower.includes('demobank ai chat')) {
            const messageMatch = commandLower.match(/--message "([^"]+)"|--message (\S+)/);
            const message = messageMatch ? (messageMatch[1] || messageMatch[2]) : 'Hello AI';
            rawOutput = `AI: I'm currently processing your request: "${message}". In a real scenario, I'd provide a detailed response or command suggestion.`;
        } else if (commandLower.includes('demobank script run')) {
            const scriptIdMatch = commandLower.match(/demobank script run (\w+)/);
            const scriptId = scriptIdMatch ? scriptIdMatch[1] : null;
            if (scriptId) {
                rawOutput = `Running script ${scriptId}... (Simulated)`;
            } else {
                rawOutput = `Error: Missing script ID. Usage: demobank script run <script_id>`;
                throw new Error(rawOutput);
            }
        } else if (commandLower.includes('clear')) {
            rawOutput = 'CLEAR_COMMAND_SIGNAL'; // Special signal for clearing terminal
            outputType = 'clear';
        } else if (commandLower.includes('demobank audit list')) {
            const response = await simulateApiCall('/api/audit', 'GET', null, 200);
            if (response.success) {
                rawOutput = formatJson(response.data.map((log: CliAuditLog) => ({ id: log.id, action: log.action, userId: log.userId, timestamp: log.timestamp.substring(11, 19), success: log.success })));
                parsedOutput = response.data;
                outputType = 'json';
            } else {
                rawOutput = `Error fetching audit logs: ${response.message}`;
                outputType = 'error';
            }
        }
        else {
            rawOutput = `Error: Command not found or not supported in simulation: "${command}". Try 'demobank payments list' or 'help'.`;
            throw new Error(rawOutput);
        }
    } catch (error: any) {
        rawOutput = error.message || `Unknown error during command execution: ${command}`;
        outputType = 'error';
    }

    const durationMs = Date.now() - (Date.now() - (200 + Math.random() * 800)); // approximate duration

    return {
        raw: rawOutput,
        parsed: parsedOutput,
        type: outputType,
        summary: rawOutput.split('\n')[0].substring(0, 100) + (rawOutput.length > 100 ? '...' : ''),
        details: rawOutput,
    };
};

// --- CLI Components ---

/**
 * Renders a single command output line in the terminal.
 * Handles different output types (text, JSON, table).
 */
export const CliOutputLine: React.FC<{ output: CliCommandOutput; theme: string }> = ({ output, theme }) => {
    const textColor = theme === 'light' ? 'text-gray-900' : 'text-white';
    const jsonColor = theme === 'light' ? 'text-blue-700' : 'text-cyan-300';
    const errorColor = theme === 'light' ? 'text-red-700' : 'text-red-400';
    const tableHeaderBg = theme === 'light' ? 'bg-gray-100' : 'bg-gray-800';
    const tableRowBg = theme === 'light' ? 'bg-white' : 'bg-gray-900';
    const tableBorder = theme === 'light' ? 'border-gray-300' : 'border-gray-800';
    const tableTextColor = theme === 'light' ? 'text-gray-800' : 'text-white';
    const tableHeaderTextColor = theme === 'light' ? 'text-gray-600' : 'text-gray-400';

    const renderContent = () => {
        if (output.type === 'json' && output.parsed) {
            return (
                <pre className={`${jsonColor} whitespace-pre-wrap`}>
                    {formatJson(output.parsed)}
                </pre>
            );
        }
        if (output.type === 'table') {
            const lines = output.raw.split('\n');
            if (lines.length > 1) {
                const headers = lines[0].split(/\s{2,}/).filter(Boolean); // Split by 2+ spaces
                const data = lines.slice(2); // Skip header and separator

                return (
                    <div className="overflow-x-auto">
                        <table className={`min-w-full divide-y ${tableBorder} text-sm`}>
                            <thead>
                                <tr>
                                    {headers.map((h, i) => (
                                        <th key={i} className={`px-4 py-2 text-left text-xs font-medium ${tableHeaderTextColor} uppercase tracking-wider ${tableHeaderBg}`}>
                                            {h}
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody className={`${tableRowBg} divide-y ${tableBorder}`}>
                                {data.map((line, rowIndex) => {
                                    const cells = line.split(/\s{2,}/).filter(Boolean);
                                    return (
                                        <tr key={rowIndex}>
                                            {cells.map((cell, cellIndex) => (
                                                <td key={cellIndex} className={`px-4 py-2 whitespace-nowrap ${tableTextColor}`}>
                                                    {cell}
                                                </td>
                                            ))}
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                );
            }
        }
        if (output.type === 'error') {
            return <p className={errorColor}>{output.raw}</p>;
        }
        return <p className={`${textColor} whitespace-pre-wrap`}>{highlightCliSyntax(output.raw)}</p>;
    };

    return (
        <div className="mt-1">
            {renderContent()}
        </div>
    );
};

/**
 * Displays the output history of the CLI terminal.
 */
export const TerminalOutput: React.FC<TerminalOutputProps> = ({ output, theme }) => {
    const outputRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (outputRef.current) {
            outputRef.current.scrollTop = outputRef.current.scrollHeight;
        }
    }, [output]);

    const bgColor = theme === 'light' ? 'bg-gray-50' : 'bg-black';

    return (
        <div ref={outputRef} className={`flex-grow ${bgColor} p-4 rounded-b-lg font-mono text-sm overflow-y-auto custom-scrollbar`}>
            {output.map((out, index) => (
                <div key={index} className="mb-2">
                    <CliOutputLine output={out} theme={theme} />
                </div>
            ))}
        </div>
    );
};

/**
 * The input component for the CLI terminal, handles command entry and history.
 */
export const TerminalInput: React.FC<TerminalInputProps> = ({ onExecute, isLoading, commandHistory, currentWorkingDirectory, autocompleteSuggestions }) => {
    const [inputValue, setInputValue] = useState('');
    const [historyIndex, setHistoryIndex] = useState(-1);
    const [suggestionIndex, setSuggestionIndex] = useState(-1);
    const inputRef = useRef<HTMLInputElement>(null);
    const { notifications, addNotification } = useCli(); // Access notifications to add errors

    useEffect(() => {
        if (inputRef.current) {
            inputRef.current.focus();
        }
    }, [isLoading]);

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            if (isLoading) return;

            const commandToExecute = suggestionIndex > -1 && autocompleteSuggestions[suggestionIndex]
                ? autocompleteSuggestions[suggestionIndex]
                : inputValue;

            if (commandToExecute.trim()) {
                onExecute(commandToExecute);
                setInputValue('');
                setHistoryIndex(-1); // Reset history index
                setSuggestionIndex(-1); // Reset suggestion index
            }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (autocompleteSuggestions.length > 0 && suggestionIndex < autocompleteSuggestions.length - 1) {
                const newIndex = suggestionIndex + 1;
                setSuggestionIndex(newIndex);
                setInputValue(autocompleteSuggestions[newIndex]);
            } else if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                const newIndex = historyIndex + 1;
                setHistoryIndex(newIndex);
                setInputValue(commandHistory[commandHistory.length - 1 - newIndex]);
                setSuggestionIndex(-1); // Clear suggestion index when navigating history
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (autocompleteSuggestions.length > 0 && suggestionIndex > 0) {
                const newIndex = suggestionIndex - 1;
                setSuggestionIndex(newIndex);
                setInputValue(autocompleteSuggestions[newIndex]);
            } else if (autocompleteSuggestions.length > 0 && suggestionIndex === 0) {
                 setSuggestionIndex(-1);
                 setInputValue(''); // Clear input if at the end of suggestions
            } else if (historyIndex > 0) {
                const newIndex = historyIndex - 1;
                setHistoryIndex(newIndex);
                setInputValue(commandHistory[commandHistory.length - 1 - newIndex]);
            } else if (historyIndex === 0) {
                setHistoryIndex(-1);
                setInputValue('');
            }
        } else if (e.key === 'Tab') {
            e.preventDefault();
            if (autocompleteSuggestions.length > 0) {
                const nextSuggestionIndex = (suggestionIndex + 1) % autocompleteSuggestions.length;
                setSuggestionIndex(nextSuggestionIndex);
                setInputValue(autocompleteSuggestions[nextSuggestionIndex]);
            }
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
        setHistoryIndex(-1); // Reset history index on new input
        setSuggestionIndex(-1); // Reset suggestion index on new input
    };

    const promptText = isLoading ? 'Executing...' : `Enter command (${currentWorkingDirectory})`;

    return (
        <div className="relative">
            <div className="flex bg-gray-800 p-2 rounded-t-lg border-b border-gray-700">
                <span className="select-none text-green-400 mr-2 font-bold">{currentWorkingDirectory} $</span>
                <input
                    ref={inputRef}
                    type="text"
                    className="flex-grow bg-transparent text-white focus:outline-none placeholder-gray-500"
                    value={inputValue}
                    onChange={handleChange}
                    onKeyDown={handleKeyDown}
                    placeholder={promptText}
                    disabled={isLoading}
                    spellCheck="false"
                />
            </div>
            {autocompleteSuggestions.length > 0 && (
                <div className="absolute z-10 w-full bg-gray-800 border border-gray-700 rounded-b-lg shadow-lg max-h-48 overflow-y-auto">
                    {autocompleteSuggestions.map((suggestion, index) => (
                        <div
                            key={index}
                            className={`px-4 py-2 text-sm text-gray-200 cursor-pointer hover:bg-cyan-700 ${index === suggestionIndex ? 'bg-cyan-700' : ''}`}
                            onClick={() => {
                                setInputValue(suggestion);
                                setSuggestionIndex(index);
                                inputRef.current?.focus();
                            }}
                        >
                            <span className="text-gray-500 mr-2">$</span> {highlightCliSyntax(suggestion)}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

/**
 * The main interactive CLI terminal component.
 */
export const CliTerminal: React.FC = () => {
    const { executeCommand, addCommandToHistory, currentWorkingDirectory, changeDirectory } = useCli();
    const [currentOutput, setCurrentOutput] = useState<CliCommandOutput[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [commandHistory, setCommandHistory] = useState<string[]>([]);
    const [autocompleteSuggestions, setAutocompleteSuggestions] = useState<string[]>([]);
    const [cliSettings, setCliSettings] = useState<CliSettingsData | null>(null);

    // Fetch settings on mount
    useEffect(() => {
        const fetchSettings = async () => {
            const response = await simulateApiCall('/api/settings', 'GET', null, 100);
            if (response.success) {
                setCliSettings(response.data);
            }
        };
        fetchSettings();
    }, []);

    const availableCommands = [
        'demobank payments list', 'demobank payments approve', 'demobank payments create', 'demobank payments show',
        'demobank users list', 'demobank users create', 'demobank users show', 'demobank users update', 'demobank users delete',
        'demobank config get', 'demobank config set', 'demobank help', 'demobank version', 'demobank script run',
        'demobank script save', 'demobank jobs schedule', 'demobank jobs list', 'demobank plugins list', 'demobank ai chat',
        'ls', 'cd', 'clear'
    ];

    const generateAutocomplete = useCallback(debounce((input: string) => {
        if (!cliSettings?.enableAutocomplete || !input) {
            setAutocompleteSuggestions([]);
            return;
        }
        const filtered = availableCommands.filter(cmd => cmd.startsWith(input));
        setAutocompleteSuggestions(filtered);
    }, 200), [cliSettings?.enableAutocomplete]);

    const handleCommandExecution = useCallback(async (command: string, isAiGenerated: boolean = false) => {
        setIsLoading(true);
        const startTime = Date.now();
        const commandId = generateUniqueId('cmd');

        // Update CLI history display first
        setCurrentOutput(prev => [...prev, { raw: `${currentWorkingDirectory} $ ${highlightCliSyntax(command).map(n => typeof n === 'string' ? n : n.props.children).join('')}`, type: 'text' }]);

        try {
            const result = await simulateCliCommandExecution(command);

            if (result.type === 'clear') {
                setCurrentOutput([]);
                // Still log the clear command in full history
                addCommandToHistory({
                    id: commandId,
                    command: command,
                    timestamp: new Date().toISOString(),
                    status: 'success',
                    output: 'Terminal cleared.',
                    durationMs: Date.now() - startTime,
                    contextPath: currentWorkingDirectory,
                    isAiGenerated: isAiGenerated,
                });
                return;
            }

            setCurrentOutput(prev => [...prev, result]);
            addCommandToHistory({
                id: commandId,
                command: command,
                timestamp: new Date().toISOString(),
                status: result.type === 'error' ? 'error' : 'success',
                output: result.summary || result.raw,
                durationMs: Date.now() - startTime,
                error: result.type === 'error' ? result.raw : undefined,
                contextPath: currentWorkingDirectory,
                isAiGenerated: isAiGenerated,
            });

            if (command.startsWith('cd ')) {
                const newPath = command.substring(3).trim();
                changeDirectory(newPath);
            }

        } catch (error: any) {
            const errorOutput: CliCommandOutput = {
                raw: error.message || 'Unknown error during command execution.',
                type: 'error',
                summary: 'Execution failed.',
                details: error.message,
            };
            setCurrentOutput(prev => [...prev, errorOutput]);
            addCommandToHistory({
                id: commandId,
                command: command,
                timestamp: new Date().toISOString(),
                status: 'error',
                output: errorOutput.summary || errorOutput.raw,
                durationMs: Date.now() - startTime,
                error: errorOutput.raw,
                contextPath: currentWorkingDirectory,
                isAiGenerated: isAiGenerated,
            });
        } finally {
            setIsLoading(false);
        }
    }, [addCommandToHistory, currentWorkingDirectory, changeDirectory, cliSettings]);

    return (
        <Card title="Interactive CLI Terminal" className="flex flex-col h-[500px]">
            <div className="flex-grow flex flex-col h-full">
                <TerminalInput
                    onExecute={handleCommandExecution}
                    isLoading={isLoading}
                    commandHistory={commandHistory} // Pass simple string history for input navigation
                    currentWorkingDirectory={currentWorkingDirectory}
                    autocompleteSuggestions={autocompleteSuggestions}
                />
                <TerminalOutput output={currentOutput} theme={cliSettings?.terminalTheme || 'dark'} />
            </div>
        </Card>
    );
};

/**
 * Component to display the history of executed commands.
 */
export const CliCommandHistory: React.FC = () => {
    const { history, executeCommand } = useCli();
    const [searchTerm, setSearchTerm] = useState('');
    const [filterStatus, setFilterStatus] = useState<'all' | 'success' | 'error'>('all');
    const [cliSettings, setCliSettings] = useState<CliSettingsData | null>(null);

    useEffect(() => {
        const fetchSettings = async () => {
            const response = await simulateApiCall('/api/settings', 'GET', null, 100);
            if (response.success) {
                setCliSettings(response.data);
            }
        };
        fetchSettings();
    }, []);

    const filteredHistory = history
        .filter(cmd =>
            cmd.command.toLowerCase().includes(searchTerm.toLowerCase()) &&
            (filterStatus === 'all' || cmd.status === filterStatus)
        )
        .slice(-(cliSettings?.historyLimit || 50)) // Apply history limit from settings
        .reverse(); // Show most recent first

    const handleReRun = (command: string) => {
        executeCommand(command);
    };

    return (
        <Card title="Command History" className="h-[500px] flex flex-col">
            <div className="flex mb-4 space-x-2">
                <input
                    type="text"
                    placeholder="Search commands..."
                    className="flex-grow bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    value={searchTerm}
                    onChange={e => setSearchTerm(e.target.value)}
                />
                <select
                    className="bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    value={filterStatus}
                    onChange={e => setFilterStatus(e.target.value as 'all' | 'success' | 'error')}
                >
                    <option value="all">All Statuses</option>
                    <option value="success">Success</option>
                    <option value="error">Error</option>
                </select>
            </div>
            <div className="flex-grow overflow-y-auto space-y-3 pr-2 custom-scrollbar">
                {filteredHistory.length === 0 ? (
                    <p className="text-gray-500 text-center py-4">No commands found.</p>
                ) : (
                    filteredHistory.map(cmd => (
                        <div key={cmd.id} className="bg-gray-800 p-3 rounded-lg border border-gray-700 hover:border-cyan-600 transition duration-200 ease-in-out">
                            <div className="flex justify-between items-start mb-1">
                                <p className="font-mono text-cyan-300 text-xs break-all mr-2">
                                    <span className={`inline-block w-2 h-2 rounded-full mr-2 ${cmd.status === 'success' ? 'bg-green-500' : cmd.status === 'error' ? 'bg-red-500' : 'bg-yellow-500'}`}></span>
                                    {cmd.contextPath || '~'} $ {highlightCliSyntax(cmd.command)}
                                    {cmd.isAiGenerated && <span className="ml-2 text-purple-400 text-xs">(AI)</span>}
                                </p>
                                <button
                                    onClick={() => handleReRun(cmd.command)}
                                    className="ml-auto p-1 text-xs text-blue-400 hover:text-blue-200"
                                    title="Re-run command"
                                >
                                    &#x21BB; {/* Unicode for a refresh/redo arrow */}
                                </button>
                            </div>
                            <p className="text-gray-400 text-xs italic">
                                {new Date(cmd.timestamp).toLocaleString()} | Duration: {cmd.durationMs}ms
                            </p>
                            {cmd.output && (
                                <details className="mt-1 text-xs text-gray-500">
                                    <summary className="cursor-pointer hover:text-gray-300">Output Summary</summary>
                                    <pre className="mt-1 p-2 bg-gray-900 rounded overflow-x-auto text-gray-300 whitespace-pre-wrap">
                                        {cmd.output.length > 500 ? cmd.output.substring(0, 500) + '...' : cmd.output}
                                    </pre>
                                </details>
                            )}
                            {cmd.error && (
                                <details className="mt-1 text-xs text-red-400">
                                    <summary className="cursor-pointer hover:text-red-300">Error Details</summary>
                                    <pre className="mt-1 p-2 bg-gray-900 rounded overflow-x-auto text-red-300 whitespace-pre-wrap">
                                        {cmd.error}
                                    </pre>
                                </details>
                            )}
                        </div>
                    ))
                )}
            </div>
        </Card>
    );
};

/**
 * A sophisticated script editor with features like saving, loading, and running scripts.
 */
export const CliScriptEditor: React.FC = () => {
    const { executeCommand, addNotification } = useCli();
    const [scripts, setScripts] = useState<CliScript[]>([]);
    const [currentScript, setCurrentScript] = useState<CliScript | null>(null);
    const [scriptContent, setScriptContent] = useState('');
    const [scriptName, setScriptName] = useState('');
    const [scriptDescription, setScriptDescription] = useState('');
    const [scriptTags, setScriptTags] = useState('');
    const [isPublic, setIsPublic] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [message, setMessage] = useState<{ type: 'success' | 'error', text: string } | null>(null);

    useEffect(() => {
        fetchScripts();
    }, []);

    const fetchScripts = async () => {
        setIsLoading(true);
        setMessage(null);
        try {
            const response = await simulateApiCall('/api/scripts', 'GET');
            if (response.success) {
                setScripts(response.data);
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to fetch scripts.' });
                addNotification({ type: 'error', message: `Failed to fetch scripts: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error fetching scripts.' });
            addNotification({ type: 'error', message: `Error fetching scripts: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleNewScript = () => {
        setCurrentScript(null);
        setScriptContent('');
        setScriptName('');
        setScriptDescription('');
        setScriptTags('');
        setIsPublic(false);
        setMessage(null);
    };

    const handleLoadScript = (script: CliScript) => {
        setCurrentScript(script);
        setScriptContent(script.scriptContent);
        setScriptName(script.name);
        setScriptDescription(script.description);
        setScriptTags(script.tags.join(', '));
        setIsPublic(script.isPublic);
        setMessage(null);
    };

    const handleSaveScript = async () => {
        if (!scriptName.trim() || !scriptContent.trim()) {
            setMessage({ type: 'error', text: 'Script name and content cannot be empty.' });
            addNotification({ type: 'warning', message: 'Script name or content is empty. Cannot save.' });
            return;
        }

        setIsLoading(true);
        setMessage(null);
        const tagsArray = scriptTags.split(',').map(tag => tag.trim()).filter(Boolean);
        const scriptData: CliScript = {
            id: currentScript?.id || generateUniqueId('s'),
            name: scriptName.trim(),
            description: scriptDescription.trim(),
            scriptContent: scriptContent,
            createdAt: currentScript?.createdAt || new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            tags: tagsArray,
            author: 'dev_user', // Placeholder, would come from auth context
            isPublic: isPublic,
            runCount: currentScript?.runCount || 0,
            version: (currentScript?.version || 0) + 1,
        };

        try {
            const method = currentScript ? 'PUT' : 'POST';
            const endpoint = currentScript ? `/api/scripts/${scriptData.id}` : '/api/scripts';
            const response = await simulateApiCall(endpoint, method, scriptData);

            if (response.success) {
                const successMessage = `Script "${scriptName}" ${currentScript ? 'updated' : 'saved'} successfully!`;
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'success', message: successMessage });
                if (!currentScript) {
                    scriptData.id = response.data.id || scriptData.id;
                    setScripts(prev => [...prev, scriptData]);
                } else {
                    setScripts(prev => prev.map(s => s.id === scriptData.id ? scriptData : s));
                }
                setCurrentScript(scriptData);
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to save script.' });
                addNotification({ type: 'error', message: `Failed to save script: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error saving script.' });
            addNotification({ type: 'error', message: `Error saving script: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleDeleteScript = async (scriptId: string) => {
        if (!window.confirm('Are you sure you want to delete this script? This action cannot be undone.')) return;

        setIsLoading(true);
        setMessage(null);
        try {
            const response = await simulateApiCall(`/api/scripts/${scriptId}`, 'DELETE');
            if (response.success) {
                const successMessage = 'Script deleted successfully!';
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'info', message: successMessage });
                setScripts(prev => prev.filter(s => s.id !== scriptId));
                if (currentScript?.id === scriptId) {
                    handleNewScript();
                }
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to delete script.' });
                addNotification({ type: 'error', message: `Failed to delete script: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error deleting script.' });
            addNotification({ type: 'error', message: `Error deleting script: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleRunScript = async () => {
        if (!scriptContent.trim()) {
            setMessage({ type: 'error', text: 'Script content is empty. Nothing to run.' });
            addNotification({ type: 'warning', message: 'Attempted to run an empty script.' });
            return;
        }
        const commands = scriptContent.split('\n').map(cmd => cmd.trim()).filter(Boolean);
        const runMessage = `Running script "${scriptName || 'untitled'}" (${commands.length} commands)...`;
        setMessage({ type: 'info', text: runMessage });
        addNotification({ type: 'info', message: runMessage });

        let allSuccess = true;
        for (const cmd of commands) {
            try {
                await executeCommand(cmd);
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between commands
            } catch (error) {
                allSuccess = false;
                addNotification({ type: 'error', message: `Script "${scriptName}" failed on command: "${cmd}"` });
                break; // Stop on first error, or continue based on preference
            }
        }
        const finalMessage = allSuccess ? `Script "${scriptName || 'untitled'}" finished successfully.` : `Script "${scriptName || 'untitled'}" finished with errors.`;
        setMessage({ type: allSuccess ? 'success' : 'error', text: finalMessage });
        addNotification({ type: allSuccess ? 'success' : 'error', message: finalMessage });

        if (currentScript) {
            setScripts(prev => prev.map(s => s.id === currentScript.id ? { ...s, lastRun: new Date().toISOString(), runCount: s.runCount + 1 } : s));
        }
    };

    return (
        <Card title="CLI Script Editor" className="flex flex-col h-[600px]">
            <div className="flex-grow grid grid-cols-1 md:grid-cols-3 gap-4 h-full">
                {/* Script List */}
                <div className="md:col-span-1 bg-gray-800 p-4 rounded-lg flex flex-col">
                    <h3 className="text-xl font-semibold text-white mb-4">My Scripts</h3>
                    <button onClick={handleNewScript} className="mb-4 py-2 px-4 bg-green-600 hover:bg-green-700 rounded text-white disabled:opacity-50 transition-colors duration-200" disabled={isLoading}>
                        + New Script
                    </button>
                    <div className="flex-grow overflow-y-auto space-y-2 pr-2 custom-scrollbar">
                        {isLoading && <p className="text-gray-500">Loading scripts...</p>}
                        {message?.type === 'error' && <p className="text-red-400">{message.text}</p>}
                        {scripts.length === 0 && !isLoading && <p className="text-gray-500">No scripts saved yet.</p>}
                        {scripts.map(script => (
                            <div key={script.id}
                                 className={`p-3 rounded-lg border cursor-pointer ${currentScript?.id === script.id ? 'border-cyan-500 bg-cyan-900/20' : 'border-gray-700 hover:border-gray-500 bg-gray-900/30'}`}
                                 onClick={() => handleLoadScript(script)}>
                                <h4 className="font-semibold text-white text-md">{script.name}</h4>
                                <p className="text-gray-400 text-xs truncate">{script.description}</p>
                                <div className="flex items-center justify-between text-xs text-gray-500 mt-1">
                                    <span>Runs: {script.runCount}</span>
                                    {script.lastRun && <span>Last Run: {new Date(script.lastRun).toLocaleDateString()}</span>}
                                    <button onClick={(e) => { e.stopPropagation(); handleDeleteScript(script.id); }} className="text-red-400 hover:text-red-300 ml-auto transition-colors duration-200">Delete</button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Script Editor */}
                <div className="md:col-span-2 flex flex-col bg-gray-800 p-4 rounded-lg">
                    <h3 className="text-xl font-semibold text-white mb-4">{currentScript ? `Edit Script: ${currentScript.name} (v${currentScript.version})` : 'New Script'}</h3>
                    {message && (
                        <div className={`p-3 mb-4 rounded-lg text-sm ${message.type === 'success' ? 'bg-green-900/30 text-green-400' : message.type === 'info' ? 'bg-blue-900/30 text-blue-400' : 'bg-red-900/30 text-red-400'}`}>
                            {message.text}
                        </div>
                    )}

                    <div className="mb-4">
                        <label htmlFor="scriptName" className="block text-gray-400 text-sm mb-1">Script Name</label>
                        <input
                            type="text"
                            id="scriptName"
                            className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            value={scriptName}
                            onChange={e => setScriptName(e.target.value)}
                            disabled={isLoading}
                        />
                    </div>
                    <div className="mb-4">
                        <label htmlFor="scriptDescription" className="block text-gray-400 text-sm mb-1">Description</label>
                        <textarea
                            id="scriptDescription"
                            className="w-full h-16 bg-gray-700/50 p-2 rounded text-white text-sm resize-none focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            value={scriptDescription}
                            onChange={e => setScriptDescription(e.target.value)}
                            disabled={isLoading}
                        />
                    </div>
                    <div className="mb-4">
                        <label htmlFor="scriptTags" className="block text-gray-400 text-sm mb-1">Tags (comma-separated)</label>
                        <input
                            type="text"
                            id="scriptTags"
                            className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            value={scriptTags}
                            onChange={e => setScriptTags(e.target.value)}
                            disabled={isLoading}
                        />
                    </div>
                    <div className="mb-4 flex items-center">
                        <input
                            type="checkbox"
                            id="isPublic"
                            className="mr-2 h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                            checked={isPublic}
                            onChange={e => setIsPublic(e.target.checked)}
                            disabled={isLoading}
                        />
                        <label htmlFor="isPublic" className="text-gray-400 text-sm">Make Public (share with team)</label>
                    </div>

                    <label htmlFor="scriptContent" className="block text-gray-400 text-sm mb-1">Script Content (Commands per line)</label>
                    <textarea
                        id="scriptContent"
                        className="flex-grow w-full h-32 bg-gray-900/50 p-4 rounded-lg font-mono text-cyan-300 text-sm resize-none focus:outline-none focus:ring-2 focus:ring-cyan-500 custom-scrollbar"
                        value={scriptContent}
                        onChange={e => setScriptContent(e.target.value)}
                        placeholder="Enter CLI commands, one per line (e.g., 'demobank payments list --status=pending')..."
                        disabled={isLoading}
                        spellCheck="false"
                    />
                    <div className="mt-4 flex space-x-2">
                        <button onClick={handleSaveScript} className="py-2 px-4 bg-cyan-600 hover:bg-cyan-700 rounded text-white disabled:opacity-50 transition-colors duration-200" disabled={isLoading}>
                            {currentScript ? 'Update Script' : 'Save Script'}
                        </button>
                        <button onClick={handleRunScript} className="py-2 px-4 bg-purple-600 hover:bg-purple-700 rounded text-white disabled:opacity-50 transition-colors duration-200" disabled={isLoading || !scriptContent.trim()}>
                            Run Script
                        </button>
                    </div>
                </div>
            </div>
        </Card>
    );
};

/**
 * Component for scheduling CLI scripts to run at specific times.
 */
export const CliJobScheduler: React.FC = () => {
    const { addNotification } = useCli();
    const [jobs, setJobs] = useState<CliJob[]>([]);
    const [scripts, setScripts] = useState<CliScript[]>([]); // To populate script dropdown
    const [isLoading, setIsLoading] = useState(false);
    const [message, setMessage] = useState<{ type: 'success' | 'error' | 'info', text: string } | null>(null);

    const [selectedScriptId, setSelectedScriptId] = useState('');
    const [scheduleType, setScheduleType] = useState<'once' | 'cron'>('once');
    const [onceDateTime, setOnceDateTime] = useState(''); // YYYY-MM-DDTHH:MM
    const [cronExpression, setCronExpression] = useState('0 0 * * *'); // Default daily at midnight
    const [jobDescription, setJobDescription] = useState('');
    const [notificationEmails, setNotificationEmails] = useState('');

    useEffect(() => {
        fetchJobsAndScripts();
    }, []);

    const fetchJobsAndScripts = async () => {
        setIsLoading(true);
        setMessage(null);
        try {
            const jobsResponse = await simulateApiCall('/api/jobs', 'GET');
            const scriptsResponse = await simulateApiCall('/api/scripts', 'GET');

            if (jobsResponse.success) setJobs(jobsResponse.data);
            else addNotification({ type: 'error', message: `Failed to fetch jobs: ${jobsResponse.message || 'Unknown error.'}` });

            if (scriptsResponse.success) setScripts(scriptsResponse.data);
            else addNotification({ type: 'error', message: `Failed to fetch scripts: ${scriptsResponse.message || 'Unknown error.'}` });

            if (!jobsResponse.success && !scriptsResponse.success) {
                 setMessage({ type: 'error', text: 'Failed to fetch jobs and scripts.' });
            }

        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error fetching data.' });
            addNotification({ type: 'error', message: `Error fetching scheduler data: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleCreateJob = async () => {
        if (!selectedScriptId) {
            setMessage({ type: 'error', text: 'Please select a script to schedule.' });
            addNotification({ type: 'warning', message: 'Attempted to schedule job without selecting a script.' });
            return;
        }

        let scheduleString = '';
        if (scheduleType === 'once') {
            if (!onceDateTime) {
                setMessage({ type: 'error', text: 'Please select a date and time for the one-time schedule.' });
                addNotification({ type: 'warning', message: 'One-time job requires a date and time.' });
                return;
            }
            if (new Date(onceDateTime).getTime() < Date.now()) {
                setMessage({ type: 'error', text: 'One-time schedule cannot be in the past.' });
                addNotification({ type: 'warning', message: 'One-time job date cannot be in the past.' });
                return;
            }
            scheduleString = `once:${new Date(onceDateTime).toISOString()}`; // Store ISO string
        } else { // cron
            if (!cronExpression.match(/^(\S+\s){4}\S+$/)) { // Basic cron validation
                 setMessage({ type: 'error', text: 'Invalid cron expression. Expected 5 parts (minute hour day-of-month month day-of-week).' });
                 addNotification({ type: 'warning', message: 'Invalid cron expression provided.' });
                 return;
            }
            scheduleString = `cron:${cronExpression}`;
        }

        setIsLoading(true);
        setMessage(null);

        const newJob: CliJob = {
            id: generateUniqueId('j'),
            scriptId: selectedScriptId,
            schedule: scheduleString,
            status: 'scheduled',
            lastRunAt: undefined,
            nextRunAt: scheduleType === 'once' ? new Date(onceDateTime).toISOString() : new Date(Date.now() + 3600000).toISOString(), // Placeholder for next run
            logs: ['Job created successfully.'],
            createdAt: new Date().toISOString(),
            createdBy: 'dev_user', // Placeholder
            maxRetries: 3,
            retryCount: 0,
            description: jobDescription.trim() || undefined,
            notificationEmails: notificationEmails.split(',').map(e => e.trim()).filter(Boolean),
        };

        try {
            const response = await simulateApiCall('/api/jobs', 'POST', newJob);
            if (response.success) {
                const scriptName = scripts.find(s => s.id === selectedScriptId)?.name;
                const successMessage = `Job for script "${scriptName}" scheduled successfully!`;
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'success', message: successMessage, relatedJobId: newJob.id });
                setJobs(prev => [...prev, newJob]);
                // Reset form
                setSelectedScriptId('');
                setOnceDateTime('');
                setCronExpression('0 0 * * *');
                setJobDescription('');
                setNotificationEmails('');
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to schedule job.' });
                addNotification({ type: 'error', message: `Failed to schedule job: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error scheduling job.' });
            addNotification({ type: 'error', message: `Error scheduling job: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const getScriptDisplayName = (scriptId: string) => {
        return scripts.find(s => s.id === scriptId)?.name || `Unknown Script (${scriptId})`;
    };

    const handleCancelJob = async (jobId: string) => {
        if (!window.confirm('Are you sure you want to cancel this job?')) return;

        setIsLoading(true);
        setMessage(null);
        try {
            const response = await simulateApiCall(`/api/jobs/${jobId}/cancel`, 'POST'); // Simulate cancel endpoint
            if (response.success) {
                const successMessage = 'Job cancelled successfully!';
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'info', message: successMessage, relatedJobId: jobId });
                setJobs(prev => prev.map(job => job.id === jobId ? { ...job, status: 'cancelled' } : job));
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to cancel job.' });
                addNotification({ type: 'error', message: `Failed to cancel job: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error cancelling job.' });
            addNotification({ type: 'error', message: `Error cancelling job: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card title="CLI Job Scheduler" className="flex flex-col h-[700px]">
            <div className="flex-grow grid grid-cols-1 md:grid-cols-2 gap-6 h-full">
                {/* Schedule New Job */}
                <div className="flex flex-col bg-gray-800 p-4 rounded-lg">
                    <h3 className="text-xl font-semibold text-white mb-4">Schedule New Job</h3>
                    {message && (
                        <div className={`p-3 mb-4 rounded-lg text-sm ${message.type === 'success' ? 'bg-green-900/30 text-green-400' : message.type === 'error' ? 'bg-red-900/30 text-red-400' : 'bg-blue-900/30 text-blue-400'}`}>
                            {message.text}
                        </div>
                    )}

                    <div className="mb-4">
                        <label htmlFor="scriptSelect" className="block text-gray-400 text-sm mb-1">Select Script</label>
                        <select
                            id="scriptSelect"
                            className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            value={selectedScriptId}
                            onChange={e => setSelectedScriptId(e.target.value)}
                            disabled={isLoading}
                        >
                            <option value="">-- Select a Script --</option>
                            {scripts.map(script => (
                                <option key={script.id} value={script.id}>{script.name}</option>
                            ))}
                        </select>
                    </div>

                    <div className="mb-4">
                        <label className="block text-gray-400 text-sm mb-1">Schedule Type</label>
                        <div className="flex space-x-4">
                            <label className="inline-flex items-center">
                                <input
                                    type="radio"
                                    className="form-radio text-cyan-600"
                                    value="once"
                                    checked={scheduleType === 'once'}
                                    onChange={() => setScheduleType('once')}
                                    disabled={isLoading}
                                />
                                <span className="ml-2 text-white text-sm">One-Time</span>
                            </label>
                            <label className="inline-flex items-center">
                                <input
                                    type="radio"
                                    className="form-radio text-cyan-600"
                                    value="cron"
                                    checked={scheduleType === 'cron'}
                                    onChange={() => setScheduleType('cron')}
                                    disabled={isLoading}
                                />
                                <span className="ml-2 text-white text-sm">Cron Expression</span>
                            </label>
                        </div>
                    </div>

                    {scheduleType === 'once' && (
                        <div className="mb-4">
                            <label htmlFor="onceDateTime" className="block text-gray-400 text-sm mb-1">Date and Time</label>
                            <input
                                type="datetime-local"
                                id="onceDateTime"
                                className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                                value={onceDateTime}
                                onChange={e => setOnceDateTime(e.target.value)}
                                disabled={isLoading}
                            />
                        </div>
                    )}

                    {scheduleType === 'cron' && (
                        <div className="mb-4">
                            <label htmlFor="cronExpression" className="block text-gray-400 text-sm mb-1">Cron Expression</label>
                            <input
                                type="text"
                                id="cronExpression"
                                className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                                placeholder="e.g., 0 0 * * * (daily at midnight)"
                                value={cronExpression}
                                onChange={e => setCronExpression(e.target.value)}
                                disabled={isLoading}
                            />
                            <p className="text-xs text-gray-500 mt-1">
                                Format: minute hour day-of-month month day-of-week
                                (<a href="https://crontab.guru/" target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Cron Guru</a>)
                            </p>
                        </div>
                    )}

                    <div className="mb-4">
                        <label htmlFor="jobDescription" className="block text-gray-400 text-sm mb-1">Job Description (Optional)</label>
                        <textarea
                            id="jobDescription"
                            className="w-full h-16 bg-gray-700/50 p-2 rounded text-white text-sm resize-none focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            value={jobDescription}
                            onChange={e => setJobDescription(e.target.value)}
                            disabled={isLoading}
                        />
                    </div>

                    <div className="mb-4">
                        <label htmlFor="notificationEmails" className="block text-gray-400 text-sm mb-1">Notification Emails (comma-separated)</label>
                        <input
                            type="text"
                            id="notificationEmails"
                            className="w-full bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            placeholder="user1@example.com, user2@example.com"
                            value={notificationEmails}
                            onChange={e => setNotificationEmails(e.target.value)}
                            disabled={isLoading}
                        />
                        <p className="text-xs text-gray-500 mt-1">Receive email notifications on job completion or failure.</p>
                    </div>

                    <button
                        onClick={handleCreateJob}
                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded text-white disabled:opacity-50 mt-auto transition-colors duration-200"
                        disabled={isLoading || !selectedScriptId || (scheduleType === 'once' && !onceDateTime) || (scheduleType === 'cron' && !cronExpression)}
                    >
                        Schedule Job
                    </button>
                </div>

                {/* Scheduled Jobs List */}
                <div className="flex flex-col bg-gray-800 p-4 rounded-lg">
                    <h3 className="text-xl font-semibold text-white mb-4">Scheduled Jobs</h3>
                    <div className="flex-grow overflow-y-auto space-y-3 pr-2 custom-scrollbar">
                        {isLoading && <p className="text-gray-500">Loading jobs...</p>}
                        {jobs.length === 0 && !isLoading && <p className="text-gray-500">No jobs scheduled yet.</p>}
                        {jobs.map(job => (
                            <div key={job.id} className="bg-gray-900/30 p-3 rounded-lg border border-gray-700">
                                <div className="flex justify-between items-start mb-1">
                                    <h4 className="font-semibold text-white text-md">{getScriptDisplayName(job.scriptId)}</h4>
                                    <span className={`text-xs px-2 py-1 rounded-full ${job.status === 'scheduled' ? 'bg-blue-600' : job.status === 'running' ? 'bg-yellow-600' : job.status === 'completed' ? 'bg-green-600' : job.status === 'failed' ? 'bg-red-600' : 'bg-gray-600'}`}>
                                        {job.status.toUpperCase()}
                                    </span>
                                </div>
                                {job.description && <p className="text-gray-500 text-xs italic mb-1">{job.description}</p>}
                                <p className="text-gray-400 text-xs mt-1">Schedule: {job.schedule.startsWith('cron:') ? `CRON: ${job.schedule.substring(5)}` : `ONCE: ${new Date(job.schedule.substring(5)).toLocaleString()}`}</p>
                                {job.lastRunAt && <p className="text-gray-400 text-xs">Last Run: {new Date(job.lastRunAt).toLocaleString()}</p>}
                                {job.nextRunAt && <p className="text-gray-400 text-xs">Next Run: {new Date(job.nextRunAt).toLocaleString()}</p>}
                                <p className="text-gray-500 text-xs mt-2">Created: {new Date(job.createdAt).toLocaleDateString()} by {job.createdBy}</p>
                                {job.status !== 'cancelled' && job.status !== 'completed' && job.status !== 'failed' && (
                                    <div className="mt-3 flex justify-end">
                                        <button onClick={() => handleCancelJob(job.id)} className="text-red-400 hover:text-red-300 text-sm px-2 py-1 rounded transition-colors duration-200">Cancel Job</button>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </Card>
    );
};

/**
 * A sophisticated AI Chat Assistant for generating, explaining, and debugging commands/scripts.
 */
export const AiChatAssistant: React.FC = () => {
    const { executeCommand, addNotification } = useCli();
    const [chatHistory, setChatHistory] = useState<AiChatInteraction[]>([]);
    const [currentAiPrompt, setCurrentAiPrompt] = useState('');
    const [isAiThinking, setIsAiThinking] = useState(false);
    const chatEndRef = useRef<HTMLDivElement>(null);
    const googleGenAI = useRef(new GoogleGenAI({ apiKey: process.env.API_KEY as string }));
    const [selectedAiModel, setSelectedAiModel] = useState('gemini-pro');
    const [availableAiModels, setAvailableAiModels] = useState<AiModelConfig[]>([
        { id: 'm1', name: 'Gemini Pro', provider: 'google', modelId: 'gemini-pro', description: 'Google\'s balanced model for various tasks.', isActive: true, costPerToken: 0.0001 },
        { id: 'm2', name: 'Gemini 2.5 Flash', provider: 'google', modelId: 'gemini-2.5-flash', description: 'Faster, cost-effective model, good for quick responses.', isActive: true, costPerToken: 0.00005 },
        { id: 'm3', name: 'GPT-4 (Enterprise)', provider: 'openai', modelId: 'gpt-4', description: 'OpenAI\'s advanced reasoning model (Requires premium subscription).', isActive: false, costPerToken: 0.003 },
    ]);

    useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [chatHistory]);

    // Load AI model from settings if available
    useEffect(() => {
        const fetchSettings = async () => {
            const response = await simulateApiCall('/api/settings', 'GET', null, 50);
            if (response.success) {
                setSelectedAiModel(response.data.aiModel);
            }
        };
        fetchSettings();
    }, []);

    const sendAiPrompt = async (promptText: string, specificRole?: 'scriptGeneration' | 'commandExplanation' | 'debuggingAssistance' | 'resourceOptimization') => {
        if (!promptText.trim()) return;

        const userInteraction: AiChatInteraction = {
            id: generateUniqueId('uai'),
            timestamp: new Date().toISOString(),
            role: 'user',
            content: promptText,
        };
        setChatHistory(prev => [...prev, userInteraction]);
        setCurrentAiPrompt('');
        setIsAiThinking(true);

        try {
            const aiModelInstance = googleGenAI.current.models.gemini(selectedAiModel);
            const systemInstructions = {
                scriptGeneration: `You are an AI specializing in generating multi-line Demobank CLI scripts. The user will describe a task, and you will provide a sequence of 'demobank' commands. Each command should be on a new line. Use appropriate flags like --json for programmatic output, and pipe commands when necessary. Format command suggestions as '` + "```demobank ...```" + `'.`,
                commandExplanation: `You are an AI specializing in explaining Demobank CLI commands. The user will provide a command, and you will explain its purpose, arguments, and common options.`,
                debuggingAssistance: `You are an AI assistant for debugging Demobank CLI commands and scripts. The user will provide a command/script and an error message or unexpected behavior. Your task is to analyze the input and suggest potential causes and troubleshooting steps.`,
                resourceOptimization: `You are an AI advisor for optimizing Demobank CLI operations. The user will describe a task or a slow command/script, and you will suggest ways to make it more efficient. Focus on reducing API calls, processing data locally, or using more specific filters.`,
            };
            const currentSystemInstruction = specificRole ? systemInstructions[specificRole] : `You are an expert Demobank CLI assistant. Your goal is to help users generate, explain, or debug Demobank CLI commands and scripts. Assume commands like 'demobank payments list --status=pending', 'demobank payments approve <id>', 'demobank users create --name="John Doe" --email="john@example.com" --role=customer', 'demobank config get api-endpoint', 'demobank script run s_my_script_id', 'demobank help payments'. Respond in a conversational tone. If a command can be generated, provide it clearly, optionally with an explanation and follow-up suggestions. If explaining a command, be concise. If debugging, ask for more context or suggest common issues. For complex requests, break them down. Format command suggestions as '` + "```demobank ...```" + `'. Provide follow-up suggestions in a bulleted list. If the prompt explicitly asks to run a command, just generate the command without extra conversation if possible.`;

            const fullPrompt = `${currentSystemInstruction}\nUser request: "${promptText}"`;
            
            const result = await aiModelInstance.generateContent({
                contents: [{ role: 'user', parts: [{ text: fullPrompt }] }]
            });
            const aiResponse = result.text;

            let commandGenerated: string | undefined;
            const commandMatch = aiResponse.match(/```(demobank\s.*?)```/s);
            if (commandMatch && commandMatch[1]) {
                commandGenerated = commandMatch[1].trim();
            }

            const assistantInteraction: AiChatInteraction = {
                id: generateUniqueId('aai'),
                timestamp: new Date().toISOString(),
                role: 'assistant',
                content: aiResponse,
                commandGenerated: commandGenerated,
                followUpSuggestions: aiResponse.includes('- ') ? aiResponse.split('\n').filter(line => line.startsWith('- ')).map(line => line.substring(2).trim()) : undefined,
            };
            setChatHistory(prev => [...prev, assistantInteraction]);
            addNotification({ type: 'info', message: 'AI Assistant responded to your query.' });

        } catch (error: any) {
            const errorInteraction: AiChatInteraction = {
                id: generateUniqueId('aai'),
                timestamp: new Date().toISOString(),
                role: 'assistant',
                content: `Error: Could not process your request. ${error.message || 'Please try again.'} (Selected model: ${selectedAiModel})`,
                followUpSuggestions: ['Check your API key configuration', 'Try a simpler prompt', 'Change AI model in settings'],
            };
            setChatHistory(prev => [...prev, errorInteraction]);
            addNotification({ type: 'error', message: `AI Assistant error: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsAiThinking(false);
        }
    };

    const handleExecuteAiCommand = async (command: string) => {
        const executionPrompt: AiChatInteraction = {
            id: generateUniqueId('uai'),
            timestamp: new Date().toISOString(),
            role: 'user',
            content: `Executing AI-generated command: ${command}`,
            commandGenerated: command,
        };
        setChatHistory(prev => [...prev, executionPrompt]);
        addNotification({ type: 'info', message: `Executing AI-generated command: ${command}` });
        await executeCommand(command); // Use the global executeCommand
    };

    const handleFollowUp = (suggestion: string) => {
        setCurrentAiPrompt(suggestion);
        // Automatically send follow-up if it's a direct command or query
        if (suggestion.startsWith('demobank') || suggestion.includes('generate') || suggestion.includes('explain')) {
            sendAiPrompt(suggestion);
        }
    };

    const renderChatMessage = (interaction: AiChatInteraction) => {
        const isUser = interaction.role === 'user';
        const msgClasses = `p-3 rounded-lg max-w-[80%] ${isUser ? 'bg-blue-900/30 text-white self-end' : 'bg-gray-800 text-gray-200 self-start'}`;

        let content = interaction.content;
        // Simple markdown for commands and lists (more robust markdown parser could be used)
        content = content.replace(/```(demobank\s.*?)```/gs, (match, cmd) => {
            return `<div class="bg-gray-900/50 p-2 rounded mt-2 font-mono text-cyan-300 text-sm overflow-x-auto">
                        <span class="select-none text-gray-500 mr-2">$</span>${cmd}
                    </div>`;
        });
        content = content.replace(/^- (.*)$/gm, (match, item) => `<li>${item}</li>`);

        return (
            <div key={interaction.id} className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
                <div className={msgClasses}>
                    <p className="text-xs text-gray-500 mb-1">{isUser ? 'You' : 'AI Assistant'} at {new Date(interaction.timestamp).toLocaleTimeString()}</p>
                    <div className="text-sm prose prose-invert" dangerouslySetInnerHTML={{ __html: content }} />
                    {interaction.commandGenerated && (
                        <div className="mt-2 text-right">
                            <button
                                onClick={() => handleExecuteAiCommand(interaction.commandGenerated!)}
                                className="text-xs py-1 px-3 bg-green-600 hover:bg-green-700 rounded text-white disabled:opacity-50 transition-colors duration-200"
                                disabled={isAiThinking}
                            >
                                Run Command
                            </button>
                        </div>
                    )}
                    {interaction.followUpSuggestions && interaction.followUpSuggestions.length > 0 && (
                        <div className="mt-2 text-xs text-gray-400">
                            <strong>Suggestions:</strong>
                            <div className="flex flex-wrap gap-2 mt-1">
                                {interaction.followUpSuggestions.map((sug, i) => (
                                    <span key={i} onClick={() => handleFollowUp(sug)} className="cursor-pointer bg-gray-700/50 hover:bg-gray-600/50 px-2 py-1 rounded-full text-xs transition-colors duration-200">
                                        {sug}
                                    </span>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    return (
        <Card title="AI Chat Assistant" className="flex flex-col h-[700px]">
             <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold text-white">Chat with AI</h3>
                <div className="flex items-center space-x-2 text-sm text-gray-400">
                    <span>Model:</span>
                    <select
                        className="bg-gray-700/50 p-1 rounded text-white text-xs focus:outline-none focus:ring-2 focus:ring-cyan-500"
                        value={selectedAiModel}
                        onChange={(e) => {
                            const selected = availableAiModels.find(m => m.modelId === e.target.value);
                            if (selected && !selected.isActive) {
                                addNotification({ type: 'warning', message: `AI Model "${selected.name}" is inactive. Please activate it in settings.` });
                                return;
                            }
                            setSelectedAiModel(e.target.value);
                            addNotification({ type: 'info', message: `AI Model changed to ${selected?.name || e.target.value}.` });
                        }}
                        disabled={isAiThinking}
                    >
                        {availableAiModels.map(model => (
                            <option key={model.id} value={model.modelId} disabled={!model.isActive}>
                                {model.name} {model.isActive ? '' : '(Inactive)'}
                            </option>
                        ))}
                    </select>
                </div>
            </div>
            <div className="flex-grow flex flex-col p-4 bg-gray-900/50 rounded-lg overflow-y-auto custom-scrollbar">
                {chatHistory.length === 0 ? (
                    <div className="flex-grow flex items-center justify-center text-gray-500 text-center">
                        Start a conversation with the AI assistant. Ask it to generate commands, explain syntax, or debug issues.
                        <br/>
                        Try: "List all pending payments" or "Explain demobank users create command"
                    </div>
                ) : (
                    chatHistory.map(renderChatMessage)
                )}
                {isAiThinking && (
                    <div className="flex justify-start mb-4">
                        <div className="bg-gray-800 text-gray-200 p-3 rounded-lg max-w-[80%] self-start text-sm">
                            <span className="dot-flashing"></span> AI is thinking...
                        </div>
                    </div>
                )}
                <div ref={chatEndRef} />
            </div>
            <div className="mt-4 flex">
                <textarea
                    value={currentAiPrompt}
                    onChange={e => setCurrentAiPrompt(e.target.value)}
                    onKeyDown={e => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            sendAiPrompt(currentAiPrompt);
                        }
                    }}
                    className="flex-grow h-20 bg-gray-700/50 p-2 rounded-l text-white text-sm resize-none focus:outline-none focus:ring-2 focus:ring-cyan-500 custom-scrollbar"
                    placeholder="Ask the AI for a command, an explanation, or help debugging..."
                    disabled={isAiThinking}
                />
                <button
                    onClick={() => sendAiPrompt(currentAiPrompt)}
                    disabled={isAiThinking || !currentAiPrompt.trim()}
                    className="py-2 px-4 bg-cyan-600 hover:bg-cyan-700 rounded-r text-white disabled:opacity-50 transition-colors duration-200"
                >
                    Send
                </button>
            </div>
            {/* Minimal CSS for dot-flashing spinner */}
            <style jsx>{`
                .dot-flashing {
                    position: relative;
                    width: 5px;
                    height: 5px;
                    border-radius: 5px;
                    background-color: #9880ff;
                    color: #9880ff;
                    animation: dotFlashing 1s infinite alternate;
                    animation-delay: 0s;
                    display: inline-block;
                    margin-left: 5px;
                }
                .dot-flashing::before, .dot-flashing::after {
                    content: '';
                    display: inline-block;
                    position: absolute;
                    top: 0;
                }
                .dot-flashing::before {
                    left: -8px;
                    width: 5px;
                    height: 5px;
                    border-radius: 5px;
                    background-color: #9880ff;
                    color: #9880ff;
                    animation: dotFlashing 1s infinite alternate;
                    animation-delay: .2s;
                }
                .dot-flashing::after {
                    left: 8px;
                    width: 5px;
                    height: 5px;
                    border-radius: 5px;
                    background-color: #9880ff;
                    color: #9880ff;
                    animation: dotFlashing 1s infinite alternate;
                    animation-delay: .4s;
                }
                @keyframes dotFlashing {
                    0% { opacity: 0; }
                    50%, 100% { opacity: 1; }
                }
            `}</style>
        </Card>
    );
};


/**
 * Component to display and manage installed CLI plugins.
 */
export const CliPluginManager: React.FC = () => {
    const { addNotification } = useCli();
    const [plugins, setPlugins] = useState<CliPlugin[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [message, setMessage] = useState<{ type: 'success' | 'error' | 'info', text: string } | null>(null);
    const [newPluginName, setNewPluginName] = useState('');

    useEffect(() => {
        fetchPlugins();
    }, []);

    const fetchPlugins = async () => {
        setIsLoading(true);
        setMessage(null);
        try {
            const response = await simulateApiCall('/api/plugins', 'GET');
            if (response.success) {
                setPlugins(response.data);
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to fetch plugins.' });
                addNotification({ type: 'error', message: `Failed to fetch plugins: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error fetching plugins.' });
            addNotification({ type: 'error', message: `Error fetching plugins: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleTogglePlugin = async (pluginId: string, newState: boolean) => {
        setIsLoading(true);
        setMessage(null);
        try {
            const response = await simulateApiCall(`/api/plugins/${pluginId}/toggle`, 'POST', { isActive: newState });
            if (response.success) {
                const successMessage = `Plugin ${newState ? 'activated' : 'deactivated'} successfully.`;
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'info', message: successMessage });
                setPlugins(prev => prev.map(p => p.id === pluginId ? { ...p, isActive: newState } : p));
            } else {
                setMessage({ type: 'error', text: response.message || `Failed to ${newState ? 'activate' : 'deactivate'} plugin.` });
                addNotification({ type: 'error', message: `Failed to toggle plugin status: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error toggling plugin.' });
            addNotification({ type: 'error', message: `Error toggling plugin status: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    const handleInstallPlugin = async () => {
        if (!newPluginName.trim()) {
            setMessage({ type: 'error', text: 'Plugin name cannot be empty.' });
            return;
        }
        if (plugins.some(p => p.name.toLowerCase() === newPluginName.trim().toLowerCase())) {
            setMessage({ type: 'warning', text: `Plugin "${newPluginName}" is already installed.` });
            return;
        }

        setIsLoading(true);
        setMessage(null);
        try {
            const newPlugin: CliPlugin = {
                id: generateUniqueId('p'),
                name: newPluginName.trim(),
                version: '1.0.0',
                description: `A new plugin for ${newPluginName.trim()} functionality.`,
                commands: [`demobank ${newPluginName.toLowerCase().replace(/\s/g, '-')} new-command`],
                isActive: true,
                installationDate: new Date().toISOString(),
                settingsSchema: {},
                author: 'CLI Marketplace',
            };
            const response = await simulateApiCall('/api/plugins', 'POST', newPlugin);
            if (response.success) {
                const successMessage = `Plugin "${newPluginName}" installed successfully.`;
                setMessage({ type: 'success', text: successMessage });
                addNotification({ type: 'success', message: successMessage });
                setPlugins(prev => [...prev, newPlugin]);
                setNewPluginName('');
            } else {
                setMessage({ type: 'error', text: response.message || 'Failed to install plugin.' });
                addNotification({ type: 'error', message: `Failed to install plugin: ${response.message || 'Unknown error.'}` });
            }
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Error installing plugin.' });
            addNotification({ type: 'error', message: `Error installing plugin: ${error.message || 'Unknown error.'}` });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card title="CLI Plugin Manager" className="flex flex-col h-[500px]">
            <div className="flex-grow flex flex-col p-4 bg-gray-800 rounded-lg">
                <h3 className="text-xl font-semibold text-white mb-4">Installed Plugins</h3>
                {message && (
                    <div className={`p-3 mb-4 rounded-lg text-sm ${message.type === 'success' ? 'bg-green-900/30 text-green-400' : message.type === 'error' ? 'bg-red-900/30 text-red-400' : 'bg-blue-900/30 text-blue-400'}`}>
                        {message.text}
                    </div>
                )}
                {isLoading && <p className="text-gray-500">Loading plugins...</p>}
                {plugins.length === 0 && !isLoading && <p className="text-gray-500">No plugins installed.</p>}
                <div className="overflow-y-auto space-y-3 pr-2 custom-scrollbar">
                    {plugins.map(plugin => (
                        <div key={plugin.id} className="bg-gray-900/30 p-3 rounded-lg border border-gray-700">
                            <div className="flex justify-between items-start mb-1">
                                <h4 className="font-semibold text-white text-md">{plugin.name} <span className="text-gray-500 text-xs">v{plugin.version}</span></h4>
                                <span className={`text-xs px-2 py-1 rounded-full ${plugin.isActive ? 'bg-green-600' : 'bg-red-600'}`}>
                                    {plugin.isActive ? 'ACTIVE' : 'INACTIVE'}
                                </span>
                            </div>
                            <p className="text-gray-400 text-xs">{plugin.description}</p>
                            <p className="text-gray-500 text-xs mt-2">Commands: {plugin.commands.join(', ')}</p>
                            <p className="text-gray-500 text-xs">Author: {plugin.author} | Installed: {new Date(plugin.installationDate).toLocaleDateString()}</p>
                            <div className="mt-3 flex justify-end">
                                <button
                                    onClick={() => handleTogglePlugin(plugin.id, !plugin.isActive)}
                                    className={`text-sm px-2 py-1 rounded ${plugin.isActive ? 'text-red-400 hover:text-red-300' : 'text-green-400 hover:text-green-300'} transition-colors duration-200`}
                                >
                                    {plugin.isActive ? 'Deactivate' : 'Activate'}
                                </button>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
            <div className="mt-6 p-4 bg-gray-800 rounded-lg">
                <h3 className="text-xl font-semibold text-white mb-4">Install New Plugin</h3>
                <div className="flex space-x-2">
                    <input
                        type="text"
                        placeholder="Enter plugin name from marketplace..."
                        className="flex-grow bg-gray-700/50 p-2 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
                        value={newPluginName}
                        onChange={(e) => setNewPluginName(e.target.value)}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                                handleInstallPlugin();
                            }
                        }}
                        disabled={isLoading}
                    />
                    <button
                        onClick={handleInstallPlugin}
                        className="py-2 px-4 bg-purple-600 hover:bg-purple-700 rounded text-white disabled:opacity-50 transition-colors duration-200"
                        disabled={isLoading || !newPluginName.trim()}
                    >
                        Install Plugin
                    </button>
                </div>
                <p className="text-xs text-gray-500 mt-2">Simulates installing a plugin by name. In a real app, this would query a plugin marketplace.</p>
            </div>
        </Card>
    );
};

/**
 * Provides a basic documentation viewer for CLI commands.
 */
export const CliDocumentationViewer: React.FC = () => {
    const [selectedCommand, setSelectedCommand] = useState<string>('demobank');
    const [isLoading, setIsLoading] = useState(false);
    const [documentationContent, setDocumentationContent] = useState<string | null>(null);

    const commands = [
        'demobank',
        'demobank payments',
        'demobank payments list',
        'demobank payments approve',
        'demobank users',
        'demobank users create',
        'demobank users show',
        'demobank scripts',
        'demobank scripts save',
        'demobank jobs',
        'demobank jobs schedule',
        'demobank config',
        'demobank config get',
        'demobank plugins',
        'demobank ai',
        'demobank audit',
        'demobank metrics',
        'demobank help',
        'demobank version',
    ];

    const fetchDocumentation = useCallback(async (cmd: string) => {
        setIsLoading(true);
        setDocumentationContent(null);
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 200)); // Simulate API call

        let content = '';
        switch (cmd) {
            case 'demobank':
                content = `# NAME
    \`demobank\` - Command-line interface for Demobank services.

# DESCRIPTION
    The 'demobank' CLI is a powerful tool to manage your bank's resources.
    It allows you to interact with payments, users, accounts, and more.

# COMMANDS
* \`payments\`    Manage payment orders.
* \`users\`       Manage user accounts.
* \`accounts\`    Manage bank accounts.
* \`transactions\` View transaction history.
* \`scripts\`     Manage CLI scripts.
* \`jobs\`        Manage scheduled CLI jobs.
* \`config\`      Manage CLI configuration.
* \`plugins\`     Manage CLI plugins.
* \`ai\`          Interact with AI assistant.
* \`audit\`       View audit logs.
* \`metrics\`     View resource metrics.
* \`help\`        Get help on commands.
* \`version\`     Display CLI version.

# SEE ALSO
    \`demobank help <command>\``;
                break;
            case 'demobank payments':
                content = `# NAME
    \`demobank payments\` - Manage payment orders.

# DESCRIPTION
    Provides subcommands to list, approve, create, and manage payment orders.

# SUBCOMMANDS
* \`list\`        List payment orders.
* \`approve\`     Approve a pending payment order.
* \`create\`      Create a new payment order.
* \`show\`        Show details of a specific payment order.

# SEE ALSO
    \`demobank payments list --help\`
    \`demobank payments approve --help\``;
                break;
            case 'demobank payments list':
                content = `# NAME
    \`demobank payments list\` - List payment orders.

# SYNOPSIS
    \`demobank payments list [--status=STATUS] [--amount-gte=AMOUNT] [--amount-lte=AMOUNT] [--counterparty=NAME] [--json]\`

# DESCRIPTION
    Retrieves a list of payment orders based on specified criteria.

# OPTIONS
* \`--status=STATUS\`
    Filter payments by status (e.g., \`pending\`, \`approved\`, \`rejected\`, \`all\`). Default is 'pending'.
* \`--amount-gte=AMOUNT\`
    Filter payments with amount greater than or equal to AMOUNT.
* \`--amount-lte=AMOUNT\`
    Filter payments with amount less than or equal to AMOUNT.
* \`--counterparty=NAME\`
    Filter payments by counterparty name.
* \`--json\`
    Output results in JSON format.

# EXAMPLES
    \`\`\`
    demobank payments list
    demobank payments list --status=approved
    demobank payments list --amount-lte=100 --status=pending --json
    demobank payments list --counterparty="Cloud Services Inc."
    \`\`\``;
                break;
            case 'demobank payments approve':
                content = `# NAME
    \`demobank payments approve\` - Approve a pending payment order.

# SYNOPSIS
    \`demobank payments approve <payment_id> [--reason=REASON] [--force]\`

# DESCRIPTION
    Approves a specific payment order that is currently in 'pending' status.
    This action typically requires appropriate permissions.

# ARGUMENTS
* \`payment_id\`
    The unique ID of the payment order to approve.

# OPTIONS
* \`--reason=REASON\`
    A short explanation for approving the payment.
* \`--force\`
    Force approval even if there are minor warnings.

# EXAMPLES
    \`\`\`
    demobank payments approve po_001
    demobank payments approve po_002 --reason="Emergency payment"
    \`\`\``;
                break;
            case 'demobank users':
                content = `# NAME
    \`demobank users\` - Manage user accounts.

# DESCRIPTION
    Provides subcommands to create, list, show, update, and delete user accounts.

# SUBCOMMANDS
* \`list\`        List user accounts.
* \`create\`      Create a new user account.
* \`show\`        Show details of a specific user.
* \`update\`      Update an existing user account.
* \`delete\`      Delete a user account.

# SEE ALSO
    \`demobank users list --help\``;
                break;
            case 'demobank users create':
                content = `# NAME
    \`demobank users create\` - Create a new user account.

# SYNOPSIS
    \`demobank users create --name=NAME --email=EMAIL --role=ROLE [--status=STATUS] [--password=PASSWORD]\`

# DESCRIPTION
    Creates a new user account in the Demobank system.

# OPTIONS
* \`--name=NAME\` (required)
    The full name of the user.
* \`--email=EMAIL\` (required)
    The primary email address of the user (must be unique).
* \`--role=ROLE\` (required)
    The role of the user (e.g., \`customer\`, \`employee\`, \`admin\`).
* \`--status=STATUS\`
    The initial status of the user (e.g., \`active\`, \`inactive\`, \`pending\`). Default is 'active'.
* \`--password=PASSWORD\`
    Initial password for the user. If not provided, a temporary one will be generated.

# EXAMPLES
    \`\`\`
    demobank users create --name="Jane Doe" --email="jane@example.com" --role=customer
    demobank users create --name="Admin User" --email="admin@demobank.com" --role=admin --password="SecurePass123"
    \`\`\``;
                break;
            case 'demobank users show':
                content = `# NAME
    \`demobank users show\` - Show details of a specific user.

# SYNOPSIS
    \`demobank users show <user_id> [--json]\`

# DESCRIPTION
    Retrieves and displays the detailed information for a given user ID.

# ARGUMENTS
* \`user_id\`
    The unique ID of the user to retrieve.

# OPTIONS
* \`--json\`
    Output results in JSON format.

# EXAMPLES
    \`\`\`
    demobank users show user_007
    demobank

--- FILE: ExtensionsView.tsx ---

// components/views/megadashboard/developer/ExtensionsView.tsx
import React, { useState, useEffect, useCallback, createContext, useContext, useReducer } from 'react';
import Card from '../../../Card';

// --- Existing Interfaces and Mocks ---
interface Extension {
    id: string;
    name: string;
    publisher: string;
    description: string;
    icon: React.ReactNode;
    recommended?: boolean;
    category: string; // New field
    tags: string[]; // New field
    rating: number; // New field (1-5)
    installCount: number; // New field
    price: number; // New field (0 for free)
    lastUpdated: string; // New field (ISO date string)
    version: string; // New field
    screenshots: string[]; // New field (URLs)
    documentationUrl: string; // New field
    privacyPolicyUrl: string; // New field
    developerInfo: {
        id: string;
        name: string;
        contactEmail: string;
        website?: string;
    }; // New field
    pricingPlans?: PricingPlan[]; // New field for paid extensions
    changelog?: ExtensionVersionLog[]; // New field for version history
}

interface PricingPlan {
    id: string;
    name: string;
    description: string;
    priceMonthly: number;
    priceAnnually: number;
    features: string[];
}

interface ExtensionVersionLog {
    version: string;
    releaseDate: string;
    changes: string[];
}

// --- New Interfaces ---
interface ExtensionCategory {
    id: string;
    name: string;
    icon: React.ReactNode;
    description: string;
}

interface ExtensionReview {
    id: string;
    extensionId: string;
    userId: string;
    userName: string;
    rating: number;
    comment: string;
    timestamp: string;
}

interface InstalledExtension {
    id: string;
    extensionId: string;
    userId: string;
    installationDate: string;
    enabled: boolean;
    configuration: Record<string, any>; // Dynamic configuration
    subscription?: SubscriptionDetails;
}

interface SubscriptionDetails {
    planId: string;
    startDate: string;
    endDate: string;
    status: 'active' | 'cancelled' | 'trial';
    autoRenew: boolean;
}

interface DeveloperExtension {
    id: string;
    name: string;
    status: 'published' | 'draft' | 'pending_review' | 'rejected' | 'archived';
    version: string;
    lastPublished: string;
    totalInstalls: number;
    reviewsCount: number;
    averageRating: number;
    monetizationStatus: 'free' | 'paid' | 'subscription';
    pendingUpdates: boolean;
}

interface AuditLogEntry {
    id: string;
    timestamp: string;
    action: string; // e.g., 'INSTALL_EXTENSION', 'UPDATE_CONFIG', 'PUBLISH_EXTENSION'
    userId: string;
    extensionId?: string;
    details: Record<string, any>;
}

interface ExtensionAnalytics {
    extensionId: string;
    period: 'daily' | 'weekly' | 'monthly';
    data: {
        date: string;
        installs: number;
        uninstalls: number;
        activeUsers: number;
        revenue?: number; // For paid extensions
        errors?: number; // e.g., API errors
    }[];
}

// --- Utility Functions ---
export const truncateText = (text: string, length: number) => {
    if (text.length <= length) return text;
    return text.substring(0, length) + '...';
};

export const getStarRating = (rating: number) => {
    const fullStars = Math.floor(rating);
    const hasHalfStar = rating % 1 !== 0;
    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
    return (
        <div className="flex text-yellow-400">
            {Array(fullStars).fill('')}
            {hasHalfStar && ''}
            {Array(emptyStars).fill('')}
        </div>
    );
};

export const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
    });
};

// --- Mock Data Expansion ---
const generateRandomId = () => Math.random().toString(36).substring(2, 15);

const MOCK_CATEGORIES: ExtensionCategory[] = [
    { id: 'cat-dev-tools', name: 'Developer Tools', icon: <p></p>, description: 'Tools for coding, debugging, and deployment.' },
    { id: 'cat-fin-ops', name: 'Financial Operations', icon: <p></p>, description: 'Automate financial workflows and reporting.' },
    { id: 'cat-collaboration', name: 'Collaboration', icon: <p></p>, description: 'Enhance team communication and project management.' },
    { id: 'cat-design', name: 'Design & UI', icon: <p></p>, description: 'Integrate design tools and assets.' },
    { id: 'cat-reporting', name: 'Reporting & Analytics', icon: <p></p>, description: 'Visualize data and generate reports.' },
    { id: 'cat-security', name: 'Security & Compliance', icon: <p></p>, description: 'Ensure data security and regulatory compliance.' },
    { id: 'cat-crm', name: 'CRM & Sales', icon: <p></p>, description: 'Manage customer relations and sales pipelines.' },
    { id: 'cat-marketing', name: 'Marketing', icon: <p></p>, description: 'Automate marketing campaigns and customer engagement.' },
    { id: 'cat-ai-ml', name: 'AI & Machine Learning', icon: <p></p>, description: 'Integrate AI models and machine learning workflows.' },
    { id: 'cat-iot', name: 'IoT & Edge Computing', icon: <p></p>, description: 'Connect and manage IoT devices and data streams.' },
    { id: 'cat-data-eng', name: 'Data Engineering', icon: <p></p>, description: 'Tools for data pipeline, ETL, and warehousing.' },
    { id: 'cat-ecommerce', name: 'E-commerce', icon: <p></p>, description: 'Enhance online store functionalities and payment gateways.' },
    { id: 'cat-hr', name: 'Human Resources', icon: <p></p>, description: 'Streamline HR processes and employee management.' },
    { id: 'cat-project-mgmt', name: 'Project Management', icon: <p></p>, description: 'Tools for planning, tracking, and executing projects.' },
    { id: 'cat-legal', name: 'Legal & Compliance', icon: <p></p>, description: 'Manage legal documents, contracts, and regulatory adherence.' },
    { id: 'cat-education', name: 'Education & Training', icon: <p></p>, description: 'Learning platforms and educational content delivery.' },
    { id: 'cat-healthcare', name: 'Healthcare', icon: <p></p>, description: 'Solutions for patient management, diagnostics, and medical records.' },
    { id: 'cat-manufacturing', name: 'Manufacturing', icon: <p></p>, description: 'Tools for production planning, inventory, and quality control.' },
    { id: 'cat-transport', name: 'Logistics & Transport', icon: <p></p>, description: 'Optimize supply chain, fleet management, and delivery.' },
    { id: 'cat-media', name: 'Media & Entertainment', icon: <p></p>, description: 'Content creation, streaming, and digital rights management.' },
];

const EXTENSION_DESCRIPTIONS = [
    'Seamlessly integrate your workflow with our advanced API services, ensuring data consistency and real-time updates across all platforms.',
    'Boost your productivity with automated tasks and smart notifications, keeping you ahead of your project deadlines.',
    'Gain deeper insights into your financial data with comprehensive reporting and analytics capabilities, tailored for modern businesses.',
    'Streamline your customer support operations by linking customer queries directly to relevant financial transactions, improving resolution times.',
    'Enhance your teams collaboration with shared dashboards and instant messaging, making project management effortless and effective.',
    'Secure your transactions with enterprise-grade encryption and compliance tools, meeting the highest industry standards.',
    'Personalize your customer engagement strategies using powerful CRM integrations, driving sales and fostering loyalty.',
    'Automate your marketing campaigns with data-driven insights, reaching the right audience at the right time.',
    'Leverage AI and machine learning to predict market trends and optimize resource allocation, giving you a competitive edge.',
    'Connect your IoT devices to our platform for real-time data streaming and predictive maintenance, minimizing downtime.',
    'Simplify complex data pipelines with intuitive ETL tools, transforming raw data into actionable intelligence.',
    'Improve your e-commerce conversion rates with dynamic pricing and personalized product recommendations, boosting your bottom line.',
    'Manage your human resources effectively with integrated payroll, time tracking, and employee performance modules.',
    'Execute projects with precision using advanced scheduling, resource allocation, and progress tracking features.',
    'Ensure legal compliance and streamline contract management with automated document generation and version control.',
    'Deliver engaging educational content with interactive lessons and progress tracking, fostering continuous learning.',
    'Optimize healthcare operations with secure patient data management, appointment scheduling, and telemedicine capabilities.',
    'Revolutionize manufacturing processes with predictive analytics for equipment maintenance and quality control.',
    'Enhance logistics efficiency with real-time tracking, route optimization, and inventory management solutions.',
    'Create stunning media content and manage digital assets with integrated creative tools and rights management.',
    'Manage all aspects of your supply chain, from procurement to delivery, with a unified platform for unparalleled visibility.',
    'Deploy and manage your cloud infrastructure directly from your dashboard, ensuring scalability and reliability.',
    'Automate your accounting processes, reconcile transactions, and generate financial statements with ease.',
    'Protect your digital assets with advanced threat detection, vulnerability scanning, and incident response tools.',
    'Integrate with popular communication platforms to centralize alerts and team discussions.',
];

const publishers = ['Demo Bank', 'Atlassian', 'Slack', 'Figma', 'Google', 'Microsoft', 'AWS', 'Stripe', 'Twilio', 'Zapier', 'Salesforce', 'HubSpot', 'Shopify', 'Adobe', 'Zoom', 'GitHub', 'GitLab', 'Datadog', 'New Relic', 'IBM', 'Oracle', 'SAP', 'Cisco', 'Palo Alto Networks', 'Fortinet'];

const generatePricingPlans = (id: string): PricingPlan[] => {
    const plans = [];
    if (Math.random() > 0.4) { // 60% chance of being paid
        plans.push({
            id: `${id}-basic`,
            name: 'Basic',
            description: 'Essential features for small teams.',
            priceMonthly: 9.99,
            priceAnnually: 99.99,
            features: ['Core Integration', '500 API calls/month', 'Standard Support'],
        });
        plans.push({
            id: `${id}-pro`,
            name: 'Pro',
            description: 'Advanced features for growing businesses.',
            priceMonthly: 29.99,
            priceAnnually: 299.99,
            features: ['All Basic Features', 'Unlimited API calls', 'Premium Support', 'Custom Reports', 'Multi-user Access'],
        });
        if (Math.random() > 0.6) { // 40% chance of enterprise tier
            plans.push({
                id: `${id}-enterprise`,
                name: 'Enterprise',
                description: 'Customizable solutions for large organizations.',
                priceMonthly: 99.99,
                priceAnnually: 999.99,
                features: ['All Pro Features', 'Dedicated Account Manager', 'SLA', 'On-premise Deployment Options', 'Advanced Security Audit'],
            });
        }
    }
    return plans;
};

const generateChangelog = (version: string): ExtensionVersionLog[] => {
    const logs = [];
    let currentVersion = version.split('.').map(Number);
    for (let i = 0; i < Math.floor(Math.random() * 5) + 1; i++) {
        const major = currentVersion[0];
        const minor = currentVersion[1];
        const patch = currentVersion[2];
        const newPatch = Math.max(0, patch - (i === 0 ? 0 : Math.floor(Math.random() * 5))); // Ensure patch doesn't go below 0 for older versions
        const newMinor = minor - (Math.random() > 0.8 && i !== 0 ? 1 : 0);
        const newMajor = major - (Math.random() > 0.95 && i !== 0 ? 1 : 0);

        currentVersion = [Math.max(0, newMajor), Math.max(0, newMinor), Math.max(0, newPatch)];

        logs.push({
            version: currentVersion.join('.'),
            releaseDate: new Date(Date.now() - (i * 30 + Math.random() * 15) * 24 * 60 * 60 * 1000).toISOString(),
            changes: [
                `Improved performance for ${Math.random() > 0.5 ? 'large datasets' : 'real-time updates'}.`,
                `Fixed a bug where ${Math.random() > 0.5 ? 'notifications were not sent' : 'data sync failed intermittently'}.`,
                Math.random() > 0.3 ? `Added support for new ${Math.random() > 0.5 ? 'API endpoints' : 'integration partners'}.` : '',
            ].filter(Boolean),
        });
    }
    return logs.reverse(); // Newest version last
};

const generateMockExtensions = (count: number): Extension[] => {
    const extensions: Extension[] = [];
    for (let i = 0; i < count; i++) {
        const id = `ext-${generateRandomId()}`;
        const publisher = publishers[Math.floor(Math.random() * publishers.length)];
        const category = MOCK_CATEGORIES[Math.floor(Math.random() * MOCK_CATEGORIES.length)];
        const tags = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => `tag-${generateRandomId().substring(0, 5)}`);
        const rating = parseFloat((Math.random() * 2 + 3).toFixed(1)); // Between 3.0 and 5.0
        const installCount = Math.floor(Math.random() * 50000) + 100;
        const recommended = Math.random() > 0.7; // 30% chance
        const description = EXTENSION_DESCRIPTIONS[Math.floor(Math.random() * EXTENSION_DESCRIPTIONS.length)];
        const version = `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 20)}`;
        const lastUpdated = new Date(Date.now() - Math.floor(Math.random() * 365) * 24 * 60 * 60 * 1000).toISOString();
        const price = Math.random() > 0.6 ? parseFloat((Math.random() * 100).toFixed(2)) : 0;
        const pricingPlans = price > 0 ? generatePricingPlans(id) : undefined;
        const screenshots = Array.from({ length: Math.floor(Math.random() * 4) + 2 }, (_, idx) => `https://via.placeholder.com/600x400?text=Screenshot+${idx + 1}`);
        const changelog = generateChangelog(version);

        extensions.push({
            id,
            name: `${publisher} ${category.name} ${i + 1}`,
            publisher,
            description,
            icon: category.icon, // Using category icon as extension icon
            recommended,
            category: category.name,
            tags,
            rating,
            installCount,
            price,
            lastUpdated,
            version,
            screenshots,
            documentationUrl: `https://docs.example.com/${id}`,
            privacyPolicyUrl: `https://privacy.example.com/${id}`,
            developerInfo: {
                id: `dev-${generateRandomId()}`,
                name: `${publisher} Team`,
                contactEmail: `contact@${publisher.toLowerCase().replace(/\s/g, '')}.com`,
                website: `https://${publisher.toLowerCase().replace(/\s/g, '')}.com`,
            },
            pricingPlans,
            changelog,
        });
    }
    return extensions;
};

// Start with existing mocks and add many more
const MOCK_EXTENSIONS: Extension[] = [
    { id: 'ext-vscode', name: 'Demo Bank for VS Code', publisher: 'Demo Bank', description: 'Manage your API resources and test webhooks directly from your editor.', icon: <p>VS</p>, recommended: true, category: 'Developer Tools', tags: ['IDE', 'APIs', 'Webhooks'], rating: 4.8, installCount: 120000, price: 0, lastUpdated: '2023-10-26T10:00:00Z', version: '1.5.2', screenshots: ['https://via.placeholder.com/600x400?text=VSCode+1', 'https://via.placeholder.com/600x400?text=VSCode+2'], documentationUrl: 'https://docs.demobank.com/vscode', privacyPolicyUrl: 'https://demobank.com/privacy', developerInfo: { id: 'dev-demobank', name: 'Demo Bank Team', contactEmail: 'dev@demobank.com', website: 'https://demobank.com' }, changelog: [{ version: '1.5.2', releaseDate: '2023-10-26', changes: ['Bug fixes', 'Performance improvements'] }] },
    { id: 'ext-jira', name: 'Jira Integration', publisher: 'Atlassian', description: 'Create and link Demo Bank transactions to Jira issues automatically.', icon: <p>JI</p>, recommended: false, category: 'Collaboration', tags: ['Project Management', 'Ticketing'], rating: 4.5, installCount: 85000, price: 0, lastUpdated: '2023-09-15T10:00:00Z', version: '2.1.0', screenshots: ['https://via.placeholder.com/600x400?text=Jira+1', 'https://via.placeholder.com/600x400?text=Jira+2'], documentationUrl: 'https://docs.atlassian.com/jira-demobank', privacyPolicyUrl: 'https://atlassian.com/privacy', developerInfo: { id: 'dev-atlassian', name: 'Atlassian', contactEmail: 'support@atlassian.com' }, pricingPlans: [{ id: 'jira-pro', name: 'Pro Plan', description: 'Advanced linking and automation', priceMonthly: 15.00, priceAnnually: 150.00, features: ['Unlimited automations', 'Custom fields mapping'] }] },
    { id: 'ext-slack', name: 'Slack Notifications', publisher: 'Slack', description: 'Get real-time alerts for payment approvals, compliance cases, and more.', icon: <p>SL</p>, recommended: true, category: 'Collaboration', tags: ['Communication', 'Alerts'], rating: 4.7, installCount: 200000, price: 0, lastUpdated: '2023-11-01T10:00:00Z', version: '3.0.1', screenshots: ['https://via.placeholder.com/600x400?text=Slack+1', 'https://via.placeholder.com/600x400?text=Slack+2'], documentationUrl: 'https://api.slack.com/demobank', privacyPolicyUrl: 'https://slack.com/privacy', developerInfo: { id: 'dev-slack', name: 'Slack Technologies', contactEmail: 'dev@slack.com' } },
    { id: 'ext-figma', name: 'Figma Card Designer', publisher: 'Figma', description: 'Sync your card designs from Figma directly to the Card Customization forge.', icon: <p>FI</p>, recommended: false, category: 'Design & UI', tags: ['Design', 'UX'], rating: 4.2, installCount: 30000, price: 2.99, lastUpdated: '2023-08-01T10:00:00Z', version: '1.1.0', screenshots: ['https://via.placeholder.com/600x400?text=Figma+1', 'https://via.placeholder.com/600x400?text=Figma+2'], documentationUrl: 'https://help.figma.com/demobank', privacyPolicyUrl: 'https://figma.com/privacy', developerInfo: { id: 'dev-figma', name: 'Figma Inc.', contactEmail: 'support@figma.com' } },
    { id: 'ext-sheets', name: 'Google Sheets Exporter', publisher: 'Google', description: 'Export transaction and report data to Google Sheets on a schedule.', icon: <p>GS</p>, recommended: false, category: 'Reporting & Analytics', tags: ['Data Export', 'Spreadsheets'], rating: 4.6, installCount: 95000, price: 0, lastUpdated: '2023-10-05T10:00:00Z', version: '1.8.3', screenshots: ['https://via.placeholder.com/600x400?text=Sheets+1', 'https://via.placeholder.com/600x400?text=Sheets+2'], documentationUrl: 'https://developers.google.com/sheets/demobank', privacyPolicyUrl: 'https://google.com/privacy', developerInfo: { id: 'dev-google', name: 'Google LLC', contactEmail: 'cloud-support@google.com' } },
    ...generateMockExtensions(495), // Add many more to reach the line count
];

const MOCK_REVIEWS: ExtensionReview[] = [];
MOCK_EXTENSIONS.forEach(ext => {
    for (let i = 0; i < Math.floor(Math.random() * 10) + 5; i++) { // 5-14 reviews per extension
        MOCK_REVIEWS.push({
            id: generateRandomId(),
            extensionId: ext.id,
            userId: `user-${generateRandomId()}`,
            userName: `User ${generateRandomId().substring(0, 4)}`,
            rating: parseFloat((Math.random() * 2 + 3).toFixed(1)), // 3.0 to 5.0
            comment: EXTENSION_DESCRIPTIONS[Math.floor(Math.random() * EXTENSION_DESCRIPTIONS.length)],
            timestamp: new Date(Date.now() - Math.floor(Math.random() * 365 * 5) * 24 * 60 * 60 * 1000).toISOString(),
        });
    }
});

const MOCK_INSTALLED_EXTENSIONS: InstalledExtension[] = [
    { id: 'inst-vscode', extensionId: 'ext-vscode', userId: 'user-current', installationDate: '2023-01-15T10:00:00Z', enabled: true, configuration: { theme: 'dark', autoUpdate: true } },
    { id: 'inst-slack', extensionId: 'ext-slack', userId: 'user-current', installationDate: '2023-02-20T11:30:00Z', enabled: true, configuration: { channels: ['#payments', '#compliance'], notificationLevel: 'critical' } },
    { id: 'inst-jira', extensionId: 'ext-jira', userId: 'user-current', installationDate: '2023-03-01T14:00:00Z', enabled: false, configuration: { project: 'DEMO', linkPayments: false }, subscription: { planId: 'jira-pro', startDate: '2023-03-01T14:00:00Z', endDate: '2024-03-01T14:00:00Z', status: 'active', autoRenew: true } },
];
// Add more installed extensions, potentially for other users
for (let i = 0; i < 50; i++) {
    const randomExt = MOCK_EXTENSIONS[Math.floor(Math.random() * MOCK_EXTENSIONS.length)];
    if (!MOCK_INSTALLED_EXTENSIONS.some(ie => ie.extensionId === randomExt.id && ie.userId === 'user-current')) {
        MOCK_INSTALLED_EXTENSIONS.push({
            id: `inst-${generateRandomId()}`,
            extensionId: randomExt.id,
            userId: 'user-current',
            installationDate: new Date(Date.now() - Math.floor(Math.random() * 365) * 24 * 60 * 60 * 1000).toISOString(),
            enabled: Math.random() > 0.1,
            configuration: {
                setting1: Math.random() > 0.5 ? 'valueA' : 'valueB',
                setting2: Math.random() * 100,
            },
            subscription: randomExt.pricingPlans && randomExt.pricingPlans.length > 0 && Math.random() > 0.3 ? {
                planId: randomExt.pricingPlans[0].id,
                startDate: new Date(Date.now() - Math.floor(Math.random() * 180) * 24 * 60 * 60 * 1000).toISOString(),
                endDate: new Date(Date.now() + Math.floor(Math.random() * 180) * 24 * 60 * 60 * 1000).toISOString(),
                status: 'active',
                autoRenew: Math.random() > 0.5,
            } : undefined,
        });
    }
}


const MOCK_DEVELOPER_EXTENSIONS: DeveloperExtension[] = MOCK_EXTENSIONS
    .filter(ext => ext.developerInfo.id === 'dev-demobank' || Math.random() > 0.8) // Some random ones, plus demobank
    .map(ext => ({
        id: ext.id,
        name: ext.name,
        status: (['published', 'draft', 'pending_review'] as const)[Math.floor(Math.random() * 3)],
        version: ext.version,
        lastPublished: ext.lastUpdated,
        totalInstalls: ext.installCount,
        reviewsCount: MOCK_REVIEWS.filter(r => r.extensionId === ext.id).length,
        averageRating: ext.rating,
        monetizationStatus: ext.price > 0 ? (ext.pricingPlans ? 'subscription' : 'paid') : 'free',
        pendingUpdates: Math.random() > 0.7,
    }));

const MOCK_AUDIT_LOGS: AuditLogEntry[] = Array.from({ length: 200 }, () => {
    const action = (['INSTALL_EXTENSION', 'UNINSTALL_EXTENSION', 'UPDATE_CONFIG', 'SUBMIT_REVIEW', 'PUBLISH_EXTENSION', 'UPDATE_EXTENSION'] as const)[Math.floor(Math.random() * 6)];
    const randomExt = MOCK_EXTENSIONS[Math.floor(Math.random() * MOCK_EXTENSIONS.length)];
    const details: Record<string, any> = {};
    if (action === 'INSTALL_EXTENSION' || action === 'UNINSTALL_EXTENSION' || action === 'UPDATE_CONFIG' || action === 'SUBMIT_REVIEW' || action === 'UPDATE_EXTENSION') {
        details.extensionName = randomExt.name;
    }
    if (action === 'UPDATE_CONFIG') {
        details.oldConfig = { enabled: true };
        details.newConfig = { enabled: false };
    }
    if (action === 'SUBMIT_REVIEW') {
        details.rating = Math.floor(Math.random() * 5) + 1;
    }
    return {
        id: generateRandomId(),
        timestamp: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000).toISOString(),
        action,
        userId: Math.random() > 0.5 ? 'user-current' : `user-${generateRandomId()}`,
        extensionId: randomExt.id,
        details,
    };
}).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());


const MOCK_ANALYTICS_DATA: ExtensionAnalytics[] = MOCK_DEVELOPER_EXTENSIONS.map(devExt => {
    const data = [];
    for (let i = 0; i < 30; i++) {
        const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        data.push({
            date,
            installs: Math.floor(Math.random() * 100),
            uninstalls: Math.floor(Math.random() * 10),
            activeUsers: Math.floor(Math.random() * devExt.totalInstalls * 0.5),
            revenue: devExt.monetizationStatus !== 'free' ? parseFloat((Math.random() * 500).toFixed(2)) : undefined,
            errors: Math.floor(Math.random() * 5),
        });
    }
    return {
        extensionId: devExt.id,
        period: 'daily',
        data: data.reverse(), // Newest last
    };
});


// --- Mock API Service (Simulates async calls) ---
export const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

export const mockApiService = {
    fetchExtensions: async (params: {
        query?: string;
        category?: string;
        publisher?: string;
        minRating?: number;
        priceFilter?: 'free' | 'paid' | 'any';
        page?: number;
        limit?: number;
        sortBy?: keyof Extension;
        sortOrder?: 'asc' | 'desc';
    }): Promise<{ extensions: Extension[]; total: number }> => {
        await delay(300 + Math.random() * 500); // Simulate network delay
        let filtered = [...MOCK_EXTENSIONS];

        if (params.query) {
            const lowerQuery = params.query.toLowerCase();
            filtered = filtered.filter(ext =>
                ext.name.toLowerCase().includes(lowerQuery) ||
                ext.description.toLowerCase().includes(lowerQuery) ||
                ext.publisher.toLowerCase().includes(lowerQuery) ||
                ext.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
            );
        }

        if (params.category && params.category !== 'all') {
            filtered = filtered.filter(ext => ext.category.toLowerCase() === params.category!.toLowerCase());
        }

        if (params.publisher && params.publisher !== 'all') {
            filtered = filtered.filter(ext => ext.publisher.toLowerCase() === params.publisher!.toLowerCase());
        }

        if (params.minRating) {
            filtered = filtered.filter(ext => ext.rating >= params.minRating!);
        }

        if (params.priceFilter) {
            if (params.priceFilter === 'free') {
                filtered = filtered.filter(ext => ext.price === 0);
            } else if (params.priceFilter === 'paid') {
                filtered = filtered.filter(ext => ext.price > 0);
            }
        }

        if (params.sortBy) {
            filtered.sort((a, b) => {
                const valA = a[params.sortBy!] as any;
                const valB = b[params.sortBy!] as any;
                if (typeof valA === 'string') {
                    return params.sortOrder === 'desc' ? valB.localeCompare(valA) : valA.localeCompare(valB);
                }
                return params.sortOrder === 'desc' ? valB - valA : valA - valB;
            });
        }

        const total = filtered.length;
        const page = params.page || 1;
        const limit = params.limit || 12;
        const startIndex = (page - 1) * limit;
        const endIndex = startIndex + limit;
        const extensions = filtered.slice(startIndex, endIndex);

        return { extensions, total };
    },

    fetchExtensionDetails: async (id: string): Promise<Extension | null> => {
        await delay(200 + Math.random() * 300);
        return MOCK_EXTENSIONS.find(ext => ext.id === id) || null;
    },

    fetchExtensionReviews: async (extensionId: string): Promise<ExtensionReview[]> => {
        await delay(150 + Math.random() * 250);
        return MOCK_REVIEWS.filter(review => review.extensionId === extensionId);
    },

    submitReview: async (review: Omit<ExtensionReview, 'id' | 'timestamp' | 'userId' | 'userName'>): Promise<ExtensionReview> => {
        await delay(400);
        const newReview: ExtensionReview = {
            ...review,
            id: generateRandomId(),
            userId: 'user-current', // Assume current user
            userName: 'Current User',
            timestamp: new Date().toISOString(),
        };
        MOCK_REVIEWS.push(newReview);
        // Update average rating and reviews count for the extension (in-memory mock)
        const ext = MOCK_EXTENSIONS.find(e => e.id === review.extensionId);
        if (ext) {
            const reviewsForExt = MOCK_REVIEWS.filter(r => r.extensionId === ext.id);
            ext.rating = reviewsForExt.reduce((sum, r) => sum + r.rating, 0) / reviewsForExt.length;
        }
        return newReview;
    },

    fetchInstalledExtensions: async (userId: string): Promise<InstalledExtension[]> => {
        await delay(250 + Math.random() * 400);
        return MOCK_INSTALLED_EXTENSIONS.filter(installed => installed.userId === userId);
    },

    installExtension: async (extensionId: string, userId: string): Promise<InstalledExtension> => {
        await delay(500);
        const existing = MOCK_INSTALLED_EXTENSIONS.find(inst => inst.extensionId === extensionId && inst.userId === userId);
        if (existing) {
            throw new Error('Extension already installed');
        }
        const ext = MOCK_EXTENSIONS.find(e => e.id === extensionId);
        if (!ext) throw new Error('Extension not found');

        const newInstall: InstalledExtension = {
            id: `inst-${generateRandomId()}`,
            extensionId,
            userId,
            installationDate: new Date().toISOString(),
            enabled: true,
            configuration: {},
            subscription: ext.pricingPlans && ext.pricingPlans.length > 0 ? {
                planId: ext.pricingPlans[0].id, // Default to first plan for mock
                startDate: new Date().toISOString(),
                endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days trial
                status: 'trial',
                autoRenew: false,
            } : undefined,
        };
        MOCK_INSTALLED_EXTENSIONS.push(newInstall);
        ext.installCount++; // Update install count
        MOCK_AUDIT_LOGS.unshift({
            id: generateRandomId(), timestamp: new Date().toISOString(), action: 'INSTALL_EXTENSION', userId, extensionId, details: { extensionName: ext.name }
        });
        return newInstall;
    },

    uninstallExtension: async (installedExtensionId: string, userId: string): Promise<void> => {
        await delay(500);
        const index = MOCK_INSTALLED_EXTENSIONS.findIndex(inst => inst.id === installedExtensionId && inst.userId === userId);
        if (index === -1) {
            throw new Error('Installed extension not found');
        }
        const removed = MOCK_INSTALLED_EXTENSIONS.splice(index, 1)[0];
        const ext = MOCK_EXTENSIONS.find(e => e.id === removed.extensionId);
        if (ext) {
            ext.installCount = Math.max(0, ext.installCount - 1); // Decrement install count
            MOCK_AUDIT_LOGS.unshift({
                id: generateRandomId(), timestamp: new Date().toISOString(), action: 'UNINSTALL_EXTENSION', userId, extensionId: ext.id, details: { extensionName: ext.name }
            });
        }
    },

    updateExtensionConfiguration: async (installedExtensionId: string, userId: string, config: Record<string, any>): Promise<InstalledExtension> => {
        await delay(400);
        const installed = MOCK_INSTALLED_EXTENSIONS.find(inst => inst.id === installedExtensionId && inst.userId === userId);
        if (!installed) {
            throw new Error('Installed extension not found');
        }
        const oldConfig = { ...installed.configuration };
        installed.configuration = { ...installed.configuration, ...config };
        MOCK_AUDIT_LOGS.unshift({
            id: generateRandomId(), timestamp: new Date().toISOString(), action: 'UPDATE_CONFIG', userId, extensionId: installed.extensionId, details: { extensionName: MOCK_EXTENSIONS.find(e => e.id === installed.extensionId)?.name, oldConfig, newConfig: config }
        });
        return { ...installed };
    },

    // Developer-specific API
    fetchDeveloperExtensions: async (developerId: string): Promise<DeveloperExtension[]> => {
        await delay(300);
        return MOCK_DEVELOPER_EXTENSIONS.filter(devExt =>
            MOCK_EXTENSIONS.find(ext => ext.id === devExt.id)?.developerInfo.id === developerId
        );
    },

    publishNewExtension: async (newExt: Omit<Extension, 'id' | 'lastUpdated' | 'installCount' | 'rating' | 'version' | 'changelog'> & { initialVersion: string }): Promise<Extension> => {
        await delay(700);
        const id = `ext-${generateRandomId()}`;
        const version = newExt.initialVersion;
        const extension: Extension = {
            ...newExt,
            id,
            lastUpdated: new Date().toISOString(),
            installCount: 0,
            rating: 0,
            version,
            changelog: [{ version, releaseDate: new Date().toISOString(), changes: ['Initial release'] }],
        };
        MOCK_EXTENSIONS.unshift(extension); // Add to marketplace
        MOCK_DEVELOPER_EXTENSIONS.unshift({
            id,
            name: extension.name,
            status: 'pending_review', // Initially pending
            version: extension.version,
            lastPublished: extension.lastUpdated,
            totalInstalls: 0,
            reviewsCount: 0,
            averageRating: 0,
            monetizationStatus: extension.price > 0 ? (extension.pricingPlans ? 'subscription' : 'paid') : 'free',
            pendingUpdates: false,
        });
        MOCK_AUDIT_LOGS.unshift({
            id: generateRandomId(), timestamp: new Date().toISOString(), action: 'PUBLISH_EXTENSION', userId: extension.developerInfo.id, extensionId: id, details: { extensionName: extension.name, status: 'pending_review' }
        });
        return extension;
    },

    updatePublishedExtension: async (extensionId: string, updatedFields: Partial<Omit<Extension, 'id' | 'developerInfo'>>): Promise<Extension> => {
        await delay(700);
        const index = MOCK_EXTENSIONS.findIndex(ext => ext.id === extensionId);
        if (index === -1) throw new Error('Extension not found');
        const oldExt = MOCK_EXTENSIONS[index];
        const newVersion = updatedFields.version && updatedFields.version !== oldExt.version ? updatedFields.version : oldExt.version;
        const newChangelog = newVersion !== oldExt.version && updatedFields.changelog?.length ?
            [...oldExt.changelog || [], { version: newVersion, releaseDate: new Date().toISOString(), changes: updatedFields.changelog[0]?.changes || ['Version updated'] }] :
            oldExt.changelog;

        const updatedExtension: Extension = {
            ...oldExt,
            ...updatedFields,
            version: newVersion,
            changelog: newChangelog,
            lastUpdated: new Date().toISOString(),
        };
        MOCK_EXTENSIONS[index] = updatedExtension;

        const devExtIndex = MOCK_DEVELOPER_EXTENSIONS.findIndex(de => de.id === extensionId);
        if (devExtIndex !== -1) {
            MOCK_DEVELOPER_EXTENSIONS[devExtIndex] = {
                ...MOCK_DEVELOPER_EXTENSIONS[devExtIndex],
                name: updatedExtension.name,
                version: updatedExtension.version,
                lastPublished: updatedExtension.lastUpdated,
                status: 'pending_review', // After update, typically goes to review
                monetizationStatus: updatedExtension.price > 0 ? (updatedExtension.pricingPlans ? 'subscription' : 'paid') : 'free',
                pendingUpdates: false,
            };
        }
        MOCK_AUDIT_LOGS.unshift({
            id: generateRandomId(), timestamp: new Date().toISOString(), action: 'UPDATE_EXTENSION', userId: updatedExtension.developerInfo.id, extensionId, details: { extensionName: updatedExtension.name, fields: Object.keys(updatedFields) }
        });
        return updatedExtension;
    },

    deletePublishedExtension: async (extensionId: string, developerId: string): Promise<void> => {
        await delay(500);
        const index = MOCK_EXTENSIONS.findIndex(ext => ext.id === extensionId && ext.developerInfo.id === developerId);
        if (index === -1) throw new Error('Extension not found or not owned by developer');
        const [removedExt] = MOCK_EXTENSIONS.splice(index, 1);

        const devIndex = MOCK_DEVELOPER_EXTENSIONS.findIndex(de => de.id === extensionId);
        if (devIndex !== -1) {
            MOCK_DEVELOPER_EXTENSIONS.splice(devIndex, 1);
        }
        MOCK_AUDIT_LOGS.unshift({
            id: generateRandomId(), timestamp: new Date().toISOString(), action: 'DELETE_EXTENSION', userId: developerId, extensionId, details: { extensionName: removedExt.name }
        });
    },

    fetchExtensionAnalytics: async (extensionId: string): Promise<ExtensionAnalytics | null> => {
        await delay(300);
        return MOCK_ANALYTICS_DATA.find(data => data.extensionId === extensionId) || null;
    },

    fetchAuditLogs: async (params: { userId?: string; extensionId?: string; limit?: number }): Promise<AuditLogEntry[]> => {
        await delay(200);
        let logs = [...MOCK_AUDIT_LOGS];
        if (params.userId) {
            logs = logs.filter(log => log.userId === params.userId);
        }
        if (params.extensionId) {
            logs = logs.filter(log => log.extensionId === params.extensionId);
        }
        return logs.slice(0, params.limit || 50);
    },
};

// --- User Context (for simulating user roles) ---
type UserRole = 'standard_user' | 'developer' | 'admin';

interface UserContextType {
    currentUser: { id: string; name: string; role: UserRole };
    setCurrentUser: (user: { id: string; name: string; role: UserRole }) => void;
}

export const UserContext = createContext<UserContextType | undefined>(undefined);

export const UserProvider: React.FC<React.PropsWithChildren<{}>> = ({ children }) => {
    const [currentUser, setCurrentUser] = useState<{ id: string; name: string; role: UserRole }>({
        id: 'user-current',
        name: 'John Doe',
        role: 'standard_user', // Default role
    });

    return (
        <UserContext.Provider value={{ currentUser, setCurrentUser }}>
            {children}
        </UserContext.Provider>
    );
};

export const useUser = () => {
    const context = useContext(UserContext);
    if (context === undefined) {
        throw new Error('useUser must be used within a UserProvider');
    }
    return context;
};

// --- Custom Hooks ---
export const useExtensions = (params: Parameters<typeof mockApiService.fetchExtensions>[0]) => {
    const [extensions, setExtensions] = useState<Extension[]>([]);
    const [totalExtensions, setTotalExtensions] = useState(0);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetch = async () => {
            setLoading(true);
            setError(null);
            try {
                const { extensions: fetchedExtensions, total } = await mockApiService.fetchExtensions(params);
                setExtensions(fetchedExtensions);
                setTotalExtensions(total);
            } catch (err) {
                setError('Failed to fetch extensions.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetch();
    }, [params]);

    return { extensions, totalExtensions, loading, error };
};

export const useExtensionDetails = (extensionId: string | null) => {
    const [extension, setExtension] = useState<Extension | null>(null);
    const [reviews, setReviews] = useState<ExtensionReview[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (!extensionId) {
            setExtension(null);
            setReviews([]);
            setLoading(false);
            return;
        }

        const fetchDetails = async () => {
            setLoading(true);
            setError(null);
            try {
                const fetchedExtension = await mockApiService.fetchExtensionDetails(extensionId);
                setExtension(fetchedExtension);
                if (fetchedExtension) {
                    const fetchedReviews = await mockApiService.fetchExtensionReviews(extensionId);
                    setReviews(fetchedReviews);
                }
            } catch (err) {
                setError('Failed to fetch extension details.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchDetails();
    }, [extensionId]);

    return { extension, reviews, loading, error, setReviews };
};

export const useInstalledExtensions = (userId: string) => {
    const [installedExtensions, setInstalledExtensions] = useState<InstalledExtension[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const refreshInstalled = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const fetched = await mockApiService.fetchInstalledExtensions(userId);
            setInstalledExtensions(fetched);
        } catch (err) {
            setError('Failed to fetch installed extensions.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [userId]);

    useEffect(() => {
        refreshInstalled();
    }, [refreshInstalled]);

    return { installedExtensions, loading, error, refreshInstalled, setInstalledExtensions };
};

export const useDeveloperExtensions = (developerId: string) => {
    const [developerExtensions, setDeveloperExtensions] = useState<DeveloperExtension[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const refreshDeveloperExtensions = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const fetched = await mockApiService.fetchDeveloperExtensions(developerId);
            setDeveloperExtensions(fetched);
        } catch (err) {
            setError('Failed to fetch developer extensions.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [developerId]);

    useEffect(() => {
        refreshDeveloperExtensions();
    }, [refreshDeveloperExtensions]);

    return { developerExtensions, loading, error, refreshDeveloperExtensions };
};

// --- Generic Loading and Error Components ---
export const LoadingSpinner: React.FC = () => (
    <div className="flex justify-center items-center py-8">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-cyan-400"></div>
        <p className="ml-4 text-cyan-300">Loading...</p>
    </div>
);

export const ErrorMessage: React.FC<{ message: string }> = ({ message }) => (
    <div className="bg-red-900/30 text-red-300 p-4 rounded-lg flex items-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span>Error: {message}</span>
    </div>
);

// --- Component: Rating Stars ---
export const RatingStars: React.FC<{ rating: number; maxStars?: number }> = ({ rating, maxStars = 5 }) => {
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.5 ? 1 : 0;
    const emptyStars = maxStars - fullStars - halfStar;

    return (
        <div className="flex items-center text-yellow-400 text-lg">
            {Array(fullStars).fill(0).map((_, i) => <span key={`full-${i}`}></span>)}
            {halfStar === 1 && <span key="half"></span>}
            {Array(emptyStars).fill(0).map((_, i) => <span key={`empty-${i}`}></span>)}
            <span className="ml-2 text-sm text-gray-400">({rating.toFixed(1)})</span>
        </div>
    );
};

// --- Component: ExtensionCard (Existing, slightly enhanced) ---
export const ExtensionCard: React.FC<{ extension: Extension; onInstall?: (ext: Extension) => void; onUninstall?: (installedExt: InstalledExtension) => void; installed?: InstalledExtension; onViewDetails: (ext: Extension) => void }> = ({ extension, onInstall, onUninstall, installed, onViewDetails }) => {
    const { currentUser } = useUser();
    const isInstalled = !!installed;
    const [installing, setInstalling] = useState(false);
    const [uninstalling, setUninstalling] = useState(false);

    const handleInstall = async () => {
        if (!onInstall || installing) return;
        setInstalling(true);
        try {
            await mockApiService.installExtension(extension.id, currentUser.id);
            onInstall(extension);
        } catch (error: any) {
            alert(`Failed to install: ${error.message}`);
        } finally {
            setInstalling(false);
        }
    };

    const handleUninstall = async () => {
        if (!onUninstall || uninstalling || !installed) return;
        setUninstalling(true);
        try {
            await mockApiService.uninstallExtension(installed.id, currentUser.id);
            onUninstall(installed);
        } catch (error: any) {
            alert(`Failed to uninstall: ${error.message}`);
        } finally {
            setUninstalling(false);
        }
    };

    return (
        <Card variant="interactive" className="flex flex-col h-full hover:shadow-lg hover:shadow-cyan-500/20 transition-all duration-200">
            <div className="flex-grow flex flex-col">
                <div className="flex items-center gap-4 mb-3" onClick={() => onViewDetails(extension)} style={{ cursor: 'pointer' }}>
                    <div className="w-12 h-12 bg-gray-700/50 rounded-lg flex items-center justify-center text-xl font-bold text-cyan-300">{extension.icon}</div>
                    <div>
                        <h3 className="font-semibold text-white text-lg">{extension.name}</h3>
                        <p className="text-xs text-gray-400">by {extension.publisher}</p>
                    </div>
                </div>
                <div className="mb-2">
                    <RatingStars rating={extension.rating} />
                    <p className="text-xs text-gray-500">{extension.installCount.toLocaleString()} installs</p>
                </div>
                <p className="text-sm text-gray-400 flex-grow mb-3">{truncateText(extension.description, 100)}</p>
                <div className="flex flex-wrap gap-2 mb-3">
                    <span className="bg-gray-700/30 text-gray-300 text-xs px-2 py-1 rounded-full">{extension.category}</span>
                    {extension.tags.map(tag => (
                        <span key={tag} className="bg-gray-700/30 text-gray-500 text-xs px-2 py-1 rounded-full">#{tag}</span>
                    ))}
                </div>
                {extension.price > 0 && (
                    <p className="text-sm text-cyan-300 font-semibold mt-auto">{extension.price === 0 ? 'Free' : `$${extension.price.toFixed(2)}`}</p>
                )}
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700/50">
                {isInstalled ? (
                    <div className="flex gap-2">
                        <button
                            onClick={() => onViewDetails(extension)}
                            className="flex-grow py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm transition-colors duration-200"
                            disabled={installing || uninstalling}
                        >
                            Manage
                        </button>
                        <button
                            onClick={handleUninstall}
                            className="w-1/3 py-2 bg-red-600/50 hover:bg-red-600 text-white rounded-lg text-sm transition-colors duration-200"
                            disabled={uninstalling || installing}
                        >
                            {uninstalling ? '...' : 'Uninstall'}
                        </button>
                    </div>
                ) : (
                    <button
                        onClick={handleInstall}
                        className="w-full py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm transition-colors duration-200"
                        disabled={installing || uninstalling}
                    >
                        {installing ? 'Installing...' : 'Install'}
                    </button>
                )}
            </div>
        </Card>
    );
};

// --- Component: ExtensionDetailsModal ---
export const ExtensionDetailsModal: React.FC<{ extension: Extension; reviews: ExtensionReview[]; onClose: () => void; onInstall: (ext: Extension) => void; installed?: InstalledExtension; onUninstall: (installedExt: InstalledExtension) => void; onNewReview: (review: ExtensionReview) => void }> = ({
    extension,
    reviews,
    onClose,
    onInstall,
    installed,
    onUninstall,
    onNewReview,
}) => {
    const { currentUser } = useUser();
    const isInstalled = !!installed;
    const [installing, setInstalling] = useState(false);
    const [uninstalling, setUninstalling] = useState(false);
    const [currentTab, setCurrentTab] = useState<'overview' | 'reviews' | 'versions' | 'screenshots' | 'pricing'>('overview');
    const [reviewText, setReviewText] = useState('');
    const [reviewRating, setReviewRating] = useState(0);
    const [submittingReview, setSubmittingReview] = useState(false);
    const hasReviewed = reviews.some(r => r.userId === currentUser.id);

    const handleInstall = async () => {
        if (!onInstall || installing) return;
        setInstalling(true);
        try {
            const newInstalled = await mockApiService.installExtension(extension.id, currentUser.id);
            onInstall(extension); // Callback to update parent state
        } catch (error: any) {
            alert(`Failed to install: ${error.message}`);
        } finally {
            setInstalling(false);
        }
    };

    const handleUninstall = async () => {
        if (!onUninstall || uninstalling || !installed) return;
        setUninstalling(true);
        try {
            await mockApiService.uninstallExtension(installed.id, currentUser.id);
            onUninstall(installed); // Callback to update parent state
        } catch (error: any) {
            alert(`Failed to uninstall: ${error.message}`);
        } finally {
            setUninstalling(false);
        }
    };

    const handleSubmitReview = async () => {
        if (!reviewText || reviewRating === 0 || submittingReview) return;
        setSubmittingReview(true);
        try {
            const newReview = await mockApiService.submitReview({
                extensionId: extension.id,
                rating: reviewRating,
                comment: reviewText,
            });
            onNewReview(newReview); // Callback to update parent state
            setReviewText('');
            setReviewRating(0);
        } catch (error: any) {
            alert(`Failed to submit review: ${error.message}`);
        } finally {
            setSubmittingReview(false);
        }
    };

    if (!extension) return null;

    const averageRating = reviews.length > 0 ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length : 0;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-75 overflow-y-auto">
            <Card className="w-full max-w-4xl max-h-[90vh] overflow-y-auto bg-gray-800 border border-gray-700/50 relative">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">
                    &times;
                </button>

                <div className="flex items-start gap-6 pb-6 border-b border-gray-700/50 mb-6">
                    <div className="w-20 h-20 bg-gray-700/50 rounded-lg flex items-center justify-center text-4xl font-bold text-cyan-300 flex-shrink-0">
                        {extension.icon}
                    </div>
                    <div className="flex-grow">
                        <h2 className="text-3xl font-bold text-white mb-1">{extension.name}</h2>
                        <p className="text-md text-gray-400 mb-2">by {extension.publisher}</p>
                        <div className="flex items-center gap-3">
                            <RatingStars rating={averageRating} />
                            <span className="text-sm text-gray-500">({reviews.length} reviews)</span>
                            <span className="text-sm text-gray-500">| {extension.installCount.toLocaleString()} installs</span>
                        </div>
                        <p className="text-sm text-cyan-300 font-semibold mt-2">{extension.price === 0 ? 'Free' : `$${extension.price.toFixed(2)}`}</p>
                    </div>
                    <div className="flex-shrink-0">
                        {isInstalled ? (
                            <div className="flex flex-col gap-2">
                                <button
                                    onClick={() => { /* Open settings modal */ alert('Open settings for this extension!'); }}
                                    className="px-6 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm transition-colors duration-200"
                                    disabled={installing || uninstalling}
                                >
                                    Manage Settings
                                </button>
                                <button
                                    onClick={handleUninstall}
                                    className="px-6 py-2 bg-red-600/50 hover:bg-red-600 text-white rounded-lg text-sm transition-colors duration-200"
                                    disabled={uninstalling || installing}
                                >
                                    {uninstalling ? 'Uninstalling...' : 'Uninstall'}
                                </button>
                            </div>
                        ) : (
                            <button
                                onClick={handleInstall}
                                className="px-8 py-3 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-lg font-semibold transition-colors duration-200"
                                disabled={installing || uninstalling}
                            >
                                {installing ? 'Installing...' : 'Install Extension'}
                            </button>
                        )}
                    </div>
                </div>

                <div className="flex border-b border-gray-700/50 mb-6 -mx-6 px-6">
                    {['overview', 'reviews', 'versions', 'screenshots', 'pricing'].filter(tab => tab !== 'pricing' || extension.pricingPlans?.length).map(tab => (
                        <button
                            key={tab}
                            onClick={() => setCurrentTab(tab as any)}
                            className={`px-4 py-3 text-sm font-medium ${currentTab === tab ? 'text-cyan-400 border-b-2 border-cyan-400' : 'text-gray-400 hover:text-white'}`}
                        >
                            {tab.charAt(0).toUpperCase() + tab.slice(1)}
                            {tab === 'reviews' && reviews.length > 0 && ` (${reviews.length})`}
                            {tab === 'versions' && extension.changelog && extension.changelog.length > 0 && ` (${extension.changelog.length})`}
                        </button>
                    ))}
                </div>

                <div className="prose prose-invert max-w-none text-gray-300">
                    {currentTab === 'overview' && (
                        <div>
                            <p className="text-lg text-gray-300 mb-4">{extension.description}</p>
                            <h3 className="text-xl font-semibold text-white mb-2">Key Features</h3>
                            <ul className="list-disc list-inside space-y-1 mb-4">
                                <li>Real-time data synchronization</li>
                                <li>Customizable dashboards and alerts</li>
                                <li>Secure API access and robust authentication</li>
                                <li>Developer-friendly documentation and SDKs</li>
                                <li>Scalable architecture for growing demands</li>
                                <li>Integration with popular third-party services</li>
                                <li>Comprehensive audit trails for compliance</li>
                            </ul>
                            <div className="flex gap-4 mb-4">
                                <div>
                                    <h4 className="font-semibold text-white">Last Updated</h4>
                                    <p className="text-gray-400">{formatDate(extension.lastUpdated)}</p>
                                </div>
                                <div>
                                    <h4 className="font-semibold text-white">Version</h4>
                                    <p className="text-gray-400">{extension.version}</p>
                                </div>
                                <div>
                                    <h4 className="font-semibold text-white">Category</h4>
                                    <p className="text-gray-400">{extension.category}</p>
                                </div>
                            </div>
                            <div className="flex gap-4 mb-4">
                                {extension.documentationUrl && (
                                    <a href={extension.documentationUrl} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Documentation</a>
                                )}
                                {extension.privacyPolicyUrl && (
                                    <a href={extension.privacyPolicyUrl} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Privacy Policy</a>
                                )}
                            </div>
                            <h3 className="text-xl font-semibold text-white mb-2">Developer Information</h3>
                            <p className="text-gray-400"><strong>Name:</strong> {extension.developerInfo.name}</p>
                            <p className="text-gray-400"><strong>Contact:</strong> {extension.developerInfo.contactEmail}</p>
                            {extension.developerInfo.website && (
                                <p className="text-gray-400"><strong>Website:</strong> <a href={extension.developerInfo.website} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">{extension.developerInfo.website}</a></p>
                            )}
                        </div>
                    )}

                    {currentTab === 'reviews' && (
                        <div>
                            <h3 className="text-xl font-semibold text-white mb-4">User Reviews</h3>
                            {reviews.length === 0 && <p className="text-gray-500">No reviews yet. Be the first to review!</p>}
                            <div className="space-y-6 mb-6">
                                {reviews.map(review => (
                                    <div key={review.id} className="border-b border-gray-700/50 pb-4 last:border-b-0">
                                        <div className="flex items-center gap-3 mb-1">
                                            <span className="font-semibold text-white">{review.userName}</span>
                                            <RatingStars rating={review.rating} />
                                        </div>
                                        <p className="text-sm text-gray-400 mb-2">{review.comment}</p>
                                        <p className="text-xs text-gray-500">Reviewed on {formatDate(review.timestamp)}</p>
                                    </div>
                                ))}
                            </div>
                            <h3 className="text-xl font-semibold text-white mb-4">Write a Review</h3>
                            {!hasReviewed ? (
                                <div className="space-y-4">
                                    <div className="flex items-center gap-2">
                                        <span className="text-gray-300">Your Rating:</span>
                                        {[1, 2, 3, 4, 5].map(star => (
                                            <button
                                                key={star}
                                                onClick={() => setReviewRating(star)}
                                                className={`text-2xl ${star <= reviewRating ? 'text-yellow-400' : 'text-gray-500 hover:text-yellow-300'}`}
                                            >
                                                
                                            </button>
                                        ))}
                                    </div>
                                    <textarea
                                        className="w-full p-3 bg-gray-700/50 rounded-lg text-gray-200 placeholder-gray-500 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                                        rows={4}
                                        placeholder="Share your experience..."
                                        value={reviewText}
                                        onChange={(e) => setReviewText(e.target.value)}
                                    ></textarea>
                                    <button
                                        onClick={handleSubmitReview}
                                        className="px-6 py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm font-semibold transition-colors duration-200"
                                        disabled={submittingReview || reviewRating === 0 || !reviewText.trim()}
                                    >
                                        {submittingReview ? 'Submitting...' : 'Submit Review'}
                                    </button>
                                </div>
                            ) : (
                                <p className="text-gray-500">You have already submitted a review for this extension.</p>
                            )}
                        </div>
                    )}

                    {currentTab === 'versions' && (
                        <div>
                            <h3 className="text-xl font-semibold text-white mb-4">Version History</h3>
                            {extension.changelog && extension.changelog.length > 0 ? (
                                <div className="space-y-4">
                                    {extension.changelog.map((log, index) => (
                                        <div key={index} className="border-b border-gray-700/50 pb-3 last:border-b-0">
                                            <p className="font-semibold text-white">Version {log.version} <span className="text-sm text-gray-500">({formatDate(log.releaseDate)})</span></p>
                                            <ul className="list-disc list-inside text-sm text-gray-400 pl-4">
                                                {log.changes.map((change, i) => <li key={i}>{change}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <p className="text-gray-500">No version history available.</p>
                            )}
                        </div>
                    )}

                    {currentTab === 'screenshots' && (
                        <div>
                            <h3 className="text-xl font-semibold text-white mb-4">Screenshots</h3>
                            {extension.screenshots && extension.screenshots.length > 0 ? (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {extension.screenshots.map((src, index) => (
                                        <img key={index} src={src} alt={`Screenshot ${index + 1}`} className="rounded-lg object-cover w-full h-auto" />
                                    ))}
                                </div>
                            ) : (
                                <p className="text-gray-500">No screenshots available.</p>
                            )}
                        </div>
                    )}

                    {currentTab === 'pricing' && extension.pricingPlans && extension.pricingPlans.length > 0 && (
                        <div>
                            <h3 className="text-xl font-semibold text-white mb-4">Pricing Plans</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                {extension.pricingPlans.map(plan => (
                                    <Card key={plan.id} className="bg-gray-700/30 p-6 flex flex-col">
                                        <h4 className="text-xl font-bold text-cyan-300 mb-2">{plan.name}</h4>
                                        <p className="text-gray-400 mb-4 flex-grow">{plan.description}</p>
                                        <div className="mb-4">
                                            <p className="text-3xl font-bold text-white mb-1">${plan.priceMonthly.toFixed(2)}<span className="text-lg text-gray-400">/month</span></p>
                                            <p className="text-md text-gray-500">or ${plan.priceAnnually.toFixed(2)}/year</p>
                                        </div>
                                        <ul className="list-disc list-inside space-y-2 text-gray-300 mb-6">
                                            {plan.features.map((feature, i) => <li key={i}>{feature}</li>)}
                                        </ul>
                                        <button className="w-full py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm font-semibold transition-colors duration-200 mt-auto">
                                            Select Plan
                                        </button>
                                    </Card>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            </Card>
        </div>
    );
};


// --- Component: InstalledExtensionCard (for the 'Installed' view) ---
export const InstalledExtensionCard: React.FC<{ installedExtension: InstalledExtension; onUninstall: (installedExt: InstalledExtension) => void; onManageSettings: (installedExt: InstalledExtension) => void }> = ({ installedExtension, onUninstall, onManageSettings }) => {
    const { currentUser } = useUser();
    const extension = MOCK_EXTENSIONS.find(ext => ext.id === installedExtension.extensionId);
    const [uninstalling, setUninstalling] = useState(false);

    if (!extension) return null; // Should not happen with valid data

    const handleUninstall = async () => {
        if (uninstalling) return;
        setUninstalling(true);
        try {
            await mockApiService.uninstallExtension(installedExtension.id, currentUser.id);
            onUninstall(installedExtension);
        } catch (error: any) {
            alert(`Failed to uninstall: ${error.message}`);
        } finally {
            setUninstalling(false);
        }
    };

    return (
        <Card className="flex flex-col h-full bg-gray-800/50 hover:bg-gray-800 transition-colors duration-200">
            <div className="flex items-center gap-4 mb-3">
                <div className="w-12 h-12 bg-gray-700/50 rounded-lg flex items-center justify-center text-xl font-bold text-cyan-300">{extension.icon}</div>
                <div>
                    <h3 className="font-semibold text-white text-lg">{extension.name}</h3>
                    <p className="text-xs text-gray-400">by {extension.publisher}</p>
                </div>
            </div>
            <p className="text-sm text-gray-400 flex-grow mb-3">{truncateText(extension.description, 80)}</p>
            <div className="text-xs text-gray-500 mb-2">
                <p>Installed: {formatDate(installedExtension.installationDate)}</p>
                <p>Status: <span className={`${installedExtension.enabled ? 'text-green-400' : 'text-red-400'}`}>{installedExtension.enabled ? 'Enabled' : 'Disabled'}</span></p>
                {installedExtension.subscription && (
                    <p>Plan: {installedExtension.subscription.planId} (Status: {installedExtension.subscription.status})</p>
                )}
            </div>
            <div className="mt-auto pt-4 border-t border-gray-700/50 flex gap-2">
                <button
                    onClick={() => onManageSettings(installedExtension)}
                    className="flex-grow py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm transition-colors duration-200"
                >
                    Settings
                </button>
                <button
                    onClick={handleUninstall}
                    className="w-1/3 py-2 bg-red-600/50 hover:bg-red-600 text-white rounded-lg text-sm transition-colors duration-200"
                    disabled={uninstalling}
                >
                    {uninstalling ? '...' : 'Uninstall'}
                </button>
            </div>
        </Card>
    );
};

// --- Component: ExtensionSettingsModal ---
export const ExtensionSettingsModal: React.FC<{ installedExtension: InstalledExtension; onClose: () => void; onSave: (installedExt: InstalledExtension) => void }> = ({ installedExtension, onClose, onSave }) => {
    const { currentUser } = useUser();
    const extension = MOCK_EXTENSIONS.find(ext => ext.id === installedExtension.extensionId);
    const [config, setConfig] = useState(installedExtension.configuration);
    const [enabled, setEnabled] = useState(installedExtension.enabled);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);

    if (!extension) return null;

    const handleConfigChange = (key: string, value: any) => {
        setConfig(prev => ({ ...prev, [key]: value }));
    };

    const handleSave = async () => {
        setSaving(true);
        setError(null);
        try {
            const updated = await mockApiService.updateExtensionConfiguration(installedExtension.id, currentUser.id, { ...config, enabled });
            onSave(updated);
            onClose();
        } catch (err: any) {
            setError(`Failed to save settings: ${err.message}`);
        } finally {
            setSaving(false);
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-75 overflow-y-auto">
            <Card className="w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-gray-800 border border-gray-700/50 relative">
                <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">
                    &times;
                </button>
                <h2 className="text-2xl font-bold text-white mb-4">Settings for {extension.name}</h2>

                {error && <ErrorMessage message={error} className="mb-4" />}

                <div className="space-y-6">
                    <div>
                        <label className="flex items-center space-x-3 cursor-pointer mb-2">
                            <input
                                type="checkbox"
                                className="form-checkbox h-5 w-5 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                                checked={enabled}
                                onChange={(e) => setEnabled(e.target.checked)}
                            />
                            <span className="text-white text-lg">Enable Extension</span>
                        </label>
                        <p className="text-sm text-gray-500">Control whether this extension is actively running.</p>
                    </div>

                    <h3 className="text-xl font-semibold text-white mb-2">Configuration</h3>
                    {Object.keys(config).length === 0 && <p className="text-gray-500">No specific configurations available for this extension.</p>}

                    {Object.keys(config).map(key => (
                        <div key={key} className="flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-4 p-3 bg-gray-700/30 rounded-lg">
                            <label htmlFor={`config-${key}`} className="w-full md:w-1/3 text-white text-sm font-medium">{key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:</label>
                            <div className="w-full md:w-2/3">
                                {typeof config[key] === 'boolean' ? (
                                    <input
                                        type="checkbox"
                                        id={`config-${key}`}
                                        className="form-checkbox h-5 w-5 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                                        checked={config[key]}
                                        onChange={(e) => handleConfigChange(key, e.target.checked)}
                                    />
                                ) : typeof config[key] === 'number' ? (
                                    <input
                                        type="number"
                                        id={`config-${key}`}
                                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                                        value={config[key]}
                                        onChange={(e) => handleConfigChange(key, parseFloat(e.target.value))}
                                    />
                                ) : (
                                    <input
                                        type="text"
                                        id={`config-${key}`}
                                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                                        value={config[key]}
                                        onChange={(e) => handleConfigChange(key, e.target.value)}
                                    />
                                )}
                            </div>
                        </div>
                    ))}

                    {installedExtension.subscription && (
                        <>
                            <h3 className="text-xl font-semibold text-white mb-2">Subscription Details</h3>
                            <div className="space-y-2 text-gray-300">
                                <p><strong>Plan:</strong> {installedExtension.subscription.planId}</p>
                                <p><strong>Status:</strong> <span className={`font-medium ${installedExtension.subscription.status === 'active' ? 'text-green-400' : 'text-red-400'}`}>{installedExtension.subscription.status}</span></p>
                                <p><strong>Starts:</strong> {formatDate(installedExtension.subscription.startDate)}</p>
                                <p><strong>Ends:</strong> {formatDate(installedExtension.subscription.endDate)}</p>
                                <label className="flex items-center space-x-3 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        className="form-checkbox h-5 w-5 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                                        checked={installedExtension.subscription.autoRenew}
                                        disabled // Mocked as disabled for now
                                    />
                                    <span className="text-white text-sm">Auto-renew</span>
                                </label>
                                <button className="py-2 px-4 bg-purple-600/50 hover:bg-purple-600 text-white rounded-lg text-sm mt-2 transition-colors duration-200" disabled>Manage Subscription</button>
                            </div>
                        </>
                    )}

                </div>

                <div className="mt-6 pt-4 border-t border-gray-700/50 flex justify-end gap-3">
                    <button
                        onClick={onClose}
                        className="px-6 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm font-semibold transition-colors duration-200"
                        disabled={saving}
                    >
                        Cancel
                    </button>
                    <button
                        onClick={handleSave}
                        className="px-6 py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm font-semibold transition-colors duration-200"
                        disabled={saving}
                    >
                        {saving ? 'Saving...' : 'Save Settings'}
                    </button>
                </div>
            </Card>
        </div>
    );
};


// --- Component: Search and Filter Panel ---
export const SearchFilterPanel: React.FC<{
    searchQuery: string;
    setSearchQuery: (query: string) => void;
    selectedCategory: string;
    setSelectedCategory: (category: string) => void;
    priceFilter: 'free' | 'paid' | 'any';
    setPriceFilter: (filter: 'free' | 'paid' | 'any') => void;
    minRating: number;
    setMinRating: (rating: number) => void;
    sortBy: keyof Extension;
    setSortBy: (sortBy: keyof Extension) => void;
    sortOrder: 'asc' | 'desc';
    setSortOrder: (order: 'asc' | 'desc') => void;
}> = ({
    searchQuery, setSearchQuery,
    selectedCategory, setSelectedCategory,
    priceFilter, setPriceFilter,
    minRating, setMinRating,
    sortBy, setSortBy,
    sortOrder, setSortOrder,
}) => {
    const categories = ['all', ...MOCK_CATEGORIES.map(c => c.name.toLowerCase())];
    const sortOptions: { value: keyof Extension; label: string }[] = [
        { value: 'name', label: 'Name' },
        { value: 'lastUpdated', label: 'Last Updated' },
        { value: 'rating', label: 'Rating' },
        { value: 'installCount', label: 'Popularity' },
        { value: 'price', label: 'Price' },
    ];

    return (
        <Card className="p-6">
            <h3 className="text-xl font-semibold text-white mb-4">Filter Extensions</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                {/* Search */}
                <div>
                    <label htmlFor="search" className="block text-sm font-medium text-gray-300 mb-1">Search</label>
                    <input
                        type="text"
                        id="search"
                        placeholder="Search by name, publisher, tag..."
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 placeholder-gray-500 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                    />
                </div>

                {/* Category Filter */}
                <div>
                    <label htmlFor="category" className="block text-sm font-medium text-gray-300 mb-1">Category</label>
                    <select
                        id="category"
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={selectedCategory}
                        onChange={(e) => setSelectedCategory(e.target.value)}
                    >
                        {categories.map(cat => (
                            <option key={cat} value={cat}>{cat.charAt(0).toUpperCase() + cat.slice(1).replace('-', ' ')}</option>
                        ))}
                    </select>
                </div>

                {/* Price Filter */}
                <div>
                    <label htmlFor="priceFilter" className="block text-sm font-medium text-gray-300 mb-1">Price</label>
                    <select
                        id="priceFilter"
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={priceFilter}
                        onChange={(e) => setPriceFilter(e.target.value as 'free' | 'paid' | 'any')}
                    >
                        <option value="any">Any Price</option>
                        <option value="free">Free</option>
                        <option value="paid">Paid</option>
                    </select>
                </div>

                {/* Minimum Rating */}
                <div>
                    <label htmlFor="minRating" className="block text-sm font-medium text-gray-300 mb-1">Minimum Rating</label>
                    <select
                        id="minRating"
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={minRating}
                        onChange={(e) => setMinRating(parseFloat(e.target.value))}
                    >
                        <option value={0}>Any Rating</option>
                        <option value={4.5}>4.5 Stars & Up</option>
                        <option value={4}>4 Stars & Up</option>
                        <option value={3.5}>3.5 Stars & Up</option>
                        <option value={3}>3 Stars & Up</option>
                    </select>
                </div>

                {/* Sort By */}
                <div>
                    <label htmlFor="sortBy" className="block text-sm font-medium text-gray-300 mb-1">Sort By</label>
                    <select
                        id="sortBy"
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={sortBy}
                        onChange={(e) => setSortBy(e.target.value as keyof Extension)}
                    >
                        {sortOptions.map(option => (
                            <option key={option.value} value={option.value}>{option.label}</option>
                        ))}
                    </select>
                </div>

                {/* Sort Order */}
                <div>
                    <label htmlFor="sortOrder" className="block text-sm font-medium text-gray-300 mb-1">Sort Order</label>
                    <select
                        id="sortOrder"
                        className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                        value={sortOrder}
                        onChange={(e) => setSortOrder(e.target.value as 'asc' | 'desc')}
                    >
                        <option value="desc">Descending</option>
                        <option value="asc">Ascending</option>
                    </select>
                </div>
            </div>
        </Card>
    );
};

// --- Component: Pagination Controls ---
export const PaginationControls: React.FC<{ currentPage: number; totalPages: number; onPageChange: (page: number) => void }> = ({ currentPage, totalPages, onPageChange }) => {
    const pagesToShow = 5;
    const startPage = Math.max(1, currentPage - Math.floor(pagesToShow / 2));
    const endPage = Math.min(totalPages, startPage + pagesToShow - 1);

    const pages = Array.from({ length: (endPage - startPage + 1) }, (_, i) => startPage + i);

    return (
        <div className="flex justify-center items-center space-x-2 py-6">
            <button
                onClick={() => onPageChange(1)}
                disabled={currentPage === 1}
                className="px-3 py-1 bg-gray-700/50 hover:bg-gray-700 text-gray-300 rounded-lg text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            >
                First
            </button>
            <button
                onClick={() => onPageChange(currentPage - 1)}
                disabled={currentPage === 1}
                className="px-3 py-1 bg-gray-700/50 hover:bg-gray-700 text-gray-300 rounded-lg text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            >
                Previous
            </button>
            {pages.map(page => (
                <button
                    key={page}
                    onClick={() => onPageChange(page)}
                    className={`px-4 py-1 rounded-lg text-sm ${currentPage === page ? 'bg-cyan-600 text-white font-semibold' : 'bg-gray-700/50 hover:bg-gray-700 text-gray-300'}`}
                >
                    {page}
                </button>
            ))}
            <button
                onClick={() => onPageChange(currentPage + 1)}
                disabled={currentPage === totalPages}
                className="px-3 py-1 bg-gray-700/50 hover:bg-gray-700 text-gray-300 rounded-lg text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            >
                Next
            </button>
            <button
                onClick={() => onPageChange(totalPages)}
                disabled={currentPage === totalPages}
                className="px-3 py-1 bg-gray-700/50 hover:bg-gray-700 text-gray-300 rounded-lg text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            >
                Last
            </button>
        </div>
    );
};

// --- Component: PublishExtensionForm ---
export const PublishExtensionForm: React.FC<{ developerId: string; onSuccess: (ext: Extension) => void; onCancel: () => void }> = ({ developerId, onSuccess, onCancel }) => {
    const [formData, setFormData] = useState<Omit<Extension, 'id' | 'lastUpdated' | 'installCount' | 'rating' | 'version' | 'changelog'> & { initialVersion: string }>({
        name: '',
        publisher: '', // Will be overridden by developer's publisher info
        description: '',
        icon: '', // Represented as a string for now, e.g., 'VS', 'JI'
        category: MOCK_CATEGORIES[0].name,
        tags: [],
        price: 0,
        screenshots: [],
        documentationUrl: '',
        privacyPolicyUrl: '',
        developerInfo: {
            id: developerId,
            name: 'Demo Bank Team (Developer)', // Mocked, would fetch actual developer name
            contactEmail: 'developer@demobank.com',
        },
        initialVersion: '1.0.0',
        pricingPlans: [],
    });
    const [tagInput, setTagInput] = useState('');
    const [screenshotInput, setScreenshotInput] = useState('');
    const [publishing, setPublishing] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [isPaid, setIsPaid] = useState(false);
    const [pricingPlanInput, setPricingPlanInput] = useState<PricingPlan>({ id: '', name: '', description: '', priceMonthly: 0, priceAnnually: 0, features: [] });
    const [planFeatureInput, setPlanFeatureInput] = useState('');


    useEffect(() => {
        // Mock fetching developer info
        const dev = MOCK_EXTENSIONS.find(e => e.developerInfo.id === developerId)?.developerInfo || { id: developerId, name: 'Developer', contactEmail: 'dev@example.com' };
        setFormData(prev => ({
            ...prev,
            publisher: dev.name,
            developerInfo: dev,
        }));
    }, [developerId]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value,
        }));
    };

    const handleAddTag = () => {
        if (tagInput.trim() && !formData.tags.includes(tagInput.trim())) {
            setFormData(prev => ({ ...prev, tags: [...prev.tags, tagInput.trim()] }));
            setTagInput('');
        }
    };

    const handleRemoveTag = (tagToRemove: string) => {
        setFormData(prev => ({ ...prev, tags: prev.tags.filter(tag => tag !== tagToRemove) }));
    };

    const handleAddScreenshot = () => {
        if (screenshotInput.trim() && !formData.screenshots.includes(screenshotInput.trim())) {
            setFormData(prev => ({ ...prev, screenshots: [...prev.screenshots, screenshotInput.trim()] }));
            setScreenshotInput('');
        }
    };

    const handleRemoveScreenshot = (screenshotToRemove: string) => {
        setFormData(prev => ({ ...prev, screenshots: prev.screenshots.filter(s => s !== screenshotToRemove) }));
    };

    const handleAddPricingPlan = () => {
        if (pricingPlanInput.name && pricingPlanInput.priceMonthly > 0) {
            setFormData(prev => ({
                ...prev,
                pricingPlans: [...(prev.pricingPlans || []), { ...pricingPlanInput, id: generateRandomId() }],
            }));
            setPricingPlanInput({ id: '', name: '', description: '', priceMonthly: 0, priceAnnually: 0, features: [] });
        }
    };

    const handleRemovePricingPlan = (planId: string) => {
        setFormData(prev => ({
            ...prev,
            pricingPlans: (prev.pricingPlans || []).filter(p => p.id !== planId),
        }));
    };

    const handleAddPlanFeature = () => {
        if (planFeatureInput.trim()) {
            setPricingPlanInput(prev => ({
                ...prev,
                features: [...prev.features, planFeatureInput.trim()],
            }));
            setPlanFeatureInput('');
        }
    };

    const handleRemovePlanFeature = (featureToRemove: string) => {
        setPricingPlanInput(prev => ({
            ...prev,
            features: prev.features.filter(f => f !== featureToRemove),
        }));
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setPublishing(true);
        setError(null);

        // Basic validation
        if (!formData.name || !formData.description || !formData.category || !formData.icon || !formData.initialVersion) {
            setError('Please fill in all required fields.');
            setPublishing(false);
            return;
        }

        try {
            const finalFormData = {
                ...formData,
                price: isPaid ? formData.price : 0, // Ensure price is 0 if not paid
                pricingPlans: isPaid ? formData.pricingPlans : undefined, // Remove pricing plans if free
                // Mock icon element from string
                icon: <p>{formData.icon.toUpperCase().substring(0,2)}</p>
            };

            const publishedExtension = await mockApiService.publishNewExtension(finalFormData);
            onSuccess(publishedExtension);
        } catch (err: any) {
            setError(`Failed to publish extension: ${err.message}`);
        } finally {
            setPublishing(false);
        }
    };

    return (
        <Card className="p-6">
            <h2 className="text-2xl font-bold text-white mb-4">Publish New Extension</h2>
            {error && <ErrorMessage message={error} className="mb-4" />}
            <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                    <label htmlFor="name" className="block text-sm font-medium text-gray-300 mb-1">Extension Name <span className="text-red-500">*</span></label>
                    <input type="text" id="name" name="name" value={formData.name} onChange={handleChange} required
                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                </div>
                <div>
                    <label htmlFor="description" className="block text-sm font-medium text-gray-300 mb-1">Description <span className="text-red-500">*</span></label>
                    <textarea id="description" name="description" value={formData.description} onChange={handleChange} required rows={4}
                              className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"></textarea>
                </div>
                <div>
                    <label htmlFor="icon" className="block text-sm font-medium text-gray-300 mb-1">Icon Text (e.g., VS, JI) <span className="text-red-500">*</span></label>
                    <input type="text" id="icon" name="icon" value={typeof formData.icon === 'string' ? formData.icon : ''} onChange={handleChange} required maxLength={2}
                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                    <p className="text-xs text-gray-500 mt-1">This will be used to generate a simple text icon. Max 2 characters.</p>
                </div>
                <div>
                    <label htmlFor="category" className="block text-sm font-medium text-gray-300 mb-1">Category <span className="text-red-500">*</span></label>
                    <select id="category" name="category" value={formData.category} onChange={handleChange} required
                            className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50">
                        {MOCK_CATEGORIES.map(cat => (
                            <option key={cat.id} value={cat.name}>{cat.name}</option>
                        ))}
                    </select>
                </div>
                <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Tags</label>
                    <div className="flex gap-2 mb-2">
                        <input type="text" value={tagInput} onChange={(e) => setTagInput(e.target.value)}
                               className="flex-grow p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                               placeholder="Add a tag..." />
                        <button type="button" onClick={handleAddTag} className="px-4 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">Add</button>
                    </div>
                    <div className="flex flex-wrap gap-2">
                        {formData.tags.map(tag => (
                            <span key={tag} className="bg-gray-700/30 text-gray-300 text-xs px-2 py-1 rounded-full flex items-center gap-1">
                                {tag}
                                <button type="button" onClick={() => handleRemoveTag(tag)} className="text-gray-400 hover:text-white ml-1">&times;</button>
                            </span>
                        ))}
                    </div>
                </div>
                <div>
                    <label htmlFor="initialVersion" className="block text-sm font-medium text-gray-300 mb-1">Initial Version <span className="text-red-500">*</span></label>
                    <input type="text" id="initialVersion" name="initialVersion" value={formData.initialVersion} onChange={handleChange} required
                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                </div>
                <div>
                    <label htmlFor="documentationUrl" className="block text-sm font-medium text-gray-300 mb-1">Documentation URL</label>
                    <input type="url" id="documentationUrl" name="documentationUrl" value={formData.documentationUrl} onChange={handleChange}
                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                </div>
                <div>
                    <label htmlFor="privacyPolicyUrl" className="block text-sm font-medium text-gray-300 mb-1">Privacy Policy URL</label>
                    <input type="url" id="privacyPolicyUrl" name="privacyPolicyUrl" value={formData.privacyPolicyUrl} onChange={handleChange}
                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                </div>

                {/* Screenshots */}
                <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">Screenshots (URLs)</label>
                    <div className="flex gap-2 mb-2">
                        <input type="url" value={screenshotInput} onChange={(e) => setScreenshotInput(e.target.value)}
                               className="flex-grow p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                               placeholder="Add screenshot URL..." />
                        <button type="button" onClick={handleAddScreenshot} className="px-4 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">Add</button>
                    </div>
                    <div className="grid grid-cols-2 gap-2 mt-2">
                        {formData.screenshots.map((src, index) => (
                            <div key={index} className="relative group">
                                <img src={src} alt={`Screenshot ${index + 1}`} className="rounded-lg object-cover w-full h-24" />
                                <button type="button" onClick={() => handleRemoveScreenshot(src)}
                                        className="absolute top-1 right-1 bg-red-600/70 text-white rounded-full h-6 w-6 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity">
                                    &times;
                                </button>
                            </div>
                        ))}
                    </div>
                </div>

                {/* Monetization */}
                <div className="border-t border-gray-700/50 pt-6">
                    <h3 className="text-xl font-semibold text-white mb-4">Monetization</h3>
                    <label className="flex items-center space-x-3 cursor-pointer">
                        <input
                            type="checkbox"
                            className="form-checkbox h-5 w-5 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                            checked={isPaid}
                            onChange={(e) => setIsPaid(e.target.checked)}
                        />
                        <span className="text-white text-lg">This is a paid extension</span>
                    </label>

                    {isPaid && (
                        <div className="mt-4 space-y-4">
                            <div>
                                <label htmlFor="price" className="block text-sm font-medium text-gray-300 mb-1">One-time Purchase Price (Set to 0 if subscription-only)</label>
                                <input type="number" id="price" name="price" value={formData.price} onChange={handleChange} min="0" step="0.01"
                                       className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                            </div>

                            <h4 className="text-lg font-semibold text-white mb-2">Pricing Plans (for Subscription)</h4>
                            <div className="space-y-3 p-4 bg-gray-700/30 rounded-lg">
                                {formData.pricingPlans && formData.pricingPlans.length > 0 && (
                                    <div className="mb-4">
                                        {formData.pricingPlans.map(plan => (
                                            <div key={plan.id} className="flex justify-between items-center bg-gray-800/50 p-2 rounded-lg mb-2">
                                                <span className="text-white">{plan.name} - ${plan.priceMonthly}/month</span>
                                                <button type="button" onClick={() => handleRemovePricingPlan(plan.id)} className="text-red-400 hover:text-red-200">&times;</button>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                <div>
                                    <label htmlFor="planName" className="block text-sm font-medium text-gray-300 mb-1">Plan Name</label>
                                    <input type="text" id="planName" value={pricingPlanInput.name} onChange={(e) => setPricingPlanInput(prev => ({ ...prev, name: e.target.value }))}
                                           className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                                </div>
                                <div>
                                    <label htmlFor="planDescription" className="block text-sm font-medium text-gray-300 mb-1">Plan Description</label>
                                    <textarea id="planDescription" value={pricingPlanInput.description} onChange={(e) => setPricingPlanInput(prev => ({ ...prev, description: e.target.value }))} rows={2}
                                              className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"></textarea>
                                </div>
                                <div className="flex gap-4">
                                    <div className="flex-grow">
                                        <label htmlFor="priceMonthly" className="block text-sm font-medium text-gray-300 mb-1">Price Monthly</label>
                                        <input type="number" id="priceMonthly" value={pricingPlanInput.priceMonthly} onChange={(e) => setPricingPlanInput(prev => ({ ...prev, priceMonthly: parseFloat(e.target.value) || 0 }))} min="0" step="0.01"
                                               className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                                    </div>
                                    <div className="flex-grow">
                                        <label htmlFor="priceAnnually" className="block text-sm font-medium text-gray-300 mb-1">Price Annually</label>
                                        <input type="number" id="priceAnnually" value={pricingPlanInput.priceAnnually} onChange={(e) => setPricingPlanInput(prev => ({ ...prev, priceAnnually: parseFloat(e.target.value) || 0 }))} min="0" step="0.01"
                                               className="w-full p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" />
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Plan Features</label>
                                    <div className="flex gap-2 mb-2">
                                        <input type="text" value={planFeatureInput} onChange={(e) => setPlanFeatureInput(e.target.value)}
                                               className="flex-grow p-2 bg-gray-700/50 rounded-lg text-gray-200 border border-gray-600 focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50"
                                               placeholder="Add a feature..." />
                                        <button type="button" onClick={handleAddPlanFeature} className="px-4 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">Add</button>
                                    </div>
                                    <ul className="list-disc list-inside space-y-1 text-sm text-gray-400 pl-4">
                                        {pricingPlanInput.features.map((feature, i) => (
                                            <li key={i} className="flex justify-between items-center">
                                                {feature}
                                                <button type="button" onClick={() => handleRemovePlanFeature(feature)} className="text-red-400 hover:text-red-200 ml-2">&times;</button>
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                                <button type="button" onClick={handleAddPricingPlan} className="w-full py-2 bg-cyan-700 hover:bg-cyan-800 text-white rounded-lg text-sm font-semibold">Add Pricing Plan</button>
                            </div>
                        </div>
                    )}
                </div>

                <div className="flex justify-end gap-3 mt-6 pt-4 border-t border-gray-700/50">
                    <button type="button" onClick={onCancel} className="px-6 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm font-semibold">
                        Cancel
                    </button>
                    <button type="submit" className="px-6 py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm font-semibold" disabled={publishing}>
                        {publishing ? 'Publishing...' : 'Publish Extension'}
                    </button>
                </div>
            </form>
        </Card>
    );
};

// --- Component: DeveloperExtensionCard ---
export const DeveloperExtensionCard: React.FC<{ devExtension: DeveloperExtension; onViewDetails: (extId: string) => void; onEditExtension: (extId: string) => void; onDeleteExtension: (extId: string) => void; }> = ({ devExtension, onViewDetails, onEditExtension, onDeleteExtension }) => {
    const extension = MOCK_EXTENSIONS.find(e => e.id === devExtension.id); // Get full extension data

    if (!extension) return null; // Should not happen

    const statusColors = {
        'published': 'text-green-400',
        'draft': 'text-yellow-400',
        'pending_review': 'text-blue-400',
        'rejected': 'text-red-400',
        'archived': 'text-gray-500',
    };

    return (
        <Card className="flex flex-col h-full bg-gray-800/50 hover:bg-gray-800 transition-colors duration-200">
            <div className="flex-grow">
                <div className="flex items-center gap-4 mb-3">
                    <div className="w-12 h-12 bg-gray-700/50 rounded-lg flex items-center justify-center text-xl font-bold text-cyan-300">{extension.icon}</div>
                    <div>
                        <h3 className="font-semibold text-white text-lg">{devExtension.name}</h3>
                        <p className="text-xs text-gray-400">Version: {devExtension.version}</p>
                    </div>
                </div>
                <div className="mb-2">
                    <p className={`text-sm font-medium ${statusColors[devExtension.status]}`}>Status: {devExtension.status.replace('_', ' ').split(' ').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ')}</p>
                    <p className="text-sm text-gray-500">Last Published: {formatDate(devExtension.lastPublished)}</p>
                </div>
                <div className="flex items-center gap-3 text-sm text-gray-400 mb-3">
                    <RatingStars rating={devExtension.averageRating} />
                    <span>({devExtension.reviewsCount} reviews)</span>
                    <span>| {devExtension.totalInstalls.toLocaleString()} installs</span>
                </div>
                {devExtension.pendingUpdates && (
                    <div className="bg-yellow-900/30 text-yellow-300 text-xs p-2 rounded-lg flex items-center gap-2 mb-3">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                        <span>Update available or required.</span>
                    </div>
                )}
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700/50 flex gap-2">
                <button
                    onClick={() => onViewDetails(devExtension.id)}
                    className="flex-grow py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm transition-colors duration-200"
                >
                    View Details
                </button>
                <button
                    onClick={() => onEditExtension(devExtension.id)}
                    className="flex-grow py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm transition-colors duration-200"
                >
                    Edit
                </button>
                <button
                    onClick={() => onDeleteExtension(devExtension.id)}
                    className="w-1/4 py-2 bg-red-600/50 hover:bg-red-600 text-white rounded-lg text-sm transition-colors duration-200"
                >
                    Delete
                </button>
            </div>
        </Card>
    );
};

// --- Component: AnalyticsDashboard ---
export const AnalyticsDashboard: React.FC<{ extensionId: string; onClose: () => void }> = ({ extensionId, onClose }) => {
    const [analytics, setAnalytics] = useState<ExtensionAnalytics | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchAnalytics = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await mockApiService.fetchExtensionAnalytics(extensionId);
                setAnalytics(data);
            } catch (err: any) {
                setError(`Failed to fetch analytics: ${err.message}`);
            } finally {
                setLoading(false);
            }
        };
        fetchAnalytics();
    }, [extensionId]);

    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorMessage message={error} />;
    if (!analytics) return <p className="text-gray-400">No analytics data available for this extension.</p>;

    const totalInstalls = analytics.data.reduce((sum, entry) => sum + entry.installs, 0);
    const totalUninstalls = analytics.data.reduce((sum, entry) => sum + entry.uninstalls, 0);
    const totalRevenue = analytics.data.reduce((sum, entry) => sum + (entry.revenue || 0), 0);

    return (
        <Card className="p-6">
            <div className="flex justify-between items-center mb-6 border-b border-gray-700/50 pb-4">
                <h2 className="text-2xl font-bold text-white">Analytics for {MOCK_EXTENSIONS.find(e => e.id === extensionId)?.name}</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">
                    &times;
                </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div className="bg-gray-700/50 p-4 rounded-lg">
                    <p className="text-sm text-gray-400">Total Installs (last 30 days)</p>
                    <p className="text-3xl font-bold text-cyan-300">{totalInstalls.toLocaleString()}</p>
                </div>
                <div className="bg-gray-700/50 p-4 rounded-lg">
                    <p className="text-sm text-gray-400">Total Uninstalls (last 30 days)</p>
                    <p className="text-3xl font-bold text-red-400">{totalUninstalls.toLocaleString()}</p>
                </div>
                {analytics.data[0]?.revenue !== undefined && (
                    <div className="bg-gray-700/50 p-4 rounded-lg">
                        <p className="text-sm text-gray-400">Total Revenue (last 30 days)</p>
                        <p className="text-3xl font-bold text-green-400">${totalRevenue.toFixed(2)}</p>
                    </div>
                )}
            </div>

            <h3 className="text-xl font-semibold text-white mb-4">Daily Metrics (Last 30 Days)</h3>
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700/30">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Date</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Installs</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Uninstalls</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Active Users</th>
                            {analytics.data[0]?.revenue !== undefined && (
                                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Revenue</th>
                            )}
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Errors</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-gray-700">
                        {analytics.data.map((entry, index) => (
                            <tr key={index} className="hover:bg-gray-700/20">
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{entry.date}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-green-400">{entry.installs}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-red-400">{entry.uninstalls}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-cyan-300">{entry.activeUsers}</td>
                                {entry.revenue !== undefined && (
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-green-500">${entry.revenue.toFixed(2)}</td>
                                )}
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-yellow-400">{entry.errors}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

// --- Component: AuditLogViewer ---
export const AuditLogViewer: React.FC<{ onClose: () => void }> = ({ onClose }) => {
    const { currentUser } = useUser();
    const [logs, setLogs] = useState<AuditLogEntry[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchLogs = async () => {
            setLoading(true);
            setError(null);
            try {
                const fetchedLogs = await mockApiService.fetchAuditLogs({ userId: currentUser.id, limit: 100 });
                setLogs(fetchedLogs);
            } catch (err: any) {
                setError(`Failed to fetch audit logs: ${err.message}`);
            } finally {
                setLoading(false);
            }
        };
        fetchLogs();
    }, [currentUser.id]);

    const getLogMessage = (log: AuditLogEntry) => {
        const extName = log.details.extensionName || 'an extension';
        switch (log.action) {
            case 'INSTALL_EXTENSION': return `Installed ${extName}.`;
            case 'UNINSTALL_EXTENSION': return `Uninstalled ${extName}.`;
            case 'UPDATE_CONFIG': return `Updated configuration for ${extName}.`;
            case 'SUBMIT_REVIEW': return `Submitted a ${log.details.rating}-star review for ${extName}.`;
            case 'PUBLISH_EXTENSION': return `Published new extension: ${extName}.`;
            case 'UPDATE_EXTENSION': return `Updated published extension: ${extName}.`;
            case 'DELETE_EXTENSION': return `Deleted published extension: ${extName}.`;
            default: return `Performed action: ${log.action} on ${extName}.`;
        }
    };

    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorMessage message={error} />;

    return (
        <Card className="p-6">
            <div className="flex justify-between items-center mb-6 border-b border-gray-700/50 pb-4">
                <h2 className="text-2xl font-bold text-white">Recent Activity (Audit Logs)</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">
                    &times;
                </button>
            </div>
            {logs.length === 0 ? (
                <p className="text-gray-400">No recent activity found.</p>
            ) : (
                <div className="space-y-4 max-h-[60vh] overflow-y-auto pr-2">
                    {logs.map(log => (
                        <div key={log.id} className="bg-gray-700/30 p-3 rounded-lg flex items-center gap-4">
                            <span className="text-xs text-gray-500 flex-shrink-0 w-24">{formatDate(log.timestamp)}</span>
                            <span className="text-sm text-gray-300 flex-grow">{getLogMessage(log)}</span>
                        </div>
                    ))}
                </div>
            )}
        </Card>
    );
};


// --- Main View Components ---

// Extensions Marketplace View
export const MarketplaceView: React.FC<{
    onViewDetails: (ext: Extension) => void;
    onInstallSuccess: (ext: Extension) => void;
    onUninstallSuccess: (installedExt: InstalledExtension) => void;
    installedExtensions: InstalledExtension[];
}> = ({ onViewDetails, onInstallSuccess, onUninstallSuccess, installedExtensions }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [selectedCategory, setSelectedCategory] = useState('all');
    const [priceFilter, setPriceFilter] = useState<'free' | 'paid' | 'any'>('any');
    const [minRating, setMinRating] = useState(0);
    const [sortBy, setSortBy] = useState<keyof Extension>('installCount');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');
    const [currentPage, setCurrentPage] = useState(1);
    const extensionsPerPage = 12;

    const { extensions, totalExtensions, loading, error } = useExtensions({
        query: searchQuery,
        category: selectedCategory,
        priceFilter,
        minRating,
        sortBy,
        sortOrder,
        page: currentPage,
        limit: extensionsPerPage,
    });

    const totalPages = Math.ceil(totalExtensions / extensionsPerPage);

    return (
        <div className="space-y-6">
            <h2 className="text-3xl font-bold text-white tracking-wider">Extensions Marketplace</h2>

            <SearchFilterPanel
                searchQuery={searchQuery} setSearchQuery={setSearchQuery}
                selectedCategory={selectedCategory} setSelectedCategory={setSelectedCategory}
                priceFilter={priceFilter} setPriceFilter={setPriceFilter}
                minRating={minRating} setMinRating={setMinRating}
                sortBy={sortBy} setSortBy={setSortBy}
                sortOrder={sortOrder} setSortOrder={setSortOrder}
            />

            {loading && <LoadingSpinner />}
            {error && <ErrorMessage message={error} />}

            {!loading && !error && extensions.length === 0 && (
                <Card><p className="text-gray-400 p-4">No extensions found matching your criteria.</p></Card>
            )}

            {!loading && !error && extensions.length > 0 && (
                <>
                    <Card title="Recommended for You">
                        <p className="text-sm text-gray-400 mb-4">Based on your role as a developer, our AI suggests these extensions.</p>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                            {extensions.filter(e => e.recommended).slice(0, 3).map(ext => (
                                <ExtensionCard
                                    key={ext.id}
                                    extension={ext}
                                    onViewDetails={onViewDetails}
                                    onInstall={onInstallSuccess}
                                    onUninstall={onUninstallSuccess}
                                    installed={installedExtensions.find(i => i.extensionId === ext.id)}
                                />
                            ))}
                        </div>
                    </Card>

                    <Card title="All Extensions">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {extensions.map(ext => (
                                <ExtensionCard
                                    key={ext.id}
                                    extension={ext}
                                    onViewDetails={onViewDetails}
                                    onInstall={onInstallSuccess}
                                    onUninstall={onUninstallSuccess}
                                    installed={installedExtensions.find(i => i.extensionId === ext.id)}
                                />
                            ))}
                        </div>
                        <PaginationControls currentPage={currentPage} totalPages={totalPages} onPageChange={setCurrentPage} />
                    </Card>
                </>
            )}
        </div>
    );
};

// Installed Extensions View
export const InstalledView: React.FC<{
    userId: string;
    onViewDetails: (ext: Extension) => void;
    onManageSettings: (installedExt: InstalledExtension) => void;
    onUninstallSuccess: (installedExt: InstalledExtension) => void;
    installedExtensions: InstalledExtension[];
    loading: boolean;
    error: string | null;
}> = ({ userId, onViewDetails, onManageSettings, onUninstallSuccess, installedExtensions, loading, error }) => {
    return (
        <div className="space-y-6">
            <h2 className="text-3xl font-bold text-white tracking-wider">My Installed Extensions</h2>
            {loading && <LoadingSpinner />}
            {error && <ErrorMessage message={error} />}
            {!loading && !error && installedExtensions.length === 0 && (
                <Card><p className="text-gray-400 p-4">You haven't installed any extensions yet.</p></Card>
            )}
            {!loading && !error && installedExtensions.length > 0 && (
                <Card title="Currently Installed">
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {installedExtensions.map(installedExt => {
                            const ext = MOCK_EXTENSIONS.find(e => e.id === installedExt.extensionId);
                            if (!ext) return null; // Defensive check
                            return (
                                <InstalledExtensionCard
                                    key={installedExt.id}
                                    installedExtension={installedExt}
                                    onUninstall={onUninstallSuccess}
                                    onManageSettings={onManageSettings}
                                />
                            );
                        })}
                    </div>
                </Card>
            )}
        </div>
    );
};

// Developer Dashboard View
export const DeveloperDashboardView: React.FC<{
    developerId: string;
    onPublishNew: () => void;
    onEditExtension: (extId: string) => void;
    onViewAnalytics: (extId: string) => void;
    onViewDetails: (ext: Extension) => void;
}> = ({ developerId, onPublishNew, onEditExtension, onViewAnalytics, onViewDetails }) => {
    const { developerExtensions, loading, error, refreshDeveloperExtensions } = useDeveloperExtensions(developerId);
    const [deletingId, setDeletingId] = useState<string | null>(null);

    const handleDeleteExtension = async (extensionId: string) => {
        if (!window.confirm('Are you sure you want to delete this extension? This action cannot be undone.')) {
            return;
        }
        setDeletingId(extensionId);
        try {
            await mockApiService.deletePublishedExtension(extensionId, developerId);
            refreshDeveloperExtensions();
        } catch (err: any) {
            alert(`Failed to delete extension: ${err.message}`);
        } finally {
            setDeletingId(null);
        }
    };

    return (
        <div className="space-y-6">
            <h2 className="text-3xl font-bold text-white tracking-wider">Developer Dashboard</h2>

            <Card className="flex justify-between items-center">
                <p className="text-gray-400">Manage your published extensions, track performance, and publish new ones.</p>
                <button
                    onClick={onPublishNew}
                    className="px-6 py-2 bg-green-600/50 hover:bg-green-600 text-white rounded-lg text-sm font-semibold transition-colors duration-200"
                >
                    Publish New Extension
                </button>
            </Card>

            {loading && <LoadingSpinner />}
            {error && <ErrorMessage message={error} />}

            {!loading && !error && developerExtensions.length === 0 && (
                <Card><p className="text-gray-400 p-4">You haven't published any extensions yet. Start by publishing one!</p></Card>
            )}

            {!loading && !error && developerExtensions.length > 0 && (
                <Card title="Your Published Extensions">
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {developerExtensions.map(devExt => {
                            const ext = MOCK_EXTENSIONS.find(e => e.id === devExt.id);
                            if (!ext) return null; // Should not happen with consistent mocks
                            return (
                                <DeveloperExtensionCard
                                    key={devExt.id}
                                    devExtension={devExt}
                                    onViewDetails={extId => onViewDetails(ext)} // Pass full extension for details modal
                                    onEditExtension={onEditExtension}
                                    onDeleteExtension={() => handleDeleteExtension(devExt.id)}
                                />
                            );
                        })}
                    </div>
                </Card>
            )}

            <Card title="Extension Analytics Overview">
                <p className="text-sm text-gray-400 mb-4">Select an extension above to view detailed analytics.</p>
                {/* Could add aggregated metrics here or a dropdown to select an extension */}
            </Card>

            <Card title="Audit Log for Developer Actions">
                <AuditLogViewer onClose={() => { /* No-op for this embedded viewer */ }} />
            </Card>
        </div>
    );
};

// --- Main ExtensionsView Component ---
export type CurrentView = 'marketplace' | 'installed' | 'developer' | 'publish' | 'edit' | 'analytics' | 'audit_logs';

const ExtensionsView: React.FC = () => {
    const { currentUser, setCurrentUser } = useUser();
    const [currentView, setCurrentView] = useState<CurrentView>('marketplace');
    const [selectedExtension, setSelectedExtension] = useState<Extension | null>(null);
    const [selectedInstalledExtension, setSelectedInstalledExtension] = useState<InstalledExtension | null>(null);
    const [extensionToEditId, setExtensionToEditId] = useState<string | null>(null);
    const [extensionToAnalyzeId, setExtensionToAnalyzeId] = useState<string | null>(null);

    const { installedExtensions, loading: installedLoading, error: installedError, refreshInstalled } = useInstalledExtensions(currentUser.id);

    // Callbacks for various actions
    const handleViewDetails = (ext: Extension) => {
        setSelectedExtension(ext);
    };

    const handleInstallSuccess = useCallback((ext: Extension) => {
        refreshInstalled();
        // Optional: show a toast notification
        console.log(`Extension ${ext.name} installed successfully!`);
        setSelectedExtension(null); // Close details modal if open
    }, [refreshInstalled]);

    const handleUninstallSuccess = useCallback((installedExt: InstalledExtension) => {
        refreshInstalled();
        console.log(`Extension ${MOCK_EXTENSIONS.find(e => e.id === installedExt.extensionId)?.name} uninstalled successfully!`);
        setSelectedInstalledExtension(null); // Close settings modal if open
        setSelectedExtension(null); // Close details modal if open
    }, [refreshInstalled]);

    const handleManageSettings = (installedExt: InstalledExtension) => {
        setSelectedInstalledExtension(installedExt);
    };

    const handleSaveSettings = useCallback((updatedInstalledExt: InstalledExtension) => {
        refreshInstalled();
        setSelectedInstalledExtension(null); // Close settings modal
        console.log(`Settings for ${MOCK_EXTENSIONS.find(e => e.id === updatedInstalledExt.extensionId)?.name} saved!`);
    }, [refreshInstalled]);

    const handlePublishNew = () => {
        setCurrentView('publish');
    };

    const handlePublishSuccess = useCallback((ext: Extension) => {
        setCurrentView('developer');
        // A temporary solution for refreshing, would ideally be handled by DeveloperDashboardView itself
        // MOCK_DEVELOPER_EXTENSIONS needs to be updated directly here or passed down through context.
        // For simplicity in this massive mock, we'll let the user navigate and assume a refresh.
        alert(`Extension "${ext.name}" published successfully! It will now undergo review.`);
        // To trigger a refresh in DeveloperDashboardView, we can temporarily change the view
        // then change it back, forcing the hook to re-run.
        // Or simply add a forceRefresh prop/callback.
    }, []);

    const handleEditExtension = (extId: string) => {
        setExtensionToEditId(extId);
        setCurrentView('edit');
    };

    const handleEditSuccess = useCallback((ext: Extension) => {
        setCurrentView('developer');
        setExtensionToEditId(null);
        alert(`Extension "${ext.name}" updated successfully!`);
    }, []);

    const handleViewAnalytics = (extId: string) => {
        setExtensionToAnalyzeId(extId);
        setCurrentView('analytics');
    };

    // Render the selected view
    let content;
    switch (currentView) {
        case 'marketplace':
            content = (
                <MarketplaceView
                    onViewDetails={handleViewDetails}
                    onInstallSuccess={handleInstallSuccess}
                    onUninstallSuccess={handleUninstallSuccess}
                    installedExtensions={installedExtensions}
                />
            );
            break;
        case 'installed':
            content = (
                <InstalledView
                    userId={currentUser.id}
                    onViewDetails={handleViewDetails}
                    onManageSettings={handleManageSettings}
                    onUninstallSuccess={handleUninstallSuccess}
                    installedExtensions={installedExtensions}
                    loading={installedLoading}
                    error={installedError}
                />
            );
            break;
        case 'developer':
            if (currentUser.role !== 'developer') {
                content = <ErrorMessage message="You do not have permission to access the Developer Dashboard." />;
            } else {
                content = (
                    <DeveloperDashboardView
                        developerId={currentUser.id} // Assuming developerId is tied to userId for this mock
                        onPublishNew={handlePublishNew}
                        onEditExtension={handleEditExtension}
                        onViewAnalytics={handleViewAnalytics}
                        onViewDetails={handleViewDetails}
                    />
                );
            }
            break;
        case 'publish':
            if (currentUser.role !== 'developer') {
                content = <ErrorMessage message="You do not have permission to publish extensions." />;
            } else {
                content = (
                    <PublishExtensionForm
                        developerId={currentUser.id}
                        onSuccess={handlePublishSuccess}
                        onCancel={() => setCurrentView('developer')}
                    />
                );
            }
            break;
        case 'edit':
            if (currentUser.role !== 'developer' || !extensionToEditId) {
                content = <ErrorMessage message="Invalid access or extension not found for editing." />;
            } else {
                const ext = MOCK_EXTENSIONS.find(e => e.id === extensionToEditId);
                if (!ext || ext.developerInfo.id !== currentUser.id) {
                    content = <ErrorMessage message="You are not authorized to edit this extension." />;
                } else {
                    // This would ideally be a separate EditExtensionForm similar to Publish
                    content = (
                        <Card className="p-6">
                            <h2 className="text-2xl font-bold text-white mb-4">Edit Extension: {ext.name}</h2>
                            <p className="text-gray-400">
                                This would be a detailed form for editing extension metadata, pricing, screenshots, etc.
                                For now, simulating success.
                            </p>
                            <div className="flex justify-end gap-3 mt-6 pt-4 border-t border-gray-700/50">
                                <button
                                    onClick={() => setCurrentView('developer')}
                                    className="px-6 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm font-semibold"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={() => handleEditSuccess(ext)}
                                    className="px-6 py-2 bg-cyan-600/50 hover:bg-cyan-600 text-white rounded-lg text-sm font-semibold"
                                >
                                    Save Changes (Mock)
                                </button>
                            </div>
                        </Card>
                    );
                }
            }
            break;
        case 'analytics':
            if (!extensionToAnalyzeId) {
                content = <ErrorMessage message="No extension selected for analytics." />;
            } else {
                content = <AnalyticsDashboard extensionId={extensionToAnalyzeId} onClose={() => setCurrentView('developer')} />;
            }
            break;
        case 'audit_logs':
            content = <AuditLogViewer onClose={() => setCurrentView('marketplace')} />; // Can be accessed from anywhere
            break;
        default:
            content = <ErrorMessage message="Unknown view." />;
    }

    return (
        <div className="min-h-screen bg-gray-900 text-white p-6">
            <div className="flex justify-between items-center mb-6 border-b border-gray-700/50 pb-4">
                <div className="flex items-center gap-4">
                    <img src="https://via.placeholder.com/40" alt="Logo" className="h-10 w-10 rounded-full" />
                    <span className="text-2xl font-bold text-cyan-400">MegaDashboard</span>
                </div>
                <div className="flex items-center gap-4">
                    <nav>
                        <ul className="flex space-x-4">
                            <li><button onClick={() => setCurrentView('marketplace')} className={`px-4 py-2 rounded-lg text-sm font-medium ${currentView === 'marketplace' ? 'bg-cyan-600' : 'text-gray-400 hover:text-white'}`}>Marketplace</button></li>
                            <li><button onClick={() => setCurrentView('installed')} className={`px-4 py-2 rounded-lg text-sm font-medium ${currentView === 'installed' ? 'bg-cyan-600' : 'text-gray-400 hover:text-white'}`}>Installed</button></li>
                            {currentUser.role === 'developer' && (
                                <li><button onClick={() => setCurrentView('developer')} className={`px-4 py-2 rounded-lg text-sm font-medium ${currentView === 'developer' || currentView === 'publish' || currentView === 'edit' || currentView === 'analytics' ? 'bg-cyan-600' : 'text-gray-400 hover:text-white'}`}>Developer</button></li>
                            )}
                            <li><button onClick={() => setCurrentView('audit_logs')} className={`px-4 py-2 rounded-lg text-sm font-medium ${currentView === 'audit_logs' ? 'bg-cyan-600' : 'text-gray-400 hover:text-white'}`}>Audit Logs</button></li>
                        </ul>
                    </nav>
                    <div className="relative group">
                        <button className="flex items-center gap-2 text-gray-300 hover:text-white">
                            <img src="https://i.pravatar.cc/300" alt="User Avatar" className="h-8 w-8 rounded-full" />
                            <span className="text-sm">{currentUser.name} ({currentUser.role})</span>
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                        <div className="absolute right-0 mt-2 w-48 bg-gray-800 rounded-md shadow-lg py-1 z-10 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition-opacity duration-200">
                            <button
                                onClick={() => setCurrentUser({ id: 'user-current', name: 'John Doe', role: 'standard_user' })}
                                className="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700 w-full text-left"
                            >
                                Switch to Standard User
                            </button>
                            <button
                                onClick={() => setCurrentUser({ id: 'dev-demobank', name: 'Developer Admin', role: 'developer' })}
                                className="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700 w-full text-left"
                            >
                                Switch to Developer
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            {content}

            {/* Modals */}
            {selectedExtension && (
                <ExtensionDetailsModal
                    extension={selectedExtension}
                    reviews={MOCK_REVIEWS.filter(r => r.extensionId === selectedExtension.id)} // Pass actual reviews
                    onClose={() => setSelectedExtension(null)}
                    onInstall={handleInstallSuccess}
                    onUninstall={handleUninstallSuccess}
                    installed={installedExtensions.find(i => i.extensionId === selectedExtension.id)}
                    onNewReview={(newReview) => {
                        // This updates the local state of reviews for the modal
                        setSelectedExtension(prev => prev ? { ...prev, rating: (prev.rating * MOCK_REVIEWS.filter(r => r.extensionId === prev.id).length + newReview.rating) / (MOCK_REVIEWS.filter(r => r.extensionId === prev.id).length + 1) } : null);
                        // The actual MOCK_REVIEWS array is updated in mockApiService.submitReview
                    }}
                />
            )}

            {selectedInstalledExtension && (
                <ExtensionSettingsModal
                    installedExtension={selectedInstalledExtension}
                    onClose={() => setSelectedInstalledExtension(null)}
                    onSave={handleSaveSettings}
                />
            )}
        </div>
    );
};

export default () => (
    <UserProvider>
        <ExtensionsView />
    </UserProvider>
);

--- FILE: SandboxView.tsx ---

import React, { useState, useEffect, useCallback, useMemo, createContext, useContext } from 'react';
import Card from '../../../Card';
import { GoogleGenAI, Type } from "@google/genai";

// --- Global Interfaces/Types ---

export interface SandboxEnvironment {
    id: string;
    name: string;
    description: string;
    status: 'Active' | 'Stopped' | 'Archived' | 'Provisioning';
    apiKeyCount: number;
    webhookCount: number;
    createdAt: string;
    lastActivity: string;
    ownerId: string;
    region: string;
    config: {
        rateLimit: number; // requests per minute
        dataRetentionDays: number;
        loggingEnabled: boolean;
        publicAccess: boolean;
    };
}

export interface APIKey {
    id: string;
    environmentId: string;
    name: string;
    key: string; // Stored obfuscated or partially revealed
    status: 'Active' | 'Revoked' | 'Expired';
    permissions: string[]; // e.g., ['read:data', 'write:data', 'manage:webhooks']
    createdAt: string;
    expiresAt?: string;
    lastUsed: string;
    rateLimitOverride?: number; // requests per minute
}

export interface WebhookConfig {
    id: string;
    environmentId: string;
    name: string;
    url: string;
    secret: string;
    events: string[]; // e.g., ['data.created', 'environment.status_change']
    status: 'Active' | 'Paused' | 'Failed';
    createdAt: string;
    lastTriggered: string;
    retriesEnabled: boolean;
    maxRetries: number;
}

export interface LogEntry {
    id: string;
    environmentId: string;
    timestamp: string;
    level: 'INFO' | 'WARN' | 'ERROR' | 'DEBUG';
    source: 'API' | 'Webhook' | 'System' | 'Auth';
    message: string;
    details?: Record<string, any>;
    requestId?: string;
    statusCode?: number;
    latencyMs?: number;
}

export interface MetricData {
    timestamp: string;
    value: number;
}

export interface AlertRule {
    id: string;
    environmentId: string;
    name: string;
    metric: 'api_errors' | 'api_latency' | 'webhook_failures' | 'rate_limit_exceeded';
    threshold: number; // e.g., error rate > 5%, latency > 500ms
    operator: 'gt' | 'lt' | 'eq'; // greater than, less than, equals
    durationMinutes: number; // threshold must be met for this duration
    status: 'Active' | 'Paused';
    channels: ('email' | 'slack' | 'webhook')[];
    recipients: string[]; // e.g., email addresses, slack channel IDs, webhook URLs
    createdAt: string;
}

export interface UserProfile {
    id: string;
    name: string;
    email: string;
    role: 'Admin' | 'Developer' | 'Viewer';
    lastLogin: string;
}

export interface APIEndpoint {
    id: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    path: string;
    description: string;
    requestSchema?: Record<string, any>;
    responseSchema?: Record<string, any>;
    tags: string[];
    isAuthenticated: boolean;
}

export interface CodeSnippetConfig {
    language: 'javascript' | 'python' | 'go' | 'curl';
    framework?: string; // e.g., 'axios', 'requests'
    action: 'get' | 'post' | 'put' | 'delete';
    endpointPath: string;
    body?: Record<string, any>;
    queryParams?: Record<string, string>;
    headers?: Record<string, string>;
}

// --- Mock Data Generators ---

const generateUUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
const getRandomDate = (start: Date, end: Date) => new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime())).toISOString().split('T')[0];
const getRandomItem = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];
const getRandomInt = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min;
const getRandomFloat = (min: number, max: number) => parseFloat((Math.random() * (max - min) + min).toFixed(2));

export const MOCK_ENVIRONMENTS: SandboxEnvironment[] = [
    { id: 'env-1', name: 'Staging-WebApp-Test', description: 'Environment for testing web application features before production deployment.', status: 'Active', apiKeyCount: 5, webhookCount: 3, createdAt: '2024-07-20', lastActivity: '2024-08-01T14:30:00Z', ownerId: 'user-alpha', region: 'us-east-1', config: { rateLimit: 500, dataRetentionDays: 90, loggingEnabled: true, publicAccess: false } },
    { id: 'env-2', name: 'Mobile-iOS-Integration', description: 'Dedicated environment for mobile iOS app backend integrations and QA.', status: 'Active', apiKeyCount: 3, webhookCount: 2, createdAt: '2024-07-18', lastActivity: '2024-08-01T10:15:00Z', ownerId: 'user-beta', region: 'eu-west-1', config: { rateLimit: 1000, dataRetentionDays: 180, loggingEnabled: true, publicAccess: false } },
    { id: 'env-3', name: 'Archived-Q2-Tests', description: 'Historical environment for Q2 project testing, now stopped.', status: 'Stopped', apiKeyCount: 1, webhookCount: 0, createdAt: '2024-06-30', lastActivity: '2024-07-05T09:00:00Z', ownerId: 'user-gamma', region: 'ap-southeast-2', config: { rateLimit: 100, dataRetentionDays: 30, loggingEnabled: false, publicAccess: true } },
    { id: 'env-4', name: 'Dev-Frontend-Playground', description: 'Frontend development sandbox for rapid prototyping.', status: 'Active', apiKeyCount: 2, webhookCount: 1, createdAt: '2024-07-25', lastActivity: '2024-08-01T16:00:00Z', ownerId: 'user-alpha', region: 'us-west-2', config: { rateLimit: 750, dataRetentionDays: 90, loggingEnabled: true, publicAccess: true } },
    { id: 'env-5', name: 'Internal-Tooling-API', description: 'Sandbox for developing internal API services.', status: 'Provisioning', apiKeyCount: 0, webhookCount: 0, createdAt: '2024-07-29', lastActivity: '2024-07-29T11:00:00Z', ownerId: 'user-delta', region: 'us-east-1', config: { rateLimit: 200, dataRetentionDays: 60, loggingEnabled: true, publicAccess: false } },
    { id: 'env-6', name: 'POC-Experiment', description: 'Proof-of-concept environment for a new feature idea.', status: 'Active', apiKeyCount: 1, webhookCount: 0, createdAt: '2024-07-10', lastActivity: '2024-07-28T18:00:00Z', ownerId: 'user-epsilon', region: 'eu-central-1', config: { rateLimit: 300, dataRetentionDays: 30, loggingEnabled: true, publicAccess: true } },
    { id: 'env-7', name: 'Analytics-Reporting', description: 'Environment for integrating with third-party analytics platforms.', status: 'Stopped', apiKeyCount: 0, webhookCount: 0, createdAt: '2024-06-01', lastActivity: '2024-06-15T12:00:00Z', ownerId: 'user-zeta', region: 'us-east-1', config: { rateLimit: 100, dataRetentionDays: 180, loggingEnabled: false, publicAccess: false } },
];

export const MOCK_API_KEYS: APIKey[] = MOCK_ENVIRONMENTS.flatMap(env =>
    Array.from({ length: env.apiKeyCount }).map((_, i) => ({
        id: generateUUID(),
        environmentId: env.id,
        name: `${env.name.split('-')[0]} Key ${i + 1}`,
        key: `sk_test_${generateUUID().slice(0, 8)}...${generateUUID().slice(0, 4)}`,
        status: getRandomItem(['Active', 'Active', 'Active', 'Revoked', 'Expired']),
        permissions: getRandomItem([
            ['read:data'],
            ['read:data', 'write:data'],
            ['read:data', 'write:data', 'manage:webhooks'],
            ['admin']
        ]),
        createdAt: getRandomDate(new Date(2024, 0, 1), new Date()),
        expiresAt: Math.random() > 0.7 ? getRandomDate(new Date(), new Date(2025, 0, 1)) : undefined,
        lastUsed: getRandomDate(new Date(2024, 6, 15), new Date()),
        rateLimitOverride: Math.random() > 0.8 ? getRandomInt(50, 200) : undefined,
    }))
);

export const MOCK_WEBHOOKS: WebhookConfig[] = MOCK_ENVIRONMENTS.flatMap(env =>
    Array.from({ length: env.webhookCount }).map((_, i) => ({
        id: generateUUID(),
        environmentId: env.id,
        name: `${env.name.split('-')[0]} Webhook ${i + 1}`,
        url: `https://example.com/webhook/listener/${generateUUID().slice(0, 6)}`,
        secret: generateUUID(),
        events: getRandomItem([
            ['data.created'],
            ['data.updated', 'user.deleted'],
            ['environment.status_change', 'api_key.revoked']
        ]),
        status: getRandomItem(['Active', 'Active', 'Active', 'Paused', 'Failed']),
        createdAt: getRandomDate(new Date(2024, 0, 1), new Date()),
        lastTriggered: Math.random() > 0.2 ? getRandomDate(new Date(2024, 6, 1), new Date()) : 'Never',
        retriesEnabled: Math.random() > 0.3,
        maxRetries: getRandomInt(3, 10),
    }))
);

export const generateMockLogs = (envId: string, count: number): LogEntry[] => {
    const logs: LogEntry[] = [];
    const sources = ['API', 'Webhook', 'System', 'Auth'];
    const levels = ['INFO', 'INFO', 'INFO', 'WARN', 'ERROR', 'DEBUG'];
    const messages = {
        API: ['Request received', 'Data processed', 'Resource not found', 'Authentication failed', 'Rate limit hit'],
        Webhook: ['Delivery successful', 'Delivery failed', 'Retrying delivery', 'Webhook configured'],
        System: ['Environment started', 'Environment stopped', 'Configuration updated', 'Provisioning complete'],
        Auth: ['Login attempt', 'API key validated', 'Permission denied']
    };

    for (let i = 0; i < count; i++) {
        const source = getRandomItem(sources);
        const level = getRandomItem(levels);
        const timestamp = new Date(Date.now() - getRandomInt(0, 30) * 24 * 60 * 60 * 1000 - getRandomInt(0, 23) * 60 * 60 * 1000 - getRandomInt(0, 59) * 60 * 1000).toISOString();
        const requestId = source === 'API' ? generateUUID().slice(0, 10) : undefined;
        const statusCode = source === 'API' && level !== 'DEBUG' ? getRandomItem([200, 201, 204, 400, 401, 403, 404, 429, 500]) : undefined;
        const latencyMs = source === 'API' && statusCode && statusCode < 500 ? getRandomInt(10, 1500) : undefined;

        logs.push({
            id: generateUUID(),
            environmentId: envId,
            timestamp,
            level,
            source,
            message: getRandomItem(messages[source]),
            requestId,
            statusCode,
            latencyMs,
            details: level === 'ERROR' ? { errorType: 'Timeout', stackTrace: '...' } : undefined,
        });
    }
    logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()); // Newest first
    return logs;
};

export const MOCK_API_ENDPOINTS: APIEndpoint[] = [
    { id: 'ep-1', method: 'GET', path: '/users/{id}', description: 'Retrieve user details', tags: ['User', 'Read'], isAuthenticated: true, responseSchema: { id: 'string', name: 'string', email: 'string' } },
    { id: 'ep-2', method: 'POST', path: '/users', description: 'Create a new user', tags: ['User', 'Write'], isAuthenticated: true, requestSchema: { name: 'string', email: 'string' }, responseSchema: { id: 'string', name: 'string' } },
    { id: 'ep-3', method: 'GET', path: '/products', description: 'List all products', tags: ['Product', 'Read'], isAuthenticated: false, responseSchema: { items: [{ id: 'string', name: 'string', price: 'number' }] } },
    { id: 'ep-4', method: 'DELETE', path: '/products/{id}', description: 'Delete a product', tags: ['Product', 'Write'], isAuthenticated: true },
    { id: 'ep-5', method: 'POST', path: '/orders', description: 'Place a new order', tags: ['Order', 'Write'], isAuthenticated: true, requestSchema: { userId: 'string', productId: 'string', quantity: 'number' } },
    { id: 'ep-6', method: 'GET', path: '/status', description: 'Check API health', tags: ['System'], isAuthenticated: false, responseSchema: { status: 'string', uptime: 'string' } },
];

export const MOCK_USERS: UserProfile[] = [
    { id: 'user-alpha', name: 'Alice Smith', email: 'alice@example.com', role: 'Admin', lastLogin: '2024-08-01T15:00:00Z' },
    { id: 'user-beta', name: 'Bob Johnson', email: 'bob@example.com', role: 'Developer', lastLogin: '2024-07-31T10:00:00Z' },
    { id: 'user-gamma', name: 'Charlie Brown', email: 'charlie@example.com', role: 'Viewer', lastLogin: '2024-07-28T09:00:00Z' },
    { id: 'user-delta', name: 'Diana Prince', email: 'diana@example.com', role: 'Developer', lastLogin: '2024-08-01T11:00:00Z' },
    { id: 'user-epsilon', name: 'Eve Adams', email: 'eve@example.com', role: 'Admin', lastLogin: '2024-07-29T16:00:00Z' },
    { id: 'user-zeta', name: 'Frank White', email: 'frank@example.com', role: 'Viewer', lastLogin: '2024-07-20T14:00:00Z' },
];

export const generateMockMetrics = (metricType: 'api_calls' | 'api_errors' | 'api_latency' | 'webhook_failures', days: number = 7): MetricData[] => {
    const data: MetricData[] = [];
    let baseValue = metricType === 'api_calls' ? 5000 : (metricType === 'api_latency' ? 100 : 0);
    const fluctuation = metricType === 'api_calls' ? 1000 : (metricType === 'api_latency' ? 50 : (metricType === 'api_errors' || metricType === 'webhook_failures' ? 2 : 0.5));
    const isErrorOrLatency = metricType === 'api_errors' || metricType === 'api_latency' || metricType === 'webhook_failures';

    for (let i = days * 24; i >= 0; i--) {
        const timestamp = new Date(Date.now() - i * 60 * 60 * 1000).toISOString(); // Hourly data
        let value = baseValue + (Math.random() - 0.5) * fluctuation * 2;
        if (isErrorOrLatency) {
            value = Math.max(0, value); // No negative errors/latency
            if (metricType === 'api_errors') value = Math.min(value, 10); // Max 10% error rate
            if (metricType === 'webhook_failures') value = Math.min(value, 5); // Max 5% webhook failures
        }
        data.push({ timestamp, value: parseFloat(value.toFixed(2)) });
        baseValue = value; // Trend slightly
    }
    return data;
};

// --- Reusable UI Components & Helpers ---

export const getStatusColor = (status: string) => {
    switch (status) {
        case 'Active': return 'bg-green-500/20 text-green-300';
        case 'Stopped': return 'bg-gray-500/20 text-gray-300';
        case 'Archived': return 'bg-purple-500/20 text-purple-300';
        case 'Provisioning': return 'bg-yellow-500/20 text-yellow-300';
        case 'Failed': return 'bg-red-500/20 text-red-300';
        case 'Paused': return 'bg-orange-500/20 text-orange-300';
        case 'Revoked': return 'bg-red-500/20 text-red-300';
        case 'Expired': return 'bg-red-500/20 text-red-300';
        default: return 'bg-gray-500/20 text-gray-300';
    }
};

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl';
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-2xl',
        xl: 'max-w-4xl',
        '2xl': 'max-w-6xl',
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
            <div className={`bg-gray-800 rounded-lg shadow-2xl ${sizeClasses[size]} w-full border border-gray-700`} onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div className="p-6">
                    {children}
                </div>
            </div>
        </div>
    );
};

interface TooltipProps {
    children: React.ReactNode;
    text: string;
}

export const Tooltip: React.FC<TooltipProps> = ({ children, text }) => {
    return (
        <div className="relative flex items-center group">
            {children}
            <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-2 rounded bg-gray-700 text-white text-xs whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50">
                {text}
            </div>
        </div>
    );
};

interface TabProps {
    label: string;
    isActive: boolean;
    onClick: () => void;
}

export const Tab: React.FC<TabProps> = ({ label, isActive, onClick }) => (
    <button
        className={`px-4 py-2 text-sm font-medium rounded-t-lg ${isActive ? 'text-white border-b-2 border-cyan-500' : 'text-gray-400 hover:text-gray-200'}`}
        onClick={onClick}
    >
        {label}
    </button>
);

// --- Context for Environment Selection ---
interface SandboxContextType {
    selectedEnvironmentId: string | null;
    setSelectedEnvironmentId: (id: string | null) => void;
    environments: SandboxEnvironment[];
    addEnvironment: (env: SandboxEnvironment) => void;
    updateEnvironment: (env: SandboxEnvironment) => void;
    deleteEnvironment: (id: string) => void;
    apiKeys: APIKey[];
    addApiKey: (key: APIKey) => void;
    updateApiKey: (key: APIKey) => void;
    deleteApiKey: (id: string) => void;
    webhooks: WebhookConfig[];
    addWebhook: (webhook: WebhookConfig) => void;
    updateWebhook: (webhook: WebhookConfig) => void;
    deleteWebhook: (id: string) => void;
    logs: LogEntry[];
    addLog: (log: LogEntry) => void;
    refreshLogs: (envId: string) => void;
}

export const SandboxContext = createContext<SandboxContextType | undefined>(undefined);

export const useSandbox = () => {
    const context = useContext(SandboxContext);
    if (!context) {
        throw new Error('useSandbox must be used within a SandboxProvider');
    }
    return context;
};

// --- Main Sandbox Provider for State Management ---
export const SandboxProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [environments, setEnvironments] = useState<SandboxEnvironment[]>(MOCK_ENVIRONMENTS);
    const [selectedEnvironmentId, setSelectedEnvironmentId] = useState<string | null>(null);
    const [apiKeys, setApiKeys] = useState<APIKey[]>(MOCK_API_KEYS);
    const [webhooks, setWebhooks] = useState<WebhookConfig[]>(MOCK_WEBHOOKS);
    const [logs, setLogs] = useState<LogEntry[]>(() => {
        const allLogs: LogEntry[] = [];
        MOCK_ENVIRONMENTS.forEach(env => {
            allLogs.push(...generateMockLogs(env.id, getRandomInt(50, 150)));
        });
        return allLogs;
    });

    const addEnvironment = (env: SandboxEnvironment) => setEnvironments(prev => [...prev, env]);
    const updateEnvironment = (updatedEnv: SandboxEnvironment) => setEnvironments(prev => prev.map(env => env.id === updatedEnv.id ? updatedEnv : env));
    const deleteEnvironment = (id: string) => {
        setEnvironments(prev => prev.filter(env => env.id !== id));
        setApiKeys(prev => prev.filter(key => key.environmentId !== id));
        setWebhooks(prev => prev.filter(webhook => webhook.environmentId !== id));
        setLogs(prev => prev.filter(log => log.environmentId !== id));
        if (selectedEnvironmentId === id) setSelectedEnvironmentId(null);
    };

    const addApiKey = (key: APIKey) => setApiKeys(prev => [...prev, key]);
    const updateApiKey = (updatedKey: APIKey) => setApiKeys(prev => prev.map(key => key.id === updatedKey.id ? updatedKey : key));
    const deleteApiKey = (id: string) => setApiKeys(prev => prev.filter(key => key.id !== id));

    const addWebhook = (webhook: WebhookConfig) => setWebhooks(prev => [...prev, webhook]);
    const updateWebhook = (updatedWebhook: WebhookConfig) => setWebhooks(prev => prev.map(webhook => webhook.id === updatedWebhook.id ? updatedWebhook : webhook));
    const deleteWebhook = (id: string) => setWebhooks(prev => prev.filter(webhook => webhook.id !== id));

    const addLog = (log: LogEntry) => setLogs(prev => [log, ...prev]);
    const refreshLogs = (envId: string) => {
        // Simulate fetching new logs
        const newLogs = generateMockLogs(envId, getRandomInt(5, 20));
        setLogs(prev => [...newLogs, ...prev.filter(log => log.environmentId !== envId)]);
    };

    const value = useMemo(() => ({
        selectedEnvironmentId,
        setSelectedEnvironmentId,
        environments,
        addEnvironment,
        updateEnvironment,
        deleteEnvironment,
        apiKeys,
        addApiKey,
        updateApiKey,
        deleteApiKey,
        webhooks,
        addWebhook,
        updateWebhook,
        deleteWebhook,
        logs,
        addLog,
        refreshLogs,
    }), [
        selectedEnvironmentId, environments, apiKeys, webhooks, logs,
        addEnvironment, updateEnvironment, deleteEnvironment,
        addApiKey, updateApiKey, deleteApiKey,
        addWebhook, updateWebhook, deleteWebhook,
        addLog, refreshLogs
    ]);

    return (
        <SandboxContext.Provider value={value}>
            {children}
        </SandboxContext.Provider>
    );
};


// --- Feature Components ---

// 1. AI Test Data Generator (Modal from original, enhanced)
export const AIDataGeneratorModal: React.FC<{ isOpen: boolean; onClose: () => void }> = ({ isOpen, onClose }) => {
    const [prompt, setPrompt] = useState('a user with 5 recent transactions of varying amounts');
    const [generatedData, setGeneratedData] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [schemaPrompt, setSchemaPrompt] = useState('');
    const [useSchema, setUseSchema] = useState(false);

    const handleGenerate = async () => {
        setIsLoading(true);
        setGeneratedData('');
        setError(null);
        try {
            // In a real app, API_KEY would be securely managed, not directly exposed or used client-side for production.
            // For a dev sandbox, this might be acceptable with appropriate ACLs.
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            let fullPrompt = `Generate a realistic mock JSON object based on this request: "${prompt}". The JSON should be well-formed.`;
            if (useSchema && schemaPrompt.trim()) {
                fullPrompt += ` Adhere to the following JSON schema description: \n${schemaPrompt}`;
            }

            const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: fullPrompt });
            const cleanedResponse = response.text.replace(/```json\n|```/g, '').trim();
            setGeneratedData(JSON.stringify(JSON.parse(cleanedResponse), null, 2));
        } catch (err) {
            console.error('AI generation error:', err);
            setError("Error: Could not generate valid JSON data. Please check your prompt and API key. (Details: " + (err as Error).message + ")");
            setGeneratedData('');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="AI Test Data Generator" size="lg">
            <div className="space-y-4">
                <label className="block text-gray-300 text-sm font-bold mb-2" htmlFor="data-prompt">
                    Data Description Prompt
                </label>
                <textarea
                    id="data-prompt"
                    value={prompt}
                    onChange={e => setPrompt(e.target.value)}
                    placeholder="Describe the mock data you need, e.g., 'a customer object with a list of orders, each order having items and a total price'..."
                    className="w-full h-24 bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 focus:ring-cyan-500"
                />

                <div className="flex items-center space-x-2">
                    <input
                        type="checkbox"
                        id="use-schema"
                        checked={useSchema}
                        onChange={e => setUseSchema(e.target.checked)}
                        className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                    />
                    <label htmlFor="use-schema" className="text-gray-300">
                        Use JSON Schema for structure guidance
                    </label>
                </div>

                {useSchema && (
                    <div className="space-y-2">
                        <label className="block text-gray-300 text-sm font-bold mb-2" htmlFor="schema-prompt">
                            JSON Schema Description (e.g., "An array of objects, each with a 'name' string and 'age' number")
                        </label>
                        <textarea
                            id="schema-prompt"
                            value={schemaPrompt}
                            onChange={e => setSchemaPrompt(e.target.value)}
                            placeholder="Describe your desired JSON schema (e.g., 'An array of objects, each with a "name" string and "age" number')"
                            className="w-full h-24 bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 focus:ring-cyan-500"
                        />
                    </div>
                )}

                <button
                    onClick={handleGenerate}
                    disabled={isLoading || prompt.trim().length === 0 || (useSchema && schemaPrompt.trim().length === 0)}
                    className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50 text-white font-medium transition-colors"
                >
                    {isLoading ? 'Generating...' : 'Generate JSON Data'}
                </button>

                {error && <p className="text-red-400 text-sm mt-2">{error}</p>}

                <Card title="Generated Data" className="mt-4">
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono bg-gray-900/50 p-4 rounded max-h-60 overflow-auto border border-gray-700">
                        {isLoading ? 'Generating...' : (generatedData || 'No data generated yet.')}
                    </pre>
                </Card>
            </div>
        </Modal>
    );
};

// 2. Sandbox Environments Table
export const EnvironmentsTable: React.FC<{ onSelectEnv: (id: string) => void; onCreateEnv: () => void; onEditEnv: (env: SandboxEnvironment) => void; onDeleteEnv: (id: string) => void }> = ({ onSelectEnv, onCreateEnv, onEditEnv, onDeleteEnv }) => {
    const { environments } = useSandbox();

    return (
        <Card title="Sandbox Environments" className="mb-6">
            <div className="flex justify-end mb-4">
                <button
                    onClick={onCreateEnv}
                    className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium transition-colors"
                >
                    + Create New Environment
                </button>
            </div>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Name</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">API Keys</th>
                            <th scope="col" className="px-6 py-3">Webhooks</th>
                            <th scope="col" className="px-6 py-3">Created</th>
                            <th scope="col" className="px-6 py-3">Last Activity</th>
                            <th scope="col" className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {environments.length === 0 && (
                            <tr><td colSpan={7} className="px-6 py-4 text-center text-gray-500">No environments found. Create one to get started!</td></tr>
                        )}
                        {environments.map(env => (
                            <tr key={env.id} className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors">
                                <td className="px-6 py-4 font-medium text-white">
                                    <button onClick={() => onSelectEnv(env.id)} className="text-cyan-400 hover:underline">
                                        {env.name}
                                    </button>
                                </td>
                                <td className="px-6 py-4">
                                    <span className={`px-2 py-1 text-xs rounded-full ${getStatusColor(env.status)}`}>
                                        {env.status}
                                    </span>
                                </td>
                                <td className="px-6 py-4">{env.apiKeyCount}</td>
                                <td className="px-6 py-4">{env.webhookCount}</td>
                                <td className="px-6 py-4">{new Date(env.createdAt).toLocaleDateString()}</td>
                                <td className="px-6 py-4">{new Date(env.lastActivity).toLocaleString()}</td>
                                <td className="px-6 py-4 flex gap-2">
                                    <button onClick={() => onEditEnv(env)} className="text-xs text-yellow-400 hover:underline">Edit</button>
                                    <button onClick={() => onDeleteEnv(env.id)} className="text-xs text-red-400 hover:underline">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

// 3. Environment Detail View
export const EnvironmentDetail: React.FC<{ environment: SandboxEnvironment; onClose: () => void }> = ({ environment, onClose }) => {
    const { updateEnvironment, deleteEnvironment } = useSandbox();
    const [activeTab, setActiveTab] = useState('Overview');
    const [isConfirmDeleteOpen, setConfirmDeleteOpen] = useState(false);

    const handleDelete = () => {
        deleteEnvironment(environment.id);
        onClose();
    };

    const handleUpdateStatus = (newStatus: SandboxEnvironment['status']) => {
        updateEnvironment({ ...environment, status: newStatus, lastActivity: new Date().toISOString() });
    };

    return (
        <Modal isOpen={true} onClose={onClose} title={`Environment: ${environment.name}`} size="2xl">
            <div className="space-y-6">
                <div className="flex justify-between items-center pb-4 border-b border-gray-700">
                    <div className="flex items-center space-x-4">
                        <span className={`px-3 py-1 text-sm rounded-full ${getStatusColor(environment.status)} font-medium`}>
                            {environment.status}
                        </span>
                        <p className="text-gray-400 text-sm">Created: {new Date(environment.createdAt).toLocaleDateString()}</p>
                        <p className="text-gray-400 text-sm">Last Activity: {new Date(environment.lastActivity).toLocaleString()}</p>
                    </div>
                    <div className="flex space-x-2">
                        {environment.status === 'Active' && (
                            <button onClick={() => handleUpdateStatus('Stopped')} className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 text-white rounded text-sm transition-colors">Stop</button>
                        )}
                        {environment.status === 'Stopped' && (
                            <button onClick={() => handleUpdateStatus('Active')} className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-sm transition-colors">Start</button>
                        )}
                        <button onClick={() => setConfirmDeleteOpen(true)} className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded text-sm transition-colors">Delete</button>
                    </div>
                </div>

                <div className="border-b border-gray-700">
                    <div className="flex -mb-px">
                        <Tab label="Overview" isActive={activeTab === 'Overview'} onClick={() => setActiveTab('Overview')} />
                        <Tab label="API Keys" isActive={activeTab === 'API Keys'} onClick={() => setActiveTab('API Keys')} />
                        <Tab label="Webhooks" isActive={activeTab === 'Webhooks'} onClick={() => setActiveTab('Webhooks')} />
                        <Tab label="Logs" isActive={activeTab === 'Logs'} onClick={() => setActiveTab('Logs')} />
                        <Tab label="Metrics" isActive={activeTab === 'Metrics'} onClick={() => setActiveTab('Metrics')} />
                        <Tab label="Settings" isActive={activeTab === 'Settings'} onClick={() => setActiveTab('Settings')} />
                    </div>
                </div>

                <div className="pt-4">
                    {activeTab === 'Overview' && (
                        <div className="space-y-4">
                            <h4 className="text-xl font-semibold text-white">Description</h4>
                            <p className="text-gray-300">{environment.description || 'No description provided.'}</p>
                            <div className="grid grid-cols-2 gap-4 text-gray-300">
                                <div><span className="font-semibold text-gray-200">Owner:</span> {MOCK_USERS.find(u => u.id === environment.ownerId)?.name || environment.ownerId}</div>
                                <div><span className="font-semibold text-gray-200">Region:</span> {environment.region}</div>
                            </div>
                            <div className="grid grid-cols-2 gap-4 text-gray-300">
                                <div><span className="font-semibold text-gray-200">API Key Count:</span> {environment.apiKeyCount}</div>
                                <div><span className="font-semibold text-gray-200">Webhook Count:</span> {environment.webhookCount}</div>
                            </div>
                        </div>
                    )}
                    {activeTab === 'API Keys' && <EnvironmentAPIKeys environmentId={environment.id} />}
                    {activeTab === 'Webhooks' && <EnvironmentWebhooks environmentId={environment.id} />}
                    {activeTab === 'Logs' && <EnvironmentLogs environmentId={environment.id} />}
                    {activeTab === 'Metrics' && <EnvironmentMetrics environment={environment} />}
                    {activeTab === 'Settings' && <EnvironmentSettings environment={environment} onUpdate={updateEnvironment} />}
                </div>
            </div>

            <Modal isOpen={isConfirmDeleteOpen} onClose={() => setConfirmDeleteOpen(false)} title="Confirm Delete Environment" size="sm">
                <div className="text-gray-300 space-y-4">
                    <p>Are you sure you want to delete environment "<span className="font-semibold text-white">{environment.name}</span>"? This action cannot be undone.</p>
                    <p className="text-sm text-red-400">All associated API keys, webhooks, and logs will also be deleted.</p>
                    <div className="flex justify-end space-x-3">
                        <button onClick={() => setConfirmDeleteOpen(false)} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white text-sm transition-colors">Cancel</button>
                        <button onClick={handleDelete} className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded text-white text-sm transition-colors">Delete Environment</button>
                    </div>
                </div>
            </Modal>
        </Modal>
    );
};


// 4. Create/Edit Environment Form
export const EnvironmentForm: React.FC<{ environment?: SandboxEnvironment; onClose: () => void }> = ({ environment, onClose }) => {
    const { addEnvironment, updateEnvironment } = useSandbox();
    const isEditing = !!environment;

    const [formData, setFormData] = useState<SandboxEnvironment>(
        environment || {
            id: generateUUID(),
            name: '',
            description: '',
            status: 'Active',
            apiKeyCount: 0,
            webhookCount: 0,
            createdAt: new Date().toISOString().split('T')[0],
            lastActivity: new Date().toISOString(),
            ownerId: MOCK_USERS[0].id, // Default to first mock user
            region: 'us-east-1',
            config: {
                rateLimit: 500,
                dataRetentionDays: 90,
                loggingEnabled: true,
                publicAccess: false,
            }
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        if (name.startsWith('config.')) {
            const configKey = name.split('.')[1] as keyof SandboxEnvironment['config'];
            setFormData(prev => ({
                ...prev,
                config: {
                    ...prev.config,
                    [configKey]: type === 'checkbox' ? checked : (type === 'number' ? parseInt(value, 10) : value),
                },
            }));
        } else {
            setFormData(prev => ({
                ...prev,
                [name]: type === 'checkbox' ? checked : (type === 'number' ? parseInt(value, 10) : value),
            }));
        }
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (isEditing) {
            updateEnvironment(formData);
        } else {
            addEnvironment(formData);
        }
        onClose();
    };

    return (
        <Modal isOpen={true} onClose={onClose} title={isEditing ? 'Edit Environment' : 'Create New Environment'} size="lg">
            <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                    <label htmlFor="name" className="block text-gray-300 text-sm font-bold mb-2">Environment Name</label>
                    <input
                        type="text"
                        id="name"
                        name="name"
                        value={formData.name}
                        onChange={handleChange}
                        required
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                <div>
                    <label htmlFor="description" className="block text-gray-300 text-sm font-bold mb-2">Description</label>
                    <textarea
                        id="description"
                        name="description"
                        value={formData.description}
                        onChange={handleChange}
                        rows={3}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                <div>
                    <label htmlFor="ownerId" className="block text-gray-300 text-sm font-bold mb-2">Owner</label>
                    <select
                        id="ownerId"
                        name="ownerId"
                        value={formData.ownerId}
                        onChange={handleChange}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        {MOCK_USERS.map(user => (
                            <option key={user.id} value={user.id}>{user.name} ({user.role})</option>
                        ))}
                    </select>
                </div>
                <div>
                    <label htmlFor="region" className="block text-gray-300 text-sm font-bold mb-2">Region</label>
                    <select
                        id="region"
                        name="region"
                        value={formData.region}
                        onChange={handleChange}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        <option value="us-east-1">US East (N. Virginia)</option>
                        <option value="us-west-2">US West (Oregon)</option>
                        <option value="eu-west-1">Europe (Ireland)</option>
                        <option value="eu-central-1">Europe (Frankfurt)</option>
                        <option value="ap-southeast-2">Asia Pacific (Sydney)</option>
                    </select>
                </div>

                <div className="border-t border-gray-700 pt-6 space-y-4">
                    <h4 className="text-lg font-semibold text-white">Configuration</h4>
                    <div>
                        <label htmlFor="config.rateLimit" className="block text-gray-300 text-sm font-bold mb-2">Rate Limit (req/min)</label>
                        <input
                            type="number"
                            id="config.rateLimit"
                            name="config.rateLimit"
                            value={formData.config.rateLimit}
                            onChange={handleChange}
                            min="1"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                    <div>
                        <label htmlFor="config.dataRetentionDays" className="block text-gray-300 text-sm font-bold mb-2">Data Retention (days)</label>
                        <input
                            type="number"
                            id="config.dataRetentionDays"
                            name="config.dataRetentionDays"
                            value={formData.config.dataRetentionDays}
                            onChange={handleChange}
                            min="7"
                            max="365"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                    <div className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            id="config.loggingEnabled"
                            name="config.loggingEnabled"
                            checked={formData.config.loggingEnabled}
                            onChange={handleChange}
                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                        />
                        <label htmlFor="config.loggingEnabled" className="text-gray-300">Enable API Logging</label>
                    </div>
                    <div className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            id="config.publicAccess"
                            name="config.publicAccess"
                            checked={formData.config.publicAccess}
                            onChange={handleChange}
                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                        />
                        <label htmlFor="config.publicAccess" className="text-gray-300">Allow Public Access (without API Key)</label>
                    </div>
                </div>

                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white text-sm font-medium transition-colors">Cancel</button>
                    <button type="submit" className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded text-white text-sm font-medium transition-colors">
                        {isEditing ? 'Save Changes' : 'Create Environment'}
                    </button>
                </div>
            </form>
        </Modal>
    );
};


// 5. Environment API Keys Management
export const EnvironmentAPIKeys: React.FC<{ environmentId: string }> = ({ environmentId }) => {
    const { apiKeys, addApiKey, updateApiKey, deleteApiKey } = useSandbox();
    const [isCreateKeyModalOpen, setCreateKeyModalOpen] = useState(false);
    const [editingKey, setEditingKey] = useState<APIKey | null>(null);

    const filteredApiKeys = useMemo(() => apiKeys.filter(key => key.environmentId === environmentId), [apiKeys, environmentId]);

    const handleCreateKey = (newKey: APIKey) => {
        addApiKey({ ...newKey, environmentId: environmentId, id: generateUUID(), key: `sk_live_${generateUUID().slice(0, 8)}...${generateUUID().slice(0, 4)}`, createdAt: new Date().toISOString() });
        setCreateKeyModalOpen(false);
    };

    const handleUpdateKey = (updatedKey: APIKey) => {
        updateApiKey(updatedKey);
        setEditingKey(null);
    };

    const handleRevokeKey = (key: APIKey) => {
        if (confirm(`Are you sure you want to revoke API Key "${key.name}"?`)) {
            updateApiKey({ ...key, status: 'Revoked', expiresAt: new Date().toISOString() });
        }
    };

    const handleGenerateNewKey = () => {
        const newKey: APIKey = {
            id: generateUUID(),
            environmentId: environmentId,
            name: `New Key ${new Date().toLocaleDateString()}`,
            key: `sk_test_${generateUUID().slice(0, 10)}...${generateUUID().slice(0, 4)}`,
            status: 'Active',
            permissions: ['read:data'],
            createdAt: new Date().toISOString(),
            lastUsed: 'Never',
        };
        addApiKey(newKey);
    };


    return (
        <Card title="API Keys" className="mb-6">
            <div className="flex justify-end mb-4">
                <button
                    onClick={handleGenerateNewKey}
                    className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium transition-colors"
                >
                    + Generate New API Key
                </button>
            </div>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Name</th>
                            <th scope="col" className="px-6 py-3">Key</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">Permissions</th>
                            <th scope="col" className="px-6 py-3">Last Used</th>
                            <th scope="col" className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {filteredApiKeys.length === 0 && (
                            <tr><td colSpan={6} className="px-6 py-4 text-center text-gray-500">No API keys found for this environment.</td></tr>
                        )}
                        {filteredApiKeys.map(key => (
                            <tr key={key.id} className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors">
                                <td className="px-6 py-4 font-medium text-white">{key.name}</td>
                                <td className="px-6 py-4 font-mono text-gray-300">{key.key} <Tooltip text="Copy to clipboard"><button onClick={() => navigator.clipboard.writeText(key.key)} className="ml-2 text-cyan-400 hover:text-cyan-200"></button></Tooltip></td>
                                <td className="px-6 py-4"><span className={`px-2 py-1 text-xs rounded-full ${getStatusColor(key.status)}`}>{key.status}</span></td>
                                <td className="px-6 py-4 text-gray-300">{key.permissions.join(', ')}</td>
                                <td className="px-6 py-4">{key.lastUsed !== 'Never' ? new Date(key.lastUsed).toLocaleDateString() : key.lastUsed}</td>
                                <td className="px-6 py-4 flex gap-2">
                                    <button onClick={() => setEditingKey(key)} className="text-xs text-yellow-400 hover:underline">Edit</button>
                                    {key.status === 'Active' && <button onClick={() => handleRevokeKey(key)} className="text-xs text-orange-400 hover:underline">Revoke</button>}
                                    <button onClick={() => deleteApiKey(key.id)} className="text-xs text-red-400 hover:underline">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {editingKey && (
                <APIKeyForm keyToEdit={editingKey} onClose={() => setEditingKey(null)} onSave={handleUpdateKey} />
            )}
        </Card>
    );
};

export const APIKeyForm: React.FC<{ keyToEdit?: APIKey | null; onClose: () => void; onSave: (key: APIKey) => void }> = ({ keyToEdit, onClose, onSave }) => {
    const isEditing = !!keyToEdit;
    const [formData, setFormData] = useState<APIKey>(
        keyToEdit || {
            id: generateUUID(),
            environmentId: '', // Placeholder, will be set by parent
            name: '',
            key: `sk_test_${generateUUID().slice(0, 8)}...${generateUUID().slice(0, 4)}`, // Mock key
            status: 'Active',
            permissions: [],
            createdAt: new Date().toISOString(),
            lastUsed: 'Never',
        }
    );

    useEffect(() => {
        if (keyToEdit) setFormData(keyToEdit);
    }, [keyToEdit]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value,
        }));
    };

    const handlePermissionChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { value, checked } = e.target;
        setFormData(prev => ({
            ...prev,
            permissions: checked ? [...prev.permissions, value] : prev.permissions.filter(p => p !== value),
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(formData);
    };

    const allPermissions = ['read:data', 'write:data', 'manage:webhooks', 'admin'];

    return (
        <Modal isOpen={true} onClose={onClose} title={isEditing ? 'Edit API Key' : 'Create New API Key'} size="md">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="name" className="block text-gray-300 text-sm font-bold mb-2">Key Name</label>
                    <input
                        type="text"
                        id="name"
                        name="name"
                        value={formData.name}
                        onChange={handleChange}
                        required
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                {!isEditing && ( // Only show generated key on create
                    <div>
                        <label htmlFor="key" className="block text-gray-300 text-sm font-bold mb-2">Generated Key (Keep secure!)</label>
                        <div className="flex items-center space-x-2">
                            <input
                                type="text"
                                id="key"
                                name="key"
                                value={formData.key}
                                readOnly
                                className="flex-grow bg-gray-700/50 p-2 rounded text-gray-400 font-mono text-sm border border-gray-600"
                            />
                            <Tooltip text="Copy to clipboard">
                                <button type="button" onClick={() => navigator.clipboard.writeText(formData.key)} className="px-3 py-2 bg-gray-600 hover:bg-gray-500 rounded text-white text-sm transition-colors">
                                    Copy
                                </button>
                            </Tooltip>
                        </div>
                    </div>
                )}
                <div>
                    <label className="block text-gray-300 text-sm font-bold mb-2">Permissions</label>
                    <div className="grid grid-cols-2 gap-2">
                        {allPermissions.map(perm => (
                            <div key={perm} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={`perm-${perm}`}
                                    value={perm}
                                    checked={formData.permissions.includes(perm)}
                                    onChange={handlePermissionChange}
                                    className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                />
                                <label htmlFor={`perm-${perm}`} className="ml-2 text-gray-300 text-sm">{perm}</label>
                            </div>
                        ))}
                    </div>
                </div>
                <div>
                    <label htmlFor="status" className="block text-gray-300 text-sm font-bold mb-2">Status</label>
                    <select
                        id="status"
                        name="status"
                        value={formData.status}
                        onChange={handleChange}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        <option value="Active">Active</option>
                        <option value="Revoked">Revoked</option>
                        <option value="Expired">Expired</option>
                    </select>
                </div>
                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white text-sm font-medium transition-colors">Cancel</button>
                    <button type="submit" className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded text-white text-sm font-medium transition-colors">
                        {isEditing ? 'Save Changes' : 'Create Key'}
                    </button>
                </div>
            </form>
        </Modal>
    );
};


// 6. Environment Webhooks Management
export const EnvironmentWebhooks: React.FC<{ environmentId: string }> = ({ environmentId }) => {
    const { webhooks, addWebhook, updateWebhook, deleteWebhook } = useSandbox();
    const [isWebhookModalOpen, setWebhookModalOpen] = useState(false);
    const [editingWebhook, setEditingWebhook] = useState<WebhookConfig | null>(null);

    const filteredWebhooks = useMemo(() => webhooks.filter(hook => hook.environmentId === environmentId), [webhooks, environmentId]);

    const handleSaveWebhook = (webhook: WebhookConfig) => {
        if (editingWebhook) {
            updateWebhook(webhook);
        } else {
            addWebhook({ ...webhook, environmentId: environmentId, id: generateUUID(), createdAt: new Date().toISOString(), lastTriggered: 'Never' });
        }
        setWebhookModalOpen(false);
        setEditingWebhook(null);
    };

    const handleTriggerTestWebhook = (webhook: WebhookConfig) => {
        alert(`Simulating test trigger for webhook: ${webhook.name} to ${webhook.url}`);
        // In a real app, this would make an actual request to the webhook URL.
        updateWebhook({ ...webhook, lastTriggered: new Date().toISOString() });
    };

    return (
        <Card title="Webhooks" className="mb-6">
            <div className="flex justify-end mb-4">
                <button
                    onClick={() => { setEditingWebhook(null); setWebhookModalOpen(true); }}
                    className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-medium transition-colors"
                >
                    + Add New Webhook
                </button>
            </div>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Name</th>
                            <th scope="col" className="px-6 py-3">URL</th>
                            <th scope="col" className="px-6 py-3">Events</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">Last Triggered</th>
                            <th scope="col" className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {filteredWebhooks.length === 0 && (
                            <tr><td colSpan={6} className="px-6 py-4 text-center text-gray-500">No webhooks configured for this environment.</td></tr>
                        )}
                        {filteredWebhooks.map(webhook => (
                            <tr key={webhook.id} className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors">
                                <td className="px-6 py-4 font-medium text-white">{webhook.name}</td>
                                <td className="px-6 py-4 text-gray-300 font-mono truncate max-w-xs">{webhook.url}</td>
                                <td className="px-6 py-4 text-gray-300">{webhook.events.join(', ')}</td>
                                <td className="px-6 py-4"><span className={`px-2 py-1 text-xs rounded-full ${getStatusColor(webhook.status)}`}>{webhook.status}</span></td>
                                <td className="px-6 py-4">{webhook.lastTriggered !== 'Never' ? new Date(webhook.lastTriggered).toLocaleString() : 'Never'}</td>
                                <td className="px-6 py-4 flex gap-2">
                                    <button onClick={() => setEditingWebhook(webhook)} className="text-xs text-yellow-400 hover:underline">Edit</button>
                                    <button onClick={() => handleTriggerTestWebhook(webhook)} className="text-xs text-cyan-400 hover:underline">Test</button>
                                    <button onClick={() => deleteWebhook(webhook.id)} className="text-xs text-red-400 hover:underline">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {isWebhookModalOpen && (
                <WebhookForm webhookToEdit={editingWebhook} onClose={() => { setWebhookModalOpen(false); setEditingWebhook(null); }} onSave={handleSaveWebhook} />
            )}
        </Card>
    );
};

export const WebhookForm: React.FC<{ webhookToEdit?: WebhookConfig | null; onClose: () => void; onSave: (webhook: WebhookConfig) => void }> = ({ webhookToEdit, onClose, onSave }) => {
    const isEditing = !!webhookToEdit;
    const [formData, setFormData] = useState<WebhookConfig>(
        webhookToEdit || {
            id: generateUUID(),
            environmentId: '', // Placeholder
            name: '',
            url: '',
            secret: generateUUID(),
            events: [],
            status: 'Active',
            createdAt: new Date().toISOString(),
            lastTriggered: 'Never',
            retriesEnabled: true,
            maxRetries: 5,
        }
    );

    useEffect(() => {
        if (webhookToEdit) setFormData(webhookToEdit);
    }, [webhookToEdit]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : (type === 'number' ? parseInt(value, 10) : value),
        }));
    };

    const handleEventChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { value, checked } = e.target;
        setFormData(prev => ({
            ...prev,
            events: checked ? [...prev.events, value] : prev.events.filter(event => event !== value),
        }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(formData);
    };

    const allEvents = ['data.created', 'data.updated', 'data.deleted', 'user.created', 'user.updated', 'user.deleted', 'api_key.revoked', 'environment.status_change', 'payment.success', 'payment.failed'];

    return (
        <Modal isOpen={true} onClose={onClose} title={isEditing ? 'Edit Webhook' : 'Add New Webhook'} size="md">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="name" className="block text-gray-300 text-sm font-bold mb-2">Webhook Name</label>
                    <input
                        type="text"
                        id="name"
                        name="name"
                        value={formData.name}
                        onChange={handleChange}
                        required
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                <div>
                    <label htmlFor="url" className="block text-gray-300 text-sm font-bold mb-2">Target URL</label>
                    <input
                        type="url"
                        id="url"
                        name="url"
                        value={formData.url}
                        onChange={handleChange}
                        required
                        placeholder="https://your-listener.com/webhook"
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                {!isEditing && ( // Only show generated secret on create
                    <div>
                        <label htmlFor="secret" className="block text-gray-300 text-sm font-bold mb-2">Shared Secret (for verification)</label>
                        <div className="flex items-center space-x-2">
                            <input
                                type="text"
                                id="secret"
                                name="secret"
                                value={formData.secret}
                                readOnly
                                className="flex-grow bg-gray-700/50 p-2 rounded text-gray-400 font-mono text-sm border border-gray-600"
                            />
                            <Tooltip text="Copy to clipboard">
                                <button type="button" onClick={() => navigator.clipboard.writeText(formData.secret)} className="px-3 py-2 bg-gray-600 hover:bg-gray-500 rounded text-white text-sm transition-colors">
                                    Copy
                                </button>
                            </Tooltip>
                        </div>
                        <p className="text-xs text-gray-500 mt-1">This secret is used to sign webhook payloads, ensure you store it securely.</p>
                    </div>
                )}
                <div>
                    <label className="block text-gray-300 text-sm font-bold mb-2">Events to Trigger On</label>
                    <div className="grid grid-cols-2 gap-2 max-h-40 overflow-y-auto pr-2 custom-scrollbar">
                        {allEvents.map(event => (
                            <div key={event} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={`event-${event}`}
                                    value={event}
                                    checked={formData.events.includes(event)}
                                    onChange={handleEventChange}
                                    className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                />
                                <label htmlFor={`event-${event}`} className="ml-2 text-gray-300 text-sm">{event}</label>
                            </div>
                        ))}
                    </div>
                </div>
                <div>
                    <label htmlFor="status" className="block text-gray-300 text-sm font-bold mb-2">Status</label>
                    <select
                        id="status"
                        name="status"
                        value={formData.status}
                        onChange={handleChange}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        <option value="Active">Active</option>
                        <option value="Paused">Paused</option>
                        <option value="Failed">Failed (Automatic pausing)</option>
                    </select>
                </div>
                <div className="flex items-center space-x-2">
                    <input
                        type="checkbox"
                        id="retriesEnabled"
                        name="retriesEnabled"
                        checked={formData.retriesEnabled}
                        onChange={handleChange}
                        className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                    />
                    <label htmlFor="retriesEnabled" className="text-gray-300">Enable Retries on Failure</label>
                </div>
                {formData.retriesEnabled && (
                    <div>
                        <label htmlFor="maxRetries" className="block text-gray-300 text-sm font-bold mb-2">Max Retries</label>
                        <input
                            type="number"
                            id="maxRetries"
                            name="maxRetries"
                            value={formData.maxRetries}
                            onChange={handleChange}
                            min="0"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                )}
                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white text-sm font-medium transition-colors">Cancel</button>
                    <button type="submit" className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded text-white text-sm font-medium transition-colors">
                        {isEditing ? 'Save Changes' : 'Add Webhook'}
                    </button>
                </div>
            </form>
        </Modal>
    );
};


// 7. Environment Logs Viewer
export const EnvironmentLogs: React.FC<{ environmentId: string }> = ({ environmentId }) => {
    const { logs, refreshLogs } = useSandbox();
    const [filterLevel, setFilterLevel] = useState<string>('ALL');
    const [filterSource, setFilterSource] = useState<string>('ALL');
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [displayCount, setDisplayCount] = useState<number>(50);

    const filteredLogs = useMemo(() => {
        const envLogs = logs.filter(log => log.environmentId === environmentId);
        return envLogs.filter(log => {
            const levelMatch = filterLevel === 'ALL' || log.level === filterLevel;
            const sourceMatch = filterSource === 'ALL' || log.source === filterSource;
            const searchMatch = searchTerm === '' ||
                log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (log.requestId?.toLowerCase().includes(searchTerm.toLowerCase())) ||
                (log.details && JSON.stringify(log.details).toLowerCase().includes(searchTerm.toLowerCase()));
            return levelMatch && sourceMatch && searchMatch;
        }).slice(0, displayCount);
    }, [logs, environmentId, filterLevel, filterSource, searchTerm, displayCount]);

    const allLevels = ['ALL', 'INFO', 'WARN', 'ERROR', 'DEBUG'];
    const allSources = ['ALL', 'API', 'Webhook', 'System', 'Auth'];

    const getLevelColor = (level: LogEntry['level']) => {
        switch (level) {
            case 'INFO': return 'text-blue-400';
            case 'WARN': return 'text-yellow-400';
            case 'ERROR': return 'text-red-400';
            case 'DEBUG': return 'text-purple-400';
            default: return 'text-gray-400';
        }
    };

    return (
        <Card title="Logs" className="mb-6">
            <div className="flex flex-wrap gap-4 mb-4 items-center">
                <div>
                    <label htmlFor="log-level-filter" className="sr-only">Filter by Level</label>
                    <select
                        id="log-level-filter"
                        value={filterLevel}
                        onChange={e => setFilterLevel(e.target.value)}
                        className="bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 text-sm"
                    >
                        {allLevels.map(level => <option key={level} value={level}>{level}</option>)}
                    </select>
                </div>
                <div>
                    <label htmlFor="log-source-filter" className="sr-only">Filter by Source</label>
                    <select
                        id="log-source-filter"
                        value={filterSource}
                        onChange={e => setFilterSource(e.target.value)}
                        className="bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 text-sm"
                    >
                        {allSources.map(source => <option key={source} value={source}>{source}</option>)}
                    </select>
                </div>
                <div className="flex-grow">
                    <label htmlFor="log-search" className="sr-only">Search Logs</label>
                    <input
                        type="text"
                        id="log-search"
                        value={searchTerm}
                        onChange={e => setSearchTerm(e.target.value)}
                        placeholder="Search message, request ID..."
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 text-sm"
                    />
                </div>
                <div>
                    <button
                        onClick={() => refreshLogs(environmentId)}
                        className="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg text-sm font-medium transition-colors"
                    >
                        Refresh Logs
                    </button>
                </div>
            </div>
            <div className="overflow-x-auto max-h-96 custom-scrollbar">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30 sticky top-0">
                        <tr>
                            <th scope="col" className="px-6 py-3">Time</th>
                            <th scope="col" className="px-6 py-3">Level</th>
                            <th scope="col" className="px-6 py-3">Source</th>
                            <th scope="col" className="px-6 py-3">Message</th>
                            <th scope="col" className="px-6 py-3">Request ID</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">Latency</th>
                        </tr>
                    </thead>
                    <tbody>
                        {filteredLogs.length === 0 && (
                            <tr><td colSpan={7} className="px-6 py-4 text-center text-gray-500">No logs found matching criteria.</td></tr>
                        )}
                        {filteredLogs.map(log => (
                            <tr key={log.id} className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors">
                                <td className="px-6 py-2 text-gray-500 text-xs font-mono">{new Date(log.timestamp).toLocaleTimeString()}</td>
                                <td className="px-6 py-2">
                                    <span className={`${getLevelColor(log.level)} font-bold`}>{log.level}</span>
                                </td>
                                <td className="px-6 py-2 text-gray-400">{log.source}</td>
                                <td className="px-6 py-2 text-white max-w-sm truncate">{log.message}</td>
                                <td className="px-6 py-2 text-gray-500 font-mono">{log.requestId || 'N/A'}</td>
                                <td className="px-6 py-2 text-gray-500">{log.statusCode || 'N/A'}</td>
                                <td className="px-6 py-2 text-gray-500">{log.latencyMs ? `${log.latencyMs}ms` : 'N/A'}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {filteredLogs.length < logs.filter(log => log.environmentId === environmentId).length && (
                <div className="text-center mt-4">
                    <button onClick={() => setDisplayCount(prev => prev + 50)} className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg text-sm font-medium">Load More</button>
                </div>
            )}
        </Card>
    );
};

// 8. Environment Metrics Display (Mock Charts)
export const EnvironmentMetrics: React.FC<{ environment: SandboxEnvironment }> = ({ environment }) => {
    const [activeMetricTab, setActiveMetricTab] = useState('api_calls');
    const [timeframe, setTimeframe] = useState('24h');

    const getDaysForTimeframe = (tf: string) => {
        switch (tf) {
            case '1h': return 1/24;
            case '24h': return 1;
            case '7d': return 7;
            case '30d': return 30;
            default: return 1;
        }
    };

    // Simulate metrics
    const mockMetricData = useMemo(() => {
        const days = getDaysForTimeframe(timeframe);
        return {
            api_calls: generateMockMetrics('api_calls', days),
            api_errors: generateMockMetrics('api_errors', days),
            api_latency: generateMockMetrics('api_latency', days),
            webhook_failures: generateMockMetrics('webhook_failures', days),
        };
    }, [timeframe]);

    const currentMetricData = mockMetricData[activeMetricTab as keyof typeof mockMetricData] || [];

    const formatMetricValue = (metricType: string, value: number) => {
        switch(metricType) {
            case 'api_errors':
            case 'webhook_failures': return `${value.toFixed(2)}%`;
            case 'api_latency': return `${value.toFixed(0)}ms`;
            default: return value.toLocaleString();
        }
    };

    const MetricChartPlaceholder: React.FC<{ data: MetricData[]; label: string; unit: string; color: string }> = ({ data, label, unit, color }) => {
        // A simple text-based representation as a placeholder for a real chart
        if (data.length === 0) return <p className="text-gray-500 text-center py-8">No data available for this timeframe.</p>;

        const latestValue = data[data.length - 1]?.value;
        const trend = data.length > 1 && data[data.length - 1].value > data[0].value ? '' : (data.length > 1 && data[data.length - 1].value < data[0].value ? '' : '');

        return (
            <div className="bg-gray-900/50 p-4 rounded-lg border border-gray-700 h-64 flex flex-col justify-between">
                <p className="text-gray-400 text-sm">{label}</p>
                <p className="text-white text-3xl font-bold">{latestValue ? `${latestValue.toFixed(unit === '%' ? 2 : 0)}${unit}` : 'N/A'} {trend}</p>
                <div className="w-full h-24 bg-gradient-to-r from-gray-800 to-gray-700 rounded-md overflow-hidden relative">
                    {/* Simulate a sparkline with divs for visual variety */}
                    <div className={`absolute bottom-0 left-0 h-full ${color}`} style={{ width: '100%', clipPath: `polygon(${data.map((d, i) => `${(i / (data.length - 1)) * 100}% ${100 - (d.value / Math.max(...data.map(d => d.value))) * 100}%`).join(', ')})` }}></div>
                </div>
                <p className="text-gray-500 text-xs text-right">Data points: {data.length}</p>
            </div>
        );
    };

    return (
        <Card title="Metrics Overview" className="mb-6">
            <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <div>
                    <select
                        value={timeframe}
                        onChange={e => setTimeframe(e.target.value)}
                        className="bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500 text-sm"
                    >
                        <option value="1h">Last Hour</option>
                        <option value="24h">Last 24 Hours</option>
                        <option value="7d">Last 7 Days</option>
                        <option value="30d">Last 30 Days</option>
                    </select>
                </div>
                <div className="flex space-x-2">
                    <Tab label="API Calls" isActive={activeMetricTab === 'api_calls'} onClick={() => setActiveMetricTab('api_calls')} />
                    <Tab label="API Errors" isActive={activeMetricTab === 'api_errors'} onClick={() => setActiveMetricTab('api_errors')} />
                    <Tab label="Latency" isActive={activeMetricTab === 'api_latency'} onClick={() => setActiveMetricTab('api_latency')} />
                    <Tab label="Webhook Failures" isActive={activeMetricTab === 'webhook_failures'} onClick={() => setActiveMetricTab('webhook_failures')} />
                </div>
            </div>
            <div className="mt-4">
                <MetricChartPlaceholder
                    data={currentMetricData}
                    label={
                        activeMetricTab === 'api_calls' ? 'Total API Calls' :
                        activeMetricTab === 'api_errors' ? 'API Error Rate' :
                        activeMetricTab === 'api_latency' ? 'Average API Latency' :
                        'Webhook Failure Rate'
                    }
                    unit={
                        activeMetricTab === 'api_errors' || activeMetricTab === 'webhook_failures' ? '%' :
                        activeMetricTab === 'api_latency' ? 'ms' : ''
                    }
                    color={
                        activeMetricTab === 'api_errors' || activeMetricTab === 'webhook_failures' ? 'bg-red-500' :
                        activeMetricTab === 'api_latency' ? 'bg-yellow-500' : 'bg-cyan-500'
                    }
                />
            </div>
            <AlertRules environmentId={environment.id} />
        </Card>
    );
};

// 9. Environment Settings
export const EnvironmentSettings: React.FC<{ environment: SandboxEnvironment; onUpdate: (env: SandboxEnvironment) => void }> = ({ environment, onUpdate }) => {
    const [formData, setFormData] = useState(environment.config);
    const [description, setDescription] = useState(environment.description);

    useEffect(() => {
        setFormData(environment.config);
        setDescription(environment.description);
    }, [environment]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        if (name === 'description') {
            setDescription(value);
        } else {
            setFormData(prev => ({
                ...prev,
                [name]: type === 'checkbox' ? checked : (type === 'number' ? parseInt(value, 10) : value),
            }));
        }
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onUpdate({ ...environment, description: description, config: formData, lastActivity: new Date().toISOString() });
        alert('Environment settings updated!');
    };

    return (
        <Card title="Environment Settings" className="mb-6">
            <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                    <label htmlFor="description" className="block text-gray-300 text-sm font-bold mb-2">Description</label>
                    <textarea
                        id="description"
                        name="description"
                        value={description}
                        onChange={handleChange}
                        rows={3}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                <div className="border-t border-gray-700 pt-6 space-y-4">
                    <h4 className="text-lg font-semibold text-white">Configuration Parameters</h4>
                    <div>
                        <label htmlFor="rateLimit" className="block text-gray-300 text-sm font-bold mb-2">Rate Limit (requests per minute)</label>
                        <input
                            type="number"
                            id="rateLimit"
                            name="rateLimit"
                            value={formData.rateLimit}
                            onChange={handleChange}
                            min="1"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                    <div>
                        <label htmlFor="dataRetentionDays" className="block text-gray-300 text-sm font-bold mb-2">Data Retention (days)</label>
                        <input
                            type="number"
                            id="dataRetentionDays"
                            name="dataRetentionDays"
                            value={formData.dataRetentionDays}
                            onChange={handleChange}
                            min="7"
                            max="365"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                    <div className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            id="loggingEnabled"
                            name="loggingEnabled"
                            checked={formData.loggingEnabled}
                            onChange={handleChange}
                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                        />
                        <label htmlFor="loggingEnabled" className="text-gray-300">Enable Detailed API Logging</label>
                    </div>
                    <div className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            id="publicAccess"
                            name="publicAccess"
                            checked={formData.publicAccess}
                            onChange={handleChange}
                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                        />
                        <label htmlFor="publicAccess" className="text-gray-300">Allow Unauthenticated Access (use with caution)</label>
                    </div>
                </div>
                <div className="flex justify-end pt-4 border-t border-gray-700">
                    <button type="submit" className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded text-white text-sm font-medium transition-colors">
                        Save Environment Settings
                    </button>
                </div>
            </form>
        </Card>
    );
};

// 10. Alert Rules Management
export const AlertRules: React.FC<{ environmentId: string }> = ({ environmentId }) => {
    const [alertRules, setAlertRules] = useState<AlertRule[]>([]); // Using local state for alerts for simplicity
    const [isAlertModalOpen, setAlertModalOpen] = useState(false);
    const [editingAlert, setEditingAlert] = useState<AlertRule | null>(null);

    useEffect(() => {
        // Generate some mock alerts for the current environment
        const mockAlerts: AlertRule[] = [
            { id: generateUUID(), environmentId, name: 'High API Error Rate', metric: 'api_errors', threshold: 5, operator: 'gt', durationMinutes: 5, status: 'Active', channels: ['email', 'slack'], recipients: ['devs@example.com', '#alerts'], createdAt: getRandomDate(new Date(2024, 6, 1), new Date()) },
            { id: generateUUID(), environmentId, name: 'Increased API Latency', metric: 'api_latency', threshold: 300, operator: 'gt', durationMinutes: 10, status: 'Active', channels: ['email'], recipients: ['ops@example.com'], createdAt: getRandomDate(new Date(2024, 6, 1), new Date()) },
            { id: generateUUID(), environmentId, name: 'Webhook Failure Spike', metric: 'webhook_failures', threshold: 10, operator: 'gt', durationMinutes: 15, status: 'Paused', channels: ['slack'], recipients: ['#webhooks-dev'], createdAt: getRandomDate(new Date(2024, 6, 1), new Date()) },
        ].filter(rule => Math.random() > 0.3); // Randomly include some alerts

        setAlertRules(mockAlerts);
    }, [environmentId]);

    const handleSaveAlert = (alert: AlertRule) => {
        if (editingAlert) {
            setAlertRules(prev => prev.map(a => (a.id === alert.id ? alert : a)));
        } else {
            setAlertRules(prev => [...prev, { ...alert, id: generateUUID(), environmentId, createdAt: new Date().toISOString() }]);
        }
        setAlertModalOpen(false);
        setEditingAlert(null);
    };

    const handleDeleteAlert = (id: string) => {
        if (confirm('Are you sure you want to delete this alert rule?')) {
            setAlertRules(prev => prev.filter(alert => alert.id !== id));
        }
    };

    return (
        <Card title="Alert Rules" className="mt-6">
            <div className="flex justify-end mb-4">
                <button
                    onClick={() => { setEditingAlert(null); setAlertModalOpen(true); }}
                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition-colors"
                >
                    + Create New Alert
                </button>
            </div>
            <div className="overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                        <tr>
                            <th scope="col" className="px-6 py-3">Name</th>
                            <th scope="col" className="px-6 py-3">Metric</th>
                            <th scope="col" className="px-6 py-3">Condition</th>
                            <th scope="col" className="px-6 py-3">Status</th>
                            <th scope="col" className="px-6 py-3">Channels</th>
                            <th scope="col" className="px-6 py-3">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {alertRules.length === 0 && (
                            <tr><td colSpan={6} className="px-6 py-4 text-center text-gray-500">No alert rules configured for this environment.</td></tr>
                        )}
                        {alertRules.map(alert => (
                            <tr key={alert.id} className="border-b border-gray-800 hover:bg-gray-800/50 transition-colors">
                                <td className="px-6 py-4 font-medium text-white">{alert.name}</td>
                                <td className="px-6 py-4 text-gray-300">{alert.metric.replace('_', ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</td>
                                <td className="px-6 py-4 text-gray-300">{`Value ${alert.operator === 'gt' ? '>' : alert.operator === 'lt' ? '<' : '='} ${alert.threshold}${alert.metric.includes('error') || alert.metric.includes('failure') ? '%' : (alert.metric.includes('latency') ? 'ms' : '')} for ${alert.durationMinutes} min`}</td>
                                <td className="px-6 py-4"><span className={`px-2 py-1 text-xs rounded-full ${getStatusColor(alert.status)}`}>{alert.status}</span></td>
                                <td className="px-6 py-4 text-gray-300">{alert.channels.join(', ')}</td>
                                <td className="px-6 py-4 flex gap-2">
                                    <button onClick={() => setEditingAlert(alert)} className="text-xs text-yellow-400 hover:underline">Edit</button>
                                    <button onClick={() => handleDeleteAlert(alert.id)} className="text-xs text-red-400 hover:underline">Delete</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {isAlertModalOpen && (
                <AlertRuleForm alertToEdit={editingAlert} onClose={() => { setAlertModalOpen(false); setEditingAlert(null); }} onSave={handleSaveAlert} />
            )}
        </Card>
    );
};

export const AlertRuleForm: React.FC<{ alertToEdit?: AlertRule | null; onClose: () => void; onSave: (alert: AlertRule) => void }> = ({ alertToEdit, onClose, onSave }) => {
    const isEditing = !!alertToEdit;
    const [formData, setFormData] = useState<AlertRule>(
        alertToEdit || {
            id: generateUUID(),
            environmentId: '', // Placeholder
            name: '',
            metric: 'api_errors',
            threshold: 5,
            operator: 'gt',
            durationMinutes: 5,
            status: 'Active',
            channels: ['email'],
            recipients: [],
            createdAt: new Date().toISOString(),
        }
    );

    useEffect(() => {
        if (alertToEdit) setFormData(alertToEdit);
    }, [alertToEdit]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        if (name === 'recipients') {
            setFormData(prev => ({ ...prev, [name]: value.split(',').map(s => s.trim()).filter(Boolean) }));
        } else if (name === 'channels') {
            const channel = value as 'email' | 'slack' | 'webhook';
            setFormData(prev => ({
                ...prev,
                channels: checked ? [...prev.channels, channel] : prev.channels.filter(c => c !== channel),
            }));
        } else {
            setFormData(prev => ({
                ...prev,
                [name]: type === 'checkbox' ? checked : (type === 'number' ? parseInt(value, 10) : value),
            }));
        }
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave(formData);
    };

    const metricOptions = [
        { value: 'api_errors', label: 'API Error Rate (%)' },
        { value: 'api_latency', label: 'API Latency (ms)' },
        { value: 'webhook_failures', label: 'Webhook Failure Rate (%)' },
        { value: 'rate_limit_exceeded', label: 'Rate Limit Exceeded (count)' },
    ];
    const operatorOptions = [{ value: 'gt', label: 'Greater Than (>)', symbol: '>' }, { value: 'lt', label: 'Less Than (<)', symbol: '<' }, { value: 'eq', label: 'Equals (=)', symbol: '=' }];
    const channelOptions = ['email', 'slack', 'webhook'];

    return (
        <Modal isOpen={true} onClose={onClose} title={isEditing ? 'Edit Alert Rule' : 'Create New Alert Rule'} size="md">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="name" className="block text-gray-300 text-sm font-bold mb-2">Alert Name</label>
                    <input
                        type="text"
                        id="name"
                        name="name"
                        value={formData.name}
                        onChange={handleChange}
                        required
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    />
                </div>
                <div>
                    <label htmlFor="metric" className="block text-gray-300 text-sm font-bold mb-2">Monitor Metric</label>
                    <select
                        id="metric"
                        name="metric"
                        value={formData.metric}
                        onChange={handleChange}
                        required
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        {metricOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                    </select>
                </div>
                <div className="grid grid-cols-3 gap-4">
                    <div>
                        <label htmlFor="operator" className="block text-gray-300 text-sm font-bold mb-2">Operator</label>
                        <select
                            id="operator"
                            name="operator"
                            value={formData.operator}
                            onChange={handleChange}
                            required
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        >
                            {operatorOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.symbol}</option>)}
                        </select>
                    </div>
                    <div>
                        <label htmlFor="threshold" className="block text-gray-300 text-sm font-bold mb-2">Threshold</label>
                        <input
                            type="number"
                            id="threshold"
                            name="threshold"
                            value={formData.threshold}
                            onChange={handleChange}
                            required
                            min="0"
                            step={formData.metric.includes('error') || formData.metric.includes('failure') ? "0.1" : "1"}
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                    <div>
                        <label htmlFor="durationMinutes" className="block text-gray-300 text-sm font-bold mb-2">Duration (min)</label>
                        <input
                            type="number"
                            id="durationMinutes"
                            name="durationMinutes"
                            value={formData.durationMinutes}
                            onChange={handleChange}
                            required
                            min="1"
                            max="60"
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                </div>
                <div>
                    <label className="block text-gray-300 text-sm font-bold mb-2">Notification Channels</label>
                    <div className="flex gap-4">
                        {channelOptions.map(channel => (
                            <div key={channel} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={`channel-${channel}`}
                                    name="channels"
                                    value={channel}
                                    checked={formData.channels.includes(channel)}
                                    onChange={e => handleChange({ ...e, target: { ...e.target, name: 'channels', type: 'checkbox', value: channel } as HTMLInputElement })}
                                    className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                />
                                <label htmlFor={`channel-${channel}`} className="ml-2 text-gray-300 text-sm capitalize">{channel}</label>
                            </div>
                        ))}
                    </div>
                </div>
                {formData.channels.length > 0 && (
                    <div>
                        <label htmlFor="recipients" className="block text-gray-300 text-sm font-bold mb-2">Recipients (comma-separated)</label>
                        <input
                            type="text"
                            id="recipients"
                            name="recipients"
                            value={formData.recipients.join(', ')}
                            onChange={handleChange}
                            placeholder="e.g., email@example.com, #slack-channel, https://webhook.site/..."
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                )}
                <div>
                    <label htmlFor="status" className="block text-gray-300 text-sm font-bold mb-2">Status</label>
                    <select
                        id="status"
                        name="status"
                        value={formData.status}
                        onChange={handleChange}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        <option value="Active">Active</option>
                        <option value="Paused">Paused</option>
                    </select>
                </div>
                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                    <button type="button" onClick={onClose} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white text-sm font-medium transition-colors">Cancel</button>
                    <button type="submit" className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white text-sm font-medium transition-colors">
                        {isEditing ? 'Save Changes' : 'Create Alert'}
                    </button>
                </div>
            </form>
        </Modal>
    );
};

// 11. API Request Tester
export const APIRequestTester: React.FC = () => {
    const { selectedEnvironmentId, environments, apiKeys } = useSandbox();
    const [method, setMethod] = useState<'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'>('GET');
    const [path, setPath] = useState('/users/{id}');
    const [requestBody, setRequestBody] = useState('{}');
    const [headers, setHeaders] = useState('{"Content-Type": "application/json"}');
    const [response, setResponse] = useState<string>('');
    const [isLoading, setIsLoading] = useState(false);
    const [statusCode, setStatusCode] = useState<number | null>(null);
    const [responseTime, setResponseTime] = useState<number | null>(null);
    const [error, setError] = useState<string | null>(null);
    const [selectedAPIKeyId, setSelectedAPIKeyId] = useState<string>('');

    const currentEnv = selectedEnvironmentId ? environments.find(env => env.id === selectedEnvironmentId) : null;
    const availableKeys = useMemo(() => apiKeys.filter(key => key.environmentId === selectedEnvironmentId && key.status === 'Active'), [apiKeys, selectedEnvironmentId]);

    useEffect(() => {
        if (availableKeys.length > 0 && !selectedAPIKeyId) {
            setSelectedAPIKeyId(availableKeys[0].id);
        } else if (availableKeys.length === 0) {
            setSelectedAPIKeyId('');
        }
    }, [availableKeys, selectedAPIKeyId]);

    const handleSendRequest = async () => {
        setIsLoading(true);
        setResponse('');
        setStatusCode(null);
        setResponseTime(null);
        setError(null);

        try {
            const startTime = performance.now();
            // Simulate network request
            await new Promise(resolve => setTimeout(resolve, getRandomInt(100, 1500))); // Simulate latency

            const mockEndpoint = MOCK_API_ENDPOINTS.find(ep => ep.path === path);
            if (!mockEndpoint) {
                setStatusCode(404);
                setResponseTime(performance.now() - startTime);
                setResponse(JSON.stringify({ message: 'Mock endpoint not found', details: `Path: ${path}, Method: ${method}` }, null, 2));
                setError('Mock endpoint not found.');
                return;
            }

            if (method !== mockEndpoint.method) {
                setStatusCode(405);
                setResponseTime(performance.now() - startTime);
                setResponse(JSON.stringify({ message: 'Method Not Allowed', details: `Expected ${mockEndpoint.method}, got ${method}` }, null, 2));
                setError('Method Not Allowed.');
                return;
            }

            // Simulate API key validation
            if (mockEndpoint.isAuthenticated && selectedAPIKeyId) {
                const usedKey = apiKeys.find(k => k.id === selectedAPIKeyId);
                if (!usedKey || usedKey.status !== 'Active') {
                    setStatusCode(401);
                    setResponseTime(performance.now() - startTime);
                    setResponse(JSON.stringify({ message: 'Unauthorized', details: 'Invalid or revoked API Key' }, null, 2));
                    setError('Unauthorized: Invalid API Key.');
                    return;
                }
                // Simulate permission check (simplified)
                if (!usedKey.permissions.includes('admin') && ((method === 'POST' || method === 'PUT' || method === 'DELETE' || method === 'PATCH') && !usedKey.permissions.includes('write:data')) || (method === 'GET' && !usedKey.permissions.includes('read:data'))) {
                    setStatusCode(403);
                    setResponseTime(performance.now() - startTime);
                    setResponse(JSON.stringify({ message: 'Forbidden', details: 'API Key does not have required permissions' }, null, 2));
                    setError('Forbidden: Insufficient permissions.');
                    return;
                }
            } else if (mockEndpoint.isAuthenticated && !selectedAPIKeyId) {
                setStatusCode(401);
                setResponseTime(performance.now() - startTime);
                setResponse(JSON.stringify({ message: 'Unauthorized', details: 'API Key required' }, null, 2));
                setError('Unauthorized: API Key required.');
                return;
            }


            // Simulate different responses based on method
            let mockResponse: any = {};
            let mockStatusCode: number = 200;

            if (method === 'GET') {
                if (path.includes('{id}')) { // Specific item
                    mockResponse = { id: 'some-id-123', name: 'Mock Item', status: 'active', data: 'example' };
                } else { // List
                    mockResponse = {
                        items: Array.from({ length: getRandomInt(3, 10) }).map((_, i) => ({
                            id: `item-${i}`,
                            name: `Generated Item ${i + 1}`,
                            value: getRandomFloat(10, 1000)
                        }))
                    };
                }
            } else if (method === 'POST') {
                mockResponse = { message: 'Resource created successfully', id: generateUUID(), status: 'pending' };
                mockStatusCode = 201;
            } else if (method === 'PUT' || method === 'PATCH') {
                mockResponse = { message: 'Resource updated successfully' };
                mockStatusCode = 200;
            } else if (method === 'DELETE') {
                mockResponse = { message: 'Resource deleted successfully' };
                mockStatusCode = 204;
            }

            setStatusCode(mockStatusCode);
            setResponse(JSON.stringify(mockResponse, null, 2));
        } catch (err) {
            setError(`Request failed: ${(err as Error).message}`);
            setStatusCode(500);
            setResponse(JSON.stringify({ error: (err as Error).message }, null, 2));
        } finally {
            setResponseTime(performance.now() - startTime);
            setIsLoading(false);
        }
    };

    return (
        <Card title="API Request Tester" className="mb-6">
            <div className="space-y-6">
                <div>
                    <label className="block text-gray-300 text-sm font-bold mb-2">Target Environment</label>
                    <input
                        type="text"
                        value={currentEnv ? `${currentEnv.name} (${currentEnv.region})` : 'No environment selected'}
                        readOnly
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 cursor-not-allowed"
                        disabled={true}
                    />
                    {!selectedEnvironmentId && <p className="text-sm text-red-400 mt-1">Please select an environment to use the API tester.</p>}
                </div>
                <div className="grid grid-cols-4 gap-4">
                    <div className="col-span-1">
                        <label htmlFor="method" className="block text-gray-300 text-sm font-bold mb-2">Method</label>
                        <select
                            id="method"
                            value={method}
                            onChange={e => setMethod(e.target.value as any)}
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                            disabled={!selectedEnvironmentId}
                        >
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                            <option value="DELETE">DELETE</option>
                            <option value="PATCH">PATCH</option>
                        </select>
                    </div>
                    <div className="col-span-3">
                        <label htmlFor="path" className="block text-gray-300 text-sm font-bold mb-2">Path</label>
                        <select
                            id="path"
                            value={path}
                            onChange={e => setPath(e.target.value)}
                            className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                            disabled={!selectedEnvironmentId}
                        >
                            {MOCK_API_ENDPOINTS.map(ep => (
                                <option key={ep.id} value={ep.path}>{ep.method} {ep.path} - {ep.description}</option>
                            ))}
                        </select>
                    </div>
                </div>
                <div>
                    <label htmlFor="api-key-selector" className="block text-gray-300 text-sm font-bold mb-2">API Key (optional)</label>
                    <select
                        id="api-key-selector"
                        value={selectedAPIKeyId}
                        onChange={e => setSelectedAPIKeyId(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                        disabled={!selectedEnvironmentId || availableKeys.length === 0}
                    >
                        <option value="">No API Key</option>
                        {availableKeys.map(key => (
                            <option key={key.id} value={key.id}>{key.name} ({key.key.slice(0, 10)}...)</option>
                        ))}
                    </select>
                    {!availableKeys.length && selectedEnvironmentId && <p className="text-sm text-yellow-400 mt-1">No active API keys for this environment. Requests might fail if authentication is required.</p>}
                </div>

                <div>
                    <label htmlFor="headers" className="block text-gray-300 text-sm font-bold mb-2">Headers (JSON)</label>
                    <textarea
                        id="headers"
                        value={headers}
                        onChange={e => setHeaders(e.target.value)}
                        rows={3}
                        className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-sm border border-gray-600 focus:border-cyan-500"
                        disabled={!selectedEnvironmentId}
                    />
                </div>
                {(method === 'POST' || method === 'PUT' || method === 'PATCH') && (
                    <div>
                        <label htmlFor="request-body" className="block text-gray-300 text-sm font-bold mb-2">Request Body (JSON)</label>
                        <textarea
                            id="request-body"
                            value={requestBody}
                            onChange={e => setRequestBody(e.target.value)}
                            rows={5}
                            className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-sm border border-gray-600 focus:border-cyan-500"
                            disabled={!selectedEnvironmentId}
                        />
                    </div>
                )}

                <button
                    onClick={handleSendRequest}
                    disabled={isLoading || !selectedEnvironmentId}
                    className="w-full py-2 bg-purple-600 hover:bg-purple-700 rounded disabled:opacity-50 text-white font-medium transition-colors"
                >
                    {isLoading ? 'Sending Request...' : 'Send Request'}
                </button>

                <Card title="API Response" className="mt-4">
                    <div className="flex items-center space-x-4 mb-2">
                        {statusCode && (
                            <span className={`font-semibold text-sm ${statusCode >= 200 && statusCode < 300 ? 'text-green-400' : (statusCode >= 400 && statusCode < 500 ? 'text-yellow-400' : 'text-red-400')}`}>
                                Status: {statusCode}
                            </span>
                        )}
                        {responseTime && (
                            <span className="font-semibold text-sm text-gray-400">
                                Latency: {responseTime.toFixed(2)}ms
                            </span>
                        )}
                        {error && (
                            <span className="font-semibold text-sm text-red-400">
                                Error: {error}
                            </span>
                        )}
                    </div>
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono bg-gray-900/50 p-4 rounded max-h-60 overflow-auto border border-gray-700">
                        {isLoading ? 'Loading response...' : (response || 'No response yet.')}
                    </pre>
                </Card>
            </div>
        </Card>
    );
};

// 12. Code Snippet Generator
export const CodeSnippetGenerator: React.FC = () => {
    const { selectedEnvironmentId, environments } = useSandbox();
    const [selectedLanguage, setSelectedLanguage] = useState<CodeSnippetConfig['language']>('javascript');
    const [selectedEndpoint, setSelectedEndpoint] = useState<APIEndpoint | null>(MOCK_API_ENDPOINTS[0]);
    const [customBody, setCustomBody] = useState('{}');
    const [customQueryParams, setCustomQueryParams] = useState('');
    const [customHeaders, setCustomHeaders] = useState('{"Authorization": "Bearer YOUR_API_KEY"}');
    const [generatedCode, setGeneratedCode] = useState<string>('Select an endpoint and language to generate code.');

    const currentEnv = selectedEnvironmentId ? environments.find(env => env.id === selectedEnvironmentId) : null;
    const baseApiUrl = currentEnv ? `https://${currentEnv.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}.api.example.com` : 'https://your-api-domain.com';

    useEffect(() => {
        if (selectedEndpoint) {
            generateSnippet();
        }
    }, [selectedLanguage, selectedEndpoint, customBody, customQueryParams, customHeaders, baseApiUrl]);

    const generateSnippet = () => {
        if (!selectedEndpoint) {
            setGeneratedCode('Please select an API endpoint.');
            return;
        }

        const url = `${baseApiUrl}${selectedEndpoint.path}`;
        let queryParamsString = '';
        try {
            const parsedQueryParams = customQueryParams.split('&').filter(Boolean).reduce((acc, part) => {
                const [key, value] = part.split('=');
                if (key && value) acc[key] = value;
                return acc;
            }, {} as Record<string, string>);
            if (Object.keys(parsedQueryParams).length > 0) {
                queryParamsString = new URLSearchParams(parsedQueryParams).toString();
            }
        } catch (e) {
            console.warn("Invalid query params format:", e);
        }

        let finalUrl = url;
        if (queryParamsString) {
            finalUrl += `?${queryParamsString}`;
        }

        let snippet = '';
        let bodyObject = {};
        try {
            bodyObject = JSON.parse(customBody);
        } catch (e) {
            // Invalid JSON, will treat as empty object or handle below
        }

        let headersObject = {};
        try {
            headersObject = JSON.parse(customHeaders);
        } catch (e) {
            // Invalid JSON
        }

        switch (selectedLanguage) {
            case 'javascript':
                snippet = `
// JavaScript (Fetch API)
const url = '${finalUrl}';
const options = {
    method: '${selectedEndpoint.method}',
    headers: {
        'Content-Type': 'application/json',
        ...${JSON.stringify(headersObject, null, 2)}
    },
    ${(selectedEndpoint.method !== 'GET' && Object.keys(bodyObject).length > 0) ? `body: JSON.stringify(${JSON.stringify(bodyObject, null, 2)})` : ''}
};

fetch(url, options)
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));
                `.trim();
                break;
            case 'python':
                snippet = `
# Python (requests library)
import requests
import json

url = '${finalUrl}'
headers = {
    'Content-Type': 'application/json',
    ${Object.entries(headersObject).map(([key, value]) => `'${key}': '${value}'`).join(',\n    ')}
}
${(selectedEndpoint.method !== 'GET' && Object.keys(bodyObject).length > 0) ? `payload = ${JSON.stringify(bodyObject, null, 2)}\n` : 'payload = {}'}

response = requests.request(
    '${selectedEndpoint.method}',
    url,
    headers=headers,
    ${(selectedEndpoint.method !== 'GET' && Object.keys(bodyObject).length > 0) ? 'json=payload' : ''}
)

print(response.status_code)
print(json.dumps(response.json(), indent=2))
                `.trim();
                break;
            case 'go':
                snippet = `
// Go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	url := "${finalUrl}"
	method := "${selectedEndpoint.method}"

	// Headers
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("Content-Type", "application/json")
	${Object.entries(headersObject).map(([key, value]) => `req.Header.Set("${key}", "${value}")`).join('\n\t')}

	// Body
	${(selectedEndpoint.method !== 'GET' && Object.keys(bodyObject).length > 0) ? `
	payload := map[string]interface{}${JSON.stringify(bodyObject, null, 2)}
	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		log.Fatal(err)
	}
	req.Body = ioutil.NopCloser(bytes.NewReader(jsonPayload))
	` : ''}


	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Status Code:", resp.StatusCode)
	fmt.Println("Response Body:", string(body))
}
                `.trim();
                break;
            case 'curl':
                let curlBody = '';
                if (selectedEndpoint.method !== 'GET' && Object.keys(bodyObject).length > 0) {
                    curlBody = `-d '${JSON.stringify(bodyObject)}'`;
                }
                const curlHeaders = Object.entries(headersObject).map(([key, value]) => `-H '${key}: ${value}'`).join(' ');
                snippet = `
curl -X ${selectedEndpoint.method} \\
  ${curlHeaders} \\
  ${curlBody} \\
  '${finalUrl}'
                `.trim();
                break;
            default:
                snippet = `Generation not supported for ${selectedLanguage}`;
                break;
        }
        setGeneratedCode(snippet);
    };

    return (
        <Card title="Code Snippet Generator" className="mb-6">
            <div className="space-y-6">
                <div>
                    <label className="block text-gray-300 text-sm font-bold mb-2">Target Environment</label>
                    <input
                        type="text"
                        value={currentEnv ? `${currentEnv.name} (${currentEnv.region})` : 'No environment selected'}
                        readOnly
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 cursor-not-allowed"
                        disabled={true}
                    />
                    {!selectedEnvironmentId && <p className="text-sm text-yellow-400 mt-1">Select an environment to get a more accurate base URL.</p>}
                </div>
                <div>
                    <label htmlFor="endpoint-select" className="block text-gray-300 text-sm font-bold mb-2">API Endpoint</label>
                    <select
                        id="endpoint-select"
                        value={selectedEndpoint?.id || ''}
                        onChange={e => setSelectedEndpoint(MOCK_API_ENDPOINTS.find(ep => ep.id === e.target.value) || null)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        {MOCK_API_ENDPOINTS.map(ep => (
                            <option key={ep.id} value={ep.id}>{ep.method} {ep.path} - {ep.description}</option>
                        ))}
                    </select>
                </div>
                <div>
                    <label htmlFor="language-select" className="block text-gray-300 text-sm font-bold mb-2">Language</label>
                    <select
                        id="language-select"
                        value={selectedLanguage}
                        onChange={e => setSelectedLanguage(e.target.value as CodeSnippetConfig['language'])}
                        className="w-full bg-gray-700/50 p-2 rounded text-white border border-gray-600 focus:border-cyan-500"
                    >
                        <option value="javascript">JavaScript (Fetch)</option>
                        <option value="python">Python (requests)</option>
                        <option value="go">Go (net/http)</option>
                        <option value="curl">cURL</option>
                    </select>
                </div>

                <div className="flex flex-wrap gap-4">
                    <div className="flex-1 min-w-[45%]">
                        <label htmlFor="custom-headers" className="block text-gray-300 text-sm font-bold mb-2">Custom Headers (JSON)</label>
                        <textarea
                            id="custom-headers"
                            value={customHeaders}
                            onChange={e => setCustomHeaders(e.target.value)}
                            rows={4}
                            className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-sm border border-gray-600 focus:border-cyan-500"
                        />
                        <p className="text-xs text-gray-500 mt-1">Ensure Authorization header if endpoint is secured.</p>
                    </div>
                    <div className="flex-1 min-w-[45%]">
                        <label htmlFor="custom-query-params" className="block text-gray-300 text-sm font-bold mb-2">Query Parameters (URL encoded string or key=value&key2=value2)</label>
                        <textarea
                            id="custom-query-params"
                            value={customQueryParams}
                            onChange={e => setCustomQueryParams(e.target.value)}
                            rows={4}
                            placeholder="e.g., limit=10&offset=0"
                            className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-sm border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                </div>

                {(selectedEndpoint?.method === 'POST' || selectedEndpoint?.method === 'PUT' || selectedEndpoint?.method === 'PATCH') && (
                    <div>
                        <label htmlFor="custom-body" className="block text-gray-300 text-sm font-bold mb-2">Request Body (JSON)</label>
                        <textarea
                            id="custom-body"
                            value={customBody}
                            onChange={e => setCustomBody(e.target.value)}
                            rows={8}
                            className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-sm border border-gray-600 focus:border-cyan-500"
                        />
                    </div>
                )}

                <Card title="Generated Code Snippet" className="mt-4">
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono bg-gray-900/50 p-4 rounded max-h-96 overflow-auto border border-gray-700">
                        {generatedCode}
                    </pre>
                </Card>
            </div>
        </Card>
    );
};

// 13. Sandbox Overview Header (Extracted from original)
export const SandboxHeader: React.FC<{ onOpenDataGen: () => void }> = ({ onOpenDataGen }) => {
    const { environments } = useSandbox();
    const activeEnvironments = environments.filter(env => env.status === 'Active').length;

    // Simulate metrics based on total environments and mock data
    const totalApiCalls = MOCK_ENVIRONMENTS.length * getRandomInt(100000, 500000); // More realistic range
    const avgResponseTime = getRandomFloat(30, 80);
    const errorRate = getRandomFloat(0.005, 0.05);

    return (
        <>
            <div className="flex justify-between items-center mb-6">
                <h2 className="text-3xl font-bold text-white tracking-wider">Developer Sandbox</h2>
                <button onClick={onOpenDataGen} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm font-medium transition-colors">
                    AI Test Data Generator
                </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
                <Card className="text-center">
                    <p className="text-3xl font-bold text-white">{activeEnvironments}</p>
                    <p className="text-sm text-gray-400 mt-1">Active Environments</p>
                </Card>
                <Card className="text-center">
                    <p className="text-3xl font-bold text-white">{(totalApiCalls / 1_000_000).toFixed(1)}M</p>
                    <p className="text-sm text-gray-400 mt-1">API Calls (24h)</p>
                </Card>
                <Card className="text-center">
                    <p className="text-3xl font-bold text-white">{avgResponseTime.toFixed(0)}ms</p>
                    <p className="text-sm text-gray-400 mt-1">Avg. Response Time</p>
                </Card>
                <Card className="text-center">
                    <p className="text-3xl font-bold text-white">{errorRate.toFixed(2)}%</p>
                    <p className="text-sm text-gray-400 mt-1">Error Rate</p>
                </Card>
            </div>
        </>
    );
};


// --- Main Sandbox View Component ---

const SandboxView: React.FC = () => {
    const { selectedEnvironmentId, setSelectedEnvironmentId } = useSandbox();
    const { environments } = useSandbox();

    const [isDataGenOpen, setDataGenOpen] = useState(false);
    const [isCreateEnvModalOpen, setCreateEnvModalOpen] = useState(false);
    const [editingEnvironment, setEditingEnvironment] = useState<SandboxEnvironment | null>(null);

    const handleSelectEnvironment = (id: string) => {
        setSelectedEnvironmentId(id);
    };

    const handleBackToEnvironments = () => {
        setSelectedEnvironmentId(null);
    };

    const handleOpenCreateEnv = () => {
        setEditingEnvironment(null);
        setCreateEnvModalOpen(true);
    };

    const handleOpenEditEnv = (env: SandboxEnvironment) => {
        setEditingEnvironment(env);
        setCreateEnvModalOpen(true);
    };

    const currentEnvironment = useMemo(() => {
        return environments.find(env => env.id === selectedEnvironmentId);
    }, [selectedEnvironmentId, environments]);

    if (selectedEnvironmentId && currentEnvironment) {
        return (
            <div className="space-y-6">
                <div className="flex items-center justify-between pb-4 border-b border-gray-700 mb-6">
                    <button onClick={handleBackToEnvironments} className="text-cyan-400 hover:text-cyan-300 flex items-center space-x-2">
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                        <span className="text-sm font-medium">Back to Environments</span>
                    </button>
                    <h2 className="text-3xl font-bold text-white tracking-wider">{currentEnvironment.name}</h2>
                    <div className="w-fit"></div> {/* Spacer to balance flex */}
                </div>
                <EnvironmentDetail environment={currentEnvironment} onClose={handleBackToEnvironments} />
                <APIRequestTester />
                <CodeSnippetGenerator />
            </div>
        );
    }

    return (
        <>
            <div className="space-y-6">
                <SandboxHeader onOpenDataGen={() => setDataGenOpen(true)} />
                <EnvironmentsTable
                    onSelectEnv={handleSelectEnvironment}
                    onCreateEnv={handleOpenCreateEnv}
                    onEditEnv={handleOpenEditEnv}
                    onDeleteEnv={() => { /* Handled by EnvironmentDetail now, or implement confirm here */ }}
                />
            </div>
            {isDataGenOpen && <AIDataGeneratorModal isOpen={isDataGenOpen} onClose={() => setDataGenOpen(false)} />}
            {isCreateEnvModalOpen && <EnvironmentForm environment={editingEnvironment} onClose={() => setCreateEnvModalOpen(false)} />}
        </>
    );
};

// Wrap the main SandboxView with the provider
const WrappedSandboxView: React.FC = () => (
    <SandboxProvider>
        <SandboxView />
    </SandboxProvider>
);

export default WrappedSandboxView;

--- FILE: SdkDownloadsView.tsx ---

import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";

// --- Existing Interfaces and Mock Data (start) ---
interface Sdk {
    id: string;
    language: string;
    version: string;
    docsUrl: string;
    description: string;
    platform: 'frontend' | 'backend' | 'mobile' | 'universal';
    dependencies: string[];
    lastUpdated: string;
    avgDownloadTimeMs: number;
    maintainer: string;
    license: 'MIT' | 'Apache 2.0' | 'GPL 3.0' | 'Proprietary';
    stars: number;
    forks: number;
    issues: number;
    contributors: string[];
    releaseNotesUrl: string;
    setupGuideUrl: string;
    installationCmd: string;
    packageName: string;
    usageExamples: { title: string; snippet: string; }[];
    supportedFrameworks: string[];
}

const MOCK_SDKS: Sdk[] = [
    {
        id: 'ts',
        language: 'TypeScript',
        version: '3.5.1',
        docsUrl: '/docs/ts',
        description: 'The official TypeScript SDK for integrating with DemoBank APIs.',
        platform: 'universal',
        dependencies: ['axios', 'rxjs'],
        lastUpdated: '2023-11-15',
        avgDownloadTimeMs: 1200,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 1234,
        forks: 567,
        issues: 23,
        contributors: ['alice', 'bob', 'charlie'],
        releaseNotesUrl: '/release-notes/ts-3.5.1',
        setupGuideUrl: '/guides/ts-setup',
        installationCmd: 'npm install @demobank/ts-sdk',
        packageName: '@demobank/ts-sdk',
        usageExamples: [
            { title: 'Create Payment', snippet: `import { PaymentService } from '@demobank/ts-sdk';\nconst service = new PaymentService(apiKey);\nawait service.createPayment({ amount: 100, currency: 'USD' });` },
            { title: 'Fetch Account', snippet: `import { AccountService } from '@demobank/ts-sdk';\nconst service = new AccountService(apiKey);\nawait service.getAccount('acc_123');` },
        ],
        supportedFrameworks: ['Node.js', 'React', 'Angular', 'Vue'],
    },
    {
        id: 'py',
        language: 'Python',
        version: '2.8.0',
        docsUrl: '/docs/py',
        description: 'A comprehensive Python SDK for backend and data processing tasks.',
        platform: 'backend',
        dependencies: ['requests', 'dataclasses_json'],
        lastUpdated: '2023-11-10',
        avgDownloadTimeMs: 900,
        maintainer: 'DemoBank Dev Team',
        license: 'Apache 2.0',
        stars: 2100,
        forks: 890,
        issues: 15,
        contributors: ['diana', 'eve'],
        releaseNotesUrl: '/release-notes/py-2.8.0',
        setupGuideUrl: '/guides/py-setup',
        installationCmd: 'pip install demobank-python-sdk',
        packageName: 'demobank-python-sdk',
        usageExamples: [
            { title: 'Create Customer', snippet: `from demobank import CustomerService\nservice = CustomerService(api_key)\nservice.create_customer(name="John Doe")` },
            { title: 'List Transactions', snippet: `from demobank import TransactionService\nservice = TransactionService(api_key)\ntransactions = service.list_transactions(limit=10)` },
        ],
        supportedFrameworks: ['Django', 'Flask', 'FastAPI'],
    },
    {
        id: 'go',
        language: 'Go',
        version: '1.12.3',
        docsUrl: '/docs/go',
        description: 'High-performance Go SDK for microservices and critical backend systems.',
        platform: 'backend',
        dependencies: ['go-resty/resty', 'jsoniter'],
        lastUpdated: '2023-10-28',
        avgDownloadTimeMs: 700,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 980,
        forks: 340,
        issues: 8,
        contributors: ['frank', 'grace'],
        releaseNotesUrl: '/release-notes/go-1.12.3',
        setupGuideUrl: '/guides/go-setup',
        installationCmd: 'go get github.com/demobank/go-sdk',
        packageName: 'github.com/demobank/go-sdk',
        usageExamples: [
            { title: 'Initiate Transfer', snippet: `package main\nimport "github.com/demobank/go-sdk"\nfunc main() {\n  client := demobank.NewClient("YOUR_API_KEY")\n  client.Transfers.Create(transferRequest)\n}` },
            { title: 'Get Balance', snippet: `package main\nimport "github.com/demobank/go-sdk"\nfunc main() {\n  client := demobank.NewClient("YOUR_API_KEY")\n  balance, _ := client.Accounts.GetBalance("acc_abc")\n}` },
        ],
        supportedFrameworks: ['Gin', 'Echo', 'Gorilla/Mux'],
    },
    {
        id: 'rb',
        language: 'Ruby',
        version: '2.2.0',
        docsUrl: '/docs/rb',
        description: 'Ruby SDK for web applications built with Rails or Sinatra.',
        platform: 'backend',
        dependencies: ['httparty', 'json'],
        lastUpdated: '2023-09-20',
        avgDownloadTimeMs: 1100,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 750,
        forks: 210,
        issues: 12,
        contributors: ['heidi', 'ivan'],
        releaseNotesUrl: '/release-notes/rb-2.2.0',
        setupGuideUrl: '/guides/rb-setup',
        installationCmd: 'gem install demobank-ruby',
        packageName: 'demobank-ruby',
        usageExamples: [
            { title: 'Refund Transaction', snippet: `require 'demobank'\nclient = Demobank::Client.new(api_key: 'YOUR_API_KEY')\nclient.transactions.refund(transaction_id: 'txn_xyz')` },
            { title: 'Verify Webhook', snippet: `require 'demobank'\nverified = Demobank::Webhook.verify(payload: body, signature: headers['Demobank-Signature'])` },
        ],
        supportedFrameworks: ['Rails', 'Sinatra'],
    },
    {
        id: 'java',
        language: 'Java',
        version: '1.0.0',
        docsUrl: '/docs/java',
        description: 'Enterprise-grade Java SDK for robust backend services.',
        platform: 'backend',
        dependencies: ['okhttp', 'jackson'],
        lastUpdated: '2023-11-20',
        avgDownloadTimeMs: 1500,
        maintainer: 'DemoBank Dev Team',
        license: 'Apache 2.0',
        stars: 1500,
        forks: 600,
        issues: 10,
        contributors: ['john', 'doe'],
        releaseNotesUrl: '/release-notes/java-1.0.0',
        setupGuideUrl: '/guides/java-setup',
        installationCmd: 'Maven: <dependency><groupId>com.demobank</groupId><artifactId>demobank-java-sdk</artifactId><version>1.0.0</version></dependency>',
        packageName: 'demobank-java-sdk',
        usageExamples: [
            { title: 'Create Customer', snippet: `import com.demobank.client.DemobankClient;\nDemobankClient client = new DemobankClient("YOUR_API_KEY");\nclient.customers().create(new CustomerCreateRequest("John Doe"));` },
            { title: 'Process Payment', snippet: `import com.demobank.client.DemobankClient;\nDemobankClient client = new DemobankClient("YOUR_API_KEY");\nclient.payments().process(new PaymentProcessRequest(100.0, "USD"));` },
        ],
        supportedFrameworks: ['Spring Boot', 'Quarkus', 'Micronaut'],
    },
    {
        id: 'csharp',
        language: 'C#',
        version: '4.0.0',
        docsUrl: '/docs/csharp',
        description: '.NET SDK for building scalable applications with C#.',
        platform: 'backend',
        dependencies: ['Newtonsoft.Json', 'Microsoft.Net.Http'],
        lastUpdated: '2023-11-01',
        avgDownloadTimeMs: 1300,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 800,
        forks: 300,
        issues: 7,
        contributors: ['susan', 'mike'],
        releaseNotesUrl: '/release-notes/csharp-4.0.0',
        setupGuideUrl: '/guides/csharp-setup',
        installationCmd: 'dotnet add package Demobank.Sdk',
        packageName: 'Demobank.Sdk',
        usageExamples: [
            { title: 'Create Invoice', snippet: `using Demobank.Sdk;\nvar client = new DemobankClient("YOUR_API_KEY");\nawait client.Invoices.CreateAsync(new InvoiceCreateModel { Amount = 50.0m });` },
            { title: 'Get Transaction History', snippet: `using Demobank.Sdk;\nvar client = new DemobankClient("YOUR_API_KEY");\nvar history = await client.Transactions.GetHistoryAsync();` },
        ],
        supportedFrameworks: ['.NET Core', 'ASP.NET'],
    },
    {
        id: 'php',
        language: 'PHP',
        version: '1.5.0',
        docsUrl: '/docs/php',
        description: 'A robust PHP SDK for integrating with DemoBank services.',
        platform: 'backend',
        dependencies: ['guzzlehttp/guzzle'],
        lastUpdated: '2023-10-10',
        avgDownloadTimeMs: 1000,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 600,
        forks: 250,
        issues: 5,
        contributors: ['pete', 'lisa'],
        releaseNotesUrl: '/release-notes/php-1.5.0',
        setupGuideUrl: '/guides/php-setup',
        installationCmd: 'composer require demobank/php-sdk',
        packageName: 'demobank/php-sdk',
        usageExamples: [
            { title: 'Perform Checkout', snippet: `use Demobank\\Sdk\\Client;\n$client = new Client('YOUR_API_KEY');\n$checkout = $client->checkout->create(['amount' => 200]);` },
            { title: 'Retrieve Webhook Event', snippet: `use Demobank\\Sdk\\Webhook;\n$event = Webhook::constructEvent($payload, $signature);` },
        ],
        supportedFrameworks: ['Laravel', 'Symfony', 'WordPress'],
    },
    {
        id: 'swift',
        language: 'Swift',
        version: '2.0.0',
        docsUrl: '/docs/swift',
        description: 'Native iOS SDK for building DemoBank integrations on Apple platforms.',
        platform: 'mobile',
        dependencies: [], // Native usually means fewer external dependencies for core SDK functionality
        lastUpdated: '2023-11-25',
        avgDownloadTimeMs: 1800,
        maintainer: 'DemoBank Mobile Team',
        license: 'Proprietary',
        stars: 400,
        forks: 100,
        issues: 3,
        contributors: ['emma', 'liam'],
        releaseNotesUrl: '/release-notes/swift-2.0.0',
        setupGuideUrl: '/guides/swift-setup',
        installationCmd: 'Podfile: pod \'DemobankSwiftSDK\'',
        packageName: 'DemobankSwiftSDK',
        usageExamples: [
            { title: 'Initialize SDK', snippet: `import DemobankSwiftSDK\nDemobankClient.shared.configure(apiKey: "YOUR_API_KEY")` },
            { title: 'Make Payment', snippet: `DemobankClient.shared.payments.create(amount: 50.0, currency: "USD") { result in ... }` },
        ],
        supportedFrameworks: ['iOS', 'macOS'],
    },
    {
        id: 'kotlin',
        language: 'Kotlin',
        version: '1.2.0',
        docsUrl: '/docs/kotlin',
        description: 'Native Android SDK for integrating DemoBank services into Kotlin/Java apps.',
        platform: 'mobile',
        dependencies: ['com.squareup.okhttp3:okhttp', 'com.google.code.gson:gson'],
        lastUpdated: '2023-11-22',
        avgDownloadTimeMs: 1700,
        maintainer: 'DemoBank Mobile Team',
        license: 'Apache 2.0',
        stars: 350,
        forks: 90,
        issues: 4,
        contributors: ['olivia', 'noah'],
        releaseNotesUrl: '/release-notes/kotlin-1.2.0',
        setupGuideUrl: '/guides/kotlin-setup',
        installationCmd: 'Gradle: implementation \'com.demobank:android-sdk:1.2.0\'',
        packageName: 'com.demobank:android-sdk',
        usageExamples: [
            { title: 'Configure SDK', snippet: `import com.demobank.android.DemobankSDK\nDemobankSDK.initialize(applicationContext, "YOUR_API_KEY")` },
            { title: 'Process Transaction', snippet: `DemobankSDK.transactionService.process(TransactionRequest(100.0, "USD")) { result -> ... }` },
        ],
        supportedFrameworks: ['Android'],
    },
    {
        id: 'node',
        language: 'Node.js',
        version: '4.1.0',
        docsUrl: '/docs/node',
        description: 'Official Node.js SDK for server-side JavaScript applications.',
        platform: 'backend',
        dependencies: ['axios', 'dotenv'],
        lastUpdated: '2023-11-18',
        avgDownloadTimeMs: 1100,
        maintainer: 'DemoBank Dev Team',
        license: 'MIT',
        stars: 1800,
        forks: 700,
        issues: 20,
        contributors: ['sam', 'taylor'],
        releaseNotesUrl: '/release-notes/node-4.1.0',
        setupGuideUrl: '/guides/node-setup',
        installationCmd: 'npm install @demobank/node-sdk',
        packageName: '@demobank/node-sdk',
        usageExamples: [
            { title: 'Create Charge', snippet: `const { Demobank } = require('@demobank/node-sdk');\nconst demobank = new Demobank('YOUR_API_KEY');\nawait demobank.charges.create({ amount: 2000, currency: 'usd' });` },
            { title: 'Retrieve Customer', snippet: `const { Demobank } = require('@demobank/node-sdk');\nconst demobank = new Demobank('YOUR_API_KEY');\nawait demobank.customers.retrieve('cus_abc');` },
        ],
        supportedFrameworks: ['Express', 'NestJS', 'Koa'],
    },
    {
        id: 'rust',
        language: 'Rust',
        version: '0.9.0',
        docsUrl: '/docs/rust',
        description: 'Experimental Rust SDK for high-performance and safe integrations.',
        platform: 'backend',
        dependencies: ['reqwest', 'serde', 'tokio'],
        lastUpdated: '2023-11-05',
        avgDownloadTimeMs: 1400,
        maintainer: 'DemoBank Labs',
        license: 'MIT',
        stars: 250,
        forks: 80,
        issues: 6,
        contributors: ['zoe', 'xander'],
        releaseNotesUrl: '/release-notes/rust-0.9.0',
        setupGuideUrl: '/guides/rust-setup',
        installationCmd: 'Cargo.toml: demobank_sdk = "0.9.0"',
        packageName: 'demobank_sdk',
        usageExamples: [
            { title: 'Initialize Client', snippet: `use demobank_sdk::Client;\nlet client = Client::new("YOUR_API_KEY");` },
            { title: 'Fetch Product', snippet: `let product = client.products().get("prod_123").await?;` },
        ],
        supportedFrameworks: ['Actix-web', 'Rocket'],
    },
    {
        id: 'dart',
        language: 'Dart',
        version: '1.1.0',
        docsUrl: '/docs/dart',
        description: 'Flutter-compatible Dart SDK for cross-platform mobile and web applications.',
        platform: 'universal',
        dependencies: ['http', 'json_annotation'],
        lastUpdated: '2023-10-15',
        avgDownloadTimeMs: 1600,
        maintainer: 'DemoBank Mobile Team',
        license: 'MIT',
        stars: 300,
        forks: 70,
        issues: 2,
        contributors: ['yara', 'victor'],
        releaseNotesUrl: '/release-notes/dart-1.1.0',
        setupGuideUrl: '/guides/dart-setup',
        installationCmd: 'pubspec.yaml: demobank_sdk: ^1.1.0',
        packageName: 'demobank_sdk',
        usageExamples: [
            { title: 'Create Order', snippet: `import 'package:demobank_sdk/demobank_sdk.dart';\nfinal client = DemobankClient('YOUR_API_KEY');\nawait client.orders.create(OrderRequest(amount: 150.0, currency: 'EUR'));` },
            { title: 'List Accounts', snippet: `final accounts = await client.accounts.list();` },
        ],
        supportedFrameworks: ['Flutter', 'AngularDart'],
    }
];
// --- Existing Interfaces and Mock Data (end) ---

// --- NEW GLOBAL UTILITIES AND CONSTANTS (start) ---
/**
 * @typedef {Object} ApiResponse
 * @property {boolean} success - Indicates if the API call was successful.
 * @property {string} message - A human-readable message about the operation.
 * @property {any} data - The data returned by the API, if successful.
 * @property {string} [errorCode] - An error code, if the call failed.
 */
export interface ApiResponse<T> {
    success: boolean;
    message: string;
    data: T | null;
    errorCode?: string;
}

/**
 * Custom hook for debouncing a value.
 * @template T
 * @param {T} value - The value to debounce.
 * @param {number} delay - The debounce delay in milliseconds.
 * @returns {T} The debounced value.
 */
export const useDebounce = <T>(value: T, delay: number): T => {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
};

/**
 * Global application constants.
 */
export const APP_CONSTANTS = {
    DEFAULT_API_KEY: 'sk-demobank-mock-key-12345',
    AI_MODEL: 'gemini-pro-1.5', // Upgraded AI model for more complex tasks
    DEFAULT_PROMPT_TEMPLATES: [
        'create a new payment order for $100',
        'refund transaction TXN_ABC_XYZ',
        'fetch customer details for user ID 123',
        'list all recent invoices',
        'update webhook endpoint URL',
        'verify a webhook signature',
        'capture a pre-authorized payment',
        'generate a report for last month\'s transactions',
        'create a subscription for a premium plan',
        'cancel subscription SUB_ID_987'
    ],
    MAX_PROMPT_HISTORY: 20,
    MAX_CODE_SNIPPET_LENGTH: 5000,
    SUPPORTED_AI_LANGUAGES: ['TypeScript', 'Python', 'Go', 'Ruby', 'Java', 'C#', 'PHP', 'Node.js', 'Rust', 'Dart'],
    SDK_PLATFORMS: ['frontend', 'backend', 'mobile', 'universal'],
    SDK_LICENSES: ['MIT', 'Apache 2.0', 'GPL 3.0', 'Proprietary'],
    DEFAULT_THEME: 'dark', // Example theme
};

/**
 * A mock API client for SDK-related operations.
 * Simulates network delays.
 */
export const mockApiClient = {
    /**
     * Fetches a list of all available SDKs.
     * @returns {Promise<ApiResponse<Sdk[]>>}
     */
    fetchSdks: async (): Promise<ApiResponse<Sdk[]>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({
                    success: true,
                    message: 'Successfully fetched SDKs.',
                    data: MOCK_SDKS,
                });
            }, 500);
        });
    },

    /**
     * Fetches details for a specific SDK by ID.
     * @param {string} sdkId - The ID of the SDK.
     * @returns {Promise<ApiResponse<Sdk | null>>}
     */
    fetchSdkDetails: async (sdkId: string): Promise<ApiResponse<Sdk | null>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                const sdk = MOCK_SDKS.find(s => s.id === sdkId);
                if (sdk) {
                    resolve({
                        success: true,
                        message: `Successfully fetched SDK ${sdkId}.`,
                        data: sdk,
                    });
                } else {
                    resolve({
                        success: false,
                        message: `SDK ${sdkId} not found.`,
                        data: null,
                        errorCode: 'SDK_NOT_FOUND',
                    });
                }
            }, 300);
        });
    },

    /**
     * Simulates downloading an SDK.
     * @param {string} sdkId - The ID of the SDK to download.
     * @returns {Promise<ApiResponse<any>>}
     */
    downloadSdk: async (sdkId: string): Promise<ApiResponse<any>> => {
        return new Promise(resolve => {
            const sdk = MOCK_SDKS.find(s => s.id === sdkId);
            if (!sdk) {
                resolve({ success: false, message: `SDK ${sdkId} not found.`, data: null, errorCode: 'SDK_NOT_FOUND' });
                return;
            }
            setTimeout(() => {
                // Simulate download process
                console.log(`Downloading SDK: ${sdk.language} v${sdk.version}...`);
                resolve({
                    success: true,
                    message: `Successfully initiated download for ${sdk.language} SDK.`,
                    data: { sdkId, downloadUrl: `/cdn/sdk/${sdkId}-${sdk.version}.zip` }
                });
            }, sdk.avgDownloadTimeMs || 1000); // Use avgDownloadTimeMs or default
        });
    },

    /**
     * Submits a support ticket.
     * @param {object} ticketDetails - Details for the support ticket.
     * @returns {Promise<ApiResponse<any>>}
     */
    submitSupportTicket: async (ticketDetails: { subject: string; message: string; sdkId?: string }): Promise<ApiResponse<any>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                console.log('Support ticket submitted:', ticketDetails);
                resolve({
                    success: true,
                    message: 'Your support ticket has been submitted successfully. We will get back to you shortly.',
                    data: { ticketId: `TICKET_${Date.now()}` }
                });
            }, 1500);
        });
    },

    /**
     * Fetches mock API endpoint details for exploration.
     * @returns {Promise<ApiResponse<ApiEndpoint[]>>}
     */
    fetchApiEndpoints: async (): Promise<ApiResponse<ApiEndpoint[]>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({
                    success: true,
                    message: 'Successfully fetched API endpoints.',
                    data: MOCK_API_ENDPOINTS
                });
            }, 400);
        });
    },

    /**
     * Executes a mock API request.
     * @param {ApiRequestPayload} request - The API request payload.
     * @returns {Promise<ApiResponse<any>>}
     */
    executeApiRequest: async (request: ApiRequestPayload): Promise<ApiResponse<any>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                console.log('Executing mock API request:', request);
                // Simulate various responses
                if (request.url.includes('/error')) {
                    resolve({ success: false, message: 'Simulated API error.', data: null, errorCode: 'MOCK_API_ERROR' });
                } else if (request.url.includes('/payments') && request.method === 'POST') {
                    resolve({
                        success: true,
                        message: 'Payment created successfully (mock).',
                        data: {
                            id: `pay_${Date.now()}`,
                            amount: JSON.parse(request.body || '{}').amount || 100,
                            currency: JSON.parse(request.body || '{}').currency || 'USD',
                            status: 'succeeded',
                            createdAt: new Date().toISOString()
                        }
                    });
                } else if (request.url.includes('/customers')) {
                    resolve({
                        success: true,
                        message: 'Customer details (mock).',
                        data: {
                            id: `cus_${Date.now()}`,
                            name: 'Mock Customer',
                            email: 'mock@example.com'
                        }
                    });
                } else {
                    resolve({
                        success: true,
                        message: 'Generic mock API response.',
                        data: {
                            status: 'success',
                            requestedUrl: request.url,
                            method: request.method,
                            params: request.params,
                            body: request.body ? JSON.parse(request.body) : null,
                            timestamp: new Date().toISOString()
                        }
                    });
                }
            }, 800);
        });
    },

    /**
     * Fetches mock documentation content.
     * @param {string} path - The documentation path.
     * @returns {Promise<ApiResponse<string>>}
     */
    fetchDocumentationContent: async (path: string): Promise<ApiResponse<string>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                const contentMap: { [key: string]: string } = {
                    '/docs/ts': `# TypeScript SDK Documentation\n\nThis is the *full* documentation for the TypeScript SDK.\n\n## Installation\n\n\`\`\`bash\nnpm install @demobank/ts-sdk\n\`\`\`\n\n## Usage\n\n\`\`\`typescript\nimport { DemobankClient } from '@demobank/ts-sdk';\nconst client = new DemobankClient({ apiKey: 'YOUR_API_KEY' });\nconst payment = await client.payments.create({ amount: 100, currency: 'USD' });\nconsole.log(payment);\n\`\`\`\n\n### Payments\n\nMethods for handling payment operations.\n\n### Accounts\n\nManage customer accounts.\n\n### Webhooks\n\nSetup and verification.\n\n## Advanced Topics\n\nLearn about custom configurations, error handling, and security best practices.\n\n`,
                    '/docs/py': `# Python SDK Documentation\n\nWelcome to the Python SDK docs!.\n\n## Getting Started\n\n\`\`\`bash\npip install demobank-python-sdk\n\`\`\`\n\n## Examples\n\n\`\`\`python\nfrom demobank import Client\nclient = Client(api_key='YOUR_API_KEY')\ncustomer = client.customers.create(name='Jane Doe')\nprint(customer)\n\`\`\`\n`,
                    '/docs/go': `# Go SDK Documentation\n\nComprehensive guide for Go developers.\n\n## Quick Start\n\n\`\`\`go\npackage main\nimport "github.com/demobank/go-sdk"\nfunc main() {\n  client := demobank.NewClient("YOUR_API_KEY")\n  // ... further usage\n}\n\`\`\`\n`,
                    '/docs/rb': `# Ruby SDK Documentation\n\nIntegrate DemoBank with your Ruby applications.\n\n## Setup\n\n\`\`\`ruby\ngem install demobank-ruby\n\`\`\`\n`,
                    '/docs/java': `# Java SDK Documentation\n\nDocumentation for the DemoBank Java SDK.\n`,
                    '/docs/csharp': `# C# SDK Documentation\n\nDocumentation for the DemoBank C# (.NET) SDK.\n`,
                    '/docs/php': `# PHP SDK Documentation\n\nDocumentation for the DemoBank PHP SDK.\n`,
                    '/docs/swift': `# Swift SDK Documentation\n\nDocumentation for the DemoBank Swift (iOS) SDK.\n`,
                    '/docs/kotlin': `# Kotlin SDK Documentation\n\nDocumentation for the DemoBank Kotlin (Android) SDK.\n`,
                    '/docs/node': `# Node.js SDK Documentation\n\nDocumentation for the DemoBank Node.js SDK.\n`,
                    '/docs/rust': `# Rust SDK Documentation\n\nDocumentation for the DemoBank Rust SDK.\n`,
                    '/docs/dart': `# Dart SDK Documentation\n\nDocumentation for the DemoBank Dart SDK.\n`,
                    '/docs/introduction': `# Introduction\n\nWelcome to the DemoBank Developer Portal. Here you can find all the resources to integrate with our powerful financial APIs.`,
                    '/docs/authentication': `# Authentication\n\nAll API requests require authentication. We support API Key authentication via ` + "`Authorization: Bearer YOUR_API_KEY`" + ` header.\n\nYour API keys can be managed in the settings section.`,
                    '/docs/webhooks': `# Webhooks\n\nWebhooks allow you to receive real-time notifications for events happening in your DemoBank account.`,
                    '/docs/error_codes': `# Error Codes\n\nList of common error codes and their meanings.`,
                };
                const content = contentMap[path] || `# Documentation Not Found\n\nSorry, the document at \`${path}\` could not be found.`;
                resolve({ success: true, message: 'Content loaded.', data: content });
            }, 600);
        });
    },

    /**
     * Searches documentation.
     * @param {string} query - The search query.
     * @returns {Promise<ApiResponse<DocSearchResult[]>>}
     */
    searchDocumentation: async (query: string): Promise<ApiResponse<DocSearchResult[]>> => {
        return new Promise(resolve => {
            setTimeout(() => {
                const lowerQuery = query.toLowerCase();
                const results = Object.entries(MOCK_DOCS_STRUCTURE)
                    .flatMap(([category, items]) => items.map(item => ({ category, ...item })))
                    .filter(doc =>
                        doc.title.toLowerCase().includes(lowerQuery) ||
                        doc.description.toLowerCase().includes(lowerQuery)
                    )
                    .map(doc => ({
                        title: doc.title,
                        path: doc.path,
                        snippet: doc.description.length > 100 ? doc.description.substring(0, 97) + '...' : doc.description,
                        relevance: 0.8 // Mock relevance
                    }));
                resolve({ success: true, message: `Found ${results.length} results.`, data: results });
            }, 700);
        });
    }
};

/**
 * Utility for rendering Markdown.
 * (Placeholder, would typically be a library like `marked` or `react-markdown`)
 * @param {string} markdown - The markdown string to render.
 * @returns {string} HTML string.
 */
export const renderMarkdownToHtml = (markdown: string): string => {
    // This is a highly simplified mock. In a real app, use a robust markdown parser.
    let html = markdown
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>')
        .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
        .replace(/\*(.*)\*/gim, '<em>$1</em>')
        .replace(/`([^`]+)`/gim, '<code>$1</code>') // Inline code
        .replace(/```([a-zA-Z]*)\n([\s\S]*?)\n```/gim, (match, lang, code) => {
            const escapedCode = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `<pre><code class="language-${lang || 'plaintext'}">${escapedCode}</code></pre>`;
        })
        .replace(/^- (.*$)/gim, '<li>$1</li>')
        .replace(/<li>(.*)<\/li>/gim, '<ul><li>$1</li></ul>')
        .replace(/\n/gim, '<br/>'); // Simple line breaks

    // Clean up extra <br/> inside code blocks (a common issue with simple regex parsers)
    html = html.replace(/<pre><code.*?>(.*?)<\/code><\/pre>/gs, (match, codeContent) => {
        return match.replace(/<br\/>/g, '\n');
    });

    return html;
};

/**
 * Custom hook to manage toast notifications.
 * @returns {object} - Functions for adding, dismissing toasts, and the list of toasts.
 */
export const useToastNotifications = () => {
    const [toasts, setToasts] = useState<{ id: string; message: string; type: 'info' | 'success' | 'warning' | 'error'; duration?: number }[]>([]);

    const addToast = useCallback((message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info', duration: number = 5000) => {
        const id = Date.now().toString();
        setToasts(prev => [...prev, { id, message, type, duration }]);
        if (duration > 0) {
            setTimeout(() => {
                setToasts(prev => prev.filter(toast => toast.id !== id));
            }, duration);
        }
    }, []);

    const dismissToast = useCallback((id: string) => {
        setToasts(prev => prev.filter(toast => toast.id !== id));
    }, []);

    return { toasts, addToast, dismissToast };
};

/**
 * ToastNotification component.
 * @param {object} props - Component props.
 * @param {string} props.id - Unique ID of the toast.
 * @param {string} props.message - The message to display.
 * @param {'info' | 'success' | 'warning' | 'error'} props.type - The type of toast.
 * @param {function(string): void} props.onDismiss - Callback to dismiss the toast.
 */
export const ToastNotification: React.FC<{ id: string; message: string; type: 'info' | 'success' | 'warning' | 'error'; onDismiss: (id: string) => void }> = ({ id, message, type, onDismiss }) => {
    const typeClasses = {
        info: 'bg-blue-600',
        success: 'bg-green-600',
        warning: 'bg-yellow-600',
        error: 'bg-red-600',
    };
    return (
        <div className={`p-4 rounded-lg shadow-lg text-white flex items-center justify-between transition-opacity duration-300 ${typeClasses[type]}`}>
            <span>{message}</span>
            <button onClick={() => onDismiss(id)} className="ml-4 text-white opacity-75 hover:opacity-100">&times;</button>
        </div>
    );
};

/**
 * NotificationStack component to display all active toasts.
 * @param {object} props - Component props.
 * @param {any[]} props.toasts - Array of toast objects.
 * @param {function(string): void} props.onDismiss - Callback to dismiss a toast.
 */
export const NotificationStack: React.FC<{ toasts: any[]; onDismiss: (id: string) => void }> = ({ toasts, onDismiss }) => {
    return (
        <div className="fixed top-4 right-4 z-50 space-y-2 w-72">
            {toasts.map(toast => (
                <ToastNotification key={toast.id} {...toast} onDismiss={onDismiss} />
            ))}
        </div>
    );
};

// --- NEW GLOBAL UTILITIES AND CONSTANTS (end) ---

// --- NEW INTERFACES AND MOCK DATA FOR EXPANSION (start) ---
/**
 * Represents a historical download entry.
 * @interface DownloadHistoryEntry
 * @property {string} sdkId - The ID of the downloaded SDK.
 * @property {string} sdkVersion - The version of the downloaded SDK.
 * @property {string} timestamp - ISO string of when the download occurred.
 * @property {string} downloadUrl - The URL from which it was downloaded.
 * @property {string} os - Operating system of the downloader.
 * @property {string} browser - Browser used for download.
 * @property {string} ipAddress - IP address (mocked/anonymized).
 */
export interface DownloadHistoryEntry {
    sdkId: string;
    sdkVersion: string;
    timestamp: string;
    downloadUrl: string;
    os: string;
    browser: string;
    ipAddress: string;
}

const MOCK_DOWNLOAD_HISTORY: DownloadHistoryEntry[] = [
    { sdkId: 'ts', sdkVersion: '3.5.1', timestamp: '2023-11-20T10:00:00Z', downloadUrl: '/cdn/sdk/ts-3.5.1.zip', os: 'macOS', browser: 'Chrome', ipAddress: '192.168.1.10' },
    { sdkId: 'py', sdkVersion: '2.8.0', timestamp: '2023-11-19T14:30:00Z', downloadUrl: '/cdn/sdk/py-2.8.0.zip', os: 'Windows', browser: 'Edge', ipAddress: '192.168.1.11' },
    { sdkId: 'go', sdkVersion: '1.12.3', timestamp: '2023-11-18T09:15:00Z', downloadUrl: '/cdn/sdk/go-1.12.3.zip', os: 'Linux', browser: 'Firefox', ipAddress: '192.168.1.12' },
    { sdkId: 'ts', sdkVersion: '3.5.1', timestamp: '2023-11-17T11:00:00Z', downloadUrl: '/cdn/sdk/ts-3.5.1.zip', os: 'macOS', browser: 'Safari', ipAddress: '192.168.1.13' },
    { sdkId: 'java', sdkVersion: '1.0.0', timestamp: '2023-11-21T16:00:00Z', downloadUrl: '/cdn/sdk/java-1.0.0.zip', os: 'Windows', browser: 'Chrome', ipAddress: '192.168.1.14' },
    { sdkId: 'csharp', sdkVersion: '4.0.0', timestamp: '2023-11-15T10:00:00Z', downloadUrl: '/cdn/sdk/csharp-4.0.0.zip', os: 'Windows', browser: 'Edge', ipAddress: '192.168.1.15' },
    { sdkId: 'node', sdkVersion: '4.1.0', timestamp: '2023-11-19T11:00:00Z', downloadUrl: '/cdn/sdk/node-4.1.0.zip', os: 'macOS', browser: 'Chrome', ipAddress: '192.168.1.16' },
    { sdkId: 'py', sdkVersion: '2.8.0', timestamp: '2023-11-22T13:00:00Z', downloadUrl: '/cdn/sdk/py-2.8.0.zip', os: 'Linux', browser: 'Chrome', ipAddress: '192.168.1.17' },
    { sdkId: 'swift', sdkVersion: '2.0.0', timestamp: '2023-11-26T08:00:00Z', downloadUrl: '/cdn/sdk/swift-2.0.0.zip', os: 'iOS', browser: 'Safari', ipAddress: '192.168.1.18' },
    { sdkId: 'kotlin', sdkVersion: '1.2.0', timestamp: '2023-11-23T09:00:00Z', downloadUrl: '/cdn/sdk/kotlin-1.2.0.zip', os: 'Android', browser: 'Chrome', ipAddress: '192.168.1.19' },
    { sdkId: 'dart', sdkVersion: '1.1.0', timestamp: '2023-11-16T12:00:00Z', downloadUrl: '/cdn/sdk/dart-1.1.0.zip', os: 'macOS', browser: 'Chrome', ipAddress: '192.168.1.20' },
    { sdkId: 'ts', sdkVersion: '3.5.1', timestamp: '2023-11-28T15:00:00Z', downloadUrl: '/cdn/sdk/ts-3.5.1.zip', os: 'Windows', browser: 'Firefox', ipAddress: '192.168.1.21' },
    { sdkId: 'node', sdkVersion: '4.1.0', timestamp: '2023-11-27T17:00:00Z', downloadUrl: '/cdn/sdk/node-4.1.0.zip', os: 'Linux', browser: 'Edge', ipAddress: '192.168.1.22' },
];

/**
 * Represents a saved AI prompt snippet.
 * @interface SavedPrompt
 * @property {string} id - Unique ID for the prompt.
 * @property {string} prompt - The user's input prompt.
 * @property {string} generatedCode - The code generated by AI.
 * @property {string} sdkId - The ID of the SDK for which code was generated.
 * @property {string} language - The language of the generated code.
 * @property {string} timestamp - ISO string of when it was saved.
 * @property {string[]} tags - Optional tags for organization.
 */
export interface SavedPrompt {
    id: string;
    prompt: string;
    generatedCode: string;
    sdkId: string;
    language: string;
    timestamp: string;
    tags: string[];
}

/**
 * Interface for AI Configuration settings.
 * @interface AiConfig
 * @property {string} model - The AI model to use.
 * @property {number} temperature - Controls randomness (0-1).
 * @property {number} maxTokens - Maximum tokens to generate.
 * @property {string} defaultPersona - Persona for the AI (e.g., 'expert-developer', 'friendly-assistant').
 * @property {boolean} enableContextualLearning - Whether AI should learn from previous generations.
 * @property {string[]} preferredLanguages - List of preferred languages for generation.
}
*/
export interface AiConfig {
    model: string;
    temperature: number;
    maxTokens: number;
    defaultPersona: string;
    enableContextualLearning: boolean;
    preferredLanguages: string[];
}

/**
 * Interface for API endpoint details for the API Explorer.
 * @interface ApiEndpoint
 * @property {string} id - Unique ID.
 * @property {string} path - The API path (e.g., /v1/payments).
 * @property {string} method - HTTP method (GET, POST, PUT, DELETE).
 * @property {string} description - Description of the endpoint.
 * @property {object} requestSchema - JSON schema for the request body/params.
 * @property {object} responseSchema - JSON schema for the response body.
 * @property {string[]} tags - Categorization tags (e.g., 'payments', 'customers').
 * @property {string} exampleRequest - A JSON string for an example request body.
 * @property {string} exampleResponse - A JSON string for an example successful response.
 */
export interface ApiEndpoint {
    id: string;
    path: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    description: string;
    requestSchema?: object;
    responseSchema?: object;
    tags: string[];
    exampleRequest?: string;
    exampleResponse?: string;
    queryParams?: { name: string; type: string; description: string; required?: boolean; }[];
    pathParams?: { name: string; type: string; description: string; }[];
}

const MOCK_API_ENDPOINTS: ApiEndpoint[] = [
    {
        id: 'get-payments', path: '/v1/payments', method: 'GET', description: 'Retrieve a list of all payments.', tags: ['payments', 'read'],
        responseSchema: { type: 'array', items: { $ref: '#/components/schemas/Payment' } },
        queryParams: [{ name: 'limit', type: 'integer', description: 'Number of payments to retrieve.' }, { name: 'status', type: 'string', description: 'Filter by payment status.' }],
        exampleResponse: JSON.stringify([{ id: 'pay_xyz', amount: 100, currency: 'USD', status: 'succeeded' }])
    },
    {
        id: 'create-payment', path: '/v1/payments', method: 'POST', description: 'Create a new payment.', tags: ['payments', 'write'],
        requestSchema: { type: 'object', properties: { amount: { type: 'number' }, currency: { type: 'string' }, customerId: { type: 'string' } } },
        responseSchema: { $ref: '#/components/schemas/Payment' },
        exampleRequest: JSON.stringify({ amount: 1000, currency: 'USD', customerId: 'cus_123' }, null, 2),
        exampleResponse: JSON.stringify({ id: 'pay_abc', amount: 1000, currency: 'USD', status: 'pending' })
    },
    {
        id: 'get-payment-by-id', path: '/v1/payments/{paymentId}', method: 'GET', description: 'Retrieve details for a specific payment.', tags: ['payments', 'read'],
        pathParams: [{ name: 'paymentId', type: 'string', description: 'The ID of the payment.' }],
        responseSchema: { $ref: '#/components/schemas/Payment' },
        exampleResponse: JSON.stringify({ id: 'pay_xyz', amount: 100, currency: 'USD', status: 'succeeded' })
    },
    {
        id: 'refund-payment', path: '/v1/payments/{paymentId}/refund', method: 'POST', description: 'Initiate a refund for a payment.', tags: ['payments', 'write'],
        pathParams: [{ name: 'paymentId', type: 'string', description: 'The ID of the payment to refund.' }],
        requestSchema: { type: 'object', properties: { amount: { type: 'number', description: 'Amount to refund. Optional, refunds full amount if not provided.' } } },
        responseSchema: { $ref: '#/components/schemas/Refund' },
        exampleRequest: JSON.stringify({ amount: 500 }, null, 2),
        exampleResponse: JSON.stringify({ id: 'ref_123', paymentId: 'pay_xyz', amount: 500, status: 'initiated' })
    },
    {
        id: 'list-customers', path: '/v1/customers', method: 'GET', description: 'List all customer accounts.', tags: ['customers', 'read'],
        responseSchema: { type: 'array', items: { $ref: '#/components/schemas/Customer' } },
        exampleResponse: JSON.stringify([{ id: 'cus_1', name: 'Alice', email: 'alice@example.com' }])
    },
    {
        id: 'create-customer', path: '/v1/customers', method: 'POST', description: 'Create a new customer account.', tags: ['customers', 'write'],
        requestSchema: { type: 'object', properties: { name: { type: 'string' }, email: { type: 'string', format: 'email' } } },
        responseSchema: { $ref: '#/components/schemas/Customer' },
        exampleRequest: JSON.stringify({ name: 'Bob Smith', email: 'bob@example.com' }, null, 2),
        exampleResponse: JSON.stringify({ id: 'cus_2', name: 'Bob Smith', email: 'bob@example.com' })
    },
    {
        id: 'update-customer', path: '/v1/customers/{customerId}', method: 'PUT', description: 'Update an existing customer account.', tags: ['customers', 'write'],
        pathParams: [{ name: 'customerId', type: 'string', description: 'The ID of the customer.' }],
        requestSchema: { type: 'object', properties: { name: { type: 'string' }, email: { type: 'string', format: 'email' } } },
        responseSchema: { $ref: '#/components/schemas/Customer' },
        exampleRequest: JSON.stringify({ name: 'Bob Johnson' }, null, 2),
        exampleResponse: JSON.stringify({ id: 'cus_2', name: 'Bob Johnson', email: 'bob@example.com' })
    },
    {
        id: 'delete-customer', path: '/v1/customers/{customerId}', method: 'DELETE', description: 'Delete a customer account.', tags: ['customers', 'write'],
        pathParams: [{ name: 'customerId', type: 'string', description: 'The ID of the customer.' }],
        responseSchema: { type: 'object', properties: { message: { type: 'string' } } },
        exampleResponse: JSON.stringify({ message: 'Customer deleted successfully.' })
    },
    {
        id: 'list-webhooks', path: '/v1/webhooks', method: 'GET', description: 'List all configured webhooks.', tags: ['webhooks', 'read'],
        responseSchema: { type: 'array', items: { $ref: '#/components/schemas/Webhook' } },
        exampleResponse: JSON.stringify([{ id: 'wh_1', url: 'https://example.com/webhook', events: ['payment.succeeded'] }])
    },
    {
        id: 'create-webhook', path: '/v1/webhooks', method: 'POST', description: 'Create a new webhook endpoint.', tags: ['webhooks', 'write'],
        requestSchema: { type: 'object', properties: { url: { type: 'string' }, events: { type: 'array', items: { type: 'string' } } } },
        responseSchema: { $ref: '#/components/schemas/Webhook' },
        exampleRequest: JSON.stringify({ url: 'https://my-app.com/demobank-webhook', events: ['charge.succeeded', 'customer.created'] }, null, 2),
        exampleResponse: JSON.stringify({ id: 'wh_2', url: 'https://my-app.com/demobank-webhook', events: ['charge.succeeded', 'customer.created'], secret: 'whsec_randomstring' })
    },
    {
        id: 'test-endpoint', path: '/v1/test/error', method: 'GET', description: 'Endpoint to simulate an API error.', tags: ['testing'],
        exampleResponse: JSON.stringify({ error: 'This is a simulated error.' })
    }
];

/**
 * Interface for API Request Payload in the Explorer.
 * @interface ApiRequestPayload
 * @property {string} url - The full URL of the request.
 * @property {string} method - HTTP method.
 * @property {object} headers - Request headers.
 * @property {object} [params] - Query parameters.
 * @property {string} [body] - Raw request body (JSON string).
 */
export interface ApiRequestPayload {
    url: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    headers: { [key: string]: string };
    params?: { [key: string]: string };
    body?: string;
}

/**
 * Interface for a documentation node in the sidebar navigation.
 * @interface DocNode
 * @property {string} title - Display title for the document.
 * @property {string} path - The internal path to the document content.
 * @property {string} description - A brief description.
 * @property {DocNode[]} [children] - Nested documentation nodes.
 */
export interface DocNode {
    title: string;
    path: string;
    description: string;
    children?: DocNode[];
}

const MOCK_DOCS_STRUCTURE: { [key: string]: DocNode[] } = {
    'Getting Started': [
        { title: 'Introduction', path: '/docs/introduction', description: 'Welcome to the DemoBank Developer Portal.' },
        { title: 'Authentication', path: '/docs/authentication', description: 'How to authenticate your API requests.' },
        { title: 'Error Codes', path: '/docs/error_codes', description: 'Understanding common API error responses.' },
    ],
    'SDKs': MOCK_SDKS.map(sdk => ({
        title: `${sdk.language} SDK v${sdk.version}`,
        path: sdk.docsUrl,
        description: `Reference documentation for the ${sdk.language} SDK.`,
        children: [
            { title: 'Installation', path: `${sdk.docsUrl}#installation`, description: `How to install the ${sdk.language} SDK.` },
            { title: 'Payments API', path: `${sdk.docsUrl}#payments-api`, description: `Using the ${sdk.language} SDK for payment operations.` },
            { title: 'Customers API', path: `${sdk.docsUrl}#customers-api`, description: `Managing customers with the ${sdk.language} SDK.` },
        ]
    })),
    'API Reference': [
        { title: 'Payments API', path: '/api-ref/payments', description: 'Full API reference for payment related endpoints.' },
        { title: 'Customers API', path: '/api-ref/customers', description: 'Full API reference for customer related endpoints.' },
        { title: 'Webhooks', path: '/docs/webhooks', description: 'Guide to setting up and using webhooks.' },
    ],
    'Guides': [
        { title: 'Quickstart Guide', path: '/guides/quickstart', description: 'Your first API call.' },
        { title: 'Implementing Webhooks', path: '/guides/implementing-webhooks', description: 'Detailed steps for integrating webhooks.' },
        { title: 'Advanced Error Handling', path: '/guides/advanced-errors', description: 'Strategies for robust error management.' },
    ]
};

/**
 * Interface for a documentation search result.
 * @interface DocSearchResult
 * @property {string} title - The title of the document.
 * @property {string} path - The path to the document.
 * @property {string} snippet - A short contextual snippet from the document.
 * @property {number} relevance - A score indicating search relevance.
 */
export interface DocSearchResult {
    title: string;
    path: string;
    snippet: string;
    relevance: number;
}

/**
 * Interface for a community forum thread.
 * @interface ForumThread
 * @property {string} id - Unique ID.
 * @property {string} title - Title of the thread.
 * @property {string} author - Author's username.
 * @property {string} lastActivity - ISO string of last activity.
 * @property {number} replies - Number of replies.
 * @property {string[]} tags - Tags for categorization.
 * @property {string} content - Initial post content.
 * @property {ForumComment[]} comments - List of comments.
 */
export interface ForumThread {
    id: string;
    title: string;
    author: string;
    lastActivity: string;
    replies: number;
    tags: string[];
    content: string;
    comments: ForumComment[];
}

/**
 * Interface for a comment within a forum thread.
 * @interface ForumComment
 * @property {string} id - Unique ID.
 * @property {string} author - Author's username.
 * @property {string} timestamp - ISO string of comment creation.
 * @property {string} content - The comment content.
 */
export interface ForumComment {
    id: string;
    author: string;
    timestamp: string;
    content: string;
}

const MOCK_FORUM_THREADS: ForumThread[] = [
    {
        id: 'ft_1', title: 'Python SDK v2.8.0 not installing on M1 Mac', author: 'devuser1', lastActivity: '2023-11-28T14:30:00Z', replies: 5, tags: ['python', 'installation', 'bug'],
        content: 'I\'m having trouble installing the Python SDK on my M1 Mac. `pip install demobank-python-sdk` throws a compilation error. Any ideas?',
        comments: [
            { id: 'fc_1_1', author: 'helperbot', timestamp: '2023-11-28T14:35:00Z', content: 'Please ensure you have Rosetta 2 installed and are using a compatible Python version (e.g., via `conda` or `pyenv`).' },
            { id: 'fc_1_2', author: 'devuser1', timestamp: '2023-11-28T14:40:00Z', content: 'Ah, I was using the native Python. Switched to `pyenv` with `3.9` and it worked! Thanks!' }
        ]
    },
    {
        id: 'ft_2', title: 'Best practices for handling webhooks in Node.js', author: 'webdev_pro', lastActivity: '2023-11-27T10:00:00Z', replies: 12, tags: ['node.js', 'webhooks', 'best-practices'],
        content: 'Looking for advice on how to securely and reliably handle DemoBank webhooks in a Node.js Express application. What are your recommended patterns?',
        comments: []
    },
    {
        id: 'ft_3', title: 'TypeScript SDK: How to handle concurrent requests?', author: 'ts_master', lastActivity: '2023-11-26T18:00:00Z', replies: 8, tags: ['typescript', 'concurrency', 'performance'],
        content: 'When making many API calls with the TypeScript SDK, I\'m seeing some rate limiting. What\'s the best way to manage concurrency and exponential backoff?',
        comments: []
    },
    {
        id: 'ft_4', title: 'Feature Request: Go SDK support for gRPC', author: 'gopher_dev', lastActivity: '2023-11-25T11:00:00Z', replies: 3, tags: ['go', 'feature-request', 'grpc'],
        content: 'Would love to see gRPC support added to the Go SDK for better performance and type safety in microservice architectures.',
        comments: []
    },
    {
        id: 'ft_5', title: 'Payment processing failed with error code P_007', author: 'newbie_dev', lastActivity: '2023-11-24T09:00:00Z', replies: 2, tags: ['payments', 'error-code', 'support'],
        content: 'My payment processing is failing with error code `P_007`. The docs say "Insufficient Funds". What steps should I take to debug this?',
        comments: []
    },
];

/**
 * Interface for an FAQ item.
 * @interface FaqItem
 * @property {string} id - Unique ID.
 * @property {string} question - The FAQ question.
 * @property {string} answer - The detailed answer.
 * @property {string[]} tags - Tags for filtering.
 */
export interface FaqItem {
    id: string;
    question: string;
    answer: string;
    tags: string[];
}

const MOCK_FAQS: FaqItem[] = [
    {
        id: 'faq_1', question: 'How do I get my API key?', tags: ['authentication', 'setup'],
        answer: 'You can generate and manage your API keys from the Developer Settings page in your dashboard. Remember to keep your keys secure and never expose them in client-side code.'
    },
    {
        id: 'faq_2', question: 'What is the rate limit for API calls?', tags: ['api', 'limits', 'performance'],
        answer: 'Our standard rate limit is 100 requests per second per API key. Higher limits can be requested for enterprise plans. Implement exponential backoff for retries to handle transient errors gracefully.'
    },
    {
        id: 'faq_3', question: 'How do I test webhook endpoints locally?', tags: ['webhooks', 'testing'],
        answer: 'You can use tools like `ngrok` or `localtunnel` to expose your local development server to the internet, allowing DemoBank to send webhook events to it. Alternatively, some SDKs provide local testing utilities.'
    },
    {
        id: 'faq_4', question: 'Which SDK should I use?', tags: ['sdk', 'choosing'],
        answer: 'Choose the SDK that best matches your application\'s primary programming language. We offer SDKs for Python, Node.js, Java, Go, Ruby, C#, and TypeScript for various platforms (backend, frontend, mobile).'
    },
    {
        id: 'faq_5', question: 'Can I contribute to the SDKs?', tags: ['community', 'contributing'],
        answer: 'Absolutely! Most of our SDKs are open-source on GitHub. We welcome contributions, bug reports, and feature requests. Check the `CONTRIBUTING.md` file in each SDK repository for guidelines.'
    },
];

/**
 * Interface for user preferences.
 * @interface UserPreferences
 * @property {string} theme - 'light' or 'dark'.
 * @property {boolean} receiveMarketingEmails - Opt-in for marketing emails.
 * @property {boolean} receiveSdkUpdateNotifications - Opt-in for SDK update emails.
 * @property {boolean} enableAiAssistedCoding - Feature toggle for AI.
 * @property {AiConfig} aiConfig - Specific AI configuration.
 * @property {string[]} favoriteSdks - List of favorite SDK IDs.
 */
export interface UserPreferences {
    theme: 'light' | 'dark';
    receiveMarketingEmails: boolean;
    receiveSdkUpdateNotifications: boolean;
    enableAiAssistedCoding: boolean;
    aiConfig: AiConfig;
    favoriteSdks: string[];
}

const DEFAULT_USER_PREFERENCES: UserPreferences = {
    theme: APP_CONSTANTS.DEFAULT_THEME,
    receiveMarketingEmails: true,
    receiveSdkUpdateNotifications: true,
    enableAiAssistedCoding: true,
    aiConfig: {
        model: APP_CONSTANTS.AI_MODEL,
        temperature: 0.7,
        maxTokens: 500,
        defaultPersona: 'expert-developer',
        enableContextualLearning: false,
        preferredLanguages: ['TypeScript', 'Python'],
    },
    favoriteSdks: ['ts', 'py'],
};

/**
 * Interface for a Project Workspace concept (for advanced AI features).
 * @interface ProjectWorkspace
 * @property {string} id - Unique ID.
 * @property {string} name - Name of the project.
 * @property {string} language - Primary language of the project.
 * @property {string} framework - Framework used (e.g., 'Express', 'Django').
 * @property {string[]} installedSdks - List of SDK IDs installed in this project.
 * @property {string} codebaseSnippet - A large code snippet representing the project context.
 * @property {string[]} relevantFiles - List of simulated files in the project.
 */
export interface ProjectWorkspace {
    id: string;
    name: string;
    language: string;
    framework: string;
    installedSdks: string[];
    codebaseSnippet: string;
    relevantFiles: { name: string; content: string }[];
}

const MOCK_PROJECT_WORKSPACES: ProjectWorkspace[] = [
    {
        id: 'proj_1', name: 'E-commerce Backend', language: 'Node.js', framework: 'Express', installedSdks: ['node', 'ts'],
        codebaseSnippet: `
        // src/app.ts
        import express from 'express';
        import { Demobank } from '@demobank/node-sdk';
        const app = express();
        const demobank = new Demobank(process.env.DEMOBANK_API_KEY);

        app.post('/api/payments/create', async (req, res) => {
            try {
                const { amount, currency, customerId } = req.body;
                const payment = await demobank.payments.create({ amount, currency, customerId });
                res.status(201).json(payment);
            } catch (error) {
                console.error('Payment creation failed:', error);
                res.status(500).json({ error: 'Failed to create payment' });
            }
        });

        app.listen(3000, () => console.log('Server running on port 3000'));
        `,
        relevantFiles: [
            { name: 'src/app.ts', content: `import express from 'express';\n// ... more app logic` },
            { name: 'src/services/paymentService.ts', content: `// Payment service abstraction` },
        ]
    },
    {
        id: 'proj_2', name: 'Customer Portal', language: 'Python', framework: 'Django', installedSdks: ['py'],
        codebaseSnippet: `
        # customers/views.py
        from django.shortcuts import render
        from demobank import CustomerService

        def customer_detail(request, customer_id):
            service = CustomerService(api_key=settings.DEMOBANK_API_KEY)
            customer = service.get_customer(customer_id)
            return render(request, 'customer_detail.html', {'customer': customer})
        `,
        relevantFiles: [
            { name: 'customers/views.py', content: `# Django views` },
            { name: 'customers/models.py', content: `# Django models` },
        ]
    }
];

// --- NEW INTERFACES AND MOCK DATA FOR EXPANSION (end) ---

// --- SUB-COMPONENTS FOR SDK MANAGEMENT (start) ---
/**
 * @typedef {Object} SdkFilterOptions
 * @property {string} language - Filter by language.
 * @property {string} platform - Filter by platform.
 * @property {string} searchTerm - Search by description or name.
 * @property {string} license - Filter by license type.
 */
export interface SdkFilterOptions {
    language: string;
    platform: string;
    searchTerm: string;
    license: string;
}

/**
 * @typedef {Object} SdkSortOptions
 * @property {'name' | 'version' | 'stars' | 'lastUpdated' | 'none'} sortBy - Field to sort by.
 * @property {'asc' | 'desc'} sortOrder - Sort order.
 */
export interface SdkSortOptions {
    sortBy: 'name' | 'version' | 'stars' | 'lastUpdated' | 'none';
    sortOrder: 'asc' | 'desc';
}

/**
 * Filter and sort controls for the SDK list.
 * @param {object} props - Component props.
 * @param {SdkFilterOptions} props.filters - Current filter settings.
 * @param {function(SdkFilterOptions): void} props.onFiltersChange - Callback for filter changes.
 * @param {SdkSortOptions} props.sort - Current sort settings.
 * @param {function(SdkSortOptions): void} props.onSortChange - Callback for sort changes.
 */
export const SdkFilterAndSort: React.FC<{
    filters: SdkFilterOptions;
    onFiltersChange: (filters: SdkFilterOptions) => void;
    sort: SdkSortOptions;
    onSortChange: (sort: SdkSortOptions) => void;
}> = ({ filters, onFiltersChange, sort, onSortChange }) => {
    const handleFilterChange = (key: keyof SdkFilterOptions, value: string) => {
        onFiltersChange({ ...filters, [key]: value });
    };

    const handleSortChange = (key: SdkSortOptions['sortBy']) => {
        const newOrder = sort.sortBy === key && sort.sortOrder === 'asc' ? 'desc' : 'asc';
        onSortChange({ sortBy: key, sortOrder: newOrder });
    };

    return (
        <div className="flex flex-wrap items-center gap-4 p-4 bg-gray-800 rounded-lg mb-6">
            <input
                type="text"
                placeholder="Search SDKs..."
                value={filters.searchTerm}
                onChange={(e) => handleFilterChange('searchTerm', e.target.value)}
                className="flex-grow bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 max-w-xs"
            />
            <select
                value={filters.language}
                onChange={(e) => handleFilterChange('language', e.target.value)}
                className="bg-gray-700/50 p-2 rounded text-white max-w-xs"
            >
                <option value="">All Languages</option>
                {Array.from(new Set(MOCK_SDKS.map(sdk => sdk.language))).sort().map(lang => (
                    <option key={lang} value={lang}>{lang}</option>
                ))}
            </select>
            <select
                value={filters.platform}
                onChange={(e) => handleFilterChange('platform', e.target.value)}
                className="bg-gray-700/50 p-2 rounded text-white max-w-xs"
            >
                <option value="">All Platforms</option>
                {APP_CONSTANTS.SDK_PLATFORMS.map(platform => (
                    <option key={platform} value={platform}>{platform.charAt(0).toUpperCase() + platform.slice(1)}</option>
                ))}
            </select>
            <select
                value={filters.license}
                onChange={(e) => handleFilterChange('license', e.target.value)}
                className="bg-gray-700/50 p-2 rounded text-white max-w-xs"
            >
                <option value="">All Licenses</option>
                {APP_CONSTANTS.SDK_LICENSES.map(license => (
                    <option key={license} value={license}>{license}</option>
                ))}
            </select>

            <div className="flex items-center gap-2">
                <span className="text-gray-300 text-sm">Sort by:</span>
                <button
                    onClick={() => handleSortChange('name')}
                    className={`py-1 px-3 rounded text-sm ${sort.sortBy === 'name' ? 'bg-cyan-700' : 'bg-gray-600/50'} text-white`}
                >
                    Name {sort.sortBy === 'name' && (sort.sortOrder === 'asc' ? '' : '')}
                </button>
                <button
                    onClick={() => handleSortChange('lastUpdated')}
                    className={`py-1 px-3 rounded text-sm ${sort.sortBy === 'lastUpdated' ? 'bg-cyan-700' : 'bg-gray-600/50'} text-white`}
                >
                    Last Updated {sort.sortBy === 'lastUpdated' && (sort.sortOrder === 'asc' ? '' : '')}
                </button>
                <button
                    onClick={() => handleSortChange('stars')}
                    className={`py-1 px-3 rounded text-sm ${sort.sortBy === 'stars' ? 'bg-cyan-700' : 'bg-gray-600/50'} text-white`}
                >
                    Stars {sort.sortBy === 'stars' && (sort.sortOrder === 'asc' ? '' : '')}
                </button>
            </div>
        </div>
    );
};

/**
 * Displays recent SDK downloads from history.
 * @param {object} props - Component props.
 * @param {DownloadHistoryEntry[]} props.history - Array of download history entries.
 */
export const SdkDownloadHistory: React.FC<{ history: DownloadHistoryEntry[] }> = ({ history }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 5;
    const totalPages = Math.ceil(history.length / itemsPerPage);

    const paginatedHistory = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return history.slice(startIndex, startIndex + itemsPerPage);
    }, [history, currentPage, itemsPerPage]);

    return (
        <Card title="Recent Download History" className="flex-1 min-w-[300px]">
            {history.length === 0 ? (
                <p className="text-gray-400">No recent downloads found.</p>
            ) : (
                <>
                    <ul className="space-y-3">
                        {paginatedHistory.map((entry, index) => (
                            <li key={index} className="flex flex-col md:flex-row md:items-center justify-between p-3 bg-gray-800/50 rounded">
                                <div className="flex-grow">
                                    <p className="font-semibold text-white">{MOCK_SDKS.find(s => s.id === entry.sdkId)?.language || entry.sdkId} v{entry.sdkVersion}</p>
                                    <p className="text-xs text-gray-400">
                                        Downloaded on {new Date(entry.timestamp).toLocaleString()}
                                        <span className="hidden md:inline"> &bull; {entry.os} ({entry.browser})</span>
                                    </p>
                                </div>
                                <a href={entry.downloadUrl} className="text-cyan-500 hover:underline text-sm mt-2 md:mt-0 md:ml-4" download>
                                    Redownload
                                </a>
                            </li>
                        ))}
                    </ul>
                    {totalPages > 1 && (
                        <div className="flex justify-center mt-4 space-x-2">
                            <button
                                onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                                disabled={currentPage === 1}
                                className="px-3 py-1 bg-gray-700/50 text-white rounded disabled:opacity-50"
                            >
                                Previous
                            </button>
                            {Array.from({ length: totalPages }, (_, i) => i + 1).map(page => (
                                <button
                                    key={page}
                                    onClick={() => setCurrentPage(page)}
                                    className={`px-3 py-1 rounded ${currentPage === page ? 'bg-cyan-600' : 'bg-gray-700/50'} text-white`}
                                >
                                    {page}
                                </button>
                            ))}
                            <button
                                onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                                disabled={currentPage === totalPages}
                                className="px-3 py-1 bg-gray-700/50 text-white rounded disabled:opacity-50"
                            >
                                Next
                            </button>
                        </div>
                    )}
                </>
            )}
        </Card>
    );
};

/**
 * Detailed view of a single SDK.
 * @param {object} props - Component props.
 * @param {Sdk} props.sdk - The SDK object to display.
 * @param {function(): void} props.onClose - Callback to close the detail view.
 * @param {function(Sdk): void} props.onDownload - Callback when download is initiated.
 * @param {function(Sdk): void} props.onSelectForAi - Callback when SDK is selected for AI.
 */
export const SdkDetailView: React.FC<{ sdk: Sdk; onClose: () => void; onDownload: (sdk: Sdk) => void; onSelectForAi: (sdk: Sdk) => void }> = ({ sdk, onClose, onDownload, onSelectForAi }) => {
    return (
        <Card title={`${sdk.language} SDK v${sdk.version} Details`} className="relative">
            <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            <div className="space-y-4 text-gray-300">
                <p><strong>Description:</strong> {sdk.description}</p>
                <p><strong>Platform:</strong> {sdk.platform}</p>
                <p><strong>Last Updated:</strong> {new Date(sdk.lastUpdated).toLocaleDateString()}</p>
                <p><strong>Maintainer:</strong> {sdk.maintainer}</p>
                <p><strong>License:</strong> {sdk.license}</p>
                <p><strong>GitHub Stats:</strong>  {sdk.stars} |  {sdk.forks} |  {sdk.issues}</p>
                <p><strong>Installation:</strong> <code className="bg-gray-700 p-1 rounded text-cyan-300 text-sm">{sdk.installationCmd}</code></p>

                <div>
                    <h4 className="font-semibold text-white mt-4 mb-2">Usage Examples:</h4>
                    {sdk.usageExamples.length > 0 ? (
                        <div className="space-y-3">
                            {sdk.usageExamples.map((example, i) => (
                                <div key={i} className="bg-gray-900/50 p-3 rounded-lg">
                                    <p className="font-medium text-gray-200 mb-1">{example.title}</p>
                                    <pre className="text-xs text-gray-400 whitespace-pre-wrap font-mono max-h-40 overflow-auto">{example.snippet}</pre>
                                </div>
                            ))}
                        </div>
                    ) : (
                        <p className="text-gray-400 text-sm">No usage examples available.</p>
                    )}
                </div>

                <div className="flex flex-wrap gap-4 mt-6">
                    <button onClick={() => onDownload(sdk)} className="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm">Download SDK</button>
                    <button onClick={() => onSelectForAi(sdk)} className="flex-1 py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">AI Code Gen</button>
                    <a href={sdk.docsUrl} target="_blank" rel="noopener noreferrer" className="flex-1 text-center py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">View Docs</a>
                    <a href={sdk.releaseNotesUrl} target="_blank" rel="noopener noreferrer" className="flex-1 text-center py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">Release Notes</a>
                </div>
            </div>
        </Card>
    );
};

// --- SUB-COMPONENTS FOR SDK MANAGEMENT (end) ---

// --- SUB-COMPONENTS FOR AI CODELAB (start) ---

/**
 * Displays AI configuration settings.
 * @param {object} props - Component props.
 * @param {AiConfig} props.aiConfig - Current AI configuration.
 * @param {function(AiConfig): void} props.onConfigChange - Callback for config changes.
 */
export const AiSettingsPanel: React.FC<{ aiConfig: AiConfig; onConfigChange: (config: AiConfig) => void }> = ({ aiConfig, onConfigChange }) => {
    const handleChange = useCallback((key: keyof AiConfig, value: any) => {
        onConfigChange({ ...aiConfig, [key]: value });
    }, [aiConfig, onConfigChange]);

    return (
        <Card title="AI Generator Settings">
            <div className="space-y-4 text-gray-300">
                <div>
                    <label className="block text-sm font-medium mb-1">AI Model:</label>
                    <select
                        value={aiConfig.model}
                        onChange={(e) => handleChange('model', e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                    >
                        <option value="gemini-pro-1.5">Gemini 1.5 Pro</option>
                        <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        <option value="code-bison">Code-Bison</option>
                    </select>
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">Temperature (Randomness): <span className="text-cyan-400">{aiConfig.temperature.toFixed(1)}</span></label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={aiConfig.temperature}
                        onChange={(e) => handleChange('temperature', parseFloat(e.target.value))}
                        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg"
                    />
                    <p className="text-xs text-gray-500 mt-1">Lower values mean more deterministic output, higher values mean more creative/random output.</p>
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">Max Output Tokens: <span className="text-cyan-400">{aiConfig.maxTokens}</span></label>
                    <input
                        type="range"
                        min="100"
                        max="2000"
                        step="50"
                        value={aiConfig.maxTokens}
                        onChange={(e) => handleChange('maxTokens', parseInt(e.target.value))}
                        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg"
                    />
                    <p className="text-xs text-gray-500 mt-1">Controls the maximum length of the generated code snippet.</p>
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">AI Persona:</label>
                    <select
                        value={aiConfig.defaultPersona}
                        onChange={(e) => handleChange('defaultPersona', e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                    >
                        <option value="expert-developer">Expert Developer</option>
                        <option value="friendly-assistant">Friendly Assistant</option>
                        <option value="concise-coder">Concise Coder</option>
                    </select>
                    <p className="text-xs text-gray-500 mt-1">Sets the tone and style of the AI's response.</p>
                </div>
                <div className="flex items-center">
                    <input
                        type="checkbox"
                        id="enableContextualLearning"
                        checked={aiConfig.enableContextualLearning}
                        onChange={(e) => handleChange('enableContextualLearning', e.target.checked)}
                        className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                    />
                    <label htmlFor="enableContextualLearning" className="ml-2 text-sm font-medium">Enable Contextual Learning (beta)</label>
                    <p className="text-xs text-gray-500 ml-2">(AI learns from your previous prompts/code in current session)</p>
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">Preferred Languages (for suggestions):</label>
                    <div className="flex flex-wrap gap-2">
                        {APP_CONSTANTS.SUPPORTED_AI_LANGUAGES.map(lang => (
                            <label key={lang} className="inline-flex items-center">
                                <input
                                    type="checkbox"
                                    checked={aiConfig.preferredLanguages.includes(lang)}
                                    onChange={(e) => {
                                        const newPreferred = e.target.checked
                                            ? [...aiConfig.preferredLanguages, lang]
                                            : aiConfig.preferredLanguages.filter(l => l !== lang);
                                        handleChange('preferredLanguages', newPreferred);
                                    }}
                                    className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                />
                                <span className="ml-1 text-sm">{lang}</span>
                            </label>
                        ))}
                    </div>
                </div>
            </div>
        </Card>
    );
};

/**
 * Manages and displays a list of saved AI prompts/snippets.
 * @param {object} props - Component props.
 * @param {SavedPrompt[]} props.savedPrompts - Array of saved prompts.
 * @param {function(SavedPrompt): void} props.onSelectPrompt - Callback when a prompt is selected for reuse.
 * @param {function(string): void} props.onDeletePrompt - Callback to delete a prompt.
 */
export const PromptLibrary: React.FC<{
    savedPrompts: SavedPrompt[];
    onSelectPrompt: (prompt: SavedPrompt) => void;
    onDeletePrompt: (id: string) => void;
}> = ({ savedPrompts, onSelectPrompt, onDeletePrompt }) => {
    const [filterTag, setFilterTag] = useState('');
    const [searchTerm, setSearchTerm] = useState('');

    const filteredPrompts = useMemo(() => {
        return savedPrompts.filter(p =>
            (filterTag === '' || p.tags.includes(filterTag)) &&
            (searchTerm === '' || p.prompt.toLowerCase().includes(searchTerm.toLowerCase()) || p.generatedCode.toLowerCase().includes(searchTerm.toLowerCase()))
        );
    }, [savedPrompts, filterTag, searchTerm]);

    const allTags = useMemo(() => {
        const tags = new Set<string>();
        savedPrompts.forEach(p => p.tags.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
    }, [savedPrompts]);

    return (
        <Card title="Saved Code Snippets">
            <div className="mb-4 flex flex-wrap gap-3">
                <input
                    type="text"
                    placeholder="Search saved prompts..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 max-w-sm"
                />
                <select
                    value={filterTag}
                    onChange={(e) => setFilterTag(e.target.value)}
                    className="bg-gray-700/50 p-2 rounded text-white"
                >
                    <option value="">All Tags</option>
                    {allTags.map(tag => (
                        <option key={tag} value={tag}>{tag}</option>
                    ))}
                </select>
            </div>
            {filteredPrompts.length === 0 ? (
                <p className="text-gray-400">No saved snippets matching criteria.</p>
            ) : (
                <div className="space-y-4 max-h-96 overflow-y-auto pr-2">
                    {filteredPrompts.map(prompt => (
                        <div key={prompt.id} className="bg-gray-800/50 p-4 rounded-lg border border-gray-700">
                            <div className="flex justify-between items-start mb-2">
                                <h4 className="text-lg font-semibold text-white">{prompt.prompt}</h4>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => onSelectPrompt(prompt)}
                                        className="py-1 px-3 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-xs"
                                        title="Use this prompt/code"
                                    >
                                        Use
                                    </button>
                                    <button
                                        onClick={() => onDeletePrompt(prompt.id)}
                                        className="py-1 px-3 bg-red-700 hover:bg-red-800 text-white rounded-lg text-xs"
                                        title="Delete snippet"
                                    >
                                        Delete
                                    </button>
                                </div>
                            </div>
                            <p className="text-sm text-gray-400 mb-2">
                                {prompt.language} SDK ({prompt.sdkId}) - Saved: {new Date(prompt.timestamp).toLocaleDateString()}
                            </p>
                            <pre className="bg-gray-900/50 p-3 rounded text-xs text-gray-300 whitespace-pre-wrap font-mono max-h-32 overflow-auto">
                                {prompt.generatedCode}
                            </pre>
                            <div className="mt-2 flex flex-wrap gap-2 text-xs">
                                {prompt.tags.map(tag => (
                                    <span key={tag} className="bg-gray-700 px-2 py-1 rounded-full text-gray-300">#{tag}</span>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </Card>
    );
};

/**
 * Provides an interface for the AI to review code snippets or suggest refactoring.
 * @param {object} props - Component props.
 * @param {Sdk | null} props.selectedSdk - The currently selected SDK.
 * @param {AiConfig} props.aiConfig - Current AI configuration.
 */
export const CodeReviewAssistant: React.FC<{ selectedSdk: Sdk | null; aiConfig: AiConfig }> = ({ selectedSdk, aiConfig }) => {
    const [codeToReview, setCodeToReview] = useState('');
    const [reviewResult, setReviewResult] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const { addToast } = useToastNotifications();

    const handleReview = async () => {
        if (!codeToReview.trim()) {
            addToast('Please enter code to review.', 'warning');
            return;
        }
        setIsLoading(true);
        setReviewResult('');
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const reviewPrompt = `As an expert developer and security analyst, review the following code snippet written in ${selectedSdk?.language || 'a generic language'}.
            Provide constructive feedback focusing on:
            1. Potential bugs or edge cases.
            2. Security vulnerabilities.
            3. Performance improvements.
            4. Code style and readability (adhering to typical ${selectedSdk?.language || 'general'} conventions).
            5. Best practices for integrating with Demobank SDK (if applicable, assume it's used).
            6. Suggest refactorings or alternative approaches.
            
            Code to review:\n\`\`\`${selectedSdk?.language.toLowerCase() || ''}\n${codeToReview}\n\`\`\`\n\nProvide your review in a structured, concise format, highlighting key actionable points.`;

            const response = await ai.models.generateContent({
                model: aiConfig.model,
                contents: reviewPrompt,
                generationConfig: { temperature: aiConfig.temperature, maxOutputTokens: aiConfig.maxTokens }
            });
            setReviewResult(response.text.trim());
            addToast('Code review generated successfully!', 'success');
        } catch (error) {
            console.error('Code review error:', error);
            setReviewResult("Error: Could not perform code review. Please check your API key and try again.");
            addToast('Failed to generate code review.', 'error');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card title="AI Code Review & Refactoring Assistant">
            <p className="text-gray-400 mb-4">Paste your code below to get AI-powered review and suggestions for improvements. Specify the SDK language if applicable.</p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-3">
                    <label className="block text-sm font-medium text-gray-300">Code to Review:</label>
                    <textarea
                        value={codeToReview}
                        onChange={(e) => setCodeToReview(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-xs h-60"
                        placeholder={`Paste your ${selectedSdk?.language || 'code'} here...`}
                    />
                    <button
                        onClick={handleReview}
                        disabled={isLoading || !codeToReview.trim()}
                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50"
                    >
                        {isLoading ? 'Reviewing...' : 'Get Code Review'}
                    </button>
                </div>
                <div className="bg-gray-900/50 p-4 rounded-lg max-h-80 overflow-auto">
                    <label className="block text-sm font-medium text-gray-300 mb-2">Review Results:</label>
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono">
                        {isLoading ? 'Reviewing code...' : (reviewResult || 'Your code review results will appear here.')}
                    </pre>
                </div>
            </div>
        </Card>
    );
};

/**
 * Generates test cases for a given code snippet using AI.
 * @param {object} props - Component props.
 * @param {Sdk | null} props.selectedSdk - The currently selected SDK.
 * @param {AiConfig} props.aiConfig - Current AI configuration.
 */
export const TestCaseGenerator: React.FC<{ selectedSdk: Sdk | null; aiConfig: AiConfig }> = ({ selectedSdk, aiConfig }) => {
    const [functionCode, setFunctionCode] = useState('');
    const [generatedTests, setGeneratedTests] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const { addToast } = useToastNotifications();

    const handleGenerateTests = async () => {
        if (!functionCode.trim()) {
            addToast('Please enter a function to generate tests for.', 'warning');
            return;
        }
        setIsLoading(true);
        setGeneratedTests('');
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const testPrompt = `Generate unit tests for the following ${selectedSdk?.language || 'generic'} function/code snippet using common testing frameworks for ${selectedSdk?.language || 'that language'} (e.g., Jest/Mocha for JS, Pytest for Python, Go testing for Go).
            Focus on positive cases, edge cases, and error handling.
            
            Function/Code:\n\`\`\`${selectedSdk?.language.toLowerCase() || ''}\n${functionCode}\n\`\`\`\n\nProvide the generated tests in a clear, executable format.`;

            const response = await ai.models.generateContent({
                model: aiConfig.model,
                contents: testPrompt,
                generationConfig: { temperature: aiConfig.temperature, maxOutputTokens: aiConfig.maxTokens }
            });
            setGeneratedTests(response.text.trim());
            addToast('Test cases generated successfully!', 'success');
        } catch (error) {
            console.error('Test generation error:', error);
            setGeneratedTests("Error: Could not generate test cases. Please check your API key and try again.");
            addToast('Failed to generate test cases.', 'error');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card title="AI Test Case Generator">
            <p className="text-gray-400 mb-4">Provide a function or code snippet, and AI will generate relevant unit tests for it.</p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-3">
                    <label className="block text-sm font-medium text-gray-300">Function/Code to Test:</label>
                    <textarea
                        value={functionCode}
                        onChange={(e) => setFunctionCode(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-xs h-60"
                        placeholder={`Paste your ${selectedSdk?.language || 'function'} here...`}
                    />
                    <button
                        onClick={handleGenerateTests}
                        disabled={isLoading || !functionCode.trim()}
                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50"
                    >
                        {isLoading ? 'Generating Tests...' : 'Generate Tests'}
                    </button>
                </div>
                <div className="bg-gray-900/50 p-4 rounded-lg max-h-80 overflow-auto">
                    <label className="block text-sm font-medium text-gray-300 mb-2">Generated Test Cases:</label>
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono">
                        {isLoading ? 'Generating tests...' : (generatedTests || 'Generated test cases will appear here.')}
                    </pre>
                </div>
            </div>
        </Card>
    );
};

/**
 * Generates deployment scripts for applications using the SDK.
 * @param {object} props - Component props.
 * @param {Sdk | null} props.selectedSdk - The currently selected SDK.
 * @param {AiConfig} props.aiConfig - Current AI configuration.
 */
export const DeploymentScriptGenerator: React.FC<{ selectedSdk: Sdk | null; aiConfig: AiConfig }> = ({ selectedSdk, aiConfig }) => {
    const [projectDescription, setProjectDescription] = useState('');
    const [deploymentTarget, setDeploymentTarget] = useState('Docker');
    const [generatedScript, setGeneratedScript] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const { addToast } = useToastNotifications();

    const deploymentTargets = ['Docker', 'Kubernetes (K8s)', 'AWS Lambda', 'Azure Functions', 'Google Cloud Run', 'Heroku', 'Netlify'];

    const handleGenerateScript = async () => {
        if (!projectDescription.trim()) {
            addToast('Please provide a project description.', 'warning');
            return;
        }
        setIsLoading(true);
        setGeneratedScript('');
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const scriptPrompt = `Generate a deployment script for an application that uses the Demobank SDK (specifically the ${selectedSdk?.language || 'relevant'} SDK if specified).
            The application is described as: "${projectDescription}".
            The target deployment environment is: "${deploymentTarget}".
            
            Provide a detailed script (e.g., Dockerfile, Kubernetes YAML, CI/CD config snippet) that includes:
            1. Setup of the environment.
            2. Installation of dependencies, including the Demobank SDK.
            3. Building the application.
            4. Deployment configuration.
            5. Any necessary environment variables or secrets management (placeholder).
            
            Assume standard project structure for a ${selectedSdk?.language || 'generic'} application.`;

            const response = await ai.models.generateContent({
                model: aiConfig.model,
                contents: scriptPrompt,
                generationConfig: { temperature: aiConfig.temperature, maxOutputTokens: aiConfig.maxTokens }
            });
            setGeneratedScript(response.text.trim());
            addToast('Deployment script generated successfully!', 'success');
        } catch (error) {
            console.error('Deployment script generation error:', error);
            setGeneratedScript("Error: Could not generate deployment script. Please check your API key and try again.");
            addToast('Failed to generate deployment script.', 'error');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Card title="AI Deployment Script Generator">
            <p className="text-gray-400 mb-4">Generate deployment configurations and scripts for your application integrated with DemoBank SDKs.</p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-3">
                    <label className="block text-sm font-medium text-gray-300">Project Description:</label>
                    <textarea
                        value={projectDescription}
                        onChange={(e) => setProjectDescription(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white font-mono text-xs h-40"
                        placeholder="e.g., 'A Node.js Express API that processes payments via Demobank, deployed on Docker.'"
                    />
                    <label className="block text-sm font-medium text-gray-300">Deployment Target:</label>
                    <select
                        value={deploymentTarget}
                        onChange={(e) => setDeploymentTarget(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                    >
                        {deploymentTargets.map(target => (
                            <option key={target} value={target}>{target}</option>
                        ))}
                    </select>
                    <button
                        onClick={handleGenerateScript}
                        disabled={isLoading || !projectDescription.trim()}
                        className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50"
                    >
                        {isLoading ? 'Generating Script...' : 'Generate Deployment Script'}
                    </button>
                </div>
                <div className="bg-gray-900/50 p-4 rounded-lg max-h-80 overflow-auto">
                    <label className="block text-sm font-medium text-gray-300 mb-2">Generated Script:</label>
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono">
                        {isLoading ? 'Generating deployment script...' : (generatedScript || 'Generated deployment script will appear here.')}
                    </pre>
                </div>
            </div>
        </Card>
    );
};

/**
 * Allows switching between different AI tools.
 * @param {object} props - Component props.
 * @param {string} props.currentTool - The currently active AI tool.
 * @param {function(string): void} props.onSelectTool - Callback to select a new tool.
 */
export const AiToolSelector: React.FC<{ currentTool: string; onSelectTool: (tool: string) => void }> = ({ currentTool, onSelectTool }) => {
    const tools = [
        { id: 'code-gen', name: 'Code Generator' },
        { id: 'code-review', name: 'Code Review' },
        { id: 'test-gen', name: 'Test Generator' },
        { id: 'deploy-script', name: 'Deploy Script' },
        { id: 'prompt-library', name: 'Prompt Library' },
        { id: 'settings', name: 'AI Settings' },
    ];

    return (
        <div className="mb-6 border-b border-gray-700">
            <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                {tools.map((tool) => (
                    <button
                        key={tool.id}
                        onClick={() => onSelectTool(tool.id)}
                        className={`whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm focus:outline-none transition-colors duration-200
                                ${currentTool === tool.id
                                ? 'border-cyan-500 text-cyan-400'
                                : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`
                        }
                    >
                        {tool.name}
                    </button>
                ))}
            </nav>
        </div>
    );
};

// --- SUB-COMPONENTS FOR AI CODELAB (end) ---

// --- SUB-COMPONENTS FOR DOCUMENTATION (start) ---
/**
 * Displays an interactive navigation tree for documentation.
 * @param {object} props - Component props.
 * @param {object} props.docsStructure - The documentation structure object.
 * @param {string | null} props.activePath - The currently active documentation path.
 * @param {function(string): void} props.onSelectPath - Callback when a document is selected.
 */
export const DocNavigationTree: React.FC<{ docsStructure: { [key: string]: DocNode[] }; activePath: string | null; onSelectPath: (path: string) => void }> = ({ docsStructure, activePath, onSelectPath }) => {
    const renderNode = (node: DocNode) => (
        <li key={node.path} className="mb-1">
            <a
                href="#"
                onClick={(e) => { e.preventDefault(); onSelectPath(node.path); }}
                className={`block py-1 px-3 rounded-md transition-colors duration-200 text-sm
                            ${activePath === node.path
                        ? 'bg-cyan-800 text-white font-semibold'
                        : 'text-gray-300 hover:bg-gray-700 hover:text-white'}`
                }
                title={node.description}
            >
                {node.title}
            </a>
            {node.children && node.children.length > 0 && (
                <ul className="ml-4 mt-1 border-l border-gray-700">
                    {node.children.map(child => renderNode(child))}
                </ul>
            )}
        </li>
    );

    return (
        <Card className="max-w-xs flex-shrink-0" title="Documentation Topics">
            <nav className="space-y-4 max-h-[800px] overflow-y-auto pr-2">
                {Object.entries(docsStructure).map(([category, nodes]) => (
                    <div key={category}>
                        <h3 className="text-gray-200 font-semibold mb-2">{category}</h3>
                        <ul className="space-y-1">
                            {nodes.map(node => renderNode(node))}
                        </ul>
                    </div>
                ))}
            </nav>
        </Card>
    );
};

/**
 * Displays documentation content, potentially rendered from Markdown.
 * @param {object} props - Component props.
 * @param {string} props.content - The raw documentation content (e.g., Markdown).
 * @param {string} props.title - The title of the document.
 * @param {boolean} props.isLoading - Whether content is currently loading.
 */
export const DocContentDisplay: React.FC<{ content: string; title: string; isLoading: boolean }> = ({ content, title, isLoading }) => {
    const renderedHtml = useMemo(() => renderMarkdownToHtml(content), [content]);

    return (
        <Card title={isLoading ? `Loading: ${title}...` : title} className="flex-grow max-w-full">
            <div className="prose prose-invert max-w-none text-gray-300 space-y-4" style={{ color: 'inherit' }}>
                {isLoading ? (
                    <p className="text-gray-400">Loading documentation content...</p>
                ) : (
                    <div dangerouslySetInnerHTML={{ __html: renderedHtml }} />
                )}
            </div>
        </Card>
    );
};

/**
 * Search interface for documentation.
 * @param {object} props - Component props.
 * @param {function(string): void} props.onSearch - Callback for search query submission.
 * @param {DocSearchResult[]} props.searchResults - Array of search results.
 * @param {boolean} props.isLoading - Whether search is in progress.
 * @param {function(string): void} props.onSelectResult - Callback when a search result is selected.
 */
export const DocSearch: React.FC<{
    onSearch: (query: string) => void;
    searchResults: DocSearchResult[];
    isLoading: boolean;
    onSelectResult: (path: string) => void;
}> = ({ onSearch, searchResults, isLoading, onSelectResult }) => {
    const [query, setQuery] = useState('');
    const debouncedQuery = useDebounce(query, 500);

    useEffect(() => {
        if (debouncedQuery.trim()) {
            onSearch(debouncedQuery);
        }
    }, [debouncedQuery, onSearch]);

    return (
        <Card title="Search Documentation" className="mb-6">
            <input
                type="text"
                placeholder="Search articles, guides..."
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                className="w-full bg-gray-700/50 p-2 rounded text-white placeholder-gray-400"
            />
            {isLoading && query.trim() && <p className="text-gray-400 mt-2">Searching...</p>}
            {query.trim() && !isLoading && searchResults.length > 0 && (
                <div className="mt-4 space-y-2 max-h-60 overflow-y-auto pr-2">
                    {searchResults.map(result => (
                        <div key={result.path} className="bg-gray-800/50 p-3 rounded cursor-pointer hover:bg-gray-700" onClick={() => onSelectResult(result.path)}>
                            <h4 className="text-white font-semibold">{result.title}</h4>
                            <p className="text-sm text-gray-400">{result.snippet}</p>
                            <span className="text-xs text-cyan-500">{result.path}</span>
                        </div>
                    ))}
                </div>
            )}
            {query.trim() && !isLoading && searchResults.length === 0 && (
                <p className="text-gray-400 mt-2">No results found for "{query}".</p>
            )}
        </Card>
    );
};

// --- SUB-COMPONENTS FOR DOCUMENTATION (end) ---

// --- SUB-COMPONENTS FOR API EXPLORER (start) ---
/**
 * Interface for API Request History.
 * @interface ApiRequestHistoryEntry
 * @property {string} id - Unique ID.
 * @property {ApiRequestPayload} request - The request payload.
 * @property {ApiResponse<any>} response - The response received.
 * @property {string} timestamp - ISO string of when the request was made.
 */
export interface ApiRequestHistoryEntry {
    id: string;
    request: ApiRequestPayload;
    response: ApiResponse<any>;
    timestamp: string;
}

/**
 * Selector for API Endpoints.
 * @param {object} props - Component props.
 * @param {ApiEndpoint[]} props.endpoints - List of available API endpoints.
 * @param {ApiEndpoint | null} props.selectedEndpoint - The currently selected endpoint.
 * @param {function(ApiEndpoint): void} props.onSelectEndpoint - Callback when an endpoint is selected.
 */
export const ApiEndpointSelector: React.FC<{ endpoints: ApiEndpoint[]; selectedEndpoint: ApiEndpoint | null; onSelectEndpoint: (endpoint: ApiEndpoint) => void }> = ({ endpoints, selectedEndpoint, onSelectEndpoint }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [filterTag, setFilterTag] = useState('');

    const allTags = useMemo(() => {
        const tags = new Set<string>();
        endpoints.forEach(ep => ep.tags.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
    }, [endpoints]);

    const filteredEndpoints = useMemo(() => {
        return endpoints.filter(ep =>
            (searchTerm === '' || ep.path.toLowerCase().includes(searchTerm.toLowerCase()) || ep.description.toLowerCase().includes(searchTerm.toLowerCase())) &&
            (filterTag === '' || ep.tags.includes(filterTag))
        );
    }, [endpoints, searchTerm, filterTag]);

    return (
        <Card title="API Endpoints" className="flex-1 min-w-[300px]">
            <input
                type="text"
                placeholder="Search endpoints..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 mb-3"
            />
            <select
                value={filterTag}
                onChange={(e) => setFilterTag(e.target.value)}
                className="w-full bg-gray-700/50 p-2 rounded text-white mb-4"
            >
                <option value="">All Categories</option>
                {allTags.map(tag => (
                    <option key={tag} value={tag}>{tag}</option>
                ))}
            </select>
            <div className="space-y-2 max-h-96 overflow-y-auto pr-2">
                {filteredEndpoints.map(endpoint => (
                    <div
                        key={endpoint.id}
                        className={`p-3 rounded-lg cursor-pointer transition-colors duration-200
                                    ${selectedEndpoint?.id === endpoint.id ? 'bg-cyan-800' : 'bg-gray-800 hover:bg-gray-700'}`}
                        onClick={() => onSelectEndpoint(endpoint)}
                    >
                        <span className={`px-2 py-1 mr-2 rounded text-xs font-semibold ${
                            endpoint.method === 'GET' ? 'bg-blue-600' :
                            endpoint.method === 'POST' ? 'bg-green-600' :
                            endpoint.method === 'PUT' ? 'bg-yellow-600' :
                            endpoint.method === 'DELETE' ? 'bg-red-600' : 'bg-purple-600'
                        }`}>
                            {endpoint.method}
                        </span>
                        <code className="text-white text-sm">{endpoint.path}</code>
                        <p className="text-gray-400 text-xs mt-1">{endpoint.description}</p>
                    </div>
                ))}
            </div>
            {filteredEndpoints.length === 0 && <p className="text-gray-400">No endpoints found.</p>}
        </Card>
    );
};

/**
 * Editor for constructing API requests.
 * @param {object} props - Component props.
 * @param {ApiEndpoint | null} props.endpoint - The selected API endpoint.
 * @param {function(ApiRequestPayload): void} props.onRequestExecute - Callback to execute the request.
 * @param {boolean} props.isLoading - Whether a request is currently executing.
 */
export const ApiRequestEditor: React.FC<{ endpoint: ApiEndpoint | null; onRequestExecute: (request: ApiRequestPayload) => void; isLoading: boolean }> = ({ endpoint, onRequestExecute, isLoading }) => {
    const [path, setPath] = useState('');
    const [queryParams, setQueryParams] = useState<{ [key: string]: string }>({});
    const [requestBody, setRequestBody] = useState<string>('');
    const [headers, setHeaders] = useState<{ [key: string]: string }>({ 'Content-Type': 'application/json', 'Authorization': `Bearer ${APP_CONSTANTS.DEFAULT_API_KEY}` });
    const { addToast } = useToastNotifications();

    useEffect(() => {
        if (endpoint) {
            let initialPath = endpoint.path;
            const initialQueryParams: { [key: string]: string } = {};

            // Populate path params
            endpoint.pathParams?.forEach(p => {
                initialPath = initialPath.replace(`{${p.name}}`, `{${p.name}}`); // Keep placeholders for user input
            });

            // Populate query params with defaults or empty
            endpoint.queryParams?.forEach(p => {
                initialQueryParams[p.name] = '';
            });

            setPath(initialPath);
            setQueryParams(initialQueryParams);
            setRequestBody(endpoint.exampleRequest || (endpoint.method !== 'GET' ? JSON.stringify({}, null, 2) : ''));
        }
    }, [endpoint]);

    const handleExecute = () => {
        if (!endpoint) {
            addToast('Please select an API endpoint first.', 'warning');
            return;
        }

        let currentPath = path;
        let missingPathParams = false;
        endpoint.pathParams?.forEach(p => {
            if (currentPath.includes(`{${p.name}}`)) {
                addToast(`Path parameter '${p.name}' is required.`, 'error');
                missingPathParams = true;
            }
        });
        if (missingPathParams) return;

        const queryString = new URLSearchParams(queryParams).toString();
        const fullUrl = `${window.location.origin}/api${currentPath}${queryString ? `?${queryString}` : ''}`; // Prefix with /api for proxying

        let parsedBody = '';
        if (requestBody && endpoint.method !== 'GET' && endpoint.method !== 'DELETE') {
            try {
                parsedBody = JSON.stringify(JSON.parse(requestBody), null, 2);
            } catch (e) {
                addToast('Invalid JSON in request body.', 'error');
                return;
            }
        }

        onRequestExecute({
            url: fullUrl,
            method: endpoint.method,
            headers,
            params: queryParams,
            body: parsedBody
        });
    };

    if (!endpoint) {
        return <Card title="API Request Editor" className="flex-grow"><p className="text-gray-400">Select an endpoint to configure your request.</p></Card>;
    }

    return (
        <Card title={`Configure Request: ${endpoint.method} ${endpoint.path}`} className="flex-grow">
            <div className="space-y-4 text-gray-300">
                <div>
                    <label className="block text-sm font-medium mb-1">Method:</label>
                    <input type="text" value={endpoint.method} readOnly className="w-full bg-gray-700/50 p-2 rounded text-white font-bold" />
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">Path:</label>
                    <input
                        type="text"
                        value={path}
                        onChange={(e) => setPath(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                        placeholder={endpoint.path}
                    />
                    {endpoint.pathParams && endpoint.pathParams.length > 0 && (
                        <p className="text-xs text-gray-500 mt-1">Replace <code>{'{paramName}'}</code> with actual values for path parameters.</p>
                    )}
                </div>

                {endpoint.queryParams && endpoint.queryParams.length > 0 && (
                    <div>
                        <label className="block text-sm font-medium mb-1">Query Parameters:</label>
                        {endpoint.queryParams.map(param => (
                            <div key={param.name} className="flex items-center gap-2 mb-2">
                                <span className="text-sm font-mono text-cyan-400 w-24">{param.name}{param.required ? '*' : ''}:</span>
                                <input
                                    type="text"
                                    value={queryParams[param.name] || ''}
                                    onChange={(e) => setQueryParams({ ...queryParams, [param.name]: e.target.value })}
                                    className="flex-grow bg-gray-700/50 p-2 rounded text-white text-sm"
                                    placeholder={param.description}
                                />
                            </div>
                        ))}
                    </div>
                )}

                <div>
                    <label className="block text-sm font-medium mb-1">Headers:</label>
                    {Object.entries(headers).map(([key, value]) => (
                        <div key={key} className="flex items-center gap-2 mb-2">
                            <input
                                type="text"
                                value={key}
                                readOnly={key === 'Content-Type' || key === 'Authorization'}
                                className="w-1/3 bg-gray-700/50 p-2 rounded text-white text-sm"
                            />
                            <input
                                type="text"
                                value={key === 'Authorization' ? '****************' : value}
                                onChange={(e) => setHeaders({ ...headers, [key]: e.target.value })}
                                className="flex-grow bg-gray-700/50 p-2 rounded text-white text-sm"
                            />
                        </div>
                    ))}
                    {/* Add button to add more headers if needed */}
                </div>

                {endpoint.method !== 'GET' && endpoint.method !== 'DELETE' && (
                    <div>
                        <label className="block text-sm font-medium mb-1">Request Body (JSON):</label>
                        <textarea
                            value={requestBody}
                            onChange={(e) => setRequestBody(e.target.value)}
                            className="w-full bg-gray-900/50 p-2 rounded text-white font-mono text-xs h-40 resize-y"
                            placeholder="Enter JSON request body..."
                        />
                        {endpoint.requestSchema && (
                            <p className="text-xs text-gray-500 mt-1">Schema available. Ensure your JSON matches: <a href="#" onClick={(e) => { e.preventDefault(); addToast('Schema display not implemented', 'info'); }} className="text-cyan-500">View Schema</a></p>
                        )}
                    </div>
                )}

                <button
                    onClick={handleExecute}
                    disabled={isLoading}
                    className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50 mt-4"
                >
                    {isLoading ? 'Sending Request...' : 'Send Request'}
                </button>
            </div>
        </Card>
    );
};

/**
 * Displays API response and details.
 * @param {object} props - Component props.
 * @param {ApiResponse<any> | null} props.response - The API response object.
 * @param {boolean} props.isLoading - Whether a request is currently executing.
 */
export const ApiResponseViewer: React.FC<{ response: ApiResponse<any> | null; isLoading: boolean }> = ({ response, isLoading }) => {
    return (
        <Card title="API Response" className="flex-grow">
            <div className="space-y-3">
                <label className="block text-sm font-medium text-gray-300">Status:</label>
                <p className={`font-semibold ${response?.success ? 'text-green-500' : 'text-red-500'}`}>
                    {isLoading ? 'Loading...' : (response ? (response.success ? 'Success' : 'Error') : 'N/A')}
                </p>

                <label className="block text-sm font-medium text-gray-300">Message:</label>
                <p className="text-gray-400 text-sm">{response?.message || 'No response yet.'}</p>

                {response?.errorCode && (
                    <>
                        <label className="block text-sm font-medium text-gray-300">Error Code:</label>
                        <p className="text-red-400 text-sm font-mono">{response.errorCode}</p>
                    </>
                )}

                <label className="block text-sm font-medium text-gray-300">Response Body:</label>
                <div className="bg-gray-900/50 p-4 rounded-lg max-h-96 overflow-auto">
                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono">
                        {isLoading ? 'Waiting for response...' : (response?.data ? JSON.stringify(response.data, null, 2) : 'No data.')}
                    </pre>
                </div>
            </div>
        </Card>
    );
};

/**
 * Displays a history of API requests made in the explorer.
 * @param {object} props - Component props.
 * @param {ApiRequestHistoryEntry[]} props.history - Array of API request history entries.
 * @param {function(ApiRequestPayload): void} props.onReplayRequest - Callback to replay a request.
 * @param {function(string): void} props.onDeleteHistoryEntry - Callback to delete a history entry.
 */
export const ApiRequestHistory: React.FC<{
    history: ApiRequestHistoryEntry[];
    onReplayRequest: (request: ApiRequestPayload) => void;
    onDeleteHistoryEntry: (id: string) => void;
}> = ({ history, onReplayRequest, onDeleteHistoryEntry }) => {
    return (
        <Card title="Request History" className="flex-1 min-w-[300px]">
            {history.length === 0 ? (
                <p className="text-gray-400">No requests in history.</p>
            ) : (
                <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                    {history.map(entry => (
                        <div key={entry.id} className="bg-gray-800/50 p-3 rounded-lg border border-gray-700">
                            <div className="flex justify-between items-start mb-1">
                                <h4 className="font-semibold text-white">
                                    <span className={`px-2 py-1 mr-2 rounded text-xs font-semibold ${
                                        entry.request.method === 'GET' ? 'bg-blue-600' :
                                        entry.request.method === 'POST' ? 'bg-green-600' :
                                        entry.request.method === 'PUT' ? 'bg-yellow-600' :
                                        entry.request.method === 'DELETE' ? 'bg-red-600' : 'bg-purple-600'
                                    }`}>
                                        {entry.request.method}
                                    </span>
                                    <code className="text-sm">{new URL(entry.request.url).pathname.replace('/api', '')}</code>
                                </h4>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => onReplayRequest(entry.request)}
                                        className="py-1 px-3 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-xs"
                                        title="Replay this request"
                                    >
                                        Replay
                                    </button>
                                    <button
                                        onClick={() => onDeleteHistoryEntry(entry.id)}
                                        className="py-1 px-3 bg-red-700 hover:bg-red-800 text-white rounded-lg text-xs"
                                        title="Delete from history"
                                    >
                                        &times;
                                    </button>
                                </div>
                            </div>
                            <p className="text-xs text-gray-400 mb-1">
                                {new Date(entry.timestamp).toLocaleString()} &bull;
                                Status: <span className={entry.response.success ? 'text-green-400' : 'text-red-400'}>{entry.response.success ? 'Success' : 'Error'}</span>
                            </p>
                            <details className="text-gray-500 text-sm cursor-pointer">
                                <summary className="hover:text-gray-300">View Details</summary>
                                <pre className="bg-gray-900/50 p-2 rounded text-xs text-gray-400 whitespace-pre-wrap font-mono mt-2">
                                    Request: {JSON.stringify(entry.request.body ? JSON.parse(entry.request.body) : entry.request.params, null, 2)}
                                    <br />
                                    Response: {JSON.stringify(entry.response.data, null, 2)}
                                </pre>
                            </details>
                        </div>
                    ))}
                </div>
            )}
        </Card>
    );
};
// --- SUB-COMPONENTS FOR API EXPLORER (end) ---

// --- SUB-COMPONENTS FOR COMMUNITY & SUPPORT (start) ---
/**
 * Displays a list of forum threads.
 * @param {object} props - Component props.
 * @param {ForumThread[]} props.threads - Array of forum threads.
 * @param {function(ForumThread): void} props.onViewThread - Callback to view a specific thread.
 */
export const ForumThreadList: React.FC<{ threads: ForumThread[]; onViewThread: (thread: ForumThread) => void }> = ({ threads, onViewThread }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [filterTag, setFilterTag] = useState('');

    const allTags = useMemo(() => {
        const tags = new Set<string>();
        threads.forEach(thread => thread.tags.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
    }, [threads]);

    const filteredThreads = useMemo(() => {
        return threads.filter(thread =>
            (searchTerm === '' || thread.title.toLowerCase().includes(searchTerm.toLowerCase()) || thread.content.toLowerCase().includes(searchTerm.toLowerCase())) &&
            (filterTag === '' || thread.tags.includes(filterTag))
        );
    }, [threads, searchTerm, filterTag]);

    return (
        <Card title="Community Forum" className="flex-1 min-w-[400px]">
            <div className="flex flex-wrap gap-3 mb-4">
                <input
                    type="text"
                    placeholder="Search forum..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="flex-grow bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 max-w-sm"
                />
                <select
                    value={filterTag}
                    onChange={(e) => setFilterTag(e.target.value)}
                    className="bg-gray-700/50 p-2 rounded text-white"
                >
                    <option value="">All Topics</option>
                    {allTags.map(tag => (
                        <option key={tag} value={tag}>{tag}</option>
                    ))}
                </select>
                <button className="py-2 px-4 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm">New Thread</button>
            </div>
            {filteredThreads.length === 0 ? (
                <p className="text-gray-400">No forum threads matching criteria.</p>
            ) : (
                <div className="space-y-4 max-h-[700px] overflow-y-auto pr-2">
                    {filteredThreads.map(thread => (
                        <div
                            key={thread.id}
                            className="bg-gray-800/50 p-4 rounded-lg border border-gray-700 cursor-pointer hover:bg-gray-700"
                            onClick={() => onViewThread(thread)}
                        >
                            <h4 className="text-xl font-semibold text-white mb-1">{thread.title}</h4>
                            <p className="text-sm text-gray-400 mb-2">
                                By {thread.author} &bull; Last activity: {new Date(thread.lastActivity).toLocaleString()} &bull; {thread.replies} replies
                            </p>
                            <div className="flex flex-wrap gap-2 text-xs">
                                {thread.tags.map(tag => (
                                    <span key={tag} className="bg-gray-700 px-2 py-1 rounded-full text-gray-300">#{tag}</span>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </Card>
    );
};

/**
 * Displays a specific forum thread with its comments.
 * @param {object} props - Component props.
 * @param {ForumThread} props.thread - The forum thread to display.
 * @param {function(): void} props.onBack - Callback to return to the thread list.
 */
export const ForumThreadViewer: React.FC<{ thread: ForumThread; onBack: () => void }> = ({ thread, onBack }) => {
    const [newComment, setNewComment] = useState('');
    const { addToast } = useToastNotifications();

    const handlePostComment = () => {
        if (newComment.trim()) {
            addToast('Comment posted (mock)!', 'success');
            console.log('New comment:', newComment);
            setNewComment('');
            // In a real app, you would dispatch an action or make an API call to add the comment
        } else {
            addToast('Comment cannot be empty.', 'warning');
        }
    };

    return (
        <Card title={thread.title} className="relative flex-grow">
            <button onClick={onBack} className="absolute top-4 left-4 text-gray-400 hover:text-white px-3 py-1 bg-gray-700/50 rounded-lg text-sm">&lt; Back to Forum</button>
            <div className="mt-8 mb-6 border-b border-gray-700 pb-4">
                <p className="text-sm text-gray-400 mb-2">
                    By <span className="text-cyan-400">{thread.author}</span> on {new Date(thread.lastActivity).toLocaleString()}
                </p>
                <p className="text-gray-300 leading-relaxed">{thread.content}</p>
                <div className="flex flex-wrap gap-2 text-xs mt-4">
                    {thread.tags.map(tag => (
                        <span key={tag} className="bg-gray-700 px-2 py-1 rounded-full text-gray-300">#{tag}</span>
                    ))}
                </div>
            </div>

            <h5 className="text-xl font-semibold text-white mb-4">Replies ({thread.comments.length})</h5>
            <div className="space-y-6 max-h-[400px] overflow-y-auto pr-2 mb-6">
                {thread.comments.length === 0 ? (
                    <p className="text-gray-400">No replies yet. Be the first!</p>
                ) : (
                    thread.comments.map(comment => (
                        <div key={comment.id} className="bg-gray-800/50 p-4 rounded-lg">
                            <p className="text-sm text-gray-400 mb-1">
                                <span className="font-semibold text-cyan-400">{comment.author}</span> on {new Date(comment.timestamp).toLocaleString()}
                            </p>
                            <p className="text-gray-300">{comment.content}</p>
                        </div>
                    ))
                )}
            </div>

            <div className="mt-6 border-t border-gray-700 pt-6">
                <h5 className="text-lg font-semibold text-white mb-3">Post a Reply</h5>
                <textarea
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    className="w-full bg-gray-700/50 p-3 rounded text-white h-24 resize-y mb-3"
                    placeholder="Type your reply here..."
                />
                <button
                    onClick={handlePostComment}
                    className="py-2 px-4 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm"
                >
                    Post Comment
                </button>
            </div>
        </Card>
    );
};

/**
 * Displays a list of Frequently Asked Questions in an accordion style.
 * @param {object} props - Component props.
 * @param {FaqItem[]} props.faqs - Array of FAQ items.
 */
export const FaqAccordion: React.FC<{ faqs: FaqItem[] }> = ({ faqs }) => {
    const [openFaqId, setOpenFaqId] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');

    const filteredFaqs = useMemo(() => {
        return faqs.filter(faq =>
            searchTerm === '' ||
            faq.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
            faq.answer.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [faqs, searchTerm]);

    const toggleFaq = (id: string) => {
        setOpenFaqId(openFaqId === id ? null : id);
    };

    return (
        <Card title="Frequently Asked Questions" className="flex-1 min-w-[300px]">
            <input
                type="text"
                placeholder="Search FAQs..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full bg-gray-700/50 p-2 rounded text-white placeholder-gray-400 mb-4"
            />
            {filteredFaqs.length === 0 ? (
                <p className="text-gray-400">No FAQs matching your search.</p>
            ) : (
                <div className="space-y-3 max-h-[700px] overflow-y-auto pr-2">
                    {filteredFaqs.map(faq => (
                        <div key={faq.id} className="bg-gray-800/50 rounded-lg border border-gray-700">
                            <button
                                className="w-full text-left p-4 flex justify-between items-center text-white text-lg font-semibold"
                                onClick={() => toggleFaq(faq.id)}
                            >
                                {faq.question}
                                <span>{openFaqId === faq.id ? '' : '+'}</span>
                            </button>
                            {openFaqId === faq.id && (
                                <div className="p-4 pt-0 text-gray-300 text-sm border-t border-gray-700">
                                    {faq.answer}
                                    <div className="mt-3 flex flex-wrap gap-2 text-xs">
                                        {faq.tags.map(tag => (
                                            <span key={tag} className="bg-gray-700 px-2 py-1 rounded-full text-gray-400">#{tag}</span>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            )}
        </Card>
    );
};

/**
 * Form for submitting a support ticket.
 * @param {object} props - Component props.
 * @param {function(object): Promise<ApiResponse<any>>} props.onSubmitTicket - Callback to submit the ticket.
 */
export const SupportTicketForm: React.FC<{ onSubmitTicket: (ticketDetails: { subject: string; message: string; sdkId?: string }) => Promise<ApiResponse<any>> }> = ({ onSubmitTicket }) => {
    const [subject, setSubject] = useState('');
    const [message, setMessage] = useState('');
    const [selectedSdkId, setSelectedSdkId] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);
    const { addToast } = useToastNotifications();

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!subject.trim() || !message.trim()) {
            addToast('Subject and message cannot be empty.', 'error');
            return;
        }

        setIsSubmitting(true);
        const result = await onSubmitTicket({ subject, message, sdkId: selectedSdkId || undefined });
        setIsSubmitting(false);

        if (result.success) {
            addToast(result.message, 'success');
            setSubject('');
            setMessage('');
            setSelectedSdkId('');
        } else {
            addToast(result.message, 'error');
        }
    };

    return (
        <Card title="Submit a Support Ticket">
            <p className="text-gray-400 mb-4">If you can't find your answer in the FAQ or forum, please submit a direct support ticket.</p>
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label htmlFor="subject" className="block text-sm font-medium text-gray-300 mb-1">Subject:</label>
                    <input
                        type="text"
                        id="subject"
                        value={subject}
                        onChange={(e) => setSubject(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                        placeholder="e.g., Issue with Python SDK installation"
                        required
                    />
                </div>
                <div>
                    <label htmlFor="message" className="block text-sm font-medium text-gray-300 mb-1">Message:</label>
                    <textarea
                        id="message"
                        value={message}
                        onChange={(e) => setMessage(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white h-32 resize-y"
                        placeholder="Describe your issue in detail, including steps to reproduce, error messages, and SDK versions."
                        required
                    />
                </div>
                <div>
                    <label htmlFor="sdkId" className="block text-sm font-medium text-gray-300 mb-1">Related SDK (Optional):</label>
                    <select
                        id="sdkId"
                        value={selectedSdkId}
                        onChange={(e) => setSelectedSdkId(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                    >
                        <option value="">-- Select an SDK --</option>
                        {MOCK_SDKS.map(sdk => (
                            <option key={sdk.id} value={sdk.id}>{sdk.language} v{sdk.version}</option>
                        ))}
                    </select>
                </div>
                <button
                    type="submit"
                    disabled={isSubmitting}
                    className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50"
                >
                    {isSubmitting ? 'Submitting...' : 'Submit Ticket'}
                </button>
            </form>
        </Card>
    );
};
// --- SUB-COMPONENTS FOR COMMUNITY & SUPPORT (end) ---

// --- SUB-COMPONENTS FOR USER SETTINGS (start) ---
/**
 * Component for managing general user preferences.
 * @param {object} props - Component props.
 * @param {UserPreferences} props.preferences - Current user preferences.
 * @param {function(UserPreferences): void} props.onPreferencesChange - Callback for preference changes.
 */
export const GeneralSettings: React.FC<{ preferences: UserPreferences; onPreferencesChange: (prefs: UserPreferences) => void }> = ({ preferences, onPreferencesChange }) => {
    const handleChange = useCallback((key: keyof UserPreferences, value: any) => {
        onPreferencesChange({ ...preferences, [key]: value });
    }, [preferences, onPreferencesChange]);

    return (
        <Card title="General Preferences">
            <div className="space-y-4 text-gray-300">
                <div>
                    <label className="block text-sm font-medium mb-1">Theme:</label>
                    <select
                        value={preferences.theme}
                        onChange={(e) => handleChange('theme', e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded text-white"
                    >
                        <option value="dark">Dark Mode</option>
                        <option value="light">Light Mode (not implemented)</option>
                    </select>
                </div>
                <div className="flex items-center">
                    <input
                        type="checkbox"
                        id="marketingEmails"
                        checked={preferences.receiveMarketingEmails}
                        onChange={(e) => handleChange('receiveMarketingEmails', e.target.checked)}
                        className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                    />
                    <label htmlFor="marketingEmails" className="ml-2 text-sm font-medium">Receive Marketing Emails</label>
                </div>
                <div className="flex items-center">
                    <input
                        type="checkbox"
                        id="sdkUpdateNotifications"
                        checked={preferences.receiveSdkUpdateNotifications}
                        onChange={(e) => handleChange('receiveSdkUpdateNotifications', e.target.checked)}
                        className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                    />
                    <label htmlFor="sdkUpdateNotifications" className="ml-2 text-sm font-medium">Receive SDK Update Notifications</label>
                </div>
                <div>
                    <label className="block text-sm font-medium mb-1">Favorite SDKs:</label>
                    <div className="flex flex-wrap gap-2">
                        {MOCK_SDKS.map(sdk => (
                            <label key={sdk.id} className="inline-flex items-center">
                                <input
                                    type="checkbox"
                                    checked={preferences.favoriteSdks.includes(sdk.id)}
                                    onChange={(e) => {
                                        const newFavorites = e.target.checked
                                            ? [...preferences.favoriteSdks, sdk.id]
                                            : preferences.favoriteSdks.filter(id => id !== sdk.id);
                                        handleChange('favoriteSdks', newFavorites);
                                    }}
                                    className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                />
                                <span className="ml-1 text-sm">{sdk.language}</span>
                            </label>
                        ))}
                    </div>
                </div>
            </div>
        </Card>
    );
};

/**
 * Component for managing API key settings.
 * @param {object} props - Component props.
 * @param {string} props.currentApiKey - The current API key.
 * @param {function(string): void} props.onApiKeyChange - Callback to update the API key.
 */
export const ApiKeySettings: React.FC<{ currentApiKey: string; onApiKeyChange: (key: string) => void }> = ({ currentApiKey, onApiKeyChange }) => {
    const [apiKey, setApiKey] = useState(currentApiKey);
    const [isRevealed, setIsRevealed] = useState(false);
    const { addToast } = useToastNotifications();

    const handleSave = () => {
        onApiKeyChange(apiKey);
        addToast('API Key updated successfully!', 'success');
    };

    const handleGenerateNew = () => {
        const newKey = `sk-demobank-new-${Math.random().toString(36).substring(2, 15)}`;
        setApiKey(newKey);
        onApiKeyChange(newKey);
        addToast('New API Key generated!', 'info');
    };

    return (
        <Card title="API Key Management">
            <div className="space-y-4 text-gray-300">
                <div>
                    <label className="block text-sm font-medium mb-1">Your API Key:</label>
                    <div className="flex items-center gap-2">
                        <input
                            type={isRevealed ? 'text' : 'password'}
                            value={apiKey}
                            onChange={(e) => setApiKey(e.target.value)}
                            className="flex-grow bg-gray-700/50 p-2 rounded text-white font-mono"
                        />
                        <button
                            onClick={() => setIsRevealed(!isRevealed)}
                            className="py-2 px-3 bg-gray-600/50 hover:bg-gray-600 rounded text-sm text-white"
                        >
                            {isRevealed ? 'Hide' : 'Show'}
                        </button>
                    </div>
                    <p className="text-xs text-gray-500 mt-1">Keep your API key secure. Do not expose it publicly.</p>
                </div>
                <div className="flex gap-4">
                    <button
                        onClick={handleSave}
                        className="flex-1 py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50"
                        disabled={apiKey === currentApiKey}
                    >
                        Save API Key
                    </button>
                    <button
                        onClick={handleGenerateNew}
                        className="flex-1 py-2 bg-red-700 hover:bg-red-800 rounded disabled:opacity-50"
                    >
                        Generate New Key
                    </button>
                </div>
            </div>
        </Card>
    );
};

// --- SUB-COMPONENTS FOR USER SETTINGS (end) ---

// --- MAIN APP VIEW / NAVIGATION (start) ---
type DashboardView = 'overview' | 'ai-lab' | 'documentation' | 'api-explorer' | 'community' | 'settings';

/**
 * Main SDK Downloads View component.
 * Expands significantly to include multiple sub-sections and advanced features.
 */
const SdkDownloadsView: React.FC = () => {
    // --- Global State Management ---
    const [currentView, setCurrentView] = useState<DashboardView>('overview');
    const [prompt, setPrompt] = useState('create a new payment order for $100');
    const [generatedCode, setGeneratedCode] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [selectedSdk, setSelectedSdk] = useState<Sdk | null>(null);
    const [showSdkDetail, setShowSdkDetail] = useState<Sdk | null>(null); // For detailed SDK view
    const [downloadHistory, setDownloadHistory] = useState<DownloadHistoryEntry[]>(MOCK_DOWNLOAD_HISTORY);
    const [savedPrompts, setSavedPrompts] = useState<SavedPrompt[]>([]);
    const [userPreferences, setUserPreferences] = useState<UserPreferences>(DEFAULT_USER_PREFERENCES);
    const [currentApiKey, setCurrentApiKey] = useState(APP_CONSTANTS.DEFAULT_API_KEY);
    const { toasts, addToast, dismissToast } = useToastNotifications();

    // --- AI Lab Specific States ---
    const [aiCurrentTool, setAiCurrentTool] = useState('code-gen');

    // --- Documentation Specific States ---
    const [activeDocPath, setActiveDocPath] = useState<string | null>('/docs/introduction');
    const [docContent, setDocContent] = useState<string>('');
    const [isDocLoading, setIsDocLoading] = useState(false);
    const [docSearchResults, setDocSearchResults] = useState<DocSearchResult[]>([]);

    // --- API Explorer Specific States ---
    const [apiEndpoints, setApiEndpoints] = useState<ApiEndpoint[]>([]);
    const [selectedApiEndpoint, setSelectedApiEndpoint] = useState<ApiEndpoint | null>(null);
    const [apiRequestHistory, setApiRequestHistory] = useState<ApiRequestHistoryEntry[]>([]);
    const [apiResponse, setApiResponse] = useState<ApiResponse<any> | null>(null);
    const [isApiRequestLoading, setIsApiRequestLoading] = useState(false);

    // --- Community Specific States ---
    const [forumThreads, setForumThreads] = useState<ForumThread[]>(MOCK_FORUM_THREADS);
    const [selectedForumThread, setSelectedForumThread] = useState<ForumThread | null>(null);

    // --- SDK Filtering and Sorting State ---
    const [sdkFilters, setSdkFilters] = useState<SdkFilterOptions>({
        language: '',
        platform: '',
        searchTerm: '',
        license: '',
    });
    const [sdkSort, setSdkSort] = useState<SdkSortOptions>({
        sortBy: 'lastUpdated',
        sortOrder: 'desc',
    });

    const filteredAndSortedSdks = useMemo(() => {
        let filtered = MOCK_SDKS.filter(sdk =>
            (sdkFilters.language === '' || sdk.language === sdkFilters.language) &&
            (sdkFilters.platform === '' || sdk.platform === sdkFilters.platform) &&
            (sdkFilters.license === '' || sdk.license === sdkFilters.license) &&
            (sdkFilters.searchTerm === '' ||
                sdk.language.toLowerCase().includes(sdkFilters.searchTerm.toLowerCase()) ||
                sdk.description.toLowerCase().includes(sdkFilters.searchTerm.toLowerCase()) ||
                sdk.packageName.toLowerCase().includes(sdkFilters.searchTerm.toLowerCase()))
        );

        if (sdkSort.sortBy !== 'none') {
            filtered.sort((a, b) => {
                let valA: any, valB: any;
                if (sdkSort.sortBy === 'name') {
                    valA = a.language.toLowerCase();
                    valB = b.language.toLowerCase();
                } else if (sdkSort.sortBy === 'version') {
                    valA = a.version.split('.').map(Number); // Simple version comparison
                    valB = b.version.split('.').map(Number);
                    for (let i = 0; i < Math.min(valA.length, valB.length); i++) {
                        if (valA[i] !== valB[i]) return (valA[i] - valB[i]) * (sdkSort.sortOrder === 'asc' ? 1 : -1);
                    }
                    return (valA.length - valB.length) * (sdkSort.sortOrder === 'asc' ? 1 : -1);
                } else if (sdkSort.sortBy === 'stars') {
                    valA = a.stars;
                    valB = b.stars;
                } else if (sdkSort.sortBy === 'lastUpdated') {
                    valA = new Date(a.lastUpdated).getTime();
                    valB = new Date(b.lastUpdated).getTime();
                } else {
                    return 0;
                }

                if (typeof valA === 'string' && typeof valB === 'string') {
                    return valA.localeCompare(valB) * (sdkSort.sortOrder === 'asc' ? 1 : -1);
                } else {
                    return (valA - valB) * (sdkSort.sortOrder === 'asc' ? 1 : -1);
                }
            });
        }
        return filtered;
    }, [MOCK_SDKS, sdkFilters, sdkSort]);

    // --- Effects & Handlers ---

    // Initial load for API endpoints for Explorer
    useEffect(() => {
        const fetchEndpoints = async () => {
            const response = await mockApiClient.fetchApiEndpoints();
            if (response.success && response.data) {
                setApiEndpoints(response.data);
            }
        };
        fetchEndpoints();
    }, []);

    // Effect to handle theme changes
    useEffect(() => {
        document.documentElement.className = userPreferences.theme === 'dark' ? 'dark' : '';
        // In a real app, you might apply more specific classes or CSS variables
    }, [userPreferences.theme]);

    /**
     * Handles AI code generation.
     * @async
     */
    const handleGenerate = async () => {
        if (!selectedSdk) {
            addToast('Please select an SDK first.', 'error');
            return;
        }
        setIsLoading(true);
        setGeneratedCode('');
        try {
            const ai = new GoogleGenAI({ apiKey: currentApiKey });
            const fullPrompt = `As an expert ${userPreferences.aiConfig.defaultPersona} for Demobank integrations, generate a code snippet in ${selectedSdk.language} using the 'demobank' SDK to accomplish the following task: "${prompt}".
            Consider the following context and SDK version:
            - SDK Language: ${selectedSdk.language}
            - SDK Version: ${selectedSdk.version}
            - SDK Description: ${selectedSdk.description}
            - Installation Command: \`${selectedSdk.installationCmd}\`
            - Package Name: \`${selectedSdk.packageName}\`
            - Key dependencies: ${selectedSdk.dependencies.join(', ') || 'None'}
            - Supported frameworks: ${selectedSdk.supportedFrameworks.join(', ') || 'N/A'}

            Provide a complete, runnable code example if possible, including imports and basic error handling.
            Ensure the code is idiomatic for ${selectedSdk.language}.
            Output should be only the code block, no extra conversational text outside of comments in the code.`;

            const response = await ai.models.generateContent({
                model: userPreferences.aiConfig.model,
                contents: fullPrompt,
                generationConfig: {
                    temperature: userPreferences.aiConfig.temperature,
                    maxOutputTokens: userPreferences.aiConfig.maxTokens
                }
            });

            const rawText = response.text || '';
            const cleanedCode = rawText.replace(/```[a-zA-Z]*\n|```/g, '').trim();
            setGeneratedCode(cleanedCode);
            addToast('Code snippet generated successfully!', 'success');
        } catch (error) {
            console.error('AI generation error:', error);
            setGeneratedCode("Error: Could not generate code snippet. Please check your API key and try again.");
            addToast('Failed to generate code snippet. Check your API key and prompt.', 'error');
        } finally {
            setIsLoading(false);
        }
    };

    /**
     * Saves the current prompt and generated code to the prompt library.
     */
    const handleSavePrompt = () => {
        if (!selectedSdk || !prompt.trim() || !generatedCode.trim()) {
            addToast('Cannot save empty or incomplete snippet.', 'warning');
            return;
        }
        const newPrompt: SavedPrompt = {
            id: `saved_${Date.now()}`,
            prompt: prompt,
            generatedCode: generatedCode,
            sdkId: selectedSdk.id,
            language: selectedSdk.language,
            timestamp: new Date().toISOString(),
            tags: ['custom', selectedSdk.language.toLowerCase()] // Auto-tagging
        };
        setSavedPrompts(prev => {
            const updated = [newPrompt, ...prev];
            return updated.slice(0, APP_CONSTANTS.MAX_PROMPT_HISTORY); // Keep history limited
        });
        addToast('Code snippet saved to library!', 'success');
    };

    /**
     * Loads a saved prompt into the generator.
     * @param {SavedPrompt} saved - The saved prompt to load.
     */
    const handleLoadSavedPrompt = (saved: SavedPrompt) => {
        setPrompt(saved.prompt);
        setGeneratedCode(saved.generatedCode);
        const sdk = MOCK_SDKS.find(s => s.id === saved.sdkId);
        if (sdk) {
            setSelectedSdk(sdk);
        } else {
            addToast(`SDK "${saved.sdkId}" not found for this snippet.`, 'warning');
        }
        addToast(`Loaded prompt: "${saved.prompt.substring(0, 30)}..."`, 'info');
        setAiCurrentTool('code-gen'); // Switch to code gen tab
    };

    /**
     * Deletes a saved prompt from the library.
     * @param {string} id - The ID of the prompt to delete.
     */
    const handleDeleteSavedPrompt = (id: string) => {
        setSavedPrompts(prev => prev.filter(p => p.id !== id));
        addToast('Code snippet deleted.', 'info');
    };

    /**
     * Handles SDK download action.
     * @param {Sdk} sdk - The SDK to download.
     * @async
     */
    const handleSdkDownload = async (sdk: Sdk) => {
        addToast(`Attempting to download ${sdk.language} SDK...`, 'info', 3000);
        const result = await mockApiClient.downloadSdk(sdk.id);
        if (result.success && result.data) {
            addToast(`Download initiated for ${sdk.language} SDK v${sdk.version}!`, 'success');
            const newHistoryEntry: DownloadHistoryEntry = {
                sdkId: sdk.id,
                sdkVersion: sdk.version,
                timestamp: new Date().toISOString(),
                downloadUrl: result.data.downloadUrl,
                os: navigator.platform,
                browser: navigator.userAgent,
                ipAddress: '192.168.1.XX' // Mocked IP
            };
            setDownloadHistory(prev => [newHistoryEntry, ...prev]);
        } else {
            addToast(`Failed to download ${sdk.language} SDK: ${result.message}`, 'error');
        }
    };

    /**
     * Handles API request execution in the explorer.
     * @param {ApiRequestPayload} request - The request payload.
     * @async
     */
    const handleApiRequestExecute = async (request: ApiRequestPayload) => {
        setIsApiRequestLoading(true);
        setApiResponse(null);
        addToast(`Executing ${request.method} request to ${new URL(request.url).pathname.replace('/api', '')}...`, 'info', 3000);
        try {
            const result = await mockApiClient.executeApiRequest(request);
            setApiResponse(result);
            setApiRequestHistory(prev => [{ id: `hist_${Date.now()}`, request, response: result, timestamp: new Date().toISOString() }, ...prev].slice(0, 20)); // Limit history
            if (result.success) {
                addToast('API request executed successfully.', 'success');
            } else {
                addToast(`API request failed: ${result.message}`, 'error');
            }
        } catch (error: any) {
            console.error('API request execution error:', error);
            setApiResponse({ success: false, message: error.message || 'Network error.', data: null, errorCode: 'NETWORK_ERROR' });
            addToast(`API request failed: ${error.message || 'Network error.'}`, 'error');
        } finally {
            setIsApiRequestLoading(false);
        }
    };

    /**
     * Handles selection of a documentation path.
     * @param {string} path - The path to the documentation.
     * @async
     */
    const handleSelectDocPath = async (path: string) => {
        setIsDocLoading(true);
        setActiveDocPath(path);
        setDocSearchResults([]); // Clear search results when navigating
        try {
            const response = await mockApiClient.fetchDocumentationContent(path);
            if (response.success && response.data) {
                setDocContent(response.data);
            } else {
                setDocContent(`# Error Loading Document\n\n${response.message}`);
                addToast(response.message, 'error');
            }
        } catch (error: any) {
            setDocContent(`# Error Loading Document\n\n${error.message || 'Unknown error.'}`);
            addToast('Failed to fetch documentation content.', 'error');
        } finally {
            setIsDocLoading(false);
        }
    };

    /**
     * Handles documentation search.
     * @param {string} query - The search query.
     * @async
     */
    const handleDocSearch = async (query: string) => {
        setIsDocLoading(true);
        try {
            const response = await mockApiClient.searchDocumentation(query);
            if (response.success && response.data) {
                setDocSearchResults(response.data);
            } else {
                addToast(response.message, 'error');
            }
        } catch (error: any) {
            addToast('Failed to perform documentation search.', 'error');
        } finally {
            setIsDocLoading(false);
        }
    };

    // Initialize default doc content on first render
    useEffect(() => {
        if (activeDocPath && !docContent && !isDocLoading) {
            handleSelectDocPath(activeDocPath);
        }
    }, [activeDocPath, docContent, isDocLoading]); // eslint-disable-line react-hooks/exhaustive-deps

    return (
        <div className="space-y-6 min-h-screen pb-12">
            <h1 className="text-4xl font-bold text-white tracking-wider">Developer Dashboard</h1>

            {/* Main Navigation Tabs */}
            <div className="border-b border-gray-700 mb-8">
                <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                    {[
                        { id: 'overview', name: 'SDK Overview' },
                        { id: 'ai-lab', name: 'AI Code Lab' },
                        { id: 'documentation', name: 'Documentation' },
                        { id: 'api-explorer', name: 'API Explorer' },
                        { id: 'community', name: 'Community & Support' },
                        { id: 'settings', name: 'Settings' },
                    ].map((tab) => (
                        <button
                            key={tab.id}
                            onClick={() => setCurrentView(tab.id as DashboardView)}
                            className={`whitespace-nowrap py-3 px-1 border-b-2 font-medium text-lg focus:outline-none transition-colors duration-200
                                        ${currentView === tab.id
                                    ? 'border-cyan-500 text-cyan-400'
                                    : 'border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500'}`
                            }
                        >
                            {tab.name}
                        </button>
                    ))}
                </nav>
            </div>

            {/* --- SDK Overview View --- */}
            {currentView === 'overview' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">SDK Downloads & Discovery</h2>
                    <SdkFilterAndSort
                        filters={sdkFilters}
                        onFiltersChange={setSdkFilters}
                        sort={sdkSort}
                        onSortChange={setSdkSort}
                    />
                    <Card title="Available SDKs">
                        <p className="text-gray-400 mb-6">Integrate Demo Bank into your application with our official SDKs.</p>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                            {filteredAndSortedSdks.map(sdk => (
                                <Card key={sdk.id} variant="interactive" className="text-center group flex flex-col justify-between">
                                    <div>
                                        <h3 className="text-xl font-semibold text-white">{sdk.language}</h3>
                                        <p className="text-sm text-gray-400">v{sdk.version}</p>
                                        <p className="text-xs text-gray-500 mt-2 line-clamp-3">{sdk.description}</p>
                                    </div>
                                    <div className="mt-4 flex flex-col gap-2">
                                        <button onClick={() => handleSdkDownload(sdk)} className="w-full py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-sm">Download</button>
                                        <button onClick={() => setSelectedSdk(sdk)} className="w-full py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">AI Code Gen</button>
                                        <button onClick={() => setShowSdkDetail(sdk)} className="w-full py-2 bg-gray-700/50 hover:bg-gray-700 text-white rounded-lg text-sm">Details</button>
                                    </div>
                                </Card>
                            ))}
                        </div>
                        {filteredAndSortedSdks.length === 0 && (
                            <p className="text-gray-400 text-center py-8">No SDKs match your current filters and search term.</p>
                        )}
                    </Card>

                    {showSdkDetail && (
                        <SdkDetailView
                            sdk={showSdkDetail}
                            onClose={() => setShowSdkDetail(null)}
                            onDownload={handleSdkDownload}
                            onSelectForAi={(sdk) => { setSelectedSdk(sdk); setCurrentView('ai-lab'); setAiCurrentTool('code-gen'); setShowSdkDetail(null); }}
                        />
                    )}

                    <div className="flex flex-wrap gap-6">
                        <SdkDownloadHistory history={downloadHistory} />
                        {/* Could add another analytics card here for more code */}
                        <Card title="SDK Quick Stats" className="flex-1 min-w-[300px]">
                            <p className="text-gray-400 mb-4">Overall SDK usage and popularity trends.</p>
                            <div className="grid grid-cols-2 gap-4 text-sm">
                                <div>
                                    <p className="text-gray-500">Total SDKs</p>
                                    <p className="text-white text-xl font-bold">{MOCK_SDKS.length}</p>
                                </div>
                                <div>
                                    <p className="text-gray-500">Most Popular</p>
                                    <p className="text-white text-xl font-bold">{MOCK_SDKS.reduce((prev, current) => (prev.stars > current.stars ? prev : current)).language}</p>
                                </div>
                                <div>
                                    <p className="text-gray-500">Avg. Daily Downloads</p>
                                    <p className="text-white text-xl font-bold">~{Math.round(MOCK_DOWNLOAD_HISTORY.length / 30)}</p> {/* Mock for 30 days */}
                                </div>
                                <div>
                                    <p className="text-gray-500">Avg. Download Speed</p>
                                    <p className="text-white text-xl font-bold">~{(MOCK_SDKS.reduce((acc, sdk) => acc + sdk.avgDownloadTimeMs, 0) / MOCK_SDKS.length / 1000).toFixed(1)}s</p>
                                </div>
                            </div>
                        </Card>
                    </div>
                </>
            )}

            {/* --- AI Code Lab View --- */}
            {currentView === 'ai-lab' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">AI Code Lab</h2>

                    <AiToolSelector currentTool={aiCurrentTool} onSelectTool={setAiCurrentTool} />

                    {/* AI Code Generator (original functionality, expanded) */}
                    {aiCurrentTool === 'code-gen' && (
                        <Card title={`AI Code Generator for ${selectedSdk?.language || 'Any SDK'}`}>
                            {selectedSdk && (
                                <button onClick={() => setSelectedSdk(null)} className="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl" title="Clear selected SDK">&times;</button>
                            )}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div className="space-y-3">
                                    <label className="text-sm font-medium text-gray-300">Selected SDK:</label>
                                    <div className="relative">
                                        <select
                                            value={selectedSdk?.id || ''}
                                            onChange={e => setSelectedSdk(MOCK_SDKS.find(s => s.id === e.target.value) || null)}
                                            className="w-full bg-gray-700/50 p-2 rounded text-white appearance-none pr-8"
                                        >
                                            <option value="" disabled>-- Select an SDK --</option>
                                            {MOCK_SDKS.map(sdk => (
                                                <option key={sdk.id} value={sdk.id}>{sdk.language} v{sdk.version}</option>
                                            ))}
                                        </select>
                                        <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                                            <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                                        </div>
                                    </div>
                                    <label className="text-sm font-medium text-gray-300">Describe what you want to do:</label>
                                    <input type="text" value={prompt} onChange={e => setPrompt(e.target.value)} className="w-full bg-gray-700/50 p-2 rounded text-white" />
                                    <div className="flex gap-2">
                                        <button onClick={handleGenerate} disabled={isLoading || !selectedSdk || !prompt.trim()} className="flex-grow py-2 bg-cyan-600 hover:bg-cyan-700 rounded disabled:opacity-50">
                                            {isLoading ? 'Generating...' : 'Generate Code'}
                                        </button>
                                        <button onClick={handleSavePrompt} disabled={!generatedCode.trim()} className="py-2 px-4 bg-gray-600/50 hover:bg-gray-600 rounded text-white disabled:opacity-50" title="Save this snippet">
                                            Save
                                        </button>
                                    </div>
                                </div>
                                <div className="bg-gray-900/50 p-4 rounded-lg max-h-60 overflow-auto">
                                    <pre className="text-xs text-gray-300 whitespace-pre-wrap font-mono">
                                        {isLoading ? 'Generating...' : (generatedCode || 'Generated code will appear here.')}
                                    </pre>
                                </div>
                            </div>
                        </Card>
                    )}

                    {aiCurrentTool === 'code-review' && <CodeReviewAssistant selectedSdk={selectedSdk} aiConfig={userPreferences.aiConfig} />}
                    {aiCurrentTool === 'test-gen' && <TestCaseGenerator selectedSdk={selectedSdk} aiConfig={userPreferences.aiConfig} />}
                    {aiCurrentTool === 'deploy-script' && <DeploymentScriptGenerator selectedSdk={selectedSdk} aiConfig={userPreferences.aiConfig} />}
                    {aiCurrentTool === 'prompt-library' && <PromptLibrary savedPrompts={savedPrompts} onSelectPrompt={handleLoadSavedPrompt} onDeletePrompt={handleDeleteSavedPrompt} />}
                    {aiCurrentTool === 'settings' && (
                        <AiSettingsPanel
                            aiConfig={userPreferences.aiConfig}
                            onConfigChange={(newConfig) => setUserPreferences(prev => ({ ...prev, aiConfig: newConfig }))}
                        />
                    )}
                </>
            )}

            {/* --- Documentation View --- */}
            {currentView === 'documentation' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Documentation Hub</h2>
                    <DocSearch onSearch={handleDocSearch} searchResults={docSearchResults} isLoading={isDocLoading} onSelectResult={handleSelectDocPath} />
                    <div className="flex flex-col lg:flex-row gap-6">
                        <DocNavigationTree docsStructure={MOCK_DOCS_STRUCTURE} activePath={activeDocPath} onSelectPath={handleSelectDocPath} />
                        <DocContentDisplay content={docContent} title={activeDocPath || 'Documentation'} isLoading={isDocLoading} />
                    </div>
                </>
            )}

            {/* --- API Explorer View --- */}
            {currentView === 'api-explorer' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">API Explorer & Tester</h2>
                    <div className="flex flex-col lg:flex-row gap-6">
                        <ApiEndpointSelector endpoints={apiEndpoints} selectedEndpoint={selectedApiEndpoint} onSelectEndpoint={setSelectedApiEndpoint} />
                        <div className="flex flex-col flex-grow gap-6">
                            <ApiRequestEditor endpoint={selectedApiEndpoint} onRequestExecute={handleApiRequestExecute} isLoading={isApiRequestLoading} />
                            <ApiResponseViewer response={apiResponse} isLoading={isApiRequestLoading} />
                        </div>
                        <ApiRequestHistory history={apiRequestHistory} onReplayRequest={handleApiRequestExecute} onDeleteHistoryEntry={(id) => setApiRequestHistory(prev => prev.filter(entry => entry.id !== id))} />
                    </div>
                </>
            )}

            {/* --- Community & Support View --- */}
            {currentView === 'community' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Community & Support</h2>
                    {selectedForumThread ? (
                        <ForumThreadViewer thread={selectedForumThread} onBack={() => setSelectedForumThread(null)} />
                    ) : (
                        <div className="flex flex-col lg:flex-row gap-6">
                            <ForumThreadList threads={forumThreads} onViewThread={setSelectedForumThread} />
                            <div className="flex flex-col gap-6 flex-1 min-w-[300px]">
                                <FaqAccordion faqs={MOCK_FAQS} />
                                <SupportTicketForm onSubmitTicket={mockApiClient.submitSupportTicket} />
                            </div>
                        </div>
                    )}
                </>
            )}

            {/* --- Settings View --- */}
            {currentView === 'settings' && (
                <>
                    <h2 className="text-3xl font-bold text-white tracking-wider mb-6">User Settings</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <GeneralSettings preferences={userPreferences} onPreferencesChange={setUserPreferences} />
                        <ApiKeySettings currentApiKey={currentApiKey} onApiKeyChange={setCurrentApiKey} />
                        <AiSettingsPanel // AI settings can also be accessed from here
                            aiConfig={userPreferences.aiConfig}
                            onConfigChange={(newConfig) => setUserPreferences(prev => ({ ...prev, aiConfig: newConfig }))}
                        />
                        {/* Could add a 'Billing & Plans' or 'Integrations' settings card here */}
                        <Card title="Account & Profile">
                            <p className="text-gray-400 mb-4">Manage your personal account details.</p>
                            <div className="space-y-3">
                                <label className="block text-sm font-medium text-gray-300">Username:</label>
                                <input type="text" value="developer_user" readOnly className="w-full bg-gray-700/50 p-2 rounded text-white" />
                                <label className="block text-sm font-medium text-gray-300">Email:</label>
                                <input type="email" value="developer@demobank.com" readOnly className="w-full bg-gray-700/50 p-2 rounded text-white" />
                                <button className="w-full py-2 bg-gray-600/50 hover:bg-gray-600 text-white rounded-lg text-sm">Update Profile</button>
                                <button className="w-full py-2 bg-red-700 hover:bg-red-800 text-white rounded-lg text-sm mt-4">Delete Account</button>
                            </div>
                        </Card>
                    </div>
                </>
            )}

            {/* Global Notifications */}
            <NotificationStack toasts={toasts} onDismiss={dismissToast} />
        </div>
    );
};

export default SdkDownloadsView;

--- FILE: WebhooksView.tsx ---

// components/views/megadashboard/developer/WebhooksView.tsx
import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";
import { v4 as uuidv4 } from 'uuid';
import { debounce } from 'lodash'; // Assuming lodash is available or will be installed

// New Interfaces to support a real-world application with extensive features
export interface Webhook {
    id: string;
    url: string;
    status: 'Active' | 'Disabled' | 'Paused';
    events: string[];
    description: string;
    secret: string; // Stored securely, often masked in UI
    createdAt: string;
    updatedAt: string;
    lastEventSentAt?: string;
    deliveryMetrics: {
        totalAttempts: number;
        successfulDeliveries: number;
        failedDeliveries: number;
        avgLatencyMs: number;
    };
    retryPolicy: {
        maxRetries: number;
        initialIntervalSeconds: number;
        multiplier: number;
        maxIntervalSeconds: number;
    };
    headers: { key: string; value: string; id: string; }[];
    authConfig: {
        type: 'none' | 'basic' | 'bearer';
        username?: string;
        password?: string; // Stored securely
        token?: string; // Stored securely
    };
    sslVerificationEnabled: boolean;
    metadata: { [key: string]: string };
    ownerId: string; // The user or service that created it
    environment: 'development' | 'staging' | 'production';
    tags: string[];
}

export interface WebhookEvent {
    id: string;
    webhookId: string;
    type: string;
    status: 'Delivered' | 'Failed' | 'Pending' | 'Retrying';
    payload: object;
    error?: string;
    timestamp: string;
    deliveryAttempts: {
        attempt: number;
        status: 'Success' | 'Failure';
        responseStatus?: number;
        responseText?: string;
        latencyMs: number;
        timestamp: string;
        errorDetails?: string;
    }[];
    externalRef?: string; // e.g., transaction ID
    metadata: { [key: string]: string };
}

export interface WebhookSettings {
    maxRetries: number;
    retryIntervalSeconds: number[]; // e.g., [60, 300, 900] for 1min, 5min, 15min
    timeoutMs: number;
    secretSigningEnabled: boolean;
    deliveryAttemptsLoggingEnabled: boolean;
    defaultHeaders: { key: string; value: string; id: string; }[];
    ipWhitelist: string[];
    rateLimitEnabled: boolean;
    rateLimitRequestsPerMinute: number;
    eventTransformationEnabled: boolean;
    customCertsEnabled: boolean;
    customCertificates: { id: string; name: string; cert: string; expiration: string; }[];
    deadLetterQueueEnabled: boolean;
    deadLetterQueueConfig?: {
        type: 's3' | 'kafka';
        target: string; // e.g., S3 bucket name or Kafka topic
        accessKeyId?: string;
        secretAccessKey?: string;
    };
    globalMonitoringEnabled: boolean;
    webhookBatchingEnabled: boolean;
    batchingIntervalMs?: number;
    batchingMaxEvents?: number;
}

export interface ApiKey {
    id: string;
    name: string;
    key: string; // The actual key (might be masked)
    createdAt: string;
    expiresAt?: string;
    permissions: string[]; // e.g., ['webhook:read', 'webhook:write', 'event:read']
    status: 'Active' | 'Revoked';
    lastUsedAt?: string;
    createdBy: string;
}

export interface AlertRule {
    id: string;
    name: string;
    type: 'webhook_failure_rate' | 'event_latency' | 'delivery_success_rate' | 'endpoint_down' | 'custom_metric';
    threshold: number; // percentage or ms or custom value
    durationMinutes: number; // time window to check threshold
    webhookId?: string; // specific webhook or global
    status: 'Active' | 'Inactive';
    channels: { type: 'email' | 'slack' | 'sms' | 'pagerduty'; recipient: string; id: string; }[];
    severity: 'Low' | 'Medium' | 'High' | 'Critical';
    metricPath?: string; // For custom_metric type, e.g., '$.payload.amount'
    operator?: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
    condition?: 'all' | 'any'; // all channels or any channel
}

export interface AuditLogEntry {
    id: string;
    timestamp: string;
    actor: string; // User ID or system
    action: string; // e.g., 'webhook.created', 'webhook.updated', 'api_key.revoked'
    resourceType: 'webhook' | 'api_key' | 'settings' | 'event' | 'alert_rule';
    resourceId: string;
    details: object; // Old and new values, specific changes, IP address, user agent
    ipAddress?: string;
    userAgent?: string;
}

export interface WebhookFormData {
    id?: string;
    url: string;
    events: string[];
    status: 'Active' | 'Disabled' | 'Paused';
    description: string;
    secret: string; // for signing, can be empty
    headers: { key: string; value: string; id: string; }[];
    authType: 'none' | 'basic' | 'bearer';
    authToken?: string; // for bearer/basic
    username?: string; // for basic auth
    password?: string; // for basic auth
    sslVerificationEnabled: boolean;
    retryPolicy: {
        maxRetries: number;
        initialIntervalSeconds: number;
        multiplier: number;
        maxIntervalSeconds: number;
    };
    metadata: { key: string; value: string; id: string; }[];
    environment: 'development' | 'staging' | 'production';
    tags: string[];
}

export interface AnalyticsSummary {
    totalEndpoints: number;
    activeEndpoints: number;
    disabledEndpoints: number;
    totalEventsDelivered24h: number;
    failureRate24h: number; // percentage
    avgLatencyMs24h: number;
    pendingEvents: number;
    retryingEvents: number;
    topFailedEndpoints: { id: string; url: string; failures: number; }[];
    eventDistribution: { type: string; count: number; }[];
    latencyP99Ms: number;
    totalEventsProcessedMonth: number;
    successfulEventsMonth: number;
    failedEventsMonth: number;
}

export interface ChartDataPoint {
    time: string;
    value: number;
    label?: string;
    color?: string;
}

export interface ChartConfig {
    id: string;
    title: string;
    type: 'line' | 'bar' | 'pie';
    data: ChartDataPoint[];
    unit?: string;
    timeframe?: 'hourly' | 'daily' | 'weekly' | 'monthly';
    description?: string;
}

export interface PaginationInfo {
    currentPage: number;
    itemsPerPage: number;
    totalItems: number;
    totalPages: number;
}

export interface FilterOptions {
    searchTerm?: string;
    status?: string;
    eventType?: string;
    timeRange?: string;
    severity?: string;
    actor?: string;
    resourceType?: string;
}

export interface EventReplayConfig {
    webhookIds: string[];
    eventTypes: string[];
    statusFilter?: 'Failed' | 'Delivered' | 'All';
    dateRange: { start: string; end: string; };
    maxEvents: number;
    batchSize: number;
    dryRun: boolean;
}

export interface TestEventConfig {
    webhookId?: string; // Optional, can test against a specific one or all matching events
    eventType: string;
    payload: object;
    headers: { key: string; value: string; id: string; }[];
    metadata: { key: string; value: string; id: string; }[];
    expectedResponseStatus?: number;
    timeoutMs?: number;
}

// --- MOCK DATA GENERATION ---
const generateMockWebhook = (idSuffix: number): Webhook => {
    const statusOptions: ('Active' | 'Disabled' | 'Paused')[] = ['Active', 'Disabled', 'Paused'];
    const eventsOptions = ['transaction.created', 'payment.updated', 'user.created', 'user.updated', 'order.placed', 'invoice.paid', 'email.sent'];
    const selectedEvents = Array.from({ length: Math.floor(Math.random() * 3) + 1 }).map(() => eventsOptions[Math.floor(Math.random() * eventsOptions.length)]);
    const secret = uuidv4().replace(/-/g, '').substring(0, 32);
    const authTypes: ('none' | 'basic' | 'bearer')[] = ['none', 'basic', 'bearer'];
    const authType = authTypes[Math.floor(Math.random() * authTypes.length)];

    return {
        id: `wh-${idSuffix}`,
        url: `https://api.example.com/hooks/service-${idSuffix}`,
        status: statusOptions[Math.floor(Math.random() * statusOptions.length)],
        events: selectedEvents.length > 0 ? Array.from(new Set(selectedEvents)) : ['*'],
        description: `Webhook for ${Math.random() > 0.5 ? 'critical' : 'analytical'} events related to service ${idSuffix}.`,
        secret: `whsec_${secret}`,
        createdAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(), // Last 30 days
        updatedAt: new Date().toISOString(),
        lastEventSentAt: Math.random() > 0.3 ? new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000).toISOString() : undefined,
        deliveryMetrics: {
            totalAttempts: Math.floor(Math.random() * 1000000),
            successfulDeliveries: Math.floor(Math.random() * 990000) + 1000,
            failedDeliveries: Math.floor(Math.random() * 5000),
            avgLatencyMs: Math.floor(Math.random() * 300) + 50,
        },
        retryPolicy: {
            maxRetries: Math.floor(Math.random() * 5) + 3,
            initialIntervalSeconds: 60,
            multiplier: 2,
            maxIntervalSeconds: 3600,
        },
        headers: [
            { id: uuidv4(), key: 'Content-Type', value: 'application/json' },
            { id: uuidv4(), key: 'X-Request-ID', value: `req-${uuidv4()}` },
        ],
        authConfig: authType === 'basic' ? { type: 'basic', username: `user-${idSuffix}`, password: 'password123' } :
                    authType === 'bearer' ? { type: 'bearer', token: `sk_bearer_${uuidv4().replace(/-/g, '')}` } :
                    { type: 'none' },
        sslVerificationEnabled: Math.random() > 0.1,
        metadata: { 'project': `project-${Math.floor(Math.random() * 3) + 1}`, 'cost_center': `CC-${Math.floor(Math.random() * 100)}` },
        ownerId: `user-${Math.floor(Math.random() * 5) + 1}`,
        environment: Math.random() > 0.7 ? 'production' : (Math.random() > 0.5 ? 'staging' : 'development'),
        tags: Math.random() > 0.5 ? ['billing', 'payments'] : ['analytics', 'monitoring'],
    };
};

const generateMockEvent = (webhook: Webhook, idSuffix: number, isFailed?: boolean): WebhookEvent => {
    const eventTypes = webhook.events[0] === '*' ? ['transaction.created', 'payment.updated', 'user.created', 'order.placed'] : webhook.events;
    const type = eventTypes[Math.floor(Math.random() * eventTypes.length)];
    const status: 'Delivered' | 'Failed' | 'Pending' | 'Retrying' = isFailed ? 'Failed' : (Math.random() > 0.95 ? 'Failed' : 'Delivered');
    const timestamp = new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(); // Last 7 days

    const attempts = [];
    let currentStatus: 'Success' | 'Failure' = 'Failure';
    for (let i = 1; i <= (status === 'Failed' ? Math.floor(Math.random() * 3) + 1 : 1); i++) {
        const attemptStatus = (i === (status === 'Delivered' ? 1 : 0) || (status === 'Failed' && i === webhook.retryPolicy.maxRetries)) ? (status === 'Delivered' ? 'Success' : 'Failure') : 'Failure';
        currentStatus = attemptStatus;
        attempts.push({
            attempt: i,
            status: attemptStatus,
            responseStatus: attemptStatus === 'Success' ? 200 : (Math.random() > 0.5 ? 500 : 408),
            responseText: attemptStatus === 'Success' ? 'OK' : (Math.random() > 0.5 ? 'Internal Server Error' : 'Gateway Timeout'),
            latencyMs: Math.floor(Math.random() * 500) + 100,
            timestamp: new Date(new Date(timestamp).getTime() + i * 10000).toISOString(),
            errorDetails: attemptStatus === 'Failure' ? (Math.random() > 0.5 ? 'Connection refused' : 'SSL handshake failed') : undefined,
        });
    }

    return {
        id: `evt-${idSuffix}`,
        webhookId: webhook.id,
        type: type,
        status: status,
        payload: {
            id: `payload_${uuidv4().substring(0, 8)}`,
            amount: Math.floor(Math.random() * 10000) / 100,
            currency: 'USD',
            userId: `user_${uuidv4().substring(0, 6)}`,
            timestamp: new Date().toISOString(),
        },
        error: status === 'Failed' ? (currentStatus === 'Failure' ? attempts[attempts.length - 1]?.errorDetails : undefined) : undefined,
        timestamp: timestamp,
        deliveryAttempts: attempts,
        externalRef: uuidv4().substring(0, 10),
        metadata: { 'correlationId': uuidv4() },
    };
};

const MOCK_WEBHOOKS_COUNT = 50;
const MOCK_EVENTS_COUNT = 1000;

const initialWebhooks: Webhook[] = Array.from({ length: MOCK_WEBHOOKS_COUNT }).map((_, i) => generateMockWebhook(i + 1));
const initialEvents: WebhookEvent[] = Array.from({ length: MOCK_EVENTS_COUNT }).map((_, i) => {
    const randomWebhook = initialWebhooks[Math.floor(Math.random() * initialWebhooks.length)];
    const isFailed = i % 5 === 0; // Roughly 20% failed events
    return generateMockEvent(randomWebhook, i + 1, isFailed);
});


const MOCK_API_KEYS: ApiKey[] = [
    { id: 'ak-1', name: 'Default App Key', key: 'sk_live_abc123... (masked)', createdAt: '2023-01-01T10:00:00Z', permissions: ['webhook:*', 'event:read', 'alert:write'], status: 'Active', lastUsedAt: '2024-07-20T14:30:00Z', createdBy: 'admin' },
    { id: 'ak-2', name: 'Analytics Service Key', key: 'sk_test_def456... (masked)', createdAt: '2023-03-15T11:00:00Z', expiresAt: '2025-03-15T11:00:00Z', permissions: ['event:read'], status: 'Active', createdBy: 'dev-team' },
    { id: 'ak-3', name: 'Revoked Key for Old Service', key: 'sk_live_ghi789... (masked)', createdAt: '2023-06-01T12:00:00Z', permissions: ['webhook:read'], status: 'Revoked', createdBy: 'admin' },
];

const MOCK_ALERT_RULES: AlertRule[] = [
    { id: 'ar-1', name: 'High Failure Rate (Global)', type: 'webhook_failure_rate', threshold: 5, durationMinutes: 10, status: 'Active', channels: [{ id: uuidv4(), type: 'email', recipient: 'devops@example.com' }, { id: uuidv4(), type: 'slack', recipient: '#alerts-webhooks' }], severity: 'High' },
    { id: 'ar-2', name: 'Endpoint Latency Spike (wh-1)', type: 'event_latency', threshold: 500, durationMinutes: 5, webhookId: initialWebhooks[0].id, status: 'Active', channels: [{ id: uuidv4(), type: 'slack', recipient: '#alerts-webhook-demobank' }], severity: 'Medium' },
    { id: 'ar-3', name: 'Prod Env 500 Errors', type: 'custom_metric', threshold: 10, durationMinutes: 15, status: 'Active', channels: [{ id: uuidv4(), type: 'pagerduty', recipient: 'critical-alerts' }], severity: 'Critical', metricPath: 'responseStatus', operator: 'gte' },
];

const MOCK_AUDIT_LOGS: AuditLogEntry[] = Array.from({ length: 200 }).map((_, i) => {
    const actions = ['webhook.created', 'webhook.updated', 'webhook.deleted', 'api_key.created', 'api_key.revoked', 'settings.updated', 'alert_rule.created', 'event.replay'];
    const resourceTypes = ['webhook', 'api_key', 'settings', 'event', 'alert_rule'];
    const actor = Math.random() > 0.5 ? 'user_admin' : 'user_dev';
    const action = actions[Math.floor(Math.random() * actions.length)];
    const resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
    const resourceId = uuidv4().substring(0, 8);
    const timestamp = new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000).toISOString(); // Last 60 days
    const details = {
        action,
        resourceType,
        resourceId,
        change: Math.random() > 0.5 ? { 'oldValue': 'some', 'newValue': 'other' } : {},
    };
    return { id: `log-${i + 1}`, timestamp, actor, action, resourceType, resourceId, details, ipAddress: `192.168.1.${Math.floor(Math.random() * 255)}`, userAgent: `Mozilla/5.0 (${Math.random() > 0.5 ? 'Macintosh' : 'Windows'})` };
});

const MOCK_ANALYTICS_SUMMARY: AnalyticsSummary = {
    totalEndpoints: initialWebhooks.length,
    activeEndpoints: initialWebhooks.filter(w => w.status === 'Active').length,
    disabledEndpoints: initialWebhooks.filter(w => w.status === 'Disabled').length,
    totalEventsDelivered24h: 1_500_000,
    failureRate24h: 0.2, // 0.2%
    avgLatencyMs24h: 120,
    pendingEvents: 1234,
    retryingEvents: 567,
    topFailedEndpoints: initialWebhooks.filter(w => w.deliveryMetrics.failedDeliveries > 100).sort((a, b) => b.deliveryMetrics.failedDeliveries - a.deliveryMetrics.failedDeliveries).slice(0, 5).map(w => ({ id: w.id, url: w.url, failures: w.deliveryMetrics.failedDeliveries })),
    eventDistribution: [
        { type: 'transaction.created', count: 700000 },
        { type: 'payment.updated', count: 300000 },
        { type: 'user.created', count: 200000 },
        { type: 'user.updated', count: 250000 },
        { type: 'order.placed', count: 50000 },
    ],
    latencyP99Ms: 450,
    totalEventsProcessedMonth: 30_000_000,
    successfulEventsMonth: 29_500_000,
    failedEventsMonth: 500_000,
};

const generateRandomChartData = (numPoints: number, min: number, max: number, interval: 'hourly' | 'daily'): ChartDataPoint[] => {
    const data: ChartDataPoint[] = [];
    for (let i = 0; i < numPoints; i++) {
        let timeLabel: string;
        if (interval === 'hourly') {
            timeLabel = `${String(i).padStart(2, '0')}:00`;
        } else { // daily
            const date = new Date();
            date.setDate(date.getDate() - (numPoints - 1 - i));
            timeLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        data.push({
            time: timeLabel,
            value: Math.floor(Math.random() * (max - min + 1)) + min,
        });
    }
    return data;
};

const MOCK_CHART_CONFIGS: ChartConfig[] = [
    {
        id: 'daily-failures',
        title: 'Daily Event Failures (Last 30 Days)',
        type: 'line',
        data: generateRandomChartData(30, 100, 2000, 'daily'),
        unit: 'events',
        timeframe: 'daily',
        description: 'Trend of failed webhook deliveries over the last 30 days.'
    },
    {
        id: 'hourly-latency',
        title: 'Avg. Latency (Last 24 Hours)',
        type: 'line',
        data: generateRandomChartData(24, 50, 400, 'hourly'),
        unit: 'ms',
        timeframe: 'hourly',
        description: 'Average latency for all webhook deliveries in milliseconds.'
    },
    {
        id: 'event-throughput',
        title: 'Total Events Processed (Last 30 Days)',
        type: 'bar',
        data: generateRandomChartData(30, 10000, 100000, 'daily'),
        unit: 'events',
        timeframe: 'daily',
        description: 'Total number of webhook events processed, including successful and failed deliveries.'
    },
    {
        id: 'success-failure-pie',
        title: 'Event Delivery Status (Last 24h)',
        type: 'pie',
        data: [
            { time: 'Delivered', value: MOCK_ANALYTICS_SUMMARY.totalEventsDelivered24h - (MOCK_ANALYTICS_SUMMARY.totalEventsDelivered24h * MOCK_ANALYTICS_SUMMARY.failureRate24h / 100), label: 'Delivered', color: '#34D399' },
            { time: 'Failed', value: MOCK_ANALYTICS_SUMMARY.totalEventsDelivered24h * MOCK_ANALYTICS_SUMMARY.failureRate24h / 100, label: 'Failed', color: '#EF4444' }
        ],
        unit: '%',
        timeframe: 'daily',
        description: 'Distribution of successful and failed webhook deliveries.'
    },
    {
        id: 'top-event-types',
        title: 'Top Event Types (Last 24h)',
        type: 'bar',
        data: MOCK_ANALYTICS_SUMMARY.eventDistribution.sort((a,b) => b.count - a.count).slice(0,5).map(e => ({time: e.type, value: e.count})),
        unit: 'events',
        timeframe: 'daily',
        description: 'Most frequently triggered webhook event types.'
    }
];

const DEFAULT_WEBHOOK_SETTINGS: WebhookSettings = {
    maxRetries: 5,
    retryIntervalSeconds: [60, 300, 900, 1800, 3600],
    timeoutMs: 10000,
    secretSigningEnabled: true,
    deliveryAttemptsLoggingEnabled: true,
    defaultHeaders: [{ id: uuidv4(), key: 'X-App-Id', value: 'megadashboard' }],
    ipWhitelist: ['0.0.0.0/0'], // Allow all by default
    rateLimitEnabled: false,
    rateLimitRequestsPerMinute: 1000,
    eventTransformationEnabled: false,
    customCertsEnabled: false,
    customCertificates: [],
    deadLetterQueueEnabled: false,
    globalMonitoringEnabled: true,
    webhookBatchingEnabled: false,
};

// --- HELPER FUNCTIONS (Mock API Calls & Utilities) ---

// Utility function for simulating API calls
const simulateApiCall = <T>(data: T, delay = 500): Promise<T> => {
    return new Promise(resolve => setTimeout(() => resolve(data), delay));
};

const getPaginatedData = <T>(data: T[], page: number, itemsPerPage: number): { data: T[]; pagination: PaginationInfo; } => {
    const startIndex = (page - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedData = data.slice(startIndex, endIndex);
    return {
        data: paginatedData,
        pagination: {
            currentPage: page,
            itemsPerPage: itemsPerPage,
            totalItems: data.length,
            totalPages: Math.ceil(data.length / itemsPerPage),
        },
    };
};

const filterWebhooks = (webhooks: Webhook[], filters: FilterOptions): Webhook[] => {
    let filtered = webhooks;
    if (filters.searchTerm) {
        const lowerCaseSearch = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(wh =>
            wh.url.toLowerCase().includes(lowerCaseSearch) ||
            wh.description.toLowerCase().includes(lowerCaseSearch) ||
            wh.events.some(e => e.toLowerCase().includes(lowerCaseSearch)) ||
            wh.tags.some(t => t.toLowerCase().includes(lowerCaseSearch))
        );
    }
    if (filters.status && filters.status !== 'All') {
        filtered = filtered.filter(wh => wh.status === filters.status);
    }
    if (filters.eventType && filters.eventType !== 'All') {
        filtered = filtered.filter(wh => wh.events.includes(filters.eventType!));
    }
    return filtered;
};

const filterEvents = (events: WebhookEvent[], filters: FilterOptions): WebhookEvent[] => {
    let filtered = events;
    if (filters.searchTerm) {
        const lowerCaseSearch = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(evt =>
            evt.type.toLowerCase().includes(lowerCaseSearch) ||
            JSON.stringify(evt.payload).toLowerCase().includes(lowerCaseSearch) ||
            evt.error?.toLowerCase().includes(lowerCaseSearch) ||
            evt.id.toLowerCase().includes(lowerCaseSearch)
        );
    }
    if (filters.status && filters.status !== 'All') {
        filtered = filtered.filter(evt => evt.status === filters.status);
    }
    if (filters.eventType && filters.eventType !== 'All') {
        filtered = filtered.filter(evt => evt.type === filters.eventType);
    }
    // TODO: Implement time range filtering if necessary for real app
    return filtered;
};

const filterAuditLogs = (logs: AuditLogEntry[], filters: FilterOptions): AuditLogEntry[] => {
    let filtered = logs;
    if (filters.searchTerm) {
        const lowerCaseSearch = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(log =>
            log.action.toLowerCase().includes(lowerCaseSearch) ||
            log.actor.toLowerCase().includes(lowerCaseSearch) ||
            log.resourceId.toLowerCase().includes(lowerCaseSearch) ||
            JSON.stringify(log.details).toLowerCase().includes(lowerCaseSearch)
        );
    }
    if (filters.resourceType && filters.resourceType !== 'All') {
        filtered = filtered.filter(log => log.resourceType === filters.resourceType);
    }
    if (filters.actor && filters.actor !== 'All') {
        filtered = filtered.filter(log => log.actor === filters.actor);
    }
    return filtered.sort((a,b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
};

const generateUUID = () => uuidv4();

// --- Main WebhooksView Component ---
const WebhooksView: React.FC = () => {
    // --- State Management for different sections ---
    const [activeTab, setActiveTab] = useState<'dashboard' | 'endpoints' | 'events' | 'alerts' | 'api-keys' | 'settings' | 'audit-log' | 'testing'>('dashboard');

    // Webhooks State
    const [webhooks, setWebhooks] = useState<Webhook[]>(initialWebhooks);
    const [currentWebhookPage, setCurrentWebhookPage] = useState(1);
    const [webhooksPerPage] = useState(10);
    const [webhookFilters, setWebhookFilters] = useState<FilterOptions>({});
    const [isWebhookModalOpen, setIsWebhookModalOpen] = useState(false);
    const [editingWebhook, setEditingWebhook] = useState<WebhookFormData | null>(null);
    const [webhookFormErrors, setWebhookFormErrors] = useState<any>({});
    const [showDeleteWebhookConfirm, setShowDeleteWebhookConfirm] = useState<string | null>(null); // Webhook ID to delete

    // Events State
    const [events, setEvents] = useState<WebhookEvent[]>(initialEvents);
    const [currentEventPage, setCurrentEventPage] = useState(1);
    const [eventsPerPage] = useState(20);
    const [eventFilters, setEventFilters] = useState<FilterOptions>({});
    const [selectedEvent, setSelectedEvent] = useState<WebhookEvent | null>(null);
    const [isEventDetailsModalOpen, setIsEventDetailsModalOpen] = useState(false);

    // AI Analysis State
    const [aiAnalysis, setAiAnalysis] = useState('');
    const [isAiLoading, setIsAiLoading] = useState(false);
    const [aiError, setAiError] = useState('');

    // Alerts State
    const [alertRules, setAlertRules] = useState<AlertRule[]>(MOCK_ALERT_RULES);
    const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
    const [editingAlertRule, setEditingAlertRule] = useState<AlertRule | null>(null);
    const [alertFormErrors, setAlertFormErrors] = useState<any>({});
    const [showDeleteAlertConfirm, setShowDeleteAlertConfirm] = useState<string | null>(null);

    // API Keys State
    const [apiKeys, setApiKeys] = useState<ApiKey[]>(MOCK_API_KEYS);
    const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);
    const [newApiKeyFormData, setNewApiKeyFormData] = useState<{ name: string; permissions: string[]; expiresAt?: string; }>({ name: '', permissions: ['event:read'] });
    const [newApiKeyDisplay, setNewApiKeyDisplay] = useState<string | null>(null); // To show generated key once
    const [showRevokeApiKeyConfirm, setShowRevokeApiKeyConfirm] = useState<string | null>(null);

    // Global Settings State
    const [webhookSettings, setWebhookSettings] = useState<WebhookSettings>(DEFAULT_WEBHOOK_SETTINGS);
    const [isSettingsLoading, setIsSettingsLoading] = useState(false);
    const [settingsSaveSuccess, setSettingsSaveSuccess] = useState(false);

    // Audit Log State
    const [auditLogs, setAuditLogs] = useState<AuditLogEntry[]>(MOCK_AUDIT_LOGS);
    const [currentAuditLogPage, setCurrentAuditLogPage] = useState(1);
    const [auditLogsPerPage] = useState(15);
    const [auditLogFilters, setAuditLogFilters] = useState<FilterOptions>({});

    // Analytics State
    const [analyticsSummary, setAnalyticsSummary] = useState<AnalyticsSummary>(MOCK_ANALYTICS_SUMMARY);
    const [chartConfigs, setChartConfigs] = useState<ChartConfig[]>(MOCK_CHART_CONFIGS);
    const [isAnalyticsLoading, setIsAnalyticsLoading] = useState(false);

    // Webhook Testing State
    const [testEventConfig, setTestEventConfig] = useState<TestEventConfig>({ eventType: 'test.event', payload: { test: 'data' }, headers: [], metadata: [] });
    const [testResult, setTestResult] = useState<any>(null);
    const [isTestLoading, setIsTestLoading] = useState(false);
    const [testEventErrors, setTestEventErrors] = useState<any>({});
    const [testHeaders, setTestHeaders] = useState<{ key: string; value: string; id: string; }[]>([]);
    const [testMetadata, setTestMetadata] = useState<{ key: string; value: string; id: string; }[]>([]);

    // Event Replay State
    const [eventReplayConfig, setEventReplayConfig] = useState<EventReplayConfig>({
        webhookIds: [],
        eventTypes: ['*'],
        dateRange: { start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], end: new Date().toISOString().split('T')[0] },
        maxEvents: 100,
        batchSize: 10,
        dryRun: true,
    });
    const [replayResults, setReplayResults] = useState<any>(null);
    const [isReplayLoading, setIsReplayLoading] = useState(false);
    const [eventReplayErrors, setEventReplayErrors] = useState<any>({});

    // UI Feedback
    const [feedbackMessage, setFeedbackMessage] = useState<{ type: 'success' | 'error' | 'info'; message: string; } | null>(null);

    // Ref for the main content scroll, to ensure scroll on tab change
    const mainContentRef = useRef<HTMLDivElement>(null);

    // --- Effects & Data Fetching (Mocked) ---
    useEffect(() => {
        // Scroll to top when tab changes
        mainContentRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
        setFeedbackMessage(null); // Clear feedback when tab changes
    }, [activeTab]);

    useEffect(() => {
        // Simulate initial data load
        setIsAnalyticsLoading(true);
        simulateApiCall(MOCK_ANALYTICS_SUMMARY, 700).then(data => {
            setAnalyticsSummary(data);
            setIsAnalyticsLoading(false);
        });
        simulateApiCall(MOCK_CHART_CONFIGS, 800).then(data => setChartConfigs(data));
        simulateApiCall(DEFAULT_WEBHOOK_SETTINGS, 600).then(data => setWebhookSettings(data));
        simulateApiCall(MOCK_ALERT_RULES, 500).then(data => setAlertRules(data));
        simulateApiCall(MOCK_API_KEYS, 400).then(data => setApiKeys(data));
        simulateApiCall(MOCK_AUDIT_LOGS, 600).then(data => setAuditLogs(data));

        // Load webhooks and events (already initialized, but simulate API)
        simulateApiCall(initialWebhooks, 300).then(data => setWebhooks(data));
        simulateApiCall(initialEvents, 300).then(data => setEvents(data));
    }, []);

    // Debounced search for webhooks and events
    const debouncedSetWebhookFilters = useCallback(
        debounce((filters: FilterOptions) => setWebhookFilters(filters), 300),
        []
    );
    const debouncedSetEventFilters = useCallback(
        debounce((filters: FilterOptions) => setEventFilters(filters), 300),
        []
    );
    const debouncedSetAuditLogFilters = useCallback(
        debounce((filters: FilterOptions) => setAuditLogFilters(filters), 300),
        []
    );

    // Filtered and paginated data for display
    const filteredWebhooks = useMemo(() => filterWebhooks(webhooks, webhookFilters), [webhooks, webhookFilters]);
    const { data: displayedWebhooks, pagination: webhookPagination } = useMemo(
        () => getPaginatedData(filteredWebhooks, currentWebhookPage, webhooksPerPage),
        [filteredWebhooks, currentWebhookPage, webhooksPerPage]
    );

    const filteredEvents = useMemo(() => filterEvents(events, eventFilters), [events, eventFilters]);
    const { data: displayedEvents, pagination: eventPagination } = useMemo(
        () => getPaginatedData(filteredEvents, currentEventPage, eventsPerPage),
        [filteredEvents, currentEventPage, eventsPerPage]
    );

    const filteredAuditLogs = useMemo(() => filterAuditLogs(auditLogs, auditLogFilters), [auditLogs, auditLogFilters]);
    const { data: displayedAuditLogs, pagination: auditLogPagination } = useMemo(
        () => getPaginatedData(filteredAuditLogs, currentAuditLogPage, auditLogsPerPage),
        [filteredAuditLogs, currentAuditLogPage, auditLogsPerPage]
    );

    // --- Handlers for Webhooks Management ---

    const handleCreateWebhook = () => {
        setEditingWebhook({
            url: '',
            events: ['*'],
            status: 'Active',
            description: '',
            secret: '',
            headers: [{ key: '', value: '', id: uuidv4() }],
            authType: 'none',
            sslVerificationEnabled: true,
            retryPolicy: { maxRetries: 5, initialIntervalSeconds: 60, multiplier: 2, maxIntervalSeconds: 3600 },
            metadata: [{ key: '', value: '', id: uuidv4() }],
            environment: 'development',
            tags: [],
        });
        setIsWebhookModalOpen(true);
        setWebhookFormErrors({});
    };

    const handleEditWebhook = (webhook: Webhook) => {
        setEditingWebhook({
            ...webhook,
            headers: webhook.headers.length > 0 ? webhook.headers : [{ key: '', value: '', id: uuidv4() }],
            metadata: Object.entries(webhook.metadata).map(([key, value]) => ({ key, value, id: uuidv4() }))
                .concat({ key: '', value: '', id: uuidv4() }), // Ensure there's always an empty row for new input
            authToken: webhook.authConfig.token,
            username: webhook.authConfig.username,
            password: webhook.authConfig.password, // This should never be shown unmasked in real UI
        });
        setIsWebhookModalOpen(true);
        setWebhookFormErrors({});
    };

    const validateWebhookForm = (formData: WebhookFormData) => {
        const errors: any = {};
        if (!formData.url) errors.url = 'URL is required.';
        else if (!/^https?:\/\/.+\..+/.test(formData.url)) errors.url = 'Invalid URL format.';
        if (formData.events.length === 0) errors.events = 'At least one event type or "*" is required.';
        if (formData.authType === 'basic' && (!formData.username || !formData.password)) errors.auth = 'Username and password required for Basic Auth.';
        if (formData.authType === 'bearer' && !formData.authToken) errors.auth = 'Bearer token is required.';
        return errors;
    };

    const handleSaveWebhook = async (formData: WebhookFormData) => {
        const errors = validateWebhookForm(formData);
        if (Object.keys(errors).length > 0) {
            setWebhookFormErrors(errors);
            setFeedbackMessage({ type: 'error', message: 'Please correct the form errors.' });
            return;
        }

        setIsWebhookModalOpen(false);
        setFeedbackMessage(null);

        const newWebhook: Webhook = {
            id: formData.id || generateUUID(),
            url: formData.url,
            status: formData.status,
            events: formData.events.filter(e => e.trim() !== ''),
            description: formData.description,
            secret: formData.secret || `whsec_${uuidv4().replace(/-/g, '').substring(0, 32)}`, // Generate if empty
            createdAt: formData.id ? webhooks.find(wh => wh.id === formData.id)?.createdAt || new Date().toISOString() : new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            lastEventSentAt: formData.id ? webhooks.find(wh => wh.id === formData.id)?.lastEventSentAt : undefined,
            deliveryMetrics: formData.id ? webhooks.find(wh => wh.id === formData.id)?.deliveryMetrics || { totalAttempts: 0, successfulDeliveries: 0, failedDeliveries: 0, avgLatencyMs: 0 } : { totalAttempts: 0, successfulDeliveries: 0, failedDeliveries: 0, avgLatencyMs: 0 },
            retryPolicy: formData.retryPolicy,
            headers: formData.headers.filter(h => h.key && h.value),
            authConfig: formData.authType === 'basic' ? { type: 'basic', username: formData.username, password: formData.password } :
                        formData.authType === 'bearer' ? { type: 'bearer', token: formData.authToken } :
                        { type: 'none' },
            sslVerificationEnabled: formData.sslVerificationEnabled,
            metadata: formData.metadata.filter(m => m.key && m.value).reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {}),
            ownerId: 'current_user', // In a real app, this would be dynamic
            environment: formData.environment,
            tags: formData.tags.filter(t => t.trim() !== ''),
        };

        if (formData.id) {
            // Update existing webhook
            await simulateApiCall(newWebhook);
            setWebhooks(prev => prev.map(wh => (wh.id === newWebhook.id ? newWebhook : wh)));
            setFeedbackMessage({ type: 'success', message: `Webhook '${newWebhook.url}' updated successfully!` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'webhook.updated', resourceType: 'webhook', resourceId: newWebhook.id,
                details: { old: editingWebhook, new: newWebhook }
            }, ...prev]);
        } else {
            // Create new webhook
            await simulateApiCall(newWebhook);
            setWebhooks(prev => [...prev, newWebhook]);
            setFeedbackMessage({ type: 'success', message: `Webhook '${newWebhook.url}' created successfully!` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'webhook.created', resourceType: 'webhook', resourceId: newWebhook.id,
                details: newWebhook
            }, ...prev]);
        }
        setEditingWebhook(null);
    };

    const handleDeleteWebhook = async (webhookId: string) => {
        setShowDeleteWebhookConfirm(null);
        setFeedbackMessage(null);
        await simulateApiCall(null);
        setWebhooks(prev => prev.filter(wh => wh.id !== webhookId));
        setFeedbackMessage({ type: 'success', message: 'Webhook deleted successfully.' });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'webhook.deleted', resourceType: 'webhook', resourceId: webhookId,
            details: { id: webhookId }
        }, ...prev]);
    };

    const handleWebhookStatusChange = async (webhookId: string, newStatus: 'Active' | 'Disabled' | 'Paused') => {
        setFeedbackMessage(null);
        const updatedWebhook = webhooks.find(wh => wh.id === webhookId);
        if (updatedWebhook) {
            const newWebhook = { ...updatedWebhook, status: newStatus, updatedAt: new Date().toISOString() };
            await simulateApiCall(newWebhook);
            setWebhooks(prev => prev.map(wh => (wh.id === webhookId ? newWebhook : wh)));
            setFeedbackMessage({ type: 'success', message: `Webhook '${updatedWebhook.url}' status changed to '${newStatus}'.` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'webhook.status.changed', resourceType: 'webhook', resourceId: webhookId,
                details: { oldStatus: updatedWebhook.status, newStatus: newStatus }
            }, ...prev]);
        }
    };

    const handleWebhookFilterChange = (key: keyof FilterOptions, value: string) => {
        debouncedSetWebhookFilters({ ...webhookFilters, [key]: value });
        setCurrentWebhookPage(1); // Reset page on filter change
    };

    // --- Handlers for Event Log Viewer ---
    const handleEventDetailsClick = (event: WebhookEvent) => {
        setSelectedEvent(event);
        setIsEventDetailsModalOpen(true);
        setAiAnalysis('');
        setAiError('');
    };

    const handleAiAnalyze = async () => {
        if (!selectedEvent) return;
        setIsAiLoading(true);
        setAiAnalysis('');
        setAiError('');
        try {
            // In a real application, the API_KEY would be secured server-side.
            // For a client-side mock, we use process.env.API_KEY.
            if (!process.env.API_KEY) {
                throw new Error("API_KEY is not defined. Cannot perform AI analysis.");
            }
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `I have a failed webhook delivery. The event type was "${selectedEvent.type}". The final error was "${selectedEvent.error || 'N/A'}". The payload was ${JSON.stringify(selectedEvent.payload, null, 2)}. Delivery attempts: ${JSON.stringify(selectedEvent.deliveryAttempts, null, 2)}. What is the likely cause of this failure and how can I fix it? Provide specific, actionable steps.`;
            const model = ai.getGenerativeModel({ model: 'gemini-pro' }); // Using gemini-pro for more detailed analysis
            const result = await model.generateContent(prompt);
            const response = result.response;
            const text = response.text();
            setAiAnalysis(text);
        } catch (error: any) {
            console.error("AI Analysis Error:", error);
            setAiError(`Error generating AI analysis: ${error.message || 'Unknown error'}. Please check your API key and network connection.`);
            setAiAnalysis("Error generating analysis. Check the console for details.");
        } finally {
            setIsAiLoading(false);
        }
    };

    const handleEventFilterChange = (key: keyof FilterOptions, value: string) => {
        debouncedSetEventFilters({ ...eventFilters, [key]: value });
        setCurrentEventPage(1);
    };

    const handleReplayEvent = async (eventId: string) => {
        setFeedbackMessage(null);
        setIsReplayLoading(true);
        const eventToReplay = events.find(e => e.id === eventId);
        if (!eventToReplay) {
            setFeedbackMessage({ type: 'error', message: 'Event not found for replay.' });
            setIsReplayLoading(false);
            return;
        }

        // Simulate replaying the event
        const newAttempt = {
            attempt: eventToReplay.deliveryAttempts.length + 1,
            status: Math.random() > 0.7 ? 'Success' : 'Failure',
            responseStatus: Math.random() > 0.7 ? 200 : 500,
            responseText: Math.random() > 0.7 ? 'Replayed Successfully' : 'Replay Failed: Server Error',
            latencyMs: Math.floor(Math.random() * 300) + 50,
            timestamp: new Date().toISOString(),
            errorDetails: Math.random() > 0.7 ? undefined : 'Simulated replay failure',
        };

        const updatedEvent: WebhookEvent = {
            ...eventToReplay,
            status: newAttempt.status === 'Success' ? 'Delivered' : 'Failed',
            deliveryAttempts: [...eventToReplay.deliveryAttempts, newAttempt],
            error: newAttempt.status === 'Failure' ? newAttempt.errorDetails : undefined,
            timestamp: new Date().toISOString(), // Update timestamp to reflect last action
        };

        await simulateApiCall(updatedEvent);
        setEvents(prev => prev.map(evt => (evt.id === eventId ? updatedEvent : evt)));
        setFeedbackMessage({ type: 'success', message: `Event ${eventId} replayed. Status: ${newAttempt.status}` });
        setIsReplayLoading(false);
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'event.replayed', resourceType: 'event', resourceId: eventId,
            details: { newAttempt }
        }, ...prev]);
    };

    // --- Handlers for Alert Rules ---
    const handleCreateAlert = () => {
        setEditingAlertRule({
            id: generateUUID(), name: '', type: 'webhook_failure_rate', threshold: 1, durationMinutes: 5, status: 'Active', channels: [{ id: uuidv4(), type: 'email', recipient: '' }], severity: 'Medium'
        });
        setIsAlertModalOpen(true);
        setAlertFormErrors({});
    };

    const handleEditAlert = (rule: AlertRule) => {
        setEditingAlertRule(rule);
        setIsAlertModalOpen(true);
        setAlertFormErrors({});
    };

    const validateAlertForm = (formData: AlertRule) => {
        const errors: any = {};
        if (!formData.name) errors.name = 'Rule name is required.';
        if (!formData.threshold || formData.threshold <= 0) errors.threshold = 'Threshold must be a positive number.';
        if (!formData.durationMinutes || formData.durationMinutes <= 0) errors.durationMinutes = 'Duration must be a positive number.';
        if (formData.channels.some(c => !c.recipient)) errors.channels = 'All alert channels must have a recipient.';
        if (formData.type === 'custom_metric' && (!formData.metricPath || !formData.operator)) errors.customMetric = 'Metric path and operator are required for custom metrics.';
        return errors;
    };

    const handleSaveAlert = async (formData: AlertRule) => {
        const errors = validateAlertForm(formData);
        if (Object.keys(errors).length > 0) {
            setAlertFormErrors(errors);
            setFeedbackMessage({ type: 'error', message: 'Please correct the form errors.' });
            return;
        }

        setIsAlertModalOpen(false);
        setFeedbackMessage(null);
        await simulateApiCall(formData);
        if (alertRules.some(r => r.id === formData.id)) {
            setAlertRules(prev => prev.map(r => (r.id === formData.id ? formData : r)));
            setFeedbackMessage({ type: 'success', message: `Alert rule '${formData.name}' updated.` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'alert_rule.updated', resourceType: 'alert_rule', resourceId: formData.id,
                details: { old: editingAlertRule, new: formData }
            }, ...prev]);
        } else {
            setAlertRules(prev => [...prev, { ...formData, id: generateUUID() }]);
            setFeedbackMessage({ type: 'success', message: `Alert rule '${formData.name}' created.` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'alert_rule.created', resourceType: 'alert_rule', resourceId: formData.id,
                details: formData
            }, ...prev]);
        }
        setEditingAlertRule(null);
    };

    const handleDeleteAlert = async (ruleId: string) => {
        setShowDeleteAlertConfirm(null);
        setFeedbackMessage(null);
        await simulateApiCall(null);
        setAlertRules(prev => prev.filter(r => r.id !== ruleId));
        setFeedbackMessage({ type: 'success', message: 'Alert rule deleted.' });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'alert_rule.deleted', resourceType: 'alert_rule', resourceId: ruleId,
            details: { id: ruleId }
        }, ...prev]);
    };

    // --- Handlers for API Key Management ---
    const handleCreateApiKey = () => {
        setIsApiKeyModalOpen(true);
        setNewApiKeyFormData({ name: '', permissions: ['event:read'] });
        setNewApiKeyDisplay(null);
    };

    const handleGenerateApiKey = async () => {
        setFeedbackMessage(null);
        if (!newApiKeyFormData.name) {
            setFeedbackMessage({ type: 'error', message: 'API Key name is required.' });
            return;
        }
        const generatedKey = `sk_live_${uuidv4().replace(/-/g, '')}`; // Simulate key generation
        const newKey: ApiKey = {
            id: generateUUID(),
            name: newApiKeyFormData.name,
            key: generatedKey, // Store unmasked for now, but mask in UI
            createdAt: new Date().toISOString(),
            expiresAt: newApiKeyFormData.expiresAt,
            permissions: newApiKeyFormData.permissions,
            status: 'Active',
            createdBy: 'current_user',
        };
        await simulateApiCall(newKey);
        setApiKeys(prev => [...prev, newKey]);
        setNewApiKeyDisplay(generatedKey);
        setFeedbackMessage({ type: 'success', message: 'API Key generated successfully! Please copy it now.' });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'api_key.created', resourceType: 'api_key', resourceId: newKey.id,
            details: { name: newKey.name, permissions: newKey.permissions }
        }, ...prev]);
    };

    const handleRevokeApiKey = async (keyId: string) => {
        setShowRevokeApiKeyConfirm(null);
        setFeedbackMessage(null);
        const updatedKey = apiKeys.find(key => key.id === keyId);
        if (updatedKey) {
            const newKey = { ...updatedKey, status: 'Revoked', lastUsedAt: new Date().toISOString() }; // Simulate last used for revocation
            await simulateApiCall(newKey);
            setApiKeys(prev => prev.map(key => (key.id === keyId ? newKey : key)));
            setFeedbackMessage({ type: 'success', message: `API Key '${updatedKey.name}' revoked.` });
            setAuditLogs(prev => [{
                id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
                action: 'api_key.revoked', resourceType: 'api_key', resourceId: keyId,
                details: { name: updatedKey.name }
            }, ...prev]);
        }
    };

    // --- Handlers for Global Settings ---
    const handleSettingsChange = (key: keyof WebhookSettings, value: any) => {
        setWebhookSettings(prev => ({ ...prev, [key]: value }));
        setSettingsSaveSuccess(false);
    };

    const handleAddDefaultHeader = () => {
        setWebhookSettings(prev => ({
            ...prev,
            defaultHeaders: [...prev.defaultHeaders, { key: '', value: '', id: uuidv4() }]
        }));
        setSettingsSaveSuccess(false);
    };

    const handleUpdateDefaultHeader = (id: string, key: 'key' | 'value', val: string) => {
        setWebhookSettings(prev => ({
            ...prev,
            defaultHeaders: prev.defaultHeaders.map(h => h.id === id ? { ...h, [key]: val } : h)
        }));
        setSettingsSaveSuccess(false);
    };

    const handleRemoveDefaultHeader = (id: string) => {
        setWebhookSettings(prev => ({
            ...prev,
            defaultHeaders: prev.defaultHeaders.filter(h => h.id !== id)
        }));
        setSettingsSaveSuccess(false);
    };

    const handleSaveSettings = async () => {
        setIsSettingsLoading(true);
        setFeedbackMessage(null);
        // Clean up empty headers before saving
        const cleanedSettings = {
            ...webhookSettings,
            defaultHeaders: webhookSettings.defaultHeaders.filter(h => h.key && h.value),
            ipWhitelist: webhookSettings.ipWhitelist.filter(ip => ip.trim() !== ''),
        };
        await simulateApiCall(cleanedSettings);
        setWebhookSettings(cleanedSettings); // Update state with cleaned settings
        setIsSettingsLoading(false);
        setSettingsSaveSuccess(true);
        setFeedbackMessage({ type: 'success', message: 'Global settings updated successfully!' });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'settings.updated', resourceType: 'settings', resourceId: 'global',
            details: { newSettings: cleanedSettings }
        }, ...prev]);
    };

    // --- Handlers for Audit Log ---
    const handleAuditLogFilterChange = (key: keyof FilterOptions, value: string) => {
        debouncedSetAuditLogFilters({ ...auditLogFilters, [key]: value });
        setCurrentAuditLogPage(1);
    };

    // --- Handlers for Webhook Testing Tool ---
    const handleTestEventConfigChange = (key: keyof TestEventConfig, value: any) => {
        setTestEventConfig(prev => ({ ...prev, [key]: value }));
        setTestEventErrors({});
    };

    const handleTestHeadersChange = (id: string, key: 'key' | 'value', value: string) => {
        setTestHeaders(prev => prev.map(h => h.id === id ? { ...h, [key]: value } : h));
    };
    const handleAddTestHeader = () => {
        setTestHeaders(prev => [...prev, { id: uuidv4(), key: '', value: '' }]);
    };
    const handleRemoveTestHeader = (id: string) => {
        setTestHeaders(prev => prev.filter(h => h.id !== id));
    };

    const handleTestMetadataChange = (id: string, key: 'key' | 'value', value: string) => {
        setTestMetadata(prev => prev.map(m => m.id === id ? { ...m, [key]: value } : m));
    };
    const handleAddTestMetadata = () => {
        setTestMetadata(prev => [...prev, { id: uuidv4(), key: '', value: '' }]);
    };
    const handleRemoveTestMetadata = (id: string) => {
        setTestMetadata(prev => prev.filter(m => m.id !== id));
    };

    const handleSendTestEvent = async () => {
        setFeedbackMessage(null);
        setTestEventErrors({});
        setTestResult(null);
        setIsTestLoading(true);

        const errors: any = {};
        if (!testEventConfig.eventType) errors.eventType = 'Event Type is required.';
        try {
            JSON.parse(JSON.stringify(testEventConfig.payload)); // Validate JSON
        } catch (e) {
            errors.payload = 'Invalid JSON payload.';
        }
        if (Object.keys(errors).length > 0) {
            setTestEventErrors(errors);
            setIsTestLoading(false);
            setFeedbackMessage({ type: 'error', message: 'Please correct test event configuration errors.' });
            return;
        }

        // Simulate sending a test event
        const targetWebhook = testEventConfig.webhookId ? webhooks.find(wh => wh.id === testEventConfig.webhookId) : null;
        const simulatedResponseStatus = Math.random() > 0.8 ? 500 : 200;
        const simulatedLatency = Math.floor(Math.random() * 500) + 50;

        const result = {
            status: simulatedResponseStatus,
            message: simulatedResponseStatus === 200 ? 'Test event delivered successfully.' : 'Test event delivery failed.',
            latencyMs: simulatedLatency,
            webhookId: targetWebhook?.id || 'N/A',
            webhookUrl: targetWebhook?.url || 'All matching webhooks',
            payloadSent: testEventConfig.payload,
            headersSent: testHeaders.filter(h => h.key && h.value),
            deliveredAt: new Date().toISOString(),
            mockDetails: 'This is a simulated test webhook call. In a real system, you would see actual HTTP response data.',
        };
        await simulateApiCall(result);
        setTestResult(result);
        setIsTestLoading(false);
        setFeedbackMessage({ type: result.status === 200 ? 'success' : 'error', message: result.message });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'webhook.tested', resourceType: 'webhook', resourceId: targetWebhook?.id || 'N/A',
            details: { eventType: testEventConfig.eventType, result }
        }, ...prev]);
    };

    // --- Handlers for Event Replay Tool ---
    const handleEventReplayConfigChange = (key: keyof EventReplayConfig, value: any) => {
        setEventReplayConfig(prev => ({ ...prev, [key]: value }));
        setEventReplayErrors({});
    };

    const handleInitiateEventReplay = async () => {
        setFeedbackMessage(null);
        setEventReplayErrors({});
        setReplayResults(null);
        setIsReplayLoading(true);

        const errors: any = {};
        if (eventReplayConfig.webhookIds.length === 0 && eventReplayConfig.eventTypes.length === 0) {
            errors.target = 'Select at least one webhook or event type.';
        }
        if (eventReplayConfig.maxEvents <= 0) errors.maxEvents = 'Max events must be positive.';
        if (Object.keys(errors).length > 0) {
            setEventReplayErrors(errors);
            setIsReplayLoading(false);
            setFeedbackMessage({ type: 'error', message: 'Please correct event replay configuration errors.' });
            return;
        }

        // Simulate event replay
        const eligibleEvents = events.filter(evt =>
            (eventReplayConfig.webhookIds.length === 0 || eventReplayConfig.webhookIds.includes(evt.webhookId)) &&
            (eventReplayConfig.eventTypes.includes('*') || eventReplayConfig.eventTypes.includes(evt.type)) &&
            (eventReplayConfig.statusFilter === 'All' || !eventReplayConfig.statusFilter || evt.status === eventReplayConfig.statusFilter) &&
            (new Date(evt.timestamp) >= new Date(eventReplayConfig.dateRange.start)) &&
            (new Date(evt.timestamp) <= new Date(eventReplayConfig.dateRange.end))
        ).slice(0, eventReplayConfig.maxEvents);

        const replayCount = eligibleEvents.length;
        let successCount = 0;
        let failureCount = 0;
        const replayedEvents = [];

        if (!eventReplayConfig.dryRun) {
            for (const evt of eligibleEvents) {
                const newAttempt = {
                    attempt: evt.deliveryAttempts.length + 1,
                    status: Math.random() > 0.85 ? 'Success' : 'Failure',
                    responseStatus: Math.random() > 0.85 ? 200 : 500,
                    responseText: Math.random() > 0.85 ? 'Replayed Successfully' : 'Replay Failed: Server Error',
                    latencyMs: Math.floor(Math.random() * 300) + 50,
                    timestamp: new Date().toISOString(),
                    errorDetails: Math.random() > 0.85 ? undefined : 'Simulated replay failure during batch operation',
                };
                if (newAttempt.status === 'Success') successCount++; else failureCount++;
                replayedEvents.push({ eventId: evt.id, status: newAttempt.status, attempt: newAttempt });
            }

            // Update events in state (simplified for bulk)
            setEvents(prevEvents => {
                const updatedEventsMap = new Map(prevEvents.map(e => [e.id, e]));
                replayedEvents.forEach(replayed => {
                    const originalEvent = updatedEventsMap.get(replayed.eventId);
                    if (originalEvent) {
                        updatedEventsMap.set(replayed.eventId, {
                            ...originalEvent,
                            status: replayed.status === 'Success' ? 'Delivered' : 'Failed',
                            deliveryAttempts: [...originalEvent.deliveryAttempts, replayed.attempt],
                            error: replayed.status === 'Failure' ? replayed.attempt.errorDetails : undefined,
                            timestamp: new Date().toISOString(),
                        });
                    }
                });
                return Array.from(updatedEventsMap.values());
            });
        }

        const result = {
            dryRun: eventReplayConfig.dryRun,
            eventsFound: eligibleEvents.length,
            eventsReplayed: eventReplayConfig.dryRun ? 0 : replayCount,
            successfulReplays: eventReplayConfig.dryRun ? 0 : successCount,
            failedReplays: eventReplayConfig.dryRun ? 0 : failureCount,
            details: eventReplayConfig.dryRun ? [] : replayedEvents.map(r => ({ id: r.eventId, status: r.status })),
            message: eventReplayConfig.dryRun
                ? `Dry run completed. Found ${eligibleEvents.length} events matching criteria.`
                : `Replay completed. Successfully replayed ${successCount} events, failed to replay ${failureCount} events out of ${replayCount}.`,
        };
        await simulateApiCall(result);
        setReplayResults(result);
        setIsReplayLoading(false);
        setFeedbackMessage({ type: 'info', message: result.message });
        setAuditLogs(prev => [{
            id: generateUUID(), timestamp: new Date().toISOString(), actor: 'user_admin',
            action: 'event.bulkReplay', resourceType: 'event', resourceId: 'bulk',
            details: { config: eventReplayConfig, resultSummary: result }
        }, ...prev]);
    };


    // Generic reusable components (would be in separate files in a real app)

    // Pagination Component
    export const Pagination: React.FC<{ pagination: PaginationInfo; onPageChange: (page: number) => void; }> = ({ pagination, onPageChange }) => {
        const { currentPage, totalPages } = pagination;
        if (totalPages <= 1) return null;

        const pages = Array.from({ length: totalPages }, (_, i) => i + 1);

        return (
            <nav className="flex items-center justify-between pt-4">
                <div className="flex-1 flex justify-between sm:hidden">
                    <button onClick={() => onPageChange(currentPage - 1)} disabled={currentPage === 1} className="relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium rounded-md text-gray-300 bg-gray-800 hover:bg-gray-700 disabled:opacity-50">Previous</button>
                    <button onClick={() => onPageChange(currentPage + 1)} disabled={currentPage === totalPages} className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium rounded-md text-gray-300 bg-gray-800 hover:bg-gray-700 disabled:opacity-50">Next</button>
                </div>
                <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
                    <div>
                        <p className="text-sm text-gray-400">
                            Showing <span className="font-medium">{(currentPage - 1) * pagination.itemsPerPage + 1}</span> to <span className="font-medium">{Math.min(currentPage * pagination.itemsPerPage, pagination.totalItems)}</span> of <span className="font-medium">{pagination.totalItems}</span> results
                        </p>
                    </div>
                    <div>
                        <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                            <button onClick={() => onPageChange(1)} disabled={currentPage === 1} className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50">
                                <span className="sr-only">First</span>
                                &laquo;
                            </button>
                            <button onClick={() => onPageChange(currentPage - 1)} disabled={currentPage === 1} className="relative inline-flex items-center px-2 py-2 border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50">
                                <span className="sr-only">Previous</span>
                                &lsaquo;
                            </button>
                            {pages.map(page => (
                                <button
                                    key={page}
                                    onClick={() => onPageChange(page)}
                                    aria-current={page === currentPage ? 'page' : undefined}
                                    className={`relative inline-flex items-center px-4 py-2 border text-sm font-medium ${page === currentPage ? 'z-10 bg-cyan-800 border-cyan-500 text-white' : 'bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700'}`}
                                >
                                    {page}
                                </button>
                            ))}
                            <button onClick={() => onPageChange(currentPage + 1)} disabled={currentPage === totalPages} className="relative inline-flex items-center px-2 py-2 border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50">
                                <span className="sr-only">Next</span>
                                &rsaquo;
                            </button>
                            <button onClick={() => onPageChange(totalPages)} disabled={currentPage === totalPages} className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50">
                                <span className="sr-only">Last</span>
                                &raquo;
                            </button>
                        </nav>
                    </div>
                </div>
            </nav>
        );
    };

    // Form Field Row Component
    export const FormField: React.FC<{ label: string; children: React.ReactNode; error?: string; description?: string; htmlFor?: string; }> = ({ label, children, error, description, htmlFor }) => (
        <div className="flex flex-col gap-1">
            <label htmlFor={htmlFor} className="text-sm font-medium text-gray-300 flex items-center">
                {label}
                {description && <span className="ml-2 text-xs text-gray-500">{description}</span>}
            </label>
            {children}
            {error && <p className="text-red-400 text-xs mt-1">{error}</p>}
        </div>
    );

    // Dynamic List Editor (for headers, metadata, channels)
    export const DynamicKeyValueList: React.FC<{
        label: string;
        items: { key: string; value: string; id: string; }[];
        onItemChange: (id: string, key: 'key' | 'value', value: string) => void;
        onAddItem: () => void;
        onRemoveItem: (id: string) => void;
        keyPlaceholder?: string;
        valuePlaceholder?: string;
        addButtonText?: string;
        description?: string;
    }> = ({
        label, items, onItemChange, onAddItem, onRemoveItem,
        keyPlaceholder = 'Key', valuePlaceholder = 'Value', addButtonText = `Add ${label} item`, description
    }) => {
        return (
            <FormField label={label} description={description}>
                <div className="space-y-2">
                    {items.map(item => (
                        <div key={item.id} className="flex items-center space-x-2">
                            <input
                                type="text"
                                placeholder={keyPlaceholder}
                                value={item.key}
                                onChange={(e) => onItemChange(item.id, 'key', e.target.value)}
                                className="flex-1 bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                            />
                            <input
                                type="text"
                                placeholder={valuePlaceholder}
                                value={item.value}
                                onChange={(e) => onItemChange(item.id, 'value', e.target.value)}
                                className="flex-1 bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                            />
                            <button
                                type="button"
                                onClick={() => onRemoveItem(item.id)}
                                className="text-red-400 hover:text-red-500 p-2 text-sm"
                            >
                                Remove
                            </button>
                        </div>
                    ))}
                    <button
                        type="button"
                        onClick={onAddItem}
                        className="bg-gray-700 text-gray-300 hover:bg-gray-600 border border-gray-600 px-4 py-2 rounded-md text-sm transition-colors duration-200"
                    >
                        {addButtonText}
                    </button>
                </div>
            </FormField>
        );
    };

    // Chart Placeholder (for demonstration)
    export const ChartPlaceholder: React.FC<ChartConfig> = ({ title, type, data, unit, description }) => (
        <Card title={title} className="col-span-1">
            <div className="flex flex-col h-full">
                <p className="text-sm text-gray-400 mb-2">{description}</p>
                <div className="flex-grow flex items-center justify-center bg-gray-700/50 rounded-md p-4 min-h-[150px]">
                    <p className="text-gray-500 text-xs italic">
                        [Placeholder for a {type} chart showing {title.toLowerCase()}]
                        <br/>
                        {data.slice(0, 3).map((d, i) => <span key={i} className="block">{d.time}: {d.value}{unit}</span>)}
                        {data.length > 3 && <span className="block">...</span>}
                    </p>
                </div>
            </div>
        </Card>
    );

    // --- Component JSX ---
    return (
        <div className="min-h-screen bg-gray-900 text-white flex flex-col">
            <header className="px-8 py-6 border-b border-gray-800">
                <h1 className="text-4xl font-extrabold text-white tracking-tight">MegaDashboard Webhooks</h1>
                <p className="text-gray-400 mt-1 text-lg">Manage, monitor, and debug your webhook integrations.</p>
            </header>

            <div className="flex-grow flex">
                {/* Sidebar Navigation */}
                <nav className="w-64 bg-gray-800 border-r border-gray-700 p-6 flex-shrink-0">
                    <ul className="space-y-2">
                        {[
                            { id: 'dashboard', label: 'Dashboard', icon: '' },
                            { id: 'endpoints', label: 'Endpoints', icon: '' },
                            { id: 'events', label: 'Events Log', icon: '' },
                            { id: 'alerts', label: 'Alerts', icon: '' },
                            { id: 'api-keys', label: 'API Keys', icon: '' },
                            { id: 'settings', label: 'Global Settings', icon: '' },
                            { id: 'audit-log', label: 'Audit Log', icon: '' },
                            { id: 'testing', label: 'Developer Tools', icon: '' },
                        ].map(item => (
                            <li key={item.id}>
                                <button
                                    onClick={() => setActiveTab(item.id as any)}
                                    className={`flex items-center w-full px-4 py-2 rounded-md text-left text-sm font-medium transition-colors duration-200
                                        ${activeTab === item.id ? 'bg-cyan-700 text-white shadow-md' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}`}
                                >
                                    <span className="mr-3">{item.icon}</span>
                                    {item.label}
                                </button>
                            </li>
                        ))}
                    </ul>
                </nav>

                {/* Main Content Area */}
                <main ref={mainContentRef} className="flex-grow p-8 overflow-y-auto space-y-6">
                    {feedbackMessage && (
                        <div className={`p-4 rounded-md text-sm font-medium ${feedbackMessage.type === 'success' ? 'bg-green-600 text-white' : feedbackMessage.type === 'error' ? 'bg-red-600 text-white' : 'bg-blue-600 text-white'}`}>
                            {feedbackMessage.message}
                            <button onClick={() => setFeedbackMessage(null)} className="float-right text-white opacity-75 hover:opacity-100">&times;</button>
                        </div>
                    )}

                    {/* --- Dashboard Tab --- */}
                    {activeTab === 'dashboard' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Dashboard Overview</h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                                <Card className="text-center">
                                    <p className="text-3xl font-bold text-white">{analyticsSummary.activeEndpoints}</p>
                                    <p className="text-sm text-gray-400 mt-1">Active Endpoints</p>
                                    <p className="text-xs text-gray-500">of {analyticsSummary.totalEndpoints} total</p>
                                </Card>
                                <Card className="text-center">
                                    <p className="text-3xl font-bold text-white">{analyticsSummary.totalEventsDelivered24h.toLocaleString()}</p>
                                    <p className="text-sm text-gray-400 mt-1">Events Delivered (24h)</p>
                                    <p className="text-xs text-gray-500">{analyticsSummary.pendingEvents.toLocaleString()} pending</p>
                                </Card>
                                <Card className="text-center">
                                    <p className="text-3xl font-bold text-white">{analyticsSummary.failureRate24h}%</p>
                                    <p className="text-sm text-gray-400 mt-1">Failure Rate (24h)</p>
                                    <p className="text-xs text-gray-500">{analyticsSummary.retryingEvents.toLocaleString()} retrying</p>
                                </Card>
                                <Card className="text-center">
                                    <p className="text-3xl font-bold text-white">{analyticsSummary.avgLatencyMs24h}ms</p>
                                    <p className="text-sm text-gray-400 mt-1">Avg. Latency (24h)</p>
                                    <p className="text-xs text-gray-500">P99: {analyticsSummary.latencyP99Ms}ms</p>
                                </Card>
                            </div>

                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                {chartConfigs.map(chart => (
                                    <ChartPlaceholder key={chart.id} {...chart} />
                                ))}
                            </div>

                            <Card title="Top 5 Failed Endpoints (24h)" className="col-span-2">
                                <table className="w-full text-sm text-left text-gray-400">
                                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                        <tr>
                                            <th className="px-6 py-3">Endpoint URL</th>
                                            <th className="px-6 py-3 text-right">Failures</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {analyticsSummary.topFailedEndpoints.length === 0 ? (
                                            <tr><td colSpan={2} className="px-6 py-4 text-center text-gray-500">No failed endpoints in the last 24h.</td></tr>
                                        ) : (
                                            analyticsSummary.topFailedEndpoints.map(wh => (
                                                <tr key={wh.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 font-mono text-white">{wh.url}</td>
                                                    <td className="px-6 py-4 text-right text-red-400">{wh.failures.toLocaleString()}</td>
                                                </tr>
                                            ))
                                        )}
                                    </tbody>
                                </table>
                            </Card>
                        </div>
                    )}

                    {/* --- Endpoints Tab --- */}
                    {activeTab === 'endpoints' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider flex items-center justify-between">
                                Webhook Endpoints
                                <button onClick={handleCreateWebhook} className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                    + Add New Webhook
                                </button>
                            </h2>

                            <Card className="p-4">
                                <div className="flex flex-wrap items-center gap-4 mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search URLs, descriptions, events..."
                                        className="flex-1 min-w-[200px] bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        onChange={(e) => handleWebhookFilterChange('searchTerm', e.target.value)}
                                    />
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleWebhookFilterChange('status', e.target.value)}
                                        value={webhookFilters.status || 'All'}
                                    >
                                        <option value="All">All Statuses</option>
                                        <option value="Active">Active</option>
                                        <option value="Disabled">Disabled</option>
                                        <option value="Paused">Paused</option>
                                    </select>
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleWebhookFilterChange('eventType', e.target.value)}
                                        value={webhookFilters.eventType || 'All'}
                                    >
                                        <option value="All">All Event Types</option>
                                        <option value="transaction.created">transaction.created</option>
                                        <option value="payment.updated">payment.updated</option>
                                        <option value="user.created">user.created</option>
                                        <option value="user.updated">user.updated</option>
                                        <option value="*">* (All Events)</option>
                                    </select>
                                </div>
                            </Card>

                            <Card title="Registered Webhooks">
                                {displayedWebhooks.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">No webhooks found matching your criteria.</p>
                                ) : (
                                    <table className="w-full text-sm text-left text-gray-400">
                                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                            <tr>
                                                <th className="px-6 py-3">URL</th>
                                                <th className="px-6 py-3">Status</th>
                                                <th className="px-6 py-3">Subscribed Events</th>
                                                <th className="px-6 py-3">Metrics (24h)</th>
                                                <th className="px-6 py-3 text-right">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {displayedWebhooks.map(wh => (
                                                <tr key={wh.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 font-mono text-white text-xs max-w-xs truncate">{wh.url}</td>
                                                    <td className="px-6 py-4">
                                                        <span className={`${wh.status === 'Active' ? 'text-green-400' : wh.status === 'Disabled' ? 'text-gray-500' : 'text-yellow-400'} text-xs font-semibold`}>
                                                            {wh.status}
                                                        </span>
                                                    </td>
                                                    <td className="px-6 py-4 flex flex-wrap gap-1 max-w-sm">
                                                        {wh.events.map(e => <span key={e} className="text-xs bg-gray-700 px-2 py-0.5 rounded-full">{e}</span>)}
                                                    </td>
                                                    <td className="px-6 py-4 text-xs">
                                                        <p>Delivered: {wh.deliveryMetrics.successfulDeliveries.toLocaleString()}</p>
                                                        <p>Failed: <span className="text-red-400">{wh.deliveryMetrics.failedDeliveries.toLocaleString()}</span></p>
                                                        <p>Avg Latency: {wh.deliveryMetrics.avgLatencyMs}ms</p>
                                                    </td>
                                                    <td className="px-6 py-4 text-right whitespace-nowrap">
                                                        <button onClick={() => handleEditWebhook(wh)} className="text-cyan-400 hover:underline text-sm mr-4">Edit</button>
                                                        <div className="relative inline-block text-left">
                                                            <select
                                                                className="bg-gray-800 border border-gray-700 rounded-md text-white text-sm focus:ring-cyan-500 focus:border-cyan-500 p-1"
                                                                value={wh.status}
                                                                onChange={(e) => handleWebhookStatusChange(wh.id, e.target.value as 'Active' | 'Disabled' | 'Paused')}
                                                            >
                                                                <option value="Active">Active</option>
                                                                <option value="Paused">Pause</option>
                                                                <option value="Disabled">Disable</option>
                                                            </select>
                                                        </div>
                                                        <button onClick={() => setShowDeleteWebhookConfirm(wh.id)} className="text-red-400 hover:underline text-sm ml-4">Delete</button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                                <Pagination pagination={webhookPagination} onPageChange={setCurrentWebhookPage} />
                            </Card>
                        </div>
                    )}

                    {/* Webhook Editor Modal */}
                    {isWebhookModalOpen && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsWebhookModalOpen(false)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700">
                                    <h3 className="text-lg font-semibold text-white">{editingWebhook?.id ? 'Edit Webhook Endpoint' : 'Create New Webhook Endpoint'}</h3>
                                </div>
                                <form className="p-6 space-y-4 max-h-[80vh] overflow-y-auto custom-scrollbar" onSubmit={(e) => { e.preventDefault(); editingWebhook && handleSaveWebhook(editingWebhook); }}>
                                    <FormField label="Endpoint URL" htmlFor="url" error={webhookFormErrors.url}>
                                        <input
                                            id="url"
                                            type="url"
                                            value={editingWebhook?.url || ''}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, url: e.target.value } : null)}
                                            placeholder="https://your-app.com/webhook-listener"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            required
                                        />
                                    </FormField>

                                    <FormField label="Description" htmlFor="description">
                                        <textarea
                                            id="description"
                                            value={editingWebhook?.description || ''}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, description: e.target.value } : null)}
                                            placeholder="A brief description of this webhook's purpose."
                                            rows={2}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm resize-y"
                                        ></textarea>
                                    </FormField>

                                    <FormField label="Subscribed Events" description="Comma-separated list of event types (e.g., user.created, payment.succeeded) or '*' for all events." error={webhookFormErrors.events}>
                                        <input
                                            type="text"
                                            value={editingWebhook?.events.join(', ') || ''}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, events: e.target.value.split(',').map(s => s.trim()).filter(s => s !== '') } : null)}
                                            placeholder="*, transaction.created"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            required
                                        />
                                    </FormField>

                                    <FormField label="Status" htmlFor="status">
                                        <select
                                            id="status"
                                            value={editingWebhook?.status || 'Active'}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, status: e.target.value as 'Active' | 'Disabled' | 'Paused' } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="Active">Active</option>
                                            <option value="Disabled">Disabled</option>
                                            <option value="Paused">Paused</option>
                                        </select>
                                    </FormField>

                                    <FormField label="Secret for Signature Verification" description="Used to sign payloads for security. Leave empty to auto-generate." htmlFor="secret">
                                        <input
                                            id="secret"
                                            type="password" // Use password type for security in UI
                                            value={editingWebhook?.secret || ''}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, secret: e.target.value } : null)}
                                            placeholder="Optional: custom secret string"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        />
                                    </FormField>

                                    <DynamicKeyValueList
                                        label="Custom Headers"
                                        description="Add custom HTTP headers to be sent with each webhook request."
                                        items={editingWebhook?.headers || []}
                                        onItemChange={(id, key, value) => {
                                            setEditingWebhook(prev => prev ? { ...prev, headers: prev.headers.map(h => h.id === id ? { ...h, [key]: value } : h) } : null);
                                        }}
                                        onAddItem={() => {
                                            setEditingWebhook(prev => prev ? { ...prev, headers: [...prev.headers, { key: '', value: '', id: uuidv4() }] } : null);
                                        }}
                                        onRemoveItem={(id) => {
                                            setEditingWebhook(prev => prev ? { ...prev, headers: prev.headers.filter(h => h.id !== id) } : null);
                                        }}
                                        keyPlaceholder="Header-Key"
                                        valuePlaceholder="Header Value"
                                        addButtonText="Add Header"
                                    />

                                    <FormField label="Authentication Type" htmlFor="authType" error={webhookFormErrors.auth}>
                                        <select
                                            id="authType"
                                            value={editingWebhook?.authType || 'none'}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, authType: e.target.value as 'none' | 'basic' | 'bearer' } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="none">None</option>
                                            <option value="basic">Basic Auth</option>
                                            <option value="bearer">Bearer Token</option>
                                        </select>
                                    </FormField>

                                    {editingWebhook?.authType === 'basic' && (
                                        <div className="grid grid-cols-2 gap-4">
                                            <FormField label="Username" htmlFor="authUsername">
                                                <input
                                                    id="authUsername"
                                                    type="text"
                                                    value={editingWebhook?.username || ''}
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, username: e.target.value } : null)}
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                    required
                                                />
                                            </FormField>
                                            <FormField label="Password" htmlFor="authPassword">
                                                <input
                                                    id="authPassword"
                                                    type="password" // Use password type
                                                    value={editingWebhook?.password || ''} // In real app, this would be masked/re-entered
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, password: e.target.value } : null)}
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                    required
                                                />
                                            </FormField>
                                        </div>
                                    )}

                                    {editingWebhook?.authType === 'bearer' && (
                                        <FormField label="Bearer Token" htmlFor="authToken">
                                            <input
                                                id="authToken"
                                                type="password" // Use password type
                                                value={editingWebhook?.authToken || ''} // In real app, this would be masked/re-entered
                                                onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, authToken: e.target.value } : null)}
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                required
                                            />
                                        </FormField>
                                    )}

                                    <FormField label="SSL Verification" description="Enable to verify SSL certificates of the endpoint URL. Recommended for production.">
                                        <label className="inline-flex items-center mt-2">
                                            <input
                                                type="checkbox"
                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                checked={editingWebhook?.sslVerificationEnabled || false}
                                                onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, sslVerificationEnabled: e.target.checked } : null)}
                                            />
                                            <span className="ml-2 text-gray-300 text-sm">Verify SSL Certificate</span>
                                        </label>
                                    </FormField>

                                    <Card title="Retry Policy" className="p-4 bg-gray-800 border-gray-700">
                                        <div className="grid grid-cols-2 gap-4">
                                            <FormField label="Max Retries">
                                                <input
                                                    type="number"
                                                    value={editingWebhook?.retryPolicy.maxRetries || 0}
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, retryPolicy: { ...prev.retryPolicy, maxRetries: parseInt(e.target.value) } } : null)}
                                                    min="0"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <FormField label="Initial Interval (seconds)">
                                                <input
                                                    type="number"
                                                    value={editingWebhook?.retryPolicy.initialIntervalSeconds || 0}
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, retryPolicy: { ...prev.retryPolicy, initialIntervalSeconds: parseInt(e.target.value) } } : null)}
                                                    min="0"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <FormField label="Multiplier">
                                                <input
                                                    type="number"
                                                    step="0.1"
                                                    value={editingWebhook?.retryPolicy.multiplier || 0}
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, retryPolicy: { ...prev.retryPolicy, multiplier: parseFloat(e.target.value) } } : null)}
                                                    min="1"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <FormField label="Max Interval (seconds)">
                                                <input
                                                    type="number"
                                                    value={editingWebhook?.retryPolicy.maxIntervalSeconds || 0}
                                                    onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, retryPolicy: { ...prev.retryPolicy, maxIntervalSeconds: parseInt(e.target.value) } } : null)}
                                                    min="0"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                        </div>
                                    </Card>

                                    <DynamicKeyValueList
                                        label="Metadata"
                                        description="Custom key-value pairs for internal categorization or tagging."
                                        items={editingWebhook?.metadata || []}
                                        onItemChange={(id, key, value) => {
                                            setEditingWebhook(prev => prev ? { ...prev, metadata: prev.metadata.map(m => m.id === id ? { ...m, [key]: value } : m) } : null);
                                        }}
                                        onAddItem={() => {
                                            setEditingWebhook(prev => prev ? { ...prev, metadata: [...prev.metadata, { key: '', value: '', id: uuidv4() }] } : null);
                                        }}
                                        onRemoveItem={(id) => {
                                            setEditingWebhook(prev => prev ? { ...prev, metadata: prev.metadata.filter(m => m.id !== id) } : null);
                                        }}
                                        keyPlaceholder="metadata-key"
                                        valuePlaceholder="metadata-value"
                                        addButtonText="Add Metadata"
                                    />

                                    <FormField label="Environment" htmlFor="environment">
                                        <select
                                            id="environment"
                                            value={editingWebhook?.environment || 'development'}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, environment: e.target.value as 'development' | 'staging' | 'production' } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="development">Development</option>
                                            <option value="staging">Staging</option>
                                            <option value="production">Production</option>
                                        </select>
                                    </FormField>

                                    <FormField label="Tags" description="Comma-separated tags for organization.">
                                        <input
                                            type="text"
                                            value={editingWebhook?.tags.join(', ') || ''}
                                            onChange={(e) => setEditingWebhook(prev => prev ? { ...prev, tags: e.target.value.split(',').map(s => s.trim()).filter(s => s !== '') } : null)}
                                            placeholder="billing, customer-service"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        />
                                    </FormField>

                                    <div className="flex justify-end space-x-3 mt-6">
                                        <button type="button" onClick={() => setIsWebhookModalOpen(false)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Cancel
                                        </button>
                                        <button type="submit" className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            {editingWebhook?.id ? 'Save Changes' : 'Create Webhook'}
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}

                    {/* Delete Webhook Confirmation Modal */}
                    {showDeleteWebhookConfirm && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setShowDeleteWebhookConfirm(null)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700"><h3 className="text-lg font-semibold text-white">Confirm Deletion</h3></div>
                                <div className="p-6">
                                    <p className="text-gray-300 mb-6">Are you sure you want to delete this webhook endpoint? This action cannot be undone.</p>
                                    <div className="flex justify-end space-x-3">
                                        <button type="button" onClick={() => setShowDeleteWebhookConfirm(null)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Cancel
                                        </button>
                                        <button type="button" onClick={() => handleDeleteWebhook(showDeleteWebhookConfirm)} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Delete Permanently
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- Events Log Tab --- */}
                    {activeTab === 'events' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Recent Events Log</h2>

                            <Card className="p-4">
                                <div className="flex flex-wrap items-center gap-4 mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search by event type, payload, error..."
                                        className="flex-1 min-w-[200px] bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        onChange={(e) => handleEventFilterChange('searchTerm', e.target.value)}
                                    />
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleEventFilterChange('status', e.target.value)}
                                        value={eventFilters.status || 'All'}
                                    >
                                        <option value="All">All Statuses</option>
                                        <option value="Delivered">Delivered</option>
                                        <option value="Failed">Failed</option>
                                        <option value="Pending">Pending</option>
                                        <option value="Retrying">Retrying</option>
                                    </select>
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleEventFilterChange('eventType', e.target.value)}
                                        value={eventFilters.eventType || 'All'}
                                    >
                                        <option value="All">All Event Types</option>
                                        <option value="transaction.created">transaction.created</option>
                                        <option value="payment.updated">payment.updated</option>
                                        <option value="user.created">user.created</option>
                                        <option value="user.updated">user.updated</option>
                                        <option value="order.placed">order.placed</option>
                                    </select>
                                </div>
                            </Card>

                            <Card title="Recent Events">
                                {displayedEvents.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">No events found matching your criteria.</p>
                                ) : (
                                    <table className="w-full text-sm text-left text-gray-400">
                                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                            <tr>
                                                <th className="px-6 py-3">Timestamp</th>
                                                <th className="px-6 py-3">Webhook ID</th>
                                                <th className="px-6 py-3">Type</th>
                                                <th className="px-6 py-3">Status</th>
                                                <th className="px-6 py-3 text-right">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {displayedEvents.map(evt => (
                                                <tr key={evt.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 text-xs">{new Date(evt.timestamp).toLocaleString()}</td>
                                                    <td className="px-6 py-4 font-mono text-white text-xs">{evt.webhookId}</td>
                                                    <td className="px-6 py-4 font-mono text-white text-xs">{evt.type}</td>
                                                    <td className="px-6 py-4">
                                                        <span className={`${evt.status === 'Delivered' ? 'text-green-400' : evt.status === 'Failed' ? 'text-red-400' : 'text-yellow-400'} text-xs font-semibold`}>
                                                            {evt.status}
                                                        </span>
                                                    </td>
                                                    <td className="px-6 py-4 text-right whitespace-nowrap">
                                                        <button onClick={() => handleEventDetailsClick(evt)} className="text-cyan-400 hover:underline text-sm mr-4">View Details</button>
                                                        {evt.status === 'Failed' && (
                                                            <button onClick={() => handleReplayEvent(evt.id)} className="text-purple-400 hover:underline text-sm disabled:opacity-50" disabled={isReplayLoading}>
                                                                {isReplayLoading ? 'Replaying...' : 'Replay'}
                                                            </button>
                                                        )}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                                <Pagination pagination={eventPagination} onPageChange={setCurrentEventPage} />
                            </Card>
                        </div>
                    )}

                    {/* Event Details and AI Debugger Modal */}
                    {isEventDetailsModalOpen && selectedEvent && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsEventDetailsModalOpen(false)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-3xl w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                                    <h3 className="text-lg font-semibold text-white">Event Details: {selectedEvent.id}</h3>
                                    <button onClick={() => setIsEventDetailsModalOpen(false)} className="text-gray-400 hover:text-white">&times;</button>
                                </div>
                                <div className="p-6 space-y-4 max-h-[70vh] overflow-y-auto custom-scrollbar">
                                    <Card title="Event Summary">
                                        <div className="grid grid-cols-2 gap-2 text-sm text-gray-300">
                                            <p><strong>Webhook ID:</strong> <span className="font-mono">{selectedEvent.webhookId}</span></p>
                                            <p><strong>Type:</strong> <span className="font-mono">{selectedEvent.type}</span></p>
                                            <p><strong>Status:</strong> <span className={`${selectedEvent.status === 'Delivered' ? 'text-green-400' : selectedEvent.status === 'Failed' ? 'text-red-400' : 'text-yellow-400'} font-semibold`}>{selectedEvent.status}</span></p>
                                            <p><strong>Timestamp:</strong> {new Date(selectedEvent.timestamp).toLocaleString()}</p>
                                            <p className="col-span-2"><strong>External Ref:</strong> {selectedEvent.externalRef || 'N/A'}</p>
                                            <p className="col-span-2"><strong>Metadata:</strong> <pre className="text-xs">{JSON.stringify(selectedEvent.metadata, null, 2)}</pre></p>
                                        </div>
                                    </Card>

                                    <Card title="Event Payload">
                                        <pre className="text-xs bg-gray-900 p-3 rounded-md overflow-x-auto text-white">{JSON.stringify(selectedEvent.payload, null, 2)}</pre>
                                    </Card>

                                    <Card title="Delivery Attempts">
                                        {selectedEvent.deliveryAttempts.length === 0 ? (
                                            <p className="text-sm text-gray-500">No delivery attempts recorded.</p>
                                        ) : (
                                            <div className="space-y-3">
                                                {selectedEvent.deliveryAttempts.map((attempt, index) => (
                                                    <div key={index} className="border border-gray-700 rounded-md p-3 text-xs">
                                                        <p><strong>Attempt #{attempt.attempt}</strong> ({new Date(attempt.timestamp).toLocaleString()})</p>
                                                        <p>Status: <span className={`${attempt.status === 'Success' ? 'text-green-400' : 'text-red-400'}`}>{attempt.status}</span> (HTTP {attempt.responseStatus || 'N/A'})</p>
                                                        <p>Latency: {attempt.latencyMs}ms</p>
                                                        {attempt.errorDetails && <p className="text-red-400">Error: {attempt.errorDetails}</p>}
                                                        {attempt.responseText && <p>Response: <span className="truncate max-w-full inline-block">{attempt.responseText}</span></p>}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </Card>

                                    {selectedEvent.status === 'Failed' && (
                                        <Card title="AI Analysis for Failure">
                                            <p className="text-sm text-gray-300 whitespace-pre-line">{isAiLoading ? 'Analyzing...' : (aiError || aiAnalysis || 'Click "Analyze" to get AI insights.')}</p>
                                            <button onClick={handleAiAnalyze} disabled={isAiLoading} className="mt-4 bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200 disabled:opacity-50">
                                                {isAiLoading ? 'Analyzing...' : 'Analyze with AI'}
                                            </button>
                                            {aiError && <p className="text-red-400 text-xs mt-2">{aiError}</p>}
                                        </Card>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- Alerts Tab --- */}
                    {activeTab === 'alerts' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider flex items-center justify-between">
                                Alert Rules
                                <button onClick={handleCreateAlert} className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                    + Create New Alert
                                </button>
                            </h2>
                            <p className="text-gray-400">Configure rules to get notified about critical webhook events and performance issues.</p>

                            <Card title="Defined Alert Rules">
                                {alertRules.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">No alert rules configured yet.</p>
                                ) : (
                                    <table className="w-full text-sm text-left text-gray-400">
                                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                            <tr>
                                                <th className="px-6 py-3">Name</th>
                                                <th className="px-6 py-3">Type</th>
                                                <th className="px-6 py-3">Threshold</th>
                                                <th className="px-6 py-3">Scope</th>
                                                <th className="px-6 py-3">Status</th>
                                                <th className="px-6 py-3 text-right">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {alertRules.map(rule => (
                                                <tr key={rule.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 font-semibold text-white">{rule.name}</td>
                                                    <td className="px-6 py-4 text-xs font-mono">{rule.type.replace(/_/g, ' ')}</td>
                                                    <td className="px-6 py-4">{rule.threshold} / {rule.durationMinutes}min</td>
                                                    <td className="px-6 py-4 text-xs">{rule.webhookId ? `Webhook: ${rule.webhookId}` : 'Global'}</td>
                                                    <td className="px-6 py-4">
                                                        <span className={`${rule.status === 'Active' ? 'text-green-400' : 'text-gray-500'} text-xs font-semibold`}>
                                                            {rule.status}
                                                        </span>
                                                    </td>
                                                    <td className="px-6 py-4 text-right whitespace-nowrap">
                                                        <button onClick={() => handleEditAlert(rule)} className="text-cyan-400 hover:underline text-sm mr-4">Edit</button>
                                                        <button onClick={() => setShowDeleteAlertConfirm(rule.id)} className="text-red-400 hover:underline text-sm">Delete</button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                            </Card>
                        </div>
                    )}

                    {/* Alert Rule Editor Modal */}
                    {isAlertModalOpen && editingAlertRule && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsAlertModalOpen(false)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700">
                                    <h3 className="text-lg font-semibold text-white">{editingAlertRule.id ? 'Edit Alert Rule' : 'Create New Alert Rule'}</h3>
                                </div>
                                <form className="p-6 space-y-4 max-h-[80vh] overflow-y-auto custom-scrollbar" onSubmit={(e) => { e.preventDefault(); handleSaveAlert(editingAlertRule); }}>
                                    <FormField label="Rule Name" htmlFor="alertName" error={alertFormErrors.name}>
                                        <input
                                            id="alertName"
                                            type="text"
                                            value={editingAlertRule.name}
                                            onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, name: e.target.value } : null)}
                                            placeholder="e.g., High Failure Rate in Production"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            required
                                        />
                                    </FormField>

                                    <FormField label="Alert Type" htmlFor="alertType">
                                        <select
                                            id="alertType"
                                            value={editingAlertRule.type}
                                            onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, type: e.target.value as AlertRule['type'] } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="webhook_failure_rate">Webhook Failure Rate (%)</option>
                                            <option value="event_latency">Event Latency (ms)</option>
                                            <option value="delivery_success_rate">Delivery Success Rate (%)</option>
                                            <option value="endpoint_down">Endpoint Down</option>
                                            <option value="custom_metric">Custom Metric</option>
                                        </select>
                                    </FormField>

                                    {editingAlertRule.type === 'custom_metric' && (
                                        <div className="grid grid-cols-2 gap-4">
                                            <FormField label="Metric Path (JSONPath)" htmlFor="metricPath" error={alertFormErrors.customMetric}>
                                                <input
                                                    id="metricPath"
                                                    type="text"
                                                    value={editingAlertRule.metricPath || ''}
                                                    onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, metricPath: e.target.value } : null)}
                                                    placeholder="e.g., $.payload.amount, $.responseStatus"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <FormField label="Operator" htmlFor="operator" error={alertFormErrors.customMetric}>
                                                <select
                                                    id="operator"
                                                    value={editingAlertRule.operator || 'gt'}
                                                    onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, operator: e.target.value as AlertRule['operator'] } : null)}
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                >
                                                    <option value="gt">Greater Than ( > )</option>
                                                    <option value="lt">Less Than ( &lt; )</option>
                                                    <option value="eq">Equals ( = )</option>
                                                    <option value="gte">Greater Than or Equal ( >= )</option>
                                                    <option value="lte">Less Than or Equal ( &lt;= )</option>
                                                </select>
                                            </FormField>
                                        </div>
                                    )}

                                    <div className="grid grid-cols-2 gap-4">
                                        <FormField label="Threshold Value" htmlFor="threshold" error={alertFormErrors.threshold}>
                                            <input
                                                id="threshold"
                                                type="number"
                                                step="0.1"
                                                value={editingAlertRule.threshold}
                                                onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, threshold: parseFloat(e.target.value) } : null)}
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                required
                                            />
                                        </FormField>
                                        <FormField label="Duration (minutes)" htmlFor="durationMinutes" error={alertFormErrors.durationMinutes}>
                                            <input
                                                id="durationMinutes"
                                                type="number"
                                                value={editingAlertRule.durationMinutes}
                                                onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, durationMinutes: parseInt(e.target.value) } : null)}
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                required
                                            />
                                        </FormField>
                                    </div>

                                    <FormField label="Scope (Optional)" description="Apply this rule to a specific webhook or globally." htmlFor="webhookId">
                                        <select
                                            id="webhookId"
                                            value={editingAlertRule.webhookId || ''}
                                            onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, webhookId: e.target.value || undefined } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="">Global</option>
                                            {webhooks.map(wh => <option key={wh.id} value={wh.id}>{wh.url} ({wh.id})</option>)}
                                        </select>
                                    </FormField>

                                    <FormField label="Severity" htmlFor="severity">
                                        <select
                                            id="severity"
                                            value={editingAlertRule.severity}
                                            onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, severity: e.target.value as AlertRule['severity'] } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="Low">Low</option>
                                            <option value="Medium">Medium</option>
                                            <option value="High">High</option>
                                            <option value="Critical">Critical</option>
                                        </select>
                                    </FormField>

                                    <FormField label="Status" htmlFor="alertStatus">
                                        <select
                                            id="alertStatus"
                                            value={editingAlertRule.status}
                                            onChange={(e) => setEditingAlertRule(prev => prev ? { ...prev, status: e.target.value as AlertRule['status'] } : null)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="Active">Active</option>
                                            <option value="Inactive">Inactive</option>
                                        </select>
                                    </FormField>

                                    <Card title="Notification Channels" className="bg-gray-800 border-gray-700">
                                        <p className="text-sm text-gray-400 mb-3">Configure where alerts should be sent.</p>
                                        {editingAlertRule.channels.map((channel, index) => (
                                            <div key={channel.id} className="flex items-center space-x-2 mb-2">
                                                <select
                                                    value={channel.type}
                                                    onChange={(e) => setEditingAlertRule(prev => prev ? {
                                                        ...prev, channels: prev.channels.map(c => c.id === channel.id ? { ...c, type: e.target.value as any } : c)
                                                    } : null)}
                                                    className="w-1/3 bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm"
                                                >
                                                    <option value="email">Email</option>
                                                    <option value="slack">Slack</option>
                                                    <option value="sms">SMS</option>
                                                    <option value="pagerduty">PagerDuty</option>
                                                </select>
                                                <input
                                                    type="text"
                                                    value={channel.recipient}
                                                    onChange={(e) => setEditingAlertRule(prev => prev ? {
                                                        ...prev, channels: prev.channels.map(c => c.id === channel.id ? { ...c, recipient: e.target.value } : c)
                                                    } : null)}
                                                    placeholder={channel.type === 'email' ? 'email@example.com' : channel.type === 'slack' ? '#channel-name' : 'PagerDuty Key'}
                                                    className="flex-1 bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                                <button
                                                    type="button"
                                                    onClick={() => setEditingAlertRule(prev => prev ? { ...prev, channels: prev.channels.filter(c => c.id !== channel.id) } : null)}
                                                    className="text-red-400 hover:text-red-500 p-2 text-sm"
                                                >
                                                    Remove
                                                </button>
                                            </div>
                                        ))}
                                        {alertFormErrors.channels && <p className="text-red-400 text-xs mt-1">{alertFormErrors.channels}</p>}
                                        <button
                                            type="button"
                                            onClick={() => setEditingAlertRule(prev => prev ? { ...prev, channels: [...prev.channels, { id: uuidv4(), type: 'email', recipient: '' }] } : null)}
                                            className="mt-3 bg-gray-700 text-gray-300 hover:bg-gray-600 border border-gray-600 px-4 py-2 rounded-md text-sm transition-colors duration-200"
                                        >
                                            Add Channel
                                        </button>
                                    </Card>

                                    <div className="flex justify-end space-x-3 mt-6">
                                        <button type="button" onClick={() => setIsAlertModalOpen(false)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Cancel
                                        </button>
                                        <button type="submit" className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Save Alert Rule
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    )}

                    {/* Delete Alert Rule Confirmation Modal */}
                    {showDeleteAlertConfirm && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setShowDeleteAlertConfirm(null)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700"><h3 className="text-lg font-semibold text-white">Confirm Deletion</h3></div>
                                <div className="p-6">
                                    <p className="text-gray-300 mb-6">Are you sure you want to delete this alert rule? This action cannot be undone.</p>
                                    <div className="flex justify-end space-x-3">
                                        <button type="button" onClick={() => setShowDeleteAlertConfirm(null)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Cancel
                                        </button>
                                        <button type="button" onClick={() => handleDeleteAlert(showDeleteAlertConfirm)} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Delete Permanently
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- API Keys Tab --- */}
                    {activeTab === 'api-keys' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider flex items-center justify-between">
                                API Keys
                                <button onClick={handleCreateApiKey} className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                    + Generate New Key
                                </button>
                            </h2>
                            <p className="text-gray-400">Manage API keys for programmatic access to your webhook platform. Keep your keys secure!</p>

                            <Card title="Your API Keys">
                                {apiKeys.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">No API keys generated yet.</p>
                                ) : (
                                    <table className="w-full text-sm text-left text-gray-400">
                                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                            <tr>
                                                <th className="px-6 py-3">Name</th>
                                                <th className="px-6 py-3">Key</th>
                                                <th className="px-6 py-3">Permissions</th>
                                                <th className="px-6 py-3">Status</th>
                                                <th className="px-6 py-3">Created At</th>
                                                <th className="px-6 py-3 text-right">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {apiKeys.map(key => (
                                                <tr key={key.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 font-semibold text-white">{key.name}</td>
                                                    <td className="px-6 py-4 font-mono text-xs">{key.key.substring(0, 10)}... (masked)</td>
                                                    <td className="px-6 py-4 flex flex-wrap gap-1 max-w-sm">
                                                        {key.permissions.map(p => <span key={p} className="text-xs bg-gray-700 px-2 py-0.5 rounded-full">{p}</span>)}
                                                    </td>
                                                    <td className="px-6 py-4">
                                                        <span className={`${key.status === 'Active' ? 'text-green-400' : 'text-red-400'} text-xs font-semibold`}>
                                                            {key.status}
                                                        </span>
                                                    </td>
                                                    <td className="px-6 py-4 text-xs">{new Date(key.createdAt).toLocaleDateString()}</td>
                                                    <td className="px-6 py-4 text-right whitespace-nowrap">
                                                        {key.status === 'Active' ? (
                                                            <button onClick={() => setShowRevokeApiKeyConfirm(key.id)} className="text-red-400 hover:underline text-sm">Revoke</button>
                                                        ) : (
                                                            <span className="text-gray-500 text-sm">Revoked</span>
                                                        )}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                            </Card>
                        </div>
                    )}

                    {/* API Key Generation Modal */}
                    {isApiKeyModalOpen && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsApiKeyModalOpen(false)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-xl w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700">
                                    <h3 className="text-lg font-semibold text-white">Generate New API Key</h3>
                                </div>
                                <div className="p-6 space-y-4">
                                    {!newApiKeyDisplay ? (
                                        <>
                                            <FormField label="Key Name" htmlFor="newApiKeyName">
                                                <input
                                                    id="newApiKeyName"
                                                    type="text"
                                                    value={newApiKeyFormData.name}
                                                    onChange={(e) => setNewApiKeyFormData(prev => ({ ...prev, name: e.target.value }))}
                                                    placeholder="e.g., My Integration Service Key"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                    required
                                                />
                                            </FormField>
                                            <FormField label="Permissions" description="Select required permissions for this API key.">
                                                <div className="grid grid-cols-2 gap-2 text-sm">
                                                    {['webhook:read', 'webhook:write', 'event:read', 'event:replay', 'alert:read', 'alert:write'].map(perm => (
                                                        <label key={perm} className="inline-flex items-center text-gray-300">
                                                            <input
                                                                type="checkbox"
                                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                                checked={newApiKeyFormData.permissions.includes(perm)}
                                                                onChange={(e) => {
                                                                    setNewApiKeyFormData(prev => ({
                                                                        ...prev,
                                                                        permissions: e.target.checked
                                                                            ? [...prev.permissions, perm]
                                                                            : prev.permissions.filter(p => p !== perm)
                                                                    }));
                                                                }}
                                                            />
                                                            <span className="ml-2">{perm}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </FormField>
                                            <FormField label="Expires At (Optional)" htmlFor="expiresAt">
                                                <input
                                                    id="expiresAt"
                                                    type="date"
                                                    value={newApiKeyFormData.expiresAt || ''}
                                                    onChange={(e) => setNewApiKeyFormData(prev => ({ ...prev, expiresAt: e.target.value }))}
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <div className="flex justify-end space-x-3 mt-6">
                                                <button type="button" onClick={() => setIsApiKeyModalOpen(false)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                                    Cancel
                                                </button>
                                                <button type="button" onClick={handleGenerateApiKey} className="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                                    Generate Key
                                                </button>
                                            </div>
                                        </>
                                    ) : (
                                        <Card title="New API Key Generated!">
                                            <p className="text-yellow-400 mb-3">Please copy this key now. It will not be shown again!</p>
                                            <pre className="bg-gray-900 p-3 rounded-md overflow-x-auto text-green-400 font-mono text-sm break-all">{newApiKeyDisplay}</pre>
                                            <div className="flex justify-end mt-4">
                                                <button
                                                    onClick={() => { navigator.clipboard.writeText(newApiKeyDisplay); setFeedbackMessage({ type: 'success', message: 'API Key copied to clipboard!' }); }}
                                                    className="bg-gray-700 text-gray-300 hover:bg-gray-600 border border-gray-600 px-4 py-2 rounded-md text-sm transition-colors duration-200"
                                                >
                                                    Copy to Clipboard
                                                </button>
                                                <button onClick={() => setIsApiKeyModalOpen(false)} className="ml-3 bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                                    Done
                                                </button>
                                            </div>
                                        </Card>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Revoke API Key Confirmation Modal */}
                    {showRevokeApiKeyConfirm && (
                        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setShowRevokeApiKeyConfirm(null)}>
                            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full border border-gray-700" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700"><h3 className="text-lg font-semibold text-white">Confirm API Key Revocation</h3></div>
                                <div className="p-6">
                                    <p className="text-gray-300 mb-6">Are you sure you want to revoke this API key? This will immediately invalidate it and cannot be undone.</p>
                                    <div className="flex justify-end space-x-3">
                                        <button type="button" onClick={() => setShowRevokeApiKeyConfirm(null)} className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Cancel
                                        </button>
                                        <button type="button" onClick={() => handleRevokeApiKey(showRevokeApiKeyConfirm)} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                                            Revoke Key
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- Global Settings Tab --- */}
                    {activeTab === 'settings' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Global Webhook Settings</h2>
                            <p className="text-gray-400">These settings apply to all webhooks unless overridden at the individual webhook level.</p>

                            <Card title="General Delivery Settings">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <FormField label="Max Retries" description="Maximum number of times to retry a failed webhook delivery.">
                                        <input
                                            type="number"
                                            value={webhookSettings.maxRetries}
                                            onChange={(e) => handleSettingsChange('maxRetries', parseInt(e.target.value))}
                                            min="0"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        />
                                    </FormField>
                                    <FormField label="Timeout (ms)" description="Maximum time to wait for a webhook endpoint to respond.">
                                        <input
                                            type="number"
                                            value={webhookSettings.timeoutMs}
                                            onChange={(e) => handleSettingsChange('timeoutMs', parseInt(e.target.value))}
                                            min="1000"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        />
                                    </FormField>
                                    <FormField label="Retry Intervals (seconds)" description="Comma-separated list of intervals for retry attempts (e.g., 60,300,900).">
                                        <input
                                            type="text"
                                            value={webhookSettings.retryIntervalSeconds.join(', ')}
                                            onChange={(e) => handleSettingsChange('retryIntervalSeconds', e.target.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)))}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        />
                                    </FormField>
                                    <FormField label="Secret Signing" description="Enable cryptographic signing of webhook payloads for enhanced security.">
                                        <label className="inline-flex items-center mt-2">
                                            <input
                                                type="checkbox"
                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                checked={webhookSettings.secretSigningEnabled}
                                                onChange={(e) => handleSettingsChange('secretSigningEnabled', e.target.checked)}
                                            />
                                            <span className="ml-2 text-gray-300 text-sm">Enable Secret Signing</span>
                                        </label>
                                    </FormField>
                                    <FormField label="Delivery Attempts Logging" description="Log details for each attempt of a webhook delivery.">
                                        <label className="inline-flex items-center mt-2">
                                            <input
                                                type="checkbox"
                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                checked={webhookSettings.deliveryAttemptsLoggingEnabled}
                                                onChange={(e) => handleSettingsChange('deliveryAttemptsLoggingEnabled', e.target.checked)}
                                            />
                                            <span className="ml-2 text-gray-300 text-sm">Enable Detailed Logging</span>
                                        </label>
                                    </FormField>
                                    <FormField label="Global Monitoring" description="Enable overall system health monitoring for webhooks.">
                                        <label className="inline-flex items-center mt-2">
                                            <input
                                                type="checkbox"
                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                checked={webhookSettings.globalMonitoringEnabled}
                                                onChange={(e) => handleSettingsChange('globalMonitoringEnabled', e.target.checked)}
                                            />
                                            <span className="ml-2 text-gray-300 text-sm">Enable Global Monitoring</span>
                                        </label>
                                    </FormField>
                                </div>
                            </Card>

                            <Card title="Network & Security Settings">
                                <DynamicKeyValueList
                                    label="Default Headers"
                                    description="Headers added to all webhook requests by default."
                                    items={webhookSettings.defaultHeaders}
                                    onItemChange={handleUpdateDefaultHeader}
                                    onAddItem={handleAddDefaultHeader}
                                    onRemoveItem={handleRemoveDefaultHeader}
                                    keyPlaceholder="Header-Key"
                                    valuePlaceholder="Header Value"
                                    addButtonText="Add Default Header"
                                />

                                <FormField label="IP Whitelist (CIDR)" description="Only allow webhooks to be sent to these IP ranges. Comma-separated (e.g., 192.168.1.0/24, 10.0.0.1).">
                                    <textarea
                                        value={webhookSettings.ipWhitelist.join(', ')}
                                        onChange={(e) => handleSettingsChange('ipWhitelist', e.target.value.split(',').map(ip => ip.trim()).filter(ip => ip !== ''))}
                                        rows={3}
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm resize-y"
                                    ></textarea>
                                </FormField>

                                <FormField label="Rate Limiting" description="Prevent sending too many requests to an endpoint within a given time frame.">
                                    <label className="inline-flex items-center mt-2">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                            checked={webhookSettings.rateLimitEnabled}
                                            onChange={(e) => handleSettingsChange('rateLimitEnabled', e.target.checked)}
                                        />
                                        <span className="ml-2 text-gray-300 text-sm">Enable Global Rate Limiting</span>
                                    </label>
                                    {webhookSettings.rateLimitEnabled && (
                                        <div className="mt-2">
                                            <FormField label="Requests Per Minute">
                                                <input
                                                    type="number"
                                                    value={webhookSettings.rateLimitRequestsPerMinute}
                                                    onChange={(e) => handleSettingsChange('rateLimitRequestsPerMinute', parseInt(e.target.value))}
                                                    min="1"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                        </div>
                                    )}
                                </FormField>

                                <FormField label="Custom Certificates" description="Upload custom SSL/TLS certificates for endpoints requiring client authentication.">
                                    <label className="inline-flex items-center mt-2">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                            checked={webhookSettings.customCertsEnabled}
                                            onChange={(e) => handleSettingsChange('customCertsEnabled', e.target.checked)}
                                        />
                                        <span className="ml-2 text-gray-300 text-sm">Enable Custom Certificates</span>
                                    </label>
                                    {webhookSettings.customCertsEnabled && (
                                        <div className="mt-2 space-y-2">
                                            {/* Simplified for demo; in real app, this would involve file uploads and certificate management */}
                                            {webhookSettings.customCertificates.map(cert => (
                                                <div key={cert.id} className="flex items-center space-x-2 bg-gray-700 p-2 rounded-md">
                                                    <span className="text-sm text-white flex-1">{cert.name} (Expires: {new Date(cert.expiration).toLocaleDateString()})</span>
                                                    <button className="text-red-400 text-xs hover:underline">Remove</button>
                                                </div>
                                            ))}
                                            <button className="bg-gray-600 text-white px-3 py-1 rounded-md text-sm">Upload New Certificate</button>
                                        </div>
                                    )}
                                </FormField>
                            </Card>

                            <Card title="Advanced Settings">
                                <FormField label="Event Transformation" description="Enable global payload transformation rules before sending to any webhook.">
                                    <label className="inline-flex items-center mt-2">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                            checked={webhookSettings.eventTransformationEnabled}
                                            onChange={(e) => handleSettingsChange('eventTransformationEnabled', e.target.checked)}
                                        />
                                        <span className="ml-2 text-gray-300 text-sm">Enable Event Transformation</span>
                                    </label>
                                    {webhookSettings.eventTransformationEnabled && (
                                        <div className="mt-2 text-sm text-gray-500">
                                            <p>This would typically link to a dedicated editor for defining JmesPath or custom scripting rules.</p>
                                            <button className="text-cyan-400 hover:underline mt-1">Configure Transformation Rules</button>
                                        </div>
                                    )}
                                </FormField>

                                <FormField label="Dead Letter Queue (DLQ)" description="Route failed or undeliverable events to a DLQ for later inspection.">
                                    <label className="inline-flex items-center mt-2">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                            checked={webhookSettings.deadLetterQueueEnabled}
                                            onChange={(e) => handleSettingsChange('deadLetterQueueEnabled', e.target.checked)}
                                        />
                                        <span className="ml-2 text-gray-300 text-sm">Enable Dead Letter Queue</span>
                                    </label>
                                    {webhookSettings.deadLetterQueueEnabled && (
                                        <div className="mt-2 space-y-2">
                                            <FormField label="DLQ Type">
                                                <select
                                                    value={webhookSettings.deadLetterQueueConfig?.type || 's3'}
                                                    onChange={(e) => handleSettingsChange('deadLetterQueueConfig', { ...webhookSettings.deadLetterQueueConfig, type: e.target.value as 's3' | 'kafka' })}
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                >
                                                    <option value="s3">Amazon S3</option>
                                                    <option value="kafka">Apache Kafka</option>
                                                </select>
                                            </FormField>
                                            <FormField label="Target (Bucket/Topic Name)">
                                                <input
                                                    type="text"
                                                    value={webhookSettings.deadLetterQueueConfig?.target || ''}
                                                    onChange={(e) => handleSettingsChange('deadLetterQueueConfig', { ...webhookSettings.deadLetterQueueConfig, target: e.target.value })}
                                                    placeholder="my-dlq-bucket or my-dlq-topic"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                        </div>
                                    )}
                                </FormField>

                                <FormField label="Webhook Batching" description="Group multiple events into a single webhook request to reduce load.">
                                    <label className="inline-flex items-center mt-2">
                                        <input
                                            type="checkbox"
                                            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                            checked={webhookSettings.webhookBatchingEnabled}
                                            onChange={(e) => handleSettingsChange('webhookBatchingEnabled', e.target.checked)}
                                        />
                                        <span className="ml-2 text-gray-300 text-sm">Enable Global Webhook Batching</span>
                                    </label>
                                    {webhookSettings.webhookBatchingEnabled && (
                                        <div className="mt-2 grid grid-cols-2 gap-4">
                                            <FormField label="Batching Interval (ms)">
                                                <input
                                                    type="number"
                                                    value={webhookSettings.batchingIntervalMs || 1000}
                                                    onChange={(e) => handleSettingsChange('batchingIntervalMs', parseInt(e.target.value))}
                                                    min="100"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                            <FormField label="Max Events Per Batch">
                                                <input
                                                    type="number"
                                                    value={webhookSettings.batchingMaxEvents || 100}
                                                    onChange={(e) => handleSettingsChange('batchingMaxEvents', parseInt(e.target.value))}
                                                    min="1"
                                                    className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                                />
                                            </FormField>
                                        </div>
                                    )}
                                </FormField>
                            </Card>

                            <div className="flex justify-end mt-6">
                                <button
                                    onClick={handleSaveSettings}
                                    disabled={isSettingsLoading}
                                    className={`bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-2 px-6 rounded-md transition-colors duration-200 ${isSettingsLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
                                >
                                    {isSettingsLoading ? 'Saving...' : 'Save All Settings'}
                                </button>
                                {settingsSaveSuccess && !isSettingsLoading && (
                                    <span className="text-green-400 ml-3 flex items-center">
                                        <svg className="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path></svg>
                                        Saved!
                                    </span>
                                )}
                            </div>
                        </div>
                    )}

                    {/* --- Audit Log Tab --- */}
                    {activeTab === 'audit-log' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Audit Log</h2>
                            <p className="text-gray-400">Track all significant actions performed on your webhook platform by users and automated systems.</p>

                            <Card className="p-4">
                                <div className="flex flex-wrap items-center gap-4 mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search by action, actor, resource ID..."
                                        className="flex-1 min-w-[200px] bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        onChange={(e) => handleAuditLogFilterChange('searchTerm', e.target.value)}
                                    />
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleAuditLogFilterChange('resourceType', e.target.value)}
                                        value={auditLogFilters.resourceType || 'All'}
                                    >
                                        <option value="All">All Resource Types</option>
                                        <option value="webhook">Webhook</option>
                                        <option value="api_key">API Key</option>
                                        <option value="settings">Settings</option>
                                        <option value="event">Event</option>
                                        <option value="alert_rule">Alert Rule</option>
                                    </select>
                                    <select
                                        className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500"
                                        onChange={(e) => handleAuditLogFilterChange('actor', e.target.value)}
                                        value={auditLogFilters.actor || 'All'}
                                    >
                                        <option value="All">All Actors</option>
                                        <option value="user_admin">user_admin</option>
                                        <option value="user_dev">user_dev</option>
                                        <option value="system">system</option>
                                    </select>
                                </div>
                            </Card>

                            <Card title="Recent Audit Events">
                                {displayedAuditLogs.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">No audit logs found matching your criteria.</p>
                                ) : (
                                    <table className="w-full text-sm text-left text-gray-400">
                                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                                            <tr>
                                                <th className="px-6 py-3">Timestamp</th>
                                                <th className="px-6 py-3">Actor</th>
                                                <th className="px-6 py-3">Action</th>
                                                <th className="px-6 py-3">Resource Type</th>
                                                <th className="px-6 py-3">Resource ID</th>
                                                <th className="px-6 py-3">Details</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {displayedAuditLogs.map(log => (
                                                <tr key={log.id} className="border-b border-gray-800 hover:bg-gray-800">
                                                    <td className="px-6 py-4 text-xs">{new Date(log.timestamp).toLocaleString()}</td>
                                                    <td className="px-6 py-4 font-mono text-white text-xs">{log.actor}</td>
                                                    <td className="px-6 py-4 text-white text-xs">{log.action}</td>
                                                    <td className="px-6 py-4 text-white text-xs">{log.resourceType}</td>
                                                    <td className="px-6 py-4 font-mono text-white text-xs">{log.resourceId}</td>
                                                    <td className="px-6 py-4 text-gray-500 text-xs max-w-sm truncate" title={JSON.stringify(log.details)}>{JSON.stringify(log.details)}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                                <Pagination pagination={auditLogPagination} onPageChange={setCurrentAuditLogPage} />
                            </Card>
                        </div>
                    )}

                    {/* --- Developer Tools Tab --- */}
                    {activeTab === 'testing' && (
                        <div className="space-y-6">
                            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Developer Tools</h2>
                            <p className="text-gray-400">Tools for testing, replaying, and debugging webhook events.</p>

                            <Card title="Webhook Event Tester">
                                <p className="text-gray-400 mb-4">Simulate sending a webhook event to a specific endpoint or to all matching subscribers.</p>
                                <div className="space-y-4">
                                    <FormField label="Target Webhook (Optional)" description="Leave blank to send to all webhooks subscribed to the event type.">
                                        <select
                                            value={testEventConfig.webhookId || ''}
                                            onChange={(e) => handleTestEventConfigChange('webhookId', e.target.value || undefined)}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="">All matching webhooks</option>
                                            {webhooks.map(wh => <option key={wh.id} value={wh.id}>{wh.url} ({wh.id})</option>)}
                                        </select>
                                    </FormField>

                                    <FormField label="Event Type" htmlFor="testEventType" error={testEventErrors.eventType}>
                                        <input
                                            id="testEventType"
                                            type="text"
                                            value={testEventConfig.eventType}
                                            onChange={(e) => handleTestEventConfigChange('eventType', e.target.value)}
                                            placeholder="e.g., test.event, user.activated"
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            required
                                        />
                                    </FormField>

                                    <FormField label="Payload (JSON)" htmlFor="testPayload" error={testEventErrors.payload}>
                                        <textarea
                                            id="testPayload"
                                            value={JSON.stringify(testEventConfig.payload, null, 2)}
                                            onChange={(e) => {
                                                try {
                                                    handleTestEventConfigChange('payload', JSON.parse(e.target.value));
                                                } catch {
                                                    // Invalid JSON, will be caught by validation on submit
                                                }
                                            }}
                                            rows={8}
                                            className="font-mono bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:ring-cyan-500 focus:border-cyan-500 text-sm resize-y"
                                        ></textarea>
                                    </FormField>

                                    <DynamicKeyValueList
                                        label="Custom Headers"
                                        items={testHeaders}
                                        onItemChange={handleTestHeadersChange}
                                        onAddItem={handleAddTestHeader}
                                        onRemoveItem={handleRemoveTestHeader}
                                        keyPlaceholder="Header-Key"
                                        valuePlaceholder="Header Value"
                                        addButtonText="Add Header"
                                        description="Headers to be sent with the test event."
                                    />

                                    <DynamicKeyValueList
                                        label="Metadata"
                                        items={testMetadata}
                                        onItemChange={handleTestMetadataChange}
                                        onAddItem={handleAddTestMetadata}
                                        onRemoveItem={handleRemoveTestMetadata}
                                        keyPlaceholder="metadata-key"
                                        valuePlaceholder="metadata-value"
                                        addButtonText="Add Metadata"
                                        description="Custom metadata for the test event."
                                    />

                                    <button
                                        onClick={handleSendTestEvent}
                                        disabled={isTestLoading}
                                        className="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-6 rounded-md transition-colors duration-200 disabled:opacity-50"
                                    >
                                        {isTestLoading ? 'Sending Test...' : 'Send Test Event'}
                                    </button>

                                    {testResult && (
                                        <Card title="Test Result">
                                            <pre className="text-xs bg-gray-900 p-3 rounded-md overflow-x-auto text-white">{JSON.stringify(testResult, null, 2)}</pre>
                                        </Card>
                                    )}
                                </div>
                            </Card>

                            <Card title="Event Replay Tool">
                                <p className="text-gray-400 mb-4">Replay past failed (or delivered) events to one or more webhooks. Useful for recovering missed data or re-processing events after a fix.</p>
                                <div className="space-y-4">
                                    <FormField label="Target Webhooks" description="Select specific webhooks or leave empty for all events matching other criteria.">
                                        <select
                                            multiple
                                            value={eventReplayConfig.webhookIds}
                                            onChange={(e) => handleEventReplayConfigChange('webhookIds', Array.from(e.target.selectedOptions, option => option.value))}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm h-32"
                                        >
                                            {webhooks.map(wh => <option key={wh.id} value={wh.id}>{wh.url} ({wh.id})</option>)}
                                        </select>
                                    </FormField>

                                    <FormField label="Event Types" description="Select specific event types or '*' for all.">
                                        <select
                                            multiple
                                            value={eventReplayConfig.eventTypes}
                                            onChange={(e) => handleEventReplayConfigChange('eventTypes', Array.from(e.target.selectedOptions, option => option.value))}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm h-32"
                                        >
                                            <option value="*">* (All Event Types)</option>
                                            {Array.from(new Set(events.map(e => e.type))).map(type => <option key={type} value={type}>{type}</option>)}
                                        </select>
                                    </FormField>

                                    <FormField label="Filter by Status">
                                        <select
                                            value={eventReplayConfig.statusFilter || 'All'}
                                            onChange={(e) => handleEventReplayConfigChange('statusFilter', e.target.value === 'All' ? undefined : e.target.value as 'Failed' | 'Delivered')}
                                            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                        >
                                            <option value="All">All Statuses</option>
                                            <option value="Failed">Only Failed Events</option>
                                            <option value="Delivered">Only Delivered Events</option>
                                        </select>
                                    </FormField>

                                    <div className="grid grid-cols-2 gap-4">
                                        <FormField label="Date Range (Start)">
                                            <input
                                                type="date"
                                                value={eventReplayConfig.dateRange.start}
                                                onChange={(e) => handleEventReplayConfigChange('dateRange', { ...eventReplayConfig.dateRange, start: e.target.value })}
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            />
                                        </FormField>
                                        <FormField label="Date Range (End)">
                                            <input
                                                type="date"
                                                value={eventReplayConfig.dateRange.end}
                                                onChange={(e) => handleEventReplayConfigChange('dateRange', { ...eventReplayConfig.dateRange, end: e.target.value })}
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            />
                                        </FormField>
                                    </div>

                                    <div className="grid grid-cols-2 gap-4">
                                        <FormField label="Max Events to Replay">
                                            <input
                                                type="number"
                                                value={eventReplayConfig.maxEvents}
                                                onChange={(e) => handleEventReplayConfigChange('maxEvents', parseInt(e.target.value))}
                                                min="1"
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            />
                                        </FormField>
                                        <FormField label="Batch Size (per API call)">
                                            <input
                                                type="number"
                                                value={eventReplayConfig.batchSize}
                                                onChange={(e) => handleEventReplayConfigChange('batchSize', parseInt(e.target.value))}
                                                min="1"
                                                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:ring-cyan-500 focus:border-cyan-500 text-sm"
                                            />
                                        </FormField>
                                    </div>

                                    <FormField label="Dry Run" description="Perform a simulation without actually replaying events.">
                                        <label className="inline-flex items-center mt-2">
                                            <input
                                                type="checkbox"
                                                className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                                                checked={eventReplayConfig.dryRun}
                                                onChange={(e) => handleEventReplayConfigChange('dryRun', e.target.checked)}
                                            />
                                            <span className="ml-2 text-gray-300 text-sm">Enable Dry Run</span>
                                        </label>
                                    </FormField>

                                    <button
                                        onClick={handleInitiateEventReplay}
                                        disabled={isReplayLoading}
                                        className="bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-6 rounded-md transition-colors duration-200 disabled:opacity-50"
                                    >
                                        {isReplayLoading ? 'Processing...' : eventReplayConfig.dryRun ? 'Start Dry Run' : 'Initiate Replay'}
                                    </button>

                                    {replayResults && (
                                        <Card title="Replay Results">
                                            <pre className="text-xs bg-gray-900 p-3 rounded-md overflow-x-auto text-white">{JSON.stringify(replayResults, null, 2)}</pre>
                                        </Card>
                                    )}
                                </div>
                            </Card>
                        </div>
                    )}
                </main>
            </div>
        </div>
    );
};

export default WebhooksView;