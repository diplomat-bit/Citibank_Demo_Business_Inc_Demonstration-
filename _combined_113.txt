
--- FILE: CardManagementView.tsx ---

import React, { useContext, useState, useMemo, useEffect, useCallback, createContext } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, LineChart, Line, AreaChart, Area, PieChart, Pie, Cell, Legend } from 'recharts';
import { CorporateCard, CorporateCardControls, Transaction, UserRole, CorporateCardStatus } from '../../../../types'; // Assuming UserRole and CorporateCardStatus are in types.ts

// --- START: NEW UTILITY FUNCTIONS (EXPORTED) ---
// These functions provide common helpers for data manipulation, formatting, and UI interactions.

/**
 * Formats a number as currency.
 * @param amount The number to format.
 * @param currency The currency code (e.g., 'USD', 'EUR').
 * @param locale The locale for formatting (e.g., 'en-US').
 * @returns Formatted currency string.
 */
export const formatCurrency = (amount: number, currency: string = 'USD', locale: string = 'en-US'): string => {
    return new Intl.NumberFormat(locale, { style: 'currency', currency: currency }).format(amount);
};

/**
 * Formats a Date object into a readable string.
 * @param date The date object.
 * @param options Intl.DateTimeFormatOptions.
 * @returns Formatted date string.
 */
export const formatDate = (date: Date, options?: Intl.DateTimeFormatOptions): string => {
    const defaultOptions: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    return new Intl.DateTimeFormat('en-US', options || defaultOptions).format(date);
};

/**
 * Generates a simple unique ID.
 * @returns A unique string.
 */
export const generateUniqueId = (): string => {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};

/**
 * Debounces a function call.
 * @param func The function to debounce.
 * @param delay The debounce delay in milliseconds.
 * @returns A debounced function.
 */
export const debounce = <T extends (...args: any[]) => void>(func: T, delay: number): ((...args: Parameters<T>) => void) => {
    let timeout: NodeJS.Timeout;
    return (...args: Parameters<T>): void => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), delay);
    };
};

/**
 * Calculates budget utilization as a percentage.
 * @param spent Amount spent.
 * @param limit Total limit.
 * @returns Utilization percentage.
 */
export const calculateBudgetUtilization = (spent: number, limit: number): number => {
    if (limit === 0) return 0;
    return (spent / limit) * 100;
};

/**
 * Simple email validation.
 * @param email The email string to validate.
 * @returns True if valid, false otherwise.
 */
export const isValidEmail = (email: string): boolean => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
};

/**
 * Generates a random number within a range.
 * @param min Minimum value.
 * @param max Maximum value.
 * @returns Random number.
 */
export const getRandomNumber = (min: number, max: number): number => {
    return Math.random() * (max - min) + min;
};

/**
 * Capitalizes the first letter of a string.
 * @param str The input string.
 * @returns Capitalized string.
 */
export const capitalizeFirstLetter = (str: string): string => {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * Clones a deep object.
 * @param obj The object to clone.
 * @returns A deep copy of the object.
 */
export const deepClone = <T>(obj: T): T => {
    return JSON.parse(JSON.stringify(obj));
};

/**
 * Represents a generic form validation state.
 */
interface FormValidationState {
    [key: string]: string | undefined;
}

/**
 * Custom hook for form validation.
 * @param initialValues Initial form values.
 * @param validateFn A function that takes form values and returns validation errors.
 */
export function useFormValidation<T extends Record<string, any>>(
    initialValues: T,
    validateFn: (values: T) => FormValidationState
) {
    const [values, setValues] = useState<T>(initialValues);
    const [errors, setErrors] = useState<FormValidationState>({});
    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type } = e.target;
        const targetValue = type === 'checkbox' ? (e.target as HTMLInputElement).checked : value;
        setValues({
            ...values,
            [name]: targetValue,
        });
    };

    const handleBlur = (e: React.FocusEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name } = e.target;
        const currentErrors = validateFn(values);
        setErrors(prev => ({ ...prev, [name]: currentErrors[name] }));
    };

    const handleSubmit = (callback: (values: T) => void) => (e: React.FormEvent) => {
        e.preventDefault();
        setIsSubmitting(true);
        const currentErrors = validateFn(values);
        setErrors(currentErrors);

        if (Object.keys(currentErrors).length === 0) {
            callback(values);
        } else {
            setIsSubmitting(false);
        }
    };

    useEffect(() => {
        if (isSubmitting && Object.keys(errors).length === 0) {
            setIsSubmitting(false);
        }
    }, [errors, isSubmitting]);

    return {
        values,
        setValues,
        errors,
        handleChange,
        handleBlur,
        handleSubmit,
        isSubmitting,
    };
}

/**
 * Custom hook for pagination logic.
 * @param data The array of items to paginate.
 * @param itemsPerPage Number of items per page.
 */
export function usePagination<T>(data: T[], itemsPerPage: number = 10) {
    const [currentPage, setCurrentPage] = useState(1);
    const maxPage = Math.ceil(data.length / itemsPerPage);

    const currentData = useMemo(() => {
        const begin = (currentPage - 1) * itemsPerPage;
        const end = begin + itemsPerPage;
        return data.slice(begin, end);
    }, [data, currentPage, itemsPerPage]);

    const next = () => setCurrentPage((prev) => Math.min(prev + 1, maxPage));
    const prev = () => setCurrentPage((prev) => Math.max(prev - 1, 1));
    const jump = (page: number) => {
        const pageNumber = Math.max(1, page);
        setCurrentPage(() => Math.min(pageNumber, maxPage));
    };

    return { next, prev, jump, currentData, currentPage, maxPage };
}

/**
 * Custom hook for search and filter logic on a data array.
 * @param data The array of items to search/filter.
 * @param searchKeys An array of keys to search within each item.
 * @param defaultFilters Initial filter values.
 */
export function useSearchAndFilter<T extends Record<string, any>>(
    data: T[],
    searchKeys: (keyof T)[],
    defaultFilters: Record<string, any> = {}
) {
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [filters, setFilters] = useState<Record<string, any>>(defaultFilters);

    const filteredData = useMemo(() => {
        let result = data;

        // Apply search
        if (searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            result = result.filter(item =>
                searchKeys.some(key =>
                    String(item[key]).toLowerCase().includes(lowerCaseSearchTerm)
                )
            );
        }

        // Apply filters
        result = result.filter(item => {
            for (const key in filters) {
                const filterValue = filters[key];
                if (filterValue !== undefined && filterValue !== null && filterValue !== '') {
                    if (Array.isArray(filterValue)) {
                        if (!filterValue.includes(item[key])) {
                            return false;
                        }
                    } else if (typeof filterValue === 'object' && filterValue !== null && 'min' in filterValue && 'max' in filterValue) {
                        const itemValue = parseFloat(item[key]);
                        if (isNaN(itemValue) || itemValue < filterValue.min || itemValue > filterValue.max) {
                            return false;
                        }
                    }
                    else if (item[key] !== filterValue) {
                        return false;
                    }
                }
            }
            return true;
        });

        return result;
    }, [data, searchTerm, filters, searchKeys]);

    const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(e.target.value);
    };

    const handleFilterChange = (key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
    };

    const resetFilters = () => {
        setFilters(defaultFilters);
        setSearchTerm('');
    };

    return {
        filteredData,
        searchTerm,
        setSearchTerm,
        filters,
        setFilters,
        handleSearchChange,
        handleFilterChange,
        resetFilters,
    };
}

// --- END: NEW UTILITY FUNCTIONS (EXPORTED) ---

// --- START: NEW INTERFACES (DEFINED WITHIN FILE FOR BREVITY, BUT WOULD BE IN TYPES.TS IN REAL APP) ---

/**
 * Represents a single merchant category.
 */
export interface MerchantCategory {
    id: string;
    name: string;
    code: string;
    description: string;
    blockedByDefault: boolean;
}

/**
 * Represents a spending policy rule.
 */
export interface PolicyRule {
    id: string;
    name: string;
    description: string;
    type: 'limit' | 'category_block' | 'time_restriction' | 'geo_restriction' | 'transaction_approval';
    isActive: boolean;
    priority: number;
    configuration: any; // e.g., { monthlyLimit: 5000 }, { blockedMcc: ['5812', '7995'] }
    appliesTo: 'all_cards' | 'specific_cards' | 'specific_holders';
    targetIds?: string[]; // Card IDs or user IDs
}

/**
 * Represents a request for a new card or a change to an existing one.
 */
export interface CardRequest {
    id: string;
    requestorId: string; // User ID of who made the request
    requestType: 'new_card' | 'limit_increase' | 'freeze_unfreeze' | 'card_replacement' | 'close_card';
    status: 'pending' | 'approved' | 'rejected' | 'completed';
    requestedDate: Date;
    approvedBy?: string; // User ID of approver
    approvalDate?: Date;
    details: {
        cardHolderName?: string;
        cardType?: 'physical' | 'virtual';
        limit?: number;
        reason: string;
        currency?: string;
        expirationDate?: Date;
        existingCardId?: string; // For requests related to existing cards
    };
    notes?: string;
}

/**
 * Represents a virtual card.
 * Extends CorporateCard but with specific virtual card properties.
 */
export interface VirtualCard extends CorporateCard {
    parentCardId?: string; // If this virtual card is tied to a physical one
    isSingleUse: boolean;
    expiration: Date;
    associatedProject?: string;
    purpose: string;
    generationDate: Date;
    autoTerminateDate?: Date;
}

/**
 * Represents an entry in the audit log.
 */
export interface AuditLogEntry {
    id: string;
    timestamp: Date;
    actorId: string; // User ID who performed the action
    action: string; // e.g., 'UPDATE_CARD_CONTROLS', 'APPROVE_CARD_REQUEST'
    targetType: 'card' | 'card_request' | 'policy' | 'user' | 'virtual_card';
    targetId: string;
    oldValue?: any;
    newValue?: any;
    description: string;
}

/**
 * Represents a user's permission profile or role.
 */
export interface UserPermissionProfile {
    id: string;
    name: string; // e.g., 'Admin', 'Finance Manager', 'Employee'
    description: string;
    permissions: {
        canViewAllCards: boolean;
        canManageOwnCards: boolean;
        canManageTeamCards: boolean;
        canManageAllCards: boolean;
        canCreateCards: boolean;
        canApproveRequests: boolean;
        canManagePolicies: boolean;
        canViewAuditLogs: boolean;
        canManageUserPermissions: boolean;
        canAccessReporting: boolean;
        canManageIntegrations: boolean;
    };
}

/**
 * Represents a configured alert.
 */
export interface AlertConfiguration {
    id: string;
    name: string;
    description: string;
    type: 'spending_threshold' | 'unusual_transaction' | 'policy_violation' | 'card_status_change' | 'low_balance';
    threshold?: number;
    period?: 'daily' | 'weekly' | 'monthly' | 'transaction';
    targetCards?: string[]; // Card IDs
    targetUsers?: string[]; // User IDs to notify
    channels: ('email' | 'slack' | 'sms')[];
    isActive: boolean;
}

/**
 * Represents a recurring subscription tracked on a card.
 */
export interface Subscription {
    id: string;
    cardId: string;
    merchantName: string;
    amount: number;
    currency: string;
    billingCycle: 'monthly' | 'annually' | 'quarterly';
    nextBillingDate: Date;
    status: 'active' | 'cancelled' | 'paused';
    category: string;
    startDate: Date;
    notes?: string;
}

/**
 * Represents a budget allocation for a department or project.
 */
export interface Budget {
    id: string;
    name: string;
    period: 'monthly' | 'quarterly' | 'annually';
    totalAmount: number;
    allocatedAmount: number;
    spentAmount: number;
    departmentId?: string;
    projectId?: string;
    startDate: Date;
    endDate: Date;
    cardsLinked: string[]; // Card IDs linked to this budget
}

/**
 * Represents API integration settings.
 */
export interface APISetting {
    id: string;
    name: string;
    description: string;
    apiKey: string;
    apiSecret?: string;
    endpoint: string;
    isActive: boolean;
    lastAccessed: Date;
    allowedIPs?: string[];
    webhookUrl?: string;
    eventsSubscribed?: string[];
}

/**
 * Represents a compliance report.
 */
export interface ComplianceReport {
    id: string;
    name: string;
    description: string;
    reportType: 'spending_policy_adherence' | 'transaction_audits' | 'user_activity' | 'financial_reconciliation';
    generatedBy: string; // User ID
    generatedDate: Date;
    startDate: Date;
    endDate: Date;
    status: 'pending' | 'completed' | 'failed';
    downloadUrl?: string;
    parameters: any; // e.g., { department: 'Sales', policyId: 'xyz' }
}

/**
 * Represents a generated statement (e.g., monthly).
 */
export interface Statement {
    id: string;
    cardId: string;
    statementDate: Date;
    startDate: Date;
    endDate: Date;
    totalSpent: number;
    totalRefunds: number;
    closingBalance: number;
    status: 'generated' | 'reviewed' | 'approved';
    downloadUrl: string;
}

// Global configuration for the application, stored here for simplicity.
export interface AppConfig {
    defaultCurrency: string;
    auditLogRetentionDays: number;
    cardRequestApprovalWorkflow: 'single_approver' | 'multi_approver' | 'auto_approve';
    maxVirtualCardsPerUser: number;
    enableMultiFactorAuthentication: boolean;
}

// --- END: NEW INTERFACES ---

// --- START: MOCK DATA GENERATION FUNCTIONS (EXPORTED) ---

// Mock data for cardholders to tie into requests and permissions
const MOCK_CARDHOLDERS = [
    { id: 'usr-1', name: 'Alice Johnson', email: 'alice.j@example.com', role: 'Finance Manager' },
    { id: 'usr-2', name: 'Bob Smith', email: 'bob.s@example.com', role: 'Employee' },
    { id: 'usr-3', name: 'Charlie Brown', email: 'charlie.b@example.com', role: 'Admin' },
    { id: 'usr-4', name: 'Diana Prince', email: 'diana.p@example.com', role: 'Employee' },
    { id: 'usr-5', name: 'Eve Adams', email: 'eve.a@example.com', role: 'Finance Manager' },
    { id: 'usr-6', name: 'Frank White', email: 'frank.w@example.com', role: 'Employee' },
];

export const generateMockMerchantCategories = (count: number): MerchantCategory[] => {
    const categories: MerchantCategory[] = [];
    const baseCategories = [
        { name: 'Restaurants', code: '5812', desc: 'Eating places, restaurants' },
        { name: 'Online Retail', code: '5310', desc: 'Online shopping and e-commerce' },
        { name: 'Travel Agencies', code: '4722', desc: 'Travel agencies, tour operators' },
        { name: 'Software', code: '7372', desc: 'Computer programming, data processing' },
        { name: 'Advertising', code: '7311', desc: 'Advertising services' },
        { name: 'Utilities', code: '4900', desc: 'Electric, gas, water, sanitary' },
        { name: 'Healthcare', code: '8099', desc: 'Medical services' },
        { name: 'Entertainment', code: '7994', desc: 'Video games, amusement parks' },
        { name: 'Transportation', code: '4111', desc: 'Local and suburban commuter passenger transportation' },
        { name: 'Groceries', code: '5411', desc: 'Grocery stores, supermarkets' },
        { name: 'Office Supplies', code: '5111', desc: 'Stationery, office supplies' },
        { name: 'Professional Services', code: '7392', desc: 'Management, consulting, public relations services' },
    ];

    for (let i = 0; i < count; i++) {
        const base = baseCategories[i % baseCategories.length];
        categories.push({
            id: generateUniqueId(),
            name: base.name,
            code: base.code,
            description: base.desc,
            blockedByDefault: Math.random() > 0.8, // 20% blocked by default
        });
    }
    return categories;
};

export const generateMockPolicyRules = (count: number): PolicyRule[] => {
    const rules: PolicyRule[] = [];
    const policyTypes = ['limit', 'category_block', 'time_restriction', 'geo_restriction', 'transaction_approval'];
    const appliesToOptions = ['all_cards', 'specific_cards', 'specific_holders'];
    const cardIds = Array.from({ length: 20 }, (_, i) => `card-${i + 1}`); // Assuming some card IDs exist
    const userIds = MOCK_CARDHOLDERS.map(h => h.id);

    for (let i = 0; i < count; i++) {
        const type = policyTypes[Math.floor(Math.random() * policyTypes.length)] as PolicyRule['type'];
        const appliesTo = appliesToOptions[Math.floor(Math.random() * appliesToOptions.length)] as PolicyRule['appliesTo'];
        let configuration: any = {};
        let description = '';
        let targetIds: string[] | undefined;

        if (appliesTo !== 'all_cards') {
            targetIds = Math.random() > 0.5 ? cardIds.slice(0, Math.floor(Math.random() * 5) + 1) : userIds.slice(0, Math.floor(Math.random() * 3) + 1);
        }

        switch (type) {
            case 'limit':
                configuration = { monthlyLimit: Math.floor(getRandomNumber(500, 10000) / 100) * 100 };
                description = `Limit spending to ${formatCurrency(configuration.monthlyLimit)} per month.`;
                break;
            case 'category_block':
                const mockCategories = generateMockMerchantCategories(3);
                configuration = { blockedMcc: mockCategories.map(c => c.code) };
                description = `Block transactions from categories: ${mockCategories.map(c => c.name).join(', ')}.`;
                break;
            case 'time_restriction':
                configuration = { startTime: '09:00', endTime: '18:00', daysOfWeek: [1, 2, 3, 4, 5] };
                description = `Allow transactions only during business hours (Mon-Fri 9 AM - 6 PM).`;
                break;
            case 'geo_restriction':
                configuration = { allowedCountries: ['US', 'CA', 'GB'], blockedCountries: ['RU'] };
                description = `Restrict transactions to specific countries.`;
                break;
            case 'transaction_approval':
                configuration = { minAmount: Math.floor(getRandomNumber(100, 1000) / 50) * 50, approverRole: 'Finance Manager' };
                description = `Require approval for transactions over ${formatCurrency(configuration.minAmount)}.`;
                break;
        }

        rules.push({
            id: generateUniqueId(),
            name: `Policy Rule ${i + 1}`,
            description: description,
            type,
            isActive: Math.random() > 0.1,
            priority: i + 1,
            configuration,
            appliesTo,
            targetIds,
        });
    }
    return rules;
};

export const generateMockCardRequests = (count: number): CardRequest[] => {
    const requests: CardRequest[] = [];
    const requestTypes = ['new_card', 'limit_increase', 'freeze_unfreeze', 'card_replacement', 'close_card'];
    const statuses = ['pending', 'approved', 'rejected', 'completed'];
    const cardholders = MOCK_CARDHOLDERS;
    const existingCardIds = Array.from({ length: 10 }, (_, i) => `card-existing-${i + 1}`);

    for (let i = 0; i < count; i++) {
        const requestor = cardholders[Math.floor(Math.random() * cardholders.length)];
        const requestType = requestTypes[Math.floor(Math.random() * requestTypes.length)] as CardRequest['requestType'];
        const status = statuses[Math.floor(Math.random() * statuses.length)] as CardRequest['status'];
        const requestedDate = new Date(Date.now() - getRandomNumber(0, 30 * 24 * 60 * 60 * 1000)); // Last 30 days

        let details: CardRequest['details'] = { reason: `Reason for ${requestType} request.`, currency: 'USD' };
        if (requestType === 'new_card') {
            details.cardHolderName = `${requestor.name}`;
            details.cardType = Math.random() > 0.5 ? 'physical' : 'virtual';
            details.limit = Math.floor(getRandomNumber(1000, 15000) / 100) * 100;
        } else {
            details.existingCardId = existingCardIds[Math.floor(Math.random() * existingCardIds.length)];
            if (requestType === 'limit_increase') {
                details.limit = Math.floor(getRandomNumber(500, 5000) / 100) * 100;
            }
        }

        let approvedBy, approvalDate;
        if (status === 'approved' || status === 'completed') {
            approvedBy = cardholders.find(h => h.role === 'Finance Manager')?.id || cardholders[0].id;
            approvalDate = new Date(requestedDate.getTime() + getRandomNumber(0, 7 * 24 * 60 * 60 * 1000));
        }

        requests.push({
            id: generateUniqueId(),
            requestorId: requestor.id,
            requestType,
            status,
            requestedDate,
            approvedBy,
            approvalDate,
            details,
            notes: Math.random() > 0.7 ? `Additional notes for request ${i + 1}.` : undefined,
        });
    }
    return requests;
};

export const generateMockVirtualCards = (count: number, corporateCards: CorporateCard[]): VirtualCard[] => {
    const virtualCards: VirtualCard[] = [];
    const cardholders = MOCK_CARDHOLDERS;

    for (let i = 0; i < count; i++) {
        const holder = cardholders[Math.floor(Math.random() * cardholders.length)];
        const associatedCorpCard = corporateCards[Math.floor(Math.random() * corporateCards.length)];
        const isSingleUse = Math.random() > 0.7;
        const generationDate = new Date(Date.now() - getRandomNumber(0, 90 * 24 * 60 * 60 * 1000));
        const expiration = new Date(generationDate.getTime() + getRandomNumber(30, 365) * 24 * 60 * 60 * 1000);
        const autoTerminateDate = isSingleUse ? new Date(expiration.getTime() - getRandomNumber(1, 15) * 24 * 60 * 60 * 1000) : undefined;
        const purposeOptions = ['Software Subscription', 'Ad Campaign', 'Travel Booking', 'Project Expense', 'Vendor Payment'];

        virtualCards.push({
            ...associatedCorpCard, // Inherit base properties for simplicity
            id: `vcard-${generateUniqueId()}`, // Unique ID for virtual card
            cardNumberMask: `V-${(Math.floor(getRandomNumber(1000, 9999))).toString()}`,
            holderName: `${holder.name} (Virtual)`,
            limit: Math.floor(getRandomNumber(50, 2000) / 10) * 10,
            balance: Math.floor(getRandomNumber(0, 1500) / 10) * 10,
            status: expiration.getTime() < Date.now() ? 'Expired' : Math.random() > 0.9 ? 'Frozen' : 'Active',
            frozen: expiration.getTime() < Date.now() || Math.random() > 0.9,
            parentCardId: associatedCorpCard?.id || undefined,
            isSingleUse,
            expiration,
            associatedProject: Math.random() > 0.5 ? `Project ${Math.floor(getRandomNumber(1, 5))}` : undefined,
            purpose: purposeOptions[Math.floor(Math.random() * purposeOptions.length)],
            generationDate,
            autoTerminateDate,
            transactions: associatedCorpCard.transactions.slice(0, Math.floor(getRandomNumber(0, 5))), // Fewer transactions for virtual cards
        });
    }
    return virtualCards;
};


export const generateMockAuditLogs = (count: number): AuditLogEntry[] => {
    const logs: AuditLogEntry[] = [];
    const cardIds = Array.from({ length: 20 }, (_, i) => `card-${i + 1}`);
    const policyIds = Array.from({ length: 10 }, (_, i) => `policy-${i + 1}`);
    const requestIds = Array.from({ length: 10 }, (_, i) => `req-${i + 1}`);
    const virtualCardIds = Array.from({ length: 10 }, (_, i) => `vcard-${i + 1}`);
    const targetTypes = ['card', 'card_request', 'policy', 'user', 'virtual_card'];
    const actions = [
        'CREATE_CARD', 'UPDATE_CARD_LIMIT', 'FREEZE_CARD', 'UNFREEZE_CARD', 'DELETE_CARD',
        'APPROVE_CARD_REQUEST', 'REJECT_CARD_REQUEST', 'CREATE_POLICY', 'UPDATE_POLICY', 'DEACTIVATE_POLICY',
        'ASSIGN_ROLE', 'UPDATE_USER_PERMISSIONS', 'CREATE_VIRTUAL_CARD', 'TERMINATE_VIRTUAL_CARD',
        'GENERATE_REPORT', 'UPDATE_API_SETTINGS'
    ];
    const cardholders = MOCK_CARDHOLDERS;

    for (let i = 0; i < count; i++) {
        const actor = cardholders[Math.floor(Math.random() * cardholders.length)];
        const targetType = targetTypes[Math.floor(Math.random() * targetTypes.length)] as AuditLogEntry['targetType'];
        const action = actions[Math.floor(Math.random() * actions.length)];
        let targetId = '';
        let description = '';

        switch (targetType) {
            case 'card':
                targetId = cardIds[Math.floor(Math.random() * cardIds.length)];
                description = `Card ${action.replace('_', ' ').toLowerCase()} for ${targetId}.`;
                break;
            case 'card_request':
                targetId = requestIds[Math.floor(Math.random() * requestIds.length)];
                description = `Card request ${action.replace('_', ' ').toLowerCase()} for ${targetId}.`;
                break;
            case 'policy':
                targetId = policyIds[Math.floor(Math.random() * policyIds.length)];
                description = `Policy ${action.replace('_', ' ').toLowerCase()} for ${targetId}.`;
                break;
            case 'user':
                targetId = cardholders[Math.floor(Math.random() * cardholders.length)].id;
                description = `User ${action.replace('_', ' ').toLowerCase()} for ${targetId}.`;
                break;
            case 'virtual_card':
                targetId = virtualCardIds[Math.floor(Math.random() * virtualCardIds.length)];
                description = `Virtual Card ${action.replace('_', ' ').toLowerCase()} for ${targetId}.`;
                break;
        }

        logs.push({
            id: generateUniqueId(),
            timestamp: new Date(Date.now() - getRandomNumber(0, 180 * 24 * 60 * 60 * 1000)), // Last 6 months
            actorId: actor.id,
            action,
            targetType,
            targetId,
            oldValue: Math.random() > 0.7 ? { status: 'Active' } : undefined,
            newValue: Math.random() > 0.7 ? { status: 'Frozen' } : undefined,
            description,
        });
    }
    return logs;
};

export const generateMockUserPermissionProfiles = (count: number): UserPermissionProfile[] => {
    const profiles: UserPermissionProfile[] = [];
    const baseRoles = ['Admin', 'Finance Manager', 'Team Lead', 'Employee', 'Auditor', 'Executive'];

    for (let i = 0; i < count; i++) {
        const roleName = baseRoles[i % baseRoles.length];
        profiles.push({
            id: `role-${generateUniqueId()}`,
            name: roleName,
            description: `Permissions for ${roleName} role.`,
            permissions: {
                canViewAllCards: roleName === 'Admin' || roleName === 'Finance Manager' || roleName === 'Auditor' || roleName === 'Executive',
                canManageOwnCards: roleName === 'Employee' || roleName === 'Team Lead',
                canManageTeamCards: roleName === 'Team Lead',
                canManageAllCards: roleName === 'Admin' || roleName === 'Finance Manager',
                canCreateCards: roleName === 'Admin' || roleName === 'Finance Manager',
                canApproveRequests: roleName === 'Admin' || roleName === 'Finance Manager',
                canManagePolicies: roleName === 'Admin' || roleName === 'Finance Manager',
                canViewAuditLogs: roleName === 'Admin' || roleName === 'Finance Manager' || roleName === 'Auditor',
                canManageUserPermissions: roleName === 'Admin',
                canAccessReporting: roleName === 'Admin' || roleName === 'Finance Manager' || roleName === 'Executive',
                canManageIntegrations: roleName === 'Admin',
            },
        });
    }
    return profiles;
};

export const generateMockAlertConfigurations = (count: number, cardIds: string[]): AlertConfiguration[] => {
    const configs: AlertConfiguration[] = [];
    const alertTypes = ['spending_threshold', 'unusual_transaction', 'policy_violation', 'card_status_change', 'low_balance'];
    const periods = ['daily', 'weekly', 'monthly', 'transaction'];
    const channels = [['email'], ['email', 'slack'], ['sms']];
    const userIds = MOCK_CARDHOLDERS.map(h => h.id);

    for (let i = 0; i < count; i++) {
        const type = alertTypes[Math.floor(Math.random() * alertTypes.length)] as AlertConfiguration['type'];
        const period = periods[Math.floor(Math.random() * periods.length)] as AlertConfiguration['period'];
        const targetCards = Math.random() > 0.6 ? cardIds.slice(0, Math.floor(getRandomNumber(1, 5))) : undefined;
        const targetUsers = userIds.slice(0, Math.floor(getRandomNumber(1, 3)));
        let threshold: number | undefined;

        if (type === 'spending_threshold' || type === 'low_balance') {
            threshold = Math.floor(getRandomNumber(50, 1000) / 10) * 10;
        }

        configs.push({
            id: generateUniqueId(),
            name: `${capitalizeFirstLetter(type.replace(/_/g, ' '))} Alert ${i + 1}`,
            description: `Config for ${type} alert.`,
            type,
            threshold,
            period: type === 'spending_threshold' || type === 'low_balance' ? period : undefined,
            targetCards,
            targetUsers,
            channels: channels[Math.floor(Math.random() * channels.length)] as ('email' | 'slack' | 'sms')[],
            isActive: Math.random() > 0.1,
        });
    }
    return configs;
};

export const generateMockSubscriptions = (count: number, cardIds: string[]): Subscription[] => {
    const subscriptions: Subscription[] = [];
    const merchantNames = ['Adobe Creative Cloud', 'Zoom Pro', 'Slack Business+', 'Microsoft 365', 'AWS Services', 'Salesforce CRM', 'Google Workspace', 'Netflix Business'];
    const billingCycles = ['monthly', 'annually', 'quarterly'];
    const categories = ['Software', 'Cloud Services', 'Productivity', 'Entertainment'];
    const statuses = ['active', 'cancelled', 'paused'];

    for (let i = 0; i < count; i++) {
        const cardId = cardIds[Math.floor(Math.random() * cardIds.length)];
        const billingCycle = billingCycles[Math.floor(Math.random() * billingCycles.length)];
        const startDate = new Date(Date.now() - getRandomNumber(30, 730) * 24 * 60 * 60 * 1000); // Last 2 years
        let nextBillingDate: Date;
        if (billingCycle === 'monthly') nextBillingDate = new Date(startDate.getFullYear(), startDate.getMonth() + Math.floor(getRandomNumber(1, 12)), startDate.getDate());
        else if (billingCycle === 'annually') nextBillingDate = new Date(startDate.getFullYear() + Math.floor(getRandomNumber(1, 2)), startDate.getMonth(), startDate.getDate());
        else nextBillingDate = new Date(startDate.getFullYear(), startDate.getMonth() + Math.floor(getRandomNumber(1, 8)) * 3, startDate.getDate()); // quarterly

        subscriptions.push({
            id: generateUniqueId(),
            cardId,
            merchantName: merchantNames[Math.floor(Math.random() * merchantNames.length)],
            amount: Math.floor(getRandomNumber(10, 500) / 5) * 5,
            currency: 'USD',
            billingCycle,
            nextBillingDate: nextBillingDate,
            status: statuses[Math.floor(Math.random() * statuses.length)],
            category: categories[Math.floor(Math.random() * categories.length)],
            startDate,
            notes: Math.random() > 0.7 ? `Notes for ${merchantNames[i % merchantNames.length]} subscription.` : undefined,
        });
    }
    return subscriptions;
};

export const generateMockBudgets = (count: number, cardIds: string[]): Budget[] => {
    const budgets: Budget[] = [];
    const periods = ['monthly', 'quarterly', 'annually'];
    const departmentNames = ['Sales', 'Marketing', 'Engineering', 'HR', 'Finance', 'Operations'];

    for (let i = 0; i < count; i++) {
        const period = periods[Math.floor(Math.random() * periods.length)];
        const totalAmount = Math.floor(getRandomNumber(5000, 100000) / 100) * 100;
        const allocatedAmount = Math.floor(totalAmount * getRandomNumber(0.8, 1));
        const spentAmount = Math.floor(allocatedAmount * getRandomNumber(0.1, 0.9));
        const startDate = new Date(Date.now() - getRandomNumber(0, 365) * 24 * 60 * 60 * 1000);
        const endDate = new Date(startDate.getFullYear() + (period === 'annually' ? 1 : 0), startDate.getMonth() + (period === 'monthly' ? 1 : period === 'quarterly' ? 3 : 0), startDate.getDate());
        const linkedCards = cardIds.slice(0, Math.floor(getRandomNumber(1, 5)));

        budgets.push({
            id: generateUniqueId(),
            name: `${departmentNames[i % departmentNames.length]} Budget ${i % 2 === 0 ? 'Q' + Math.floor(getRandomNumber(1, 4)) : 'FY' + (new Date().getFullYear())}`,
            period,
            totalAmount,
            allocatedAmount,
            spentAmount,
            departmentId: `dept-${i % departmentNames.length}`,
            startDate,
            endDate,
            cardsLinked: linkedCards,
        });
    }
    return budgets;
};

export const generateMockAPISettings = (count: number): APISetting[] => {
    const settings: APISetting[] = [];
    const integrationNames = ['Expenseify ERP', 'TravelBuddy Booking', 'AnalyticsSuite', 'HRConnect', 'FraudDetect AI'];
    const endpoints = ['/api/expenses', '/api/bookings', '/api/data', '/api/employees', '/api/fraud'];

    for (let i = 0; i < count; i++) {
        const name = integrationNames[i % integrationNames.length];
        settings.push({
            id: generateUniqueId(),
            name,
            description: `Integration settings for ${name}.`,
            apiKey: `pk_live_${generateUniqueId()}`,
            apiSecret: Math.random() > 0.5 ? `sk_live_${generateUniqueId()}` : undefined,
            endpoint: `https://api.external.com${endpoints[i % endpoints.length]}`,
            isActive: Math.random() > 0.1,
            lastAccessed: new Date(Date.now() - getRandomNumber(0, 30 * 24 * 60 * 60 * 1000)),
            allowedIPs: Math.random() > 0.6 ? [`192.168.1.${Math.floor(getRandomNumber(1, 254))}`, `10.0.0.${Math.floor(getRandomNumber(1, 254))}`] : undefined,
            webhookUrl: Math.random() > 0.5 ? `https://your-app.com/webhooks/${name.toLowerCase().replace(/\s/g, '-')}` : undefined,
            eventsSubscribed: Math.random() > 0.5 ? ['transaction.created', 'card.frozen', 'request.approved'] : undefined,
        });
    }
    return settings;
};

export const generateMockComplianceReports = (count: number): ComplianceReport[] => {
    const reports: ComplianceReport[] = [];
    const reportTypes = ['spending_policy_adherence', 'transaction_audits', 'user_activity', 'financial_reconciliation'];
    const userIds = MOCK_CARDHOLDERS.map(h => h.id);
    const statuses = ['pending', 'completed', 'failed'];

    for (let i = 0; i < count; i++) {
        const reportType = reportTypes[Math.floor(Math.random() * reportTypes.length)] as ComplianceReport['reportType'];
        const generatedBy = userIds[Math.floor(Math.random() * userIds.length)];
        const generatedDate = new Date(Date.now() - getRandomNumber(0, 90 * 24 * 60 * 60 * 1000));
        const startDate = new Date(generatedDate.getFullYear(), generatedDate.getMonth() - Math.floor(getRandomNumber(1, 6)), 1);
        const endDate = new Date(generatedDate.getFullYear(), generatedDate.getMonth(), 0);
        const status = statuses[Math.floor(Math.random() * statuses.length)];

        reports.push({
            id: generateUniqueId(),
            name: `${capitalizeFirstLetter(reportType.replace(/_/g, ' '))} Report ${i + 1}`,
            description: `Detailed report on ${reportType}.`,
            reportType,
            generatedBy,
            generatedDate,
            startDate,
            endDate,
            status,
            downloadUrl: status === 'completed' ? `/reports/download/${generateUniqueId()}.pdf` : undefined,
            parameters: { period: 'monthly', department: 'All' },
        });
    }
    return reports;
};

export const generateMockStatements = (count: number, cardIds: string[]): Statement[] => {
    const statements: Statement[] = [];
    const statuses = ['generated', 'reviewed', 'approved'];

    for (let i = 0; i < count; i++) {
        const cardId = cardIds[Math.floor(Math.random() * cardIds.length)];
        const statementDate = new Date(Date.now() - getRandomNumber(0, 365) * 24 * 60 * 60 * 1000);
        const startDate = new Date(statementDate.getFullYear(), statementDate.getMonth() - 1, 1);
        const endDate = new Date(statementDate.getFullYear(), statementDate.getMonth(), 0);
        const totalSpent = Math.floor(getRandomNumber(100, 5000) / 10) * 10;
        const totalRefunds = Math.floor(getRandomNumber(0, 200) / 10) * 10;
        const closingBalance = totalSpent - totalRefunds;

        statements.push({
            id: generateUniqueId(),
            cardId,
            statementDate,
            startDate,
            endDate,
            totalSpent,
            totalRefunds,
            closingBalance,
            status: statuses[Math.floor(Math.random() * statuses.length)],
            downloadUrl: `/statements/download/${generateUniqueId()}.pdf`,
        });
    }
    return statements;
};

export const generateMockAppConfig = (): AppConfig => ({
    defaultCurrency: 'USD',
    auditLogRetentionDays: 365,
    cardRequestApprovalWorkflow: 'single_approver',
    maxVirtualCardsPerUser: 5,
    enableMultiFactorAuthentication: true,
});

// --- END: MOCK DATA GENERATION FUNCTIONS ---

// --- START: CONTEXT FOR SHARED DATA AND ACTIONS (FOR NEW FEATURES) ---
// In a real application, this would be part of a larger, more structured global state management.
// For this exercise, we define it here to allow new components to interact.

interface AdvancedCardData {
    merchantCategories: MerchantCategory[];
    policyRules: PolicyRule[];
    cardRequests: CardRequest[];
    virtualCards: VirtualCard[];
    auditLogs: AuditLogEntry[];
    userPermissionProfiles: UserPermissionProfile[];
    alertConfigurations: AlertConfiguration[];
    subscriptions: Subscription[];
    budgets: Budget[];
    apiSettings: APISetting[];
    complianceReports: ComplianceReport[];
    statements: Statement[];
    appConfig: AppConfig;
}

interface AdvancedCardActions {
    updateMerchantCategory: (id: string, updates: Partial<MerchantCategory>) => void;
    addPolicyRule: (rule: PolicyRule) => void;
    updatePolicyRule: (id: string, updates: Partial<PolicyRule>) => void;
    deletePolicyRule: (id: string) => void;
    createCardRequest: (request: Omit<CardRequest, 'id' | 'status' | 'requestedDate'>) => void;
    updateCardRequestStatus: (id: string, status: CardRequest['status'], approverId: string) => void;
    createVirtualCard: (card: Omit<VirtualCard, 'id' | 'cardNumberMask' | 'generationDate'>) => void;
    updateVirtualCard: (id: string, updates: Partial<VirtualCard>) => void;
    deleteVirtualCard: (id: string) => void;
    addAuditLog: (log: Omit<AuditLogEntry, 'id' | 'timestamp'>) => void;
    addUserPermissionProfile: (profile: UserPermissionProfile) => void;
    updateUserPermissionProfile: (id: string, updates: Partial<UserPermissionProfile>) => void;
    deleteUserPermissionProfile: (id: string) => void;
    addAlertConfiguration: (config: AlertConfiguration) => void;
    updateAlertConfiguration: (id: string, updates: Partial<AlertConfiguration>) => void;
    deleteAlertConfiguration: (id: string) => void;
    addSubscription: (sub: Omit<Subscription, 'id'>) => void;
    updateSubscription: (id: string, updates: Partial<Subscription>) => void;
    deleteSubscription: (id: string) => void;
    addBudget: (budget: Omit<Budget, 'id'>) => void;
    updateBudget: (id: string, updates: Partial<Budget>) => void;
    deleteBudget: (id: string) => void;
    updateAPISetting: (id: string, updates: Partial<APISetting>) => void;
    generateComplianceReport: (params: any) => Promise<ComplianceReport>;
    generateStatement: (cardId: string, month: number, year: number) => Promise<Statement>;
    updateAppConfig: (config: Partial<AppConfig>) => void;
}

export const AdvancedCardContext = createContext<({ data: AdvancedCardData; actions: AdvancedCardActions } | null)>(null);

/**
 * Provider for advanced card management data and actions.
 * This component wraps the main CardManagementView to provide global state for new features.
 * In a real app, this would be its own file and manage actual API calls, not just mock data.
 */
export const AdvancedCardProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { corporateCards, toggleCorporateCardFreeze, updateCorporateCardControls } = useContext(DataContext)!;

    // Initialize all extended data with mocks
    const [merchantCategories, setMerchantCategories] = useState<MerchantCategory[]>(() => generateMockMerchantCategories(15));
    const [policyRules, setPolicyRules] = useState<PolicyRule[]>(() => generateMockPolicyRules(10));
    const [cardRequests, setCardRequests] = useState<CardRequest[]>(() => generateMockCardRequests(20));
    const [virtualCards, setVirtualCards] = useState<VirtualCard[]>(() => generateMockVirtualCards(25, corporateCards));
    const [auditLogs, setAuditLogs] = useState<AuditLogEntry[]>(() => generateMockAuditLogs(50));
    const [userPermissionProfiles, setUserPermissionProfiles] = useState<UserPermissionProfile[]>(() => generateMockUserPermissionProfiles(6));
    const [alertConfigurations, setAlertConfigurations] = useState<AlertConfiguration[]>(() => generateMockAlertConfigurations(12, corporateCards.map(c => c.id)));
    const [subscriptions, setSubscriptions] = useState<Subscription[]>(() => generateMockSubscriptions(30, corporateCards.map(c => c.id)));
    const [budgets, setBudgets] = useState<Budget[]>(() => generateMockBudgets(10, corporateCards.map(c => c.id)));
    const [apiSettings, setApiSettings] = useState<APISetting[]>(() => generateMockAPISettings(5));
    const [complianceReports, setComplianceReports] = useState<ComplianceReport[]>(() => generateMockComplianceReports(8));
    const [statements, setStatements] = useState<Statement[]>(() => generateMockStatements(30, corporateCards.map(c => c.id)));
    const [appConfig, setAppConfig] = useState<AppConfig>(() => generateMockAppConfig());

    // --- Action Implementations ---
    const updateMerchantCategory = useCallback((id: string, updates: Partial<MerchantCategory>) => {
        setMerchantCategories(prev => prev.map(mc => mc.id === id ? { ...mc, ...updates } : mc));
        addAuditLog({ actorId: 'system', action: 'UPDATE_MERCHANT_CATEGORY', targetType: 'policy', targetId: id, description: `Updated merchant category ${id}` });
    }, []);

    const addPolicyRule = useCallback((rule: PolicyRule) => {
        setPolicyRules(prev => [...prev, { ...rule, id: generateUniqueId() }]);
        addAuditLog({ actorId: 'system', action: 'CREATE_POLICY_RULE', targetType: 'policy', targetId: rule.id, description: `Created policy rule ${rule.name}` });
    }, []);

    const updatePolicyRule = useCallback((id: string, updates: Partial<PolicyRule>) => {
        setPolicyRules(prev => prev.map(r => r.id === id ? { ...r, ...updates } : r));
        addAuditLog({ actorId: 'system', action: 'UPDATE_POLICY_RULE', targetType: 'policy', targetId: id, description: `Updated policy rule ${id}` });
    }, []);

    const deletePolicyRule = useCallback((id: string) => {
        setPolicyRules(prev => prev.filter(r => r.id !== id));
        addAuditLog({ actorId: 'system', action: 'DELETE_POLICY_RULE', targetType: 'policy', targetId: id, description: `Deleted policy rule ${id}` });
    }, []);

    const createCardRequest = useCallback((request: Omit<CardRequest, 'id' | 'status' | 'requestedDate'>) => {
        const newRequest: CardRequest = {
            id: generateUniqueId(),
            status: 'pending',
            requestedDate: new Date(),
            ...request,
        };
        setCardRequests(prev => [...prev, newRequest]);
        addAuditLog({ actorId: newRequest.requestorId, action: 'CREATE_CARD_REQUEST', targetType: 'card_request', targetId: newRequest.id, description: `User ${newRequest.requestorId} created a card request.` });
    }, []);

    const updateCardRequestStatus = useCallback((id: string, status: CardRequest['status'], approverId: string) => {
        setCardRequests(prev => prev.map(req =>
            req.id === id ? { ...req, status, approvedBy: approverId, approvalDate: new Date() } : req
        ));
        addAuditLog({ actorId: approverId, action: `UPDATE_CARD_REQUEST_STATUS_${status.toUpperCase()}`, targetType: 'card_request', targetId: id, description: `Card request ${id} ${status} by ${approverId}.` });
    }, []);

    const createVirtualCard = useCallback((card: Omit<VirtualCard, 'id' | 'cardNumberMask' | 'generationDate'>) => {
        const newVirtualCard: VirtualCard = {
            ...card,
            id: `vcard-${generateUniqueId()}`,
            cardNumberMask: `V-${(Math.floor(getRandomNumber(1000, 9999))).toString()}`,
            generationDate: new Date(),
            // Ensure necessary fields are present or default if omitted
            holderName: card.holderName || MOCK_CARDHOLDERS.find(h => h.id === card.id)?.name || 'Unknown',
            balance: card.balance || 0,
            limit: card.limit || 1000,
            status: card.status || 'Active',
            frozen: card.frozen || false,
            transactions: card.transactions || [],
            controls: card.controls || { monthlyLimit: card.limit || 1000, atm: false, online: true, contactless: true },
        };
        setVirtualCards(prev => [...prev, newVirtualCard]);
        addAuditLog({ actorId: 'system', action: 'CREATE_VIRTUAL_CARD', targetType: 'virtual_card', targetId: newVirtualCard.id, description: `Created new virtual card for ${newVirtualCard.holderName}.` });
    }, []);

    const updateVirtualCard = useCallback((id: string, updates: Partial<VirtualCard>) => {
        setVirtualCards(prev => prev.map(vc => vc.id === id ? { ...vc, ...updates } : vc));
        addAuditLog({ actorId: 'system', action: 'UPDATE_VIRTUAL_CARD', targetType: 'virtual_card', targetId: id, description: `Updated virtual card ${id}` });
    }, []);

    const deleteVirtualCard = useCallback((id: string) => {
        setVirtualCards(prev => prev.filter(vc => vc.id !== id));
        addAuditLog({ actorId: 'system', action: 'TERMINATE_VIRTUAL_CARD', targetType: 'virtual_card', targetId: id, description: `Terminated virtual card ${id}` });
    }, []);

    const addAuditLog = useCallback((log: Omit<AuditLogEntry, 'id' | 'timestamp'>) => {
        setAuditLogs(prev => [...prev, { ...log, id: generateUniqueId(), timestamp: new Date() }]);
    }, []);

    const addUserPermissionProfile = useCallback((profile: UserPermissionProfile) => {
        setUserPermissionProfiles(prev => [...prev, { ...profile, id: `role-${generateUniqueId()}` }]);
        addAuditLog({ actorId: 'system', action: 'CREATE_PERMISSION_PROFILE', targetType: 'user', targetId: profile.id, description: `Created user permission profile ${profile.name}` });
    }, []);

    const updateUserPermissionProfile = useCallback((id: string, updates: Partial<UserPermissionProfile>) => {
        setUserPermissionProfiles(prev => prev.map(p => p.id === id ? { ...p, ...updates } : p));
        addAuditLog({ actorId: 'system', action: 'UPDATE_PERMISSION_PROFILE', targetType: 'user', targetId: id, description: `Updated user permission profile ${id}` });
    }, []);

    const deleteUserPermissionProfile = useCallback((id: string) => {
        setUserPermissionProfiles(prev => prev.filter(p => p.id !== id));
        addAuditLog({ actorId: 'system', action: 'DELETE_PERMISSION_PROFILE', targetType: 'user', targetId: id, description: `Deleted user permission profile ${id}` });
    }, []);

    const addAlertConfiguration = useCallback((config: AlertConfiguration) => {
        setAlertConfigurations(prev => [...prev, { ...config, id: generateUniqueId() }]);
        addAuditLog({ actorId: 'system', action: 'CREATE_ALERT_CONFIG', targetType: 'policy', targetId: config.id, description: `Created alert configuration ${config.name}` });
    }, []);

    const updateAlertConfiguration = useCallback((id: string, updates: Partial<AlertConfiguration>) => {
        setAlertConfigurations(prev => prev.map(ac => ac.id === id ? { ...ac, ...updates } : ac));
        addAuditLog({ actorId: 'system', action: 'UPDATE_ALERT_CONFIG', targetType: 'policy', targetId: id, description: `Updated alert configuration ${id}` });
    }, []);

    const deleteAlertConfiguration = useCallback((id: string) => {
        setAlertConfigurations(prev => prev.filter(ac => ac.id !== id));
        addAuditLog({ actorId: 'system', action: 'DELETE_ALERT_CONFIG', targetType: 'policy', targetId: id, description: `Deleted alert configuration ${id}` });
    }, []);

    const addSubscription = useCallback((sub: Omit<Subscription, 'id'>) => {
        setSubscriptions(prev => [...prev, { ...sub, id: generateUniqueId() }]);
        addAuditLog({ actorId: 'system', action: 'ADD_SUBSCRIPTION', targetType: 'card', targetId: sub.cardId, description: `Added subscription for ${sub.merchantName} to card ${sub.cardId}` });
    }, []);

    const updateSubscription = useCallback((id: string, updates: Partial<Subscription>) => {
        setSubscriptions(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
        addAuditLog({ actorId: 'system', action: 'UPDATE_SUBSCRIPTION', targetType: 'card', targetId: id, description: `Updated subscription ${id}` });
    }, []);

    const deleteSubscription = useCallback((id: string) => {
        setSubscriptions(prev => prev.filter(s => s.id !== id));
        addAuditLog({ actorId: 'system', action: 'DELETE_SUBSCRIPTION', targetType: 'card', targetId: id, description: `Deleted subscription ${id}` });
    }, []);

    const addBudget = useCallback((budget: Omit<Budget, 'id'>) => {
        setBudgets(prev => [...prev, { ...budget, id: generateUniqueId() }]);
        addAuditLog({ actorId: 'system', action: 'CREATE_BUDGET', targetType: 'policy', targetId: budget.id, description: `Created new budget ${budget.name}` });
    }, []);

    const updateBudget = useCallback((id: string, updates: Partial<Budget>) => {
        setBudgets(prev => prev.map(b => b.id === id ? { ...b, ...updates } : b));
        addAuditLog({ actorId: 'system', action: 'UPDATE_BUDGET', targetType: 'policy', targetId: id, description: `Updated budget ${id}` });
    }, []);

    const deleteBudget = useCallback((id: string) => {
        setBudgets(prev => prev.filter(b => b.id !== id));
        addAuditLog({ actorId: 'system', action: 'DELETE_BUDGET', targetType: 'policy', targetId: id, description: `Deleted budget ${id}` });
    }, []);

    const updateAPISetting = useCallback((id: string, updates: Partial<APISetting>) => {
        setApiSettings(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
        addAuditLog({ actorId: 'system', action: 'UPDATE_API_SETTING', targetType: 'policy', targetId: id, description: `Updated API setting ${id}` });
    }, []);

    const generateComplianceReport = useCallback(async (params: any) => {
        // Simulate API call
        return new Promise<ComplianceReport>(resolve => {
            setTimeout(() => {
                const newReport: ComplianceReport = {
                    ...generateMockComplianceReports(1)[0], // Generate a single mock report
                    id: generateUniqueId(),
                    generatedDate: new Date(),
                    status: 'completed',
                    downloadUrl: `/reports/download/${generateUniqueId()}.pdf`,
                    parameters: params,
                    name: `Custom Report ${formatDate(new Date(), { month: 'short', day: 'numeric' })}`
                };
                setComplianceReports(prev => [...prev, newReport]);
                addAuditLog({ actorId: 'system', action: 'GENERATE_COMPLIANCE_REPORT', targetType: 'policy', targetId: newReport.id, description: `Generated compliance report ${newReport.name}` });
                resolve(newReport);
            }, 1500); // Simulate network delay
        });
    }, []);

    const generateStatement = useCallback(async (cardId: string, month: number, year: number) => {
        return new Promise<Statement>(resolve => {
            setTimeout(() => {
                const newStatement: Statement = {
                    ...generateMockStatements(1, [cardId])[0],
                    id: generateUniqueId(),
                    cardId,
                    statementDate: new Date(year, month - 1, new Date().getDate()), // Last day of the month
                    startDate: new Date(year, month - 2, 1),
                    endDate: new Date(year, month - 1, 0),
                    status: 'generated',
                    downloadUrl: `/statements/download/card-${cardId}-${year}-${month}.pdf`
                };
                setStatements(prev => [...prev, newStatement]);
                addAuditLog({ actorId: 'system', action: 'GENERATE_STATEMENT', targetType: 'card', targetId: cardId, description: `Generated statement for card ${cardId} for ${month}/${year}` });
                resolve(newStatement);
            }, 1500);
        });
    }, []);

    const updateAppConfig = useCallback((updates: Partial<AppConfig>) => {
        setAppConfig(prev => ({ ...prev, ...updates }));
        addAuditLog({ actorId: 'system', action: 'UPDATE_APP_CONFIG', targetType: 'policy', targetId: 'global', description: `Updated application configuration` });
    }, []);

    const advancedData: AdvancedCardData = useMemo(() => ({
        merchantCategories,
        policyRules,
        cardRequests,
        virtualCards,
        auditLogs,
        userPermissionProfiles,
        alertConfigurations,
        subscriptions,
        budgets,
        apiSettings,
        complianceReports,
        statements,
        appConfig,
    }), [
        merchantCategories, policyRules, cardRequests, virtualCards, auditLogs,
        userPermissionProfiles, alertConfigurations, subscriptions, budgets,
        apiSettings, complianceReports, statements, appConfig
    ]);

    const advancedActions: AdvancedCardActions = useMemo(() => ({
        updateMerchantCategory, addPolicyRule, updatePolicyRule, deletePolicyRule,
        createCardRequest, updateCardRequestStatus, createVirtualCard, updateVirtualCard, deleteVirtualCard,
        addAuditLog, addUserPermissionProfile, updateUserPermissionProfile, deleteUserPermissionProfile,
        addAlertConfiguration, updateAlertConfiguration, deleteAlertConfiguration,
        addSubscription, updateSubscription, deleteSubscription,
        addBudget, updateBudget, deleteBudget,
        updateAPISetting, generateComplianceReport, generateStatement, updateAppConfig
    }), [
        updateMerchantCategory, addPolicyRule, updatePolicyRule, deletePolicyRule,
        createCardRequest, updateCardRequestStatus, createVirtualCard, updateVirtualCard, deleteVirtualCard,
        addAuditLog, addUserPermissionProfile, updateUserPermissionProfile, deleteUserPermissionProfile,
        addAlertConfiguration, updateAlertConfiguration, deleteAlertConfiguration,
        addSubscription, updateSubscription, deleteSubscription,
        addBudget, updateBudget, deleteBudget,
        updateAPISetting, generateComplianceReport, generateStatement, updateAppConfig
    ]);

    return (
        <AdvancedCardContext.Provider value={{ data: advancedData, actions: advancedActions }}>
            {children}
        </AdvancedCardContext.Provider>
    );
};

// --- END: CONTEXT FOR SHARED DATA AND ACTIONS ---

// --- START: SHARED UI COMPONENTS ---

interface TabProps {
    label: string;
    active: boolean;
    onClick: () => void;
}

const Tab: React.FC<TabProps> = ({ label, active, onClick }) => (
    <button
        className={`px-4 py-2 text-sm font-medium rounded-t-lg transition-colors duration-200 ${
            active ? 'bg-cyan-700 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
        }`}
        onClick={onClick}
    >
        {label}
    </button>
);

interface TabbedContentProps {
    tabs: { label: string; content: React.ReactNode; key: string }[];
    defaultActiveTab?: string;
    containerClassName?: string;
    headerClassName?: string;
    contentClassName?: string;
}

export const TabbedContent: React.FC<TabbedContentProps> = ({
    tabs,
    defaultActiveTab,
    containerClassName = "bg-gray-800 rounded-lg shadow-xl",
    headerClassName = "flex border-b border-gray-700 p-2 overflow-x-auto",
    contentClassName = "p-6",
}) => {
    const [activeTab, setActiveTab] = useState(defaultActiveTab || tabs[0]?.key);

    const activeTabContent = useMemo(() => {
        return tabs.find(tab => tab.key === activeTab)?.content || null;
    }, [activeTab, tabs]);

    return (
        <div className={containerClassName}>
            <div className={headerClassName}>
                {tabs.map(tab => (
                    <Tab
                        key={tab.key}
                        label={tab.label}
                        active={tab.key === activeTab}
                        onClick={() => setActiveTab(tab.key)}
                    />
                ))}
            </div>
            <div className={contentClassName}>
                {activeTabContent}
            </div>
        </div>
    );
};

interface PaginatedTableProps<T> {
    data: T[];
    columns: { header: string; accessor: keyof T | ((item: T) => React.ReactNode); className?: string }[];
    itemsPerPage?: number;
    title?: string;
    searchableKeys?: (keyof T)[];
    filterOptions?: Record<string, { label: string; options: { value: any; label: string }[] }>;
    actions?: (item: T) => React.ReactNode;
    emptyMessage?: string;
    rowKeyExtractor: (item: T) => string;
}

export const PaginatedTable = <T extends Record<string, any>>({
    data,
    columns,
    itemsPerPage = 10,
    title,
    searchableKeys = [],
    filterOptions = {},
    actions,
    emptyMessage = "No data available.",
    rowKeyExtractor,
}: PaginatedTableProps<T>) => {
    const {
        filteredData,
        searchTerm,
        handleSearchChange,
        filters,
        handleFilterChange,
        resetFilters
    } = useSearchAndFilter(data, searchableKeys);

    const { currentData, currentPage, maxPage, next, prev, jump } = usePagination(filteredData, itemsPerPage);

    return (
        <div className="bg-gray-800 rounded-lg shadow-xl border border-gray-700 p-4">
            {title && <h3 className="text-xl font-semibold text-white mb-4">{title}</h3>}

            <div className="flex flex-wrap items-center gap-4 mb-4">
                {searchableKeys.length > 0 && (
                    <input
                        type="text"
                        placeholder="Search..."
                        className="input input-bordered w-full md:w-auto bg-gray-700 text-white border-gray-600 focus:border-cyan-500"
                        value={searchTerm}
                        onChange={handleSearchChange}
                    />
                )}
                {Object.entries(filterOptions).map(([key, { label, options }]) => (
                    <select
                        key={key}
                        className="select select-bordered bg-gray-700 text-white border-gray-600 focus:border-cyan-500"
                        value={filters[key] || ''}
                        onChange={(e) => handleFilterChange(key, e.target.value)}
                    >
                        <option value="">{`Filter by ${label}`}</option>
                        {options.map(opt => (
                            <option key={opt.value} value={opt.value}>{opt.label}</option>
                        ))}
                    </select>
                ))}
                {(searchTerm || Object.keys(filters).length > 0) && (
                    <button onClick={resetFilters} className="btn btn-ghost text-gray-400 hover:text-white">Reset Filters</button>
                )}
            </div>

            {currentData.length === 0 ? (
                <div className="text-center text-gray-400 py-8">{emptyMessage}</div>
            ) : (
                <>
                    <div className="overflow-x-auto">
                        <table className="table w-full text-white">
                            <thead className="bg-gray-700 text-gray-300">
                                <tr>
                                    {columns.map((col, index) => (
                                        <th key={index} className={`px-4 py-2 text-left text-sm font-semibold ${col.className || ''}`}>{col.header}</th>
                                    ))}
                                    {actions && <th className="px-4 py-2 text-left text-sm font-semibold">Actions</th>}
                                </tr>
                            </thead>
                            <tbody>
                                {currentData.map((item) => (
                                    <tr key={rowKeyExtractor(item)} className="border-b border-gray-700 hover:bg-gray-700/50">
                                        {columns.map((col, index) => (
                                            <td key={index} className={`px-4 py-2 text-sm ${col.className || ''}`}>
                                                {typeof col.accessor === 'function' ? col.accessor(item) : String(item[col.accessor])}
                                            </td>
                                        ))}
                                        {actions && <td className="px-4 py-2 text-sm">{actions(item)}</td>}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    {maxPage > 1 && (
                        <div className="flex justify-center items-center gap-2 mt-4">
                            <button onClick={prev} disabled={currentPage === 1} className="btn btn-sm btn-ghost text-gray-400 hover:text-white">Previous</button>
                            {Array.from({ length: maxPage }, (_, i) => i + 1).map(page => (
                                <button
                                    key={page}
                                    onClick={() => jump(page)}
                                    className={`btn btn-sm ${currentPage === page ? 'btn-active btn-cyan' : 'btn-ghost text-gray-400 hover:text-white'}`}
                                >
                                    {page}
                                </button>
                            ))}
                            <button onClick={next} disabled={currentPage === maxPage} className="btn btn-sm btn-ghost text-gray-400 hover:text-white">Next</button>
                        </div>
                    )}
                </>
            )}
        </div>
    );
};

// --- END: SHARED UI COMPONENTS ---

// --- START: EXPANDED CardDetailModal SUB-COMPONENTS ---

interface CardControlsTabProps {
    selectedCard: CorporateCard;
    controls: CorporateCardControls;
    setControls: React.Dispatch<React.SetStateAction<CorporateCardControls>>;
    updateControls: (updates: Partial<CorporateCardControls>) => void;
    merchantCategories: MerchantCategory[]; // From AdvancedCardContext
}

const CardControlsTab: React.FC<CardControlsTabProps> = ({ selectedCard, controls, setControls, updateControls, merchantCategories }) => {
    const [spendingCategories, setSpendingCategories] = useState<string[]>(controls.allowedSpendingCategories || []);
    const [recurringTxnLimit, setRecurringTxnLimit] = useState<number>(controls.recurringTransactionLimit || 0);

    const availableCategories = useMemo(() => {
        return merchantCategories.map(mc => ({ value: mc.code, label: mc.name }));
    }, [merchantCategories]);

    const handleCategoryToggle = (code: string) => {
        setSpendingCategories(prev => {
            const newCategories = prev.includes(code) ? prev.filter(c => c !== code) : [...prev, code];
            updateControls({ allowedSpendingCategories: newCategories });
            return newCategories;
        });
    };

    const handleRecurringTxnLimitChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const value = +e.target.value;
        setRecurringTxnLimit(value);
        updateControls({ recurringTransactionLimit: value });
    };

    return (
        <div className="space-y-6">
            <h4 className="font-semibold text-cyan-300 mb-4">Core Controls</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <label className="flex flex-col"><span className="text-sm text-gray-300 mb-1">Monthly Limit: {formatCurrency(controls.monthlyLimit)}</span>
                    <input type="range" min="1000" max="50000" step="1000" value={controls.monthlyLimit} onChange={e => setControls(c => ({ ...c, monthlyLimit: +e.target.value }))} className="range range-xs range-cyan" /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">ATM Withdrawals</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.atm} onChange={e => setControls(c => ({ ...c, atm: e.target.checked }))} /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">Online Purchases</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.online} onChange={e => setControls(c => ({ ...c, online: e.target.checked }))} /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">Contactless Payments</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.contactless} onChange={e => setControls(c => ({ ...c, contactless: e.target.checked }))} /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">International Transactions</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.international || false} onChange={e => setControls(c => ({ ...c, international: e.target.checked }))} /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">Daily Transaction Count Limit</span>
                    <input type="number" min="0" max="50" step="1" value={controls.dailyTransactionLimit || 0} onChange={e => setControls(c => ({ ...c, dailyTransactionLimit: +e.target.value }))} className="input input-sm w-20 bg-gray-700 border-gray-600 text-white" /></label>
            </div>

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Advanced Spending Controls</h4>
            <div className="space-y-4">
                <div>
                    <label className="flex flex-col mb-2"><span className="text-sm text-gray-300">Recurring Transaction Limit: {formatCurrency(recurringTxnLimit)}</span>
                        <input type="range" min="0" max="5000" step="50" value={recurringTxnLimit} onChange={handleRecurringTxnLimitChange} className="range range-xs range-cyan" />
                        <p className="text-xs text-gray-500 mt-1">Maximum amount for a single recurring transaction (e.g., subscriptions).</p>
                    </label>
                </div>

                <div>
                    <h5 className="text-sm font-medium text-gray-300 mb-2">Allowed Spending Categories</h5>
                    <div className="flex flex-wrap gap-2">
                        {availableCategories.map(cat => (
                            <button
                                key={cat.value}
                                onClick={() => handleCategoryToggle(cat.value)}
                                className={`px-3 py-1 text-xs rounded-full transition-all duration-200 ${
                                    spendingCategories.includes(cat.value)
                                        ? 'bg-cyan-600 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                }`}
                            >
                                {cat.label}
                            </button>
                        ))}
                    </div>
                    <p className="text-xs text-gray-500 mt-2">Only transactions in selected categories will be allowed.</p>
                </div>

                <label className="flex flex-col"><span className="text-sm text-gray-300 mb-1">Single Transaction Max: {formatCurrency(controls.singleTransactionLimit || 0)}</span>
                    <input type="range" min="0" max="10000" step="100" value={controls.singleTransactionLimit || 0} onChange={e => setControls(c => ({ ...c, singleTransactionLimit: +e.target.value }))} className="range range-xs range-cyan" />
                    <p className="text-xs text-gray-500 mt-1">Maximum amount for any single transaction.</p>
                </label>

                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">Block Gambling Transactions</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.blockGambling || false} onChange={e => setControls(c => ({ ...c, blockGambling: e.target.checked }))} /></label>
                <label className="flex items-center justify-between"><span className="text-sm text-gray-300">Block Adult Content Purchases</span><input type="checkbox" className="toggle toggle-cyan" checked={controls.blockAdultContent || false} onChange={e => setControls(c => ({ ...c, blockAdultContent: e.target.checked }))} /></label>
            </div>
        </div>
    );
};

interface CardTransactionsTabProps {
    transactions: Transaction[];
}

const CardTransactionsTab: React.FC<CardTransactionsTabProps> = ({ transactions }) => {
    const columns = useMemo(() => [
        { header: 'Date', accessor: (tx: Transaction) => formatDate(new Date(tx.date), { year: 'numeric', month: 'short', day: 'numeric' }) },
        { header: 'Description', accessor: 'description' },
        { header: 'Merchant', accessor: 'merchant' },
        { header: 'Category', accessor: 'category' },
        { header: 'Amount', accessor: (tx: Transaction) => formatCurrency(tx.amount) },
        { header: 'Status', accessor: 'status' },
    ], []);

    const searchableKeys: (keyof Transaction)[] = ['description', 'merchant', 'category', 'status'];
    const filterOptions = {
        status: {
            label: 'Status',
            options: [
                { value: 'Completed', label: 'Completed' },
                { value: 'Pending', label: 'Pending' },
                { value: 'Declined', label: 'Declined' },
            ]
        },
        category: {
            label: 'Category',
            options: Array.from(new Set(transactions.map(tx => tx.category))).map(cat => ({ value: cat, label: cat }))
        }
    };

    return (
        <div>
            <h4 className="font-semibold text-cyan-300 mb-4">All Transactions</h4>
            <PaginatedTable
                data={transactions.sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime())}
                columns={columns}
                itemsPerPage={7}
                rowKeyExtractor={(tx) => tx.id}
                searchableKeys={searchableKeys}
                filterOptions={filterOptions}
                emptyMessage="No transactions found for this card."
            />
        </div>
    );
};

interface CardSpendingAnalysisTabProps {
    transactions: Transaction[];
    limit: number;
}

const COLORS = ['#06b6d4', '#67e8f9', '#22d3ee', '#0891b2', '#0e7490', '#155e75', '#0f766e', '#14b8a6', '#2dd4bf'];

const CardSpendingAnalysisTab: React.FC<CardSpendingAnalysisTabProps> = ({ transactions, limit }) => {
    const spendingByCategory = useMemo(() => {
        const categories: { [key: string]: number } = {};
        transactions.forEach(tx => {
            categories[tx.category] = (categories[tx.category] || 0) + tx.amount;
        });
        return Object.entries(categories).map(([name, value]) => ({ name, value }));
    }, [transactions]);

    const monthlySpendingTrend = useMemo(() => {
        const monthlyData: { [key: string]: number } = {};
        transactions.forEach(tx => {
            const date = new Date(tx.date);
            const monthYear = `${date.getFullYear()}-${date.getMonth() + 1}`;
            monthlyData[monthYear] = (monthlyData[monthYear] || 0) + tx.amount;
        });

        // Sort by month/year for charting
        return Object.entries(monthlyData)
            .map(([monthYear, spent]) => {
                const [year, month] = monthYear.split('-').map(Number);
                return { date: new Date(year, month - 1), spent };
            })
            .sort((a, b) => a.date.getTime() - b.date.getTime())
            .map(item => ({ name: formatDate(item.date, { month: 'short', year: 'numeric' }), spent: item.spent }));
    }, [transactions]);

    const totalSpent = transactions.reduce((sum, tx) => sum + tx.amount, 0);
    const utilization = calculateBudgetUtilization(totalSpent, limit);

    return (
        <div className="space-y-8">
            <h4 className="font-semibold text-cyan-300 mb-4">Spending Overview</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <Card className="text-center">
                    <p className="text-gray-300 text-sm">Total Spent</p>
                    <p className="text-white text-3xl font-bold mt-2">{formatCurrency(totalSpent)}</p>
                </Card>
                <Card className="text-center">
                    <p className="text-gray-300 text-sm">Monthly Limit</p>
                    <p className="text-white text-3xl font-bold mt-2">{formatCurrency(limit)}</p>
                </Card>
                <Card className="text-center">
                    <p className="text-gray-300 text-sm">Utilization</p>
                    <p className={`text-3xl font-bold mt-2 ${utilization > 80 ? 'text-red-400' : utilization > 50 ? 'text-yellow-400' : 'text-green-400'}`}>
                        {utilization.toFixed(2)}%
                    </p>
                </Card>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <Card title="Spending by Category" className="flex flex-col items-center">
                    {spendingByCategory.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <PieChart>
                                <Pie
                                    data={spendingByCategory}
                                    dataKey="value"
                                    nameKey="name"
                                    cx="50%"
                                    cy="50%"
                                    outerRadius={100}
                                    fill="#8884d8"
                                    label
                                >
                                    {spendingByCategory.map((entry, index) => (
                                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                    ))}
                                </Pie>
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} />
                                <Legend />
                            </PieChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">No spending data to categorize.</div>
                    )}
                </Card>

                <Card title="Monthly Spending Trend">
                    {monthlySpendingTrend.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <AreaChart data={monthlySpendingTrend} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
                                <XAxis dataKey="name" stroke="#9ca3af" fontSize={12} />
                                <YAxis stroke="#9ca3af" tickFormatter={(value) => formatCurrency(value, 'USD', 'en-US')} />
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} formatter={(value: number) => formatCurrency(value, 'USD', 'en-US')} />
                                <Area type="monotone" dataKey="spent" stroke="#06b6d4" fillOpacity={1} fill="url(#colorSpending)" />
                                <defs>
                                    <linearGradient id="colorSpending" x1="0" y1="0" x2="0" y2="1">
                                        <stop offset="5%" stopColor="#06b6d4" stopOpacity={0.8} />
                                        <stop offset="95%" stopColor="#06b6d4" stopOpacity={0} />
                                    </linearGradient>
                                </defs>
                            </AreaChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">Not enough historical data for trend analysis.</div>
                    )}
                </Card>
            </div>
        </div>
    );
};

interface CardSecurityTabProps {
    cardId: string;
    onUpdateSecurity: (cardId: string, updates: { cvvLock?: boolean; pinBlock?: boolean; threeDSecureEnabled?: boolean; tokenizationStatus?: 'enabled' | 'disabled' }) => void;
}

const CardSecurityTab: React.FC<CardSecurityTabProps> = ({ cardId, onUpdateSecurity }) => {
    // In a real app, these would come from card state. Using local state for mock UI.
    const [cvvLock, setCvvLock] = useState(Math.random() > 0.5);
    const [pinBlock, setPinBlock] = useState(Math.random() > 0.5);
    const [threeDSecureEnabled, setThreeDSecureEnabled] = useState(Math.random() > 0.5);
    const [tokenizationStatus, setTokenizationStatus] = useState<'enabled' | 'disabled'>(Math.random() > 0.5 ? 'enabled' : 'disabled');
    const [isSaving, setIsSaving] = useState(false);

    const handleSaveSecuritySettings = async () => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
        onUpdateSecurity(cardId, { cvvLock, pinBlock, threeDSecureEnabled, tokenizationStatus });
        setIsSaving(false);
        alert('Security settings updated!');
    };

    return (
        <div className="space-y-6">
            <h4 className="font-semibold text-cyan-300 mb-4">Security Features</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">CVV Lock (Online)</span>
                    <input type="checkbox" className="toggle toggle-cyan" checked={cvvLock} onChange={e => setCvvLock(e.target.checked)} />
                </label>
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">PIN Block (ATM/POS)</span>
                    <input type="checkbox" className="toggle toggle-cyan" checked={pinBlock} onChange={e => setPinBlock(e.target.checked)} />
                </label>
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">3D Secure for Online</span>
                    <input type="checkbox" className="toggle toggle-cyan" checked={threeDSecureEnabled} onChange={e => setThreeDSecureEnabled(e.target.checked)} />
                </label>
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">Card Tokenization</span>
                    <select
                        className="select select-sm bg-gray-800 border-gray-600 text-white"
                        value={tokenizationStatus}
                        onChange={e => setTokenizationStatus(e.target.value as 'enabled' | 'disabled')}
                    >
                        <option value="enabled">Enabled</option>
                        <option value="disabled">Disabled</option>
                    </select>
                </label>
            </div>
            <p className="text-xs text-gray-500 mt-2">
                CVV Lock prevents transactions without a valid CVV. PIN Block prevents transactions requiring a PIN.
                3D Secure adds an extra layer of authentication for online purchases. Card Tokenization replaces sensitive card data with a unique identifier.
            </p>

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Risk Management</h4>
            <div className="space-y-4">
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">Geolocation Restrictions</span>
                    <button className="btn btn-sm btn-outline btn-info">Configure Regions</button>
                </label>
                <label className="flex items-center justify-between p-3 bg-gray-700 rounded-md">
                    <span className="text-sm text-gray-300">Fraud Monitoring Level</span>
                    <select className="select select-sm bg-gray-800 border-gray-600 text-white">
                        <option>Standard</option>
                        <option>Enhanced</option>
                        <option>Aggressive</option>
                    </select>
                </label>
            </div>
            <button
                onClick={handleSaveSecuritySettings}
                className={`mt-6 w-full py-2 rounded transition-colors duration-200 ${isSaving ? 'bg-cyan-700/50 cursor-not-allowed' : 'bg-cyan-600 hover:bg-cyan-700'}`}
                disabled={isSaving}
            >
                {isSaving ? 'Saving...' : 'Save Security Settings'}
            </button>
        </div>
    );
};

interface CardDetailsOverviewTabProps {
    card: CorporateCard;
}

const CardDetailsOverviewTab: React.FC<CardDetailsOverviewTabProps> = ({ card }) => {
    const cardholder = MOCK_CARDHOLDERS.find(h => h.id === card.id); // Assuming card ID maps to holder ID for simplicity
    return (
        <div className="space-y-6">
            <h4 className="font-semibold text-cyan-300 mb-4">Card Information</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Card Holder</p>
                    <p className="text-white text-sm font-medium">{card.holderName}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Card Number (Masked)</p>
                    <p className="text-white text-sm font-mono">**** **** **** {card.cardNumberMask}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Current Balance</p>
                    <p className="text-white text-sm font-medium">{formatCurrency(card.balance)}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Total Limit</p>
                    <p className="text-white text-sm font-medium">{formatCurrency(card.limit)}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Status</p>
                    <p className={`text-sm font-medium ${card.status === 'Active' ? 'text-green-300' : card.status === 'Frozen' ? 'text-blue-300' : 'text-yellow-300'}`}>{card.status}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Card Type</p>
                    <p className="text-white text-sm font-medium">{card.type || 'Physical'}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Issue Date</p>
                    <p className="text-white text-sm font-medium">{formatDate(new Date(card.issueDate || '2023-01-01'), { year: 'numeric', month: 'short', day: 'numeric' })}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Expiration Date</p>
                    <p className="text-white text-sm font-medium">{formatDate(new Date(card.expirationDate || '2025-12-31'), { year: 'numeric', month: 'short' })}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md col-span-1 md:col-span-2">
                    <p className="text-xs text-gray-400">Associated Department/Project</p>
                    <p className="text-white text-sm font-medium">{card.associatedProject || 'Not Assigned'}</p>
                </div>
            </div>

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Cardholder Details</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Cardholder Email</p>
                    <p className="text-white text-sm">{cardholder?.email || 'N/A'}</p>
                </div>
                <div className="p-3 bg-gray-700 rounded-md">
                    <p className="text-xs text-gray-400">Cardholder Role</p>
                    <p className="text-white text-sm">{cardholder?.role || 'N/A'}</p>
                </div>
            </div>

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Card Actions</h4>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button className="btn btn-warning btn-outline">Replace Card</button>
                <button className="btn btn-error btn-outline">Report Lost/Stolen</button>
                <button className="btn btn-secondary btn-outline">Close Card Account</button>
            </div>
        </div>
    );
};


interface CardLimitAllocationTabProps {
    card: CorporateCard;
    onUpdateLimit: (cardId: string, newLimit: number) => void;
    budgets: Budget[]; // From AdvancedCardContext
    onLinkToBudget: (cardId: string, budgetId: string) => void;
    onUnlinkFromBudget: (cardId: string, budgetId: string) => void;
    onUpdateBudgetAllocation: (budgetId: string, cardId: string, amount: number) => void;
}

const CardLimitAllocationTab: React.FC<CardLimitAllocationTabProps> = ({
    card,
    onUpdateLimit,
    budgets,
    onLinkToBudget,
    onUnlinkFromBudget,
    onUpdateBudgetAllocation
}) => {
    const [newCardLimit, setNewCardLimit] = useState(card.limit);
    const [selectedBudgetId, setSelectedBudgetId] = useState<string>('');
    const [allocationAmount, setAllocationAmount] = useState<number>(0);
    const [isSavingLimit, setIsSavingLimit] = useState(false);
    const [isAllocatingBudget, setIsAllocatingBudget] = useState(false);

    useEffect(() => {
        setNewCardLimit(card.limit);
    }, [card.limit]);

    const handleUpdateCardLimit = async () => {
        setIsSavingLimit(true);
        await new Promise(resolve => setTimeout(resolve, 800)); // Simulate API call
        onUpdateLimit(card.id, newCardLimit);
        setIsSavingLimit(false);
    };

    const availableBudgets = useMemo(() => {
        // Filter out budgets already linked to this card
        return budgets.filter(b => !b.cardsLinked.includes(card.id));
    }, [budgets, card.id]);

    const linkedBudgets = useMemo(() => {
        return budgets.filter(b => b.cardsLinked.includes(card.id));
    }, [budgets, card.id]);

    const handleLinkBudget = async () => {
        if (!selectedBudgetId) return;
        setIsAllocatingBudget(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        onLinkToBudget(card.id, selectedBudgetId);
        setSelectedBudgetId('');
        setIsAllocatingBudget(false);
    };

    const handleUnlinkBudget = async (budgetId: string) => {
        setIsAllocatingBudget(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        onUnlinkFromBudget(card.id, budgetId);
        setIsAllocatingBudget(false);
    };

    const handleUpdateBudgetAllocation = async (budgetId: string) => {
        setIsAllocatingBudget(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        onUpdateBudgetAllocation(budgetId, card.id, allocationAmount);
        setIsAllocatingBudget(false);
    };

    return (
        <div className="space-y-8">
            <h4 className="font-semibold text-cyan-300 mb-4">Card Limit Adjustment</h4>
            <div className="bg-gray-700 p-4 rounded-md space-y-4">
                <label className="flex flex-col">
                    <span className="text-sm text-gray-300 mb-1">Current Limit: {formatCurrency(card.limit)}</span>
                    <span className="text-sm text-gray-300 mb-1">New Limit: {formatCurrency(newCardLimit)}</span>
                    <input
                        type="range"
                        min="1000"
                        max="100000"
                        step="1000"
                        value={newCardLimit}
                        onChange={e => setNewCardLimit(+e.target.value)}
                        className="range range-xs range-cyan"
                    />
                </label>
                <button
                    onClick={handleUpdateCardLimit}
                    className={`w-full py-2 rounded transition-colors duration-200 ${isSavingLimit ? 'bg-cyan-700/50 cursor-not-allowed' : 'bg-cyan-600 hover:bg-cyan-700'}`}
                    disabled={isSavingLimit}
                >
                    {isSavingLimit ? 'Updating Limit...' : 'Update Card Limit'}
                </button>
            </div>

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Budget Linkage</h4>
            <div className="bg-gray-700 p-4 rounded-md space-y-4">
                <p className="text-sm text-gray-300 mb-2">Link this card to an existing budget for tracking and enforcement.</p>
                <div className="flex flex-col md:flex-row gap-2">
                    <select
                        className="select select-bordered flex-grow bg-gray-800 border-gray-600 text-white"
                        value={selectedBudgetId}
                        onChange={e => setSelectedBudgetId(e.target.value)}
                        disabled={isAllocatingBudget}
                    >
                        <option value="">Select a Budget to Link</option>
                        {availableBudgets.map(budget => (
                            <option key={budget.id} value={budget.id}>
                                {budget.name} ({formatCurrency(budget.totalAmount)} remaining)
                            </option>
                        ))}
                    </select>
                    <button
                        onClick={handleLinkBudget}
                        className={`btn btn-primary ${isAllocatingBudget ? 'btn-disabled' : ''}`}
                        disabled={!selectedBudgetId || isAllocatingBudget}
                    >
                        {isAllocatingBudget ? 'Linking...' : 'Link Budget'}
                    </button>
                </div>

                {linkedBudgets.length > 0 && (
                    <div className="mt-6">
                        <h5 className="text-md font-medium text-gray-300 mb-2">Linked Budgets:</h5>
                        <ul className="space-y-3">
                            {linkedBudgets.map(budget => (
                                <li key={budget.id} className="flex flex-col md:flex-row items-start md:items-center justify-between p-3 bg-gray-800 rounded-md border border-gray-600">
                                    <div>
                                        <p className="font-medium text-white">{budget.name}</p>
                                        <p className="text-xs text-gray-400">
                                            Period: {capitalizeFirstLetter(budget.period)} | Total: {formatCurrency(budget.totalAmount)} | Spent: {formatCurrency(budget.spentAmount)}
                                        </p>
                                    </div>
                                    <div className="flex gap-2 mt-2 md:mt-0">
                                        <input
                                            type="number"
                                            placeholder="Allocate amount"
                                            className="input input-sm w-32 bg-gray-700 border-gray-600 text-white"
                                            value={allocationAmount}
                                            onChange={e => setAllocationAmount(+e.target.value)}
                                            disabled={isAllocatingBudget}
                                        />
                                        <button
                                            onClick={() => handleUpdateBudgetAllocation(budget.id)}
                                            className={`btn btn-sm btn-info ${isAllocatingBudget ? 'btn-disabled' : ''}`}
                                            disabled={isAllocatingBudget || allocationAmount <= 0}
                                        >
                                            Allocate
                                        </button>
                                        <button
                                            onClick={() => handleUnlinkBudget(budget.id)}
                                            className={`btn btn-sm btn-error btn-outline ${isAllocatingBudget ? 'btn-disabled' : ''}`}
                                            disabled={isAllocatingBudget}
                                        >
                                            Unlink
                                        </button>
                                    </div>
                                </li>
                            ))}
                        </ul>
                    </div>
                )}
            </div>
        </div>
    );
};

interface CardCompliancePolicyTabProps {
    cardId: string;
    policyRules: PolicyRule[];
}

const CardCompliancePolicyTab: React.FC<CardCompliancePolicyTabProps> = ({ cardId, policyRules }) => {
    // Filter policies relevant to this card, or all_cards policies
    const relevantPolicies = useMemo(() => {
        return policyRules.filter(p =>
            p.isActive && (p.appliesTo === 'all_cards' || (p.targetIds && p.targetIds.includes(cardId)))
        );
    }, [cardId, policyRules]);

    const columns = useMemo(() => [
        { header: 'Rule Name', accessor: 'name' },
        { header: 'Description', accessor: 'description' },
        { header: 'Type', accessor: (p: PolicyRule) => capitalizeFirstLetter(p.type.replace(/_/g, ' ')) },
        { header: 'Status', accessor: (p: PolicyRule) => (
            <span className={`badge ${p.isActive ? 'badge-success' : 'badge-warning'}`}>{p.isActive ? 'Active' : 'Inactive'}</span>
        ) },
    ], []);

    return (
        <div className="space-y-6">
            <h4 className="font-semibold text-cyan-300 mb-4">Applied Spending Policies</h4>
            <p className="text-sm text-gray-300">
                Below are the spending policies currently applied to this card, either globally or specifically targeting this card/cardholder.
            </p>
            {relevantPolicies.length > 0 ? (
                <PaginatedTable
                    data={relevantPolicies}
                    columns={columns}
                    itemsPerPage={5}
                    rowKeyExtractor={(item) => item.id}
                    emptyMessage="No specific policies apply to this card currently."
                />
            ) : (
                <div className="text-gray-400 text-center py-4 bg-gray-700 rounded-md">
                    No custom policies found for this card. Global policies may still apply.
                </div>
            )}

            <div className="divider"></div>

            <h4 className="font-semibold text-cyan-300 mb-4">Policy Adherence History (Mock)</h4>
            <div className="bg-gray-700 p-4 rounded-md text-gray-400">
                <p>This section would display a history of compliance checks, showing if any transactions violated a policy and the details of that violation.</p>
                <ul className="list-disc list-inside mt-2 space-y-1 text-sm">
                    <li><span className="text-green-400">Aug 15, 2024:</span> All transactions adhered to monthly limit policy.</li>
                    <li><span className="text-yellow-400">Jul 20, 2024:</span> <span className="text-red-400">Warning:</span> Transaction for {formatCurrency(550)} at "Online Casino" flagged by 'Gambling Block' policy. Transaction declined.</li>
                    <li><span className="text-green-400">Jun 01, 2024:</span> Policy 'International Transaction Block' successfully enforced.</li>
                </ul>
                <p className="text-xs italic mt-3">Detailed policy violation reports can be generated in the Compliance Reports section.</p>
            </div>
        </div>
    );
};


// --- END: EXPANDED CardDetailModal SUB-COMPONENTS ---

const CardDetailModal: React.FC = () => {
    const context = useContext(DataContext);
    const advancedContext = useContext(AdvancedCardContext);

    if (!context || !advancedContext) throw new Error("CardDetailModal must be within a DataProvider and AdvancedCardProvider");

    const { corporateCards, updateCorporateCardControls } = context;
    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [selectedCardId, setSelectedCardId] = useState<string | null>(null);
    const [localCardControls, setLocalCardControls] = useState<CorporateCardControls | null>(null);

    // Get the currently selected card from the context's corporateCards list
    const selectedCard = useMemo(() => {
        return corporateCards.find(card => card.id === selectedCardId) || null;
    }, [selectedCardId, corporateCards]);

    // Initialize local controls when a card is selected or its controls change in context
    useEffect(() => {
        if (selectedCard) {
            setLocalCardControls(deepClone(selectedCard.controls));
        } else {
            setLocalCardControls(null);
        }
    }, [selectedCard]);

    const handleSaveControls = () => {
        if (selectedCard && localCardControls) {
            updateCorporateCardControls(selectedCard.id, localCardControls);
            // Optionally close modal or give feedback
            alert('Card controls updated successfully!');
            // Log this action
            advancedActions.addAuditLog({
                actorId: 'current_user_id', // Placeholder
                action: 'UPDATE_CARD_CONTROLS',
                targetType: 'card',
                targetId: selectedCard.id,
                description: `Updated controls for card ${selectedCard.cardNumberMask}.`
            });
        }
    };

    const handleUpdateCardLimit = useCallback((cardId: string, newLimit: number) => {
        // This is a direct update to the card's limit, usually done through `updateCorporateCardControls`
        if (selectedCard && selectedCard.id === cardId) {
            setLocalCardControls(prev => (prev ? { ...prev, monthlyLimit: newLimit } : null));
            updateCorporateCardControls(cardId, { ...selectedCard.controls, monthlyLimit: newLimit });
            advancedActions.addAuditLog({
                actorId: 'current_user_id',
                action: 'UPDATE_CARD_LIMIT',
                targetType: 'card',
                targetId: cardId,
                description: `Updated limit for card ${selectedCard.cardNumberMask} to ${formatCurrency(newLimit)}.`
            });
        }
    }, [selectedCard, updateCorporateCardControls, advancedActions]);

    const handleUpdateCardSecurity = useCallback((cardId: string, updates: { cvvLock?: boolean; pinBlock?: boolean; threeDSecureEnabled?: boolean; tokenizationStatus?: 'enabled' | 'disabled' }) => {
        // This would interact with the backend to update security settings
        console.log(`Updating security for card ${cardId}:`, updates);
        alert(`Security settings for card ${cardId} updated! (Mock)`);
        advancedActions.addAuditLog({
            actorId: 'current_user_id',
            action: 'UPDATE_CARD_SECURITY',
            targetType: 'card',
            targetId: cardId,
            description: `Updated security settings for card ${selectedCard?.cardNumberMask}.`
        });
    }, [advancedActions, selectedCard]);

    const handleLinkToBudget = useCallback((cardId: string, budgetId: string) => {
        advancedActions.updateBudget(budgetId, { cardsLinked: [...(advancedData.budgets.find(b => b.id === budgetId)?.cardsLinked || []), cardId] });
        alert(`Card ${cardId} linked to budget ${budgetId}. (Mock)`);
    }, [advancedActions, advancedData.budgets]);

    const handleUnlinkFromBudget = useCallback((cardId: string, budgetId: string) => {
        advancedActions.updateBudget(budgetId, { cardsLinked: (advancedData.budgets.find(b => b.id === budgetId)?.cardsLinked || []).filter(id => id !== cardId) });
        alert(`Card ${cardId} unlinked from budget ${budgetId}. (Mock)`);
    }, [advancedActions, advancedData.budgets]);

    const handleUpdateBudgetAllocation = useCallback((budgetId: string, cardId: string, amount: number) => {
        // This would involve a more complex logic, potentially updating specific allocation within a budget for a card
        // For now, we'll just log it.
        console.log(`Allocating ${formatCurrency(amount)} from budget ${budgetId} to card ${cardId}.`);
        alert(`Budget allocation updated for card ${cardId} from budget ${budgetId}. (Mock)`);
        advancedActions.addAuditLog({
            actorId: 'current_user_id',
            action: 'UPDATE_BUDGET_ALLOCATION',
            targetType: 'card',
            targetId: cardId,
            description: `Allocated ${formatCurrency(amount)} from budget ${budgetId} to card ${selectedCard?.cardNumberMask}.`
        });
    }, [advancedActions, selectedCard]);

    // Use a local state for modal visibility and the ID of the card being managed
    const [isModalOpen, setIsModalOpen] = useState(false);
    const openModal = useCallback((card: CorporateCard) => {
        setSelectedCardId(card.id);
        setIsModalOpen(true);
    }, []);
    const closeModal = useCallback(() => {
        setSelectedCardId(null);
        setIsModalOpen(false);
    }, []);

    // Provide the openModal function to the parent component
    const contextValue = useMemo(() => ({ openCardDetailModal: openModal }), [openModal]);
    // In a real app, this would be part of a larger UI context or prop drilling.
    // For this exercise, we can extend the DataContext implicitly or make a new context.
    // For now, I'll assume the CardManagementView can directly call `openModal`.

    if (!isModalOpen || !selectedCard || !localCardControls) return null;

    const tabs = [
        { label: 'Controls', key: 'controls', content: (
            <CardControlsTab
                selectedCard={selectedCard}
                controls={localCardControls}
                setControls={setLocalCardControls}
                updateControls={(updates) => setLocalCardControls(prev => prev ? { ...prev, ...updates } : null)}
                merchantCategories={advancedData.merchantCategories}
            />
        ) },
        { label: 'Transactions', key: 'transactions', content: <CardTransactionsTab transactions={selectedCard.transactions} /> },
        { label: 'Spending Analysis', key: 'spending_analysis', content: <CardSpendingAnalysisTab transactions={selectedCard.transactions} limit={selectedCard.limit} /> },
        { label: 'Security', key: 'security', content: <CardSecurityTab cardId={selectedCard.id} onUpdateSecurity={handleUpdateCardSecurity} /> },
        { label: 'Details', key: 'details', content: <CardDetailsOverviewTab card={selectedCard} /> },
        { label: 'Limits & Budgets', key: 'limits_budgets', content: (
            <CardLimitAllocationTab
                card={selectedCard}
                onUpdateLimit={handleUpdateCardLimit}
                budgets={advancedData.budgets}
                onLinkToBudget={handleLinkToBudget}
                onUnlinkFromBudget={handleUnlinkFromBudget}
                onUpdateBudgetAllocation={handleUpdateBudgetAllocation}
            />
        ) },
        { label: 'Compliance & Policies', key: 'compliance_policies', content: <CardCompliancePolicyTab cardId={selectedCard.id} policyRules={advancedData.policyRules} /> },
    ];

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={closeModal}>
            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full border border-gray-700 h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">Manage Card: {selectedCard.holderName} (...{selectedCard.cardNumberMask})</h3>
                    <button onClick={closeModal} className="text-gray-400 hover:text-white"></button>
                </div>
                <div className="flex-grow overflow-hidden flex flex-col">
                    <TabbedContent
                        tabs={tabs}
                        containerClassName="flex-grow flex flex-col"
                        headerClassName="flex border-b border-gray-700 p-2 overflow-x-auto flex-shrink-0"
                        contentClassName="p-6 overflow-y-auto flex-grow"
                    />
                </div>
                <div className="p-4 border-t border-gray-700 flex justify-end">
                    <button onClick={handleSaveControls} className="btn btn-cyan">Save All Changes</button>
                </div>
            </div>
        </div>
    );
};

// --- START: NEW EXPORTED COMPONENTS (MAIN DASHBOARD SECTIONS) ---

export const CardRequestPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("CardRequestPanel must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isRequestModalOpen, setIsRequestModalOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);

    const initialRequestFormState: Omit<CardRequest, 'id' | 'status' | 'requestedDate' | 'requestorId'> = {
        requestType: 'new_card',
        details: {
            reason: '',
            cardHolderName: '',
            cardType: 'physical',
            limit: 5000,
            currency: 'USD',
        }
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(initialRequestFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.details.reason) newErrors.reason = 'Reason is required.';
        if (vals.requestType === 'new_card' && !vals.details.cardHolderName) newErrors.cardHolderName = 'Cardholder name is required.';
        if (vals.requestType === 'new_card' && !vals.details.limit) newErrors.limit = 'Limit is required.';
        return newErrors;
    });

    const onSubmitNewRequest = async (formValues: typeof initialRequestFormState) => {
        setIsLoading(true);
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Using a mock requestorId for now
        advancedActions.createCardRequest({ ...formValues, requestorId: MOCK_CARDHOLDERS[0].id });
        setIsLoading(false);
        setIsRequestModalOpen(false);
        setValues(initialRequestFormState); // Reset form
        alert('Card request submitted successfully!');
    };

    const handleApproveReject = async (requestId: string, status: 'approved' | 'rejected') => {
        setIsLoading(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        // Mock approver ID
        advancedActions.updateCardRequestStatus(requestId, status, MOCK_CARDHOLDERS.find(u => u.role === 'Finance Manager')?.id || 'admin-id');
        setIsLoading(false);
        alert(`Request ${requestId} ${status}!`);
    };

    const requestColumns = useMemo(() => [
        { header: 'Request ID', accessor: 'id', className: 'font-mono' },
        { header: 'Type', accessor: (req: CardRequest) => capitalizeFirstLetter(req.requestType.replace(/_/g, ' ')) },
        { header: 'Requested By', accessor: (req: CardRequest) => MOCK_CARDHOLDERS.find(h => h.id === req.requestorId)?.name || req.requestorId },
        { header: 'Details', accessor: (req: CardRequest) => req.details.cardHolderName || req.details.existingCardId || 'N/A' },
        { header: 'Amount/Limit', accessor: (req: CardRequest) => req.details.limit ? formatCurrency(req.details.limit) : 'N/A' },
        { header: 'Date', accessor: (req: CardRequest) => formatDate(req.requestedDate, { year: 'numeric', month: 'short', day: 'numeric' }) },
        { header: 'Status', accessor: (req: CardRequest) => (
            <span className={`badge ${
                req.status === 'pending' ? 'badge-info' :
                req.status === 'approved' ? 'badge-success' :
                req.status === 'rejected' ? 'badge-error' : 'badge-neutral'
            }`}>
                {capitalizeFirstLetter(req.status)}
            </span>
        )},
    ], []);

    const filterOptions = {
        requestType: {
            label: 'Request Type',
            options: [
                { value: 'new_card', label: 'New Card' },
                { value: 'limit_increase', label: 'Limit Increase' },
                { value: 'freeze_unfreeze', label: 'Freeze/Unfreeze' },
                { value: 'card_replacement', label: 'Card Replacement' },
                { value: 'close_card', label: 'Close Card' },
            ]
        },
        status: {
            label: 'Status',
            options: [
                { value: 'pending', label: 'Pending' },
                { value: 'approved', label: 'Approved' },
                { value: 'rejected', label: 'Rejected' },
                { value: 'completed', label: 'Completed' },
            ]
        },
    };

    return (
        <Card title="Card Requests & Approvals">
            <div className="flex justify-end mb-6">
                <button onClick={() => setIsRequestModalOpen(true)} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    New Card Request
                </button>
            </div>

            <PaginatedTable
                title="All Card Requests"
                data={advancedData.cardRequests.sort((a,b) => b.requestedDate.getTime() - a.requestedDate.getTime())}
                columns={requestColumns}
                rowKeyExtractor={(req) => req.id}
                searchableKeys={['id', 'requestType', 'details.cardHolderName', 'details.reason']}
                filterOptions={filterOptions}
                emptyMessage="No card requests found."
                actions={(item) => (
                    item.status === 'pending' && (
                        <div className="flex gap-2">
                            <button onClick={() => handleApproveReject(item.id, 'approved')} className="btn btn-xs btn-success" disabled={isLoading}>Approve</button>
                            <button onClick={() => handleApproveReject(item.id, 'rejected')} className="btn btn-xs btn-error" disabled={isLoading}>Reject</button>
                        </div>
                    )
                )}
            />

            {isRequestModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsRequestModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">Submit New Card Request</h3>
                        <form onSubmit={handleSubmit(onSubmitNewRequest)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Request Type</span>
                                <select name="requestType" value={values.requestType} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="new_card">New Card</option>
                                    <option value="limit_increase">Limit Increase</option>
                                    <option value="freeze_unfreeze">Freeze/Unfreeze</option>
                                    <option value="card_replacement">Card Replacement</option>
                                    <option value="close_card">Close Card</option>
                                </select>
                            </label>

                            {values.requestType === 'new_card' && (
                                <>
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Card Holder Name</span>
                                        <input type="text" name="details.cardHolderName" value={values.details.cardHolderName} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, cardHolderName: e.target.value } }))} placeholder="John Doe" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        {errors.cardHolderName && <p className="text-error text-sm mt-1">{errors.cardHolderName}</p>}
                                    </label>
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Card Type</span>
                                        <select name="details.cardType" value={values.details.cardType} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, cardType: e.target.value as 'physical' | 'virtual' } }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                            <option value="physical">Physical Card</option>
                                            <option value="virtual">Virtual Card</option>
                                        </select>
                                    </label>
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Requested Limit ({formatCurrency(values.details.limit || 0)})</span>
                                        <input type="range" min="100" max="20000" step="100" name="details.limit" value={values.details.limit} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, limit: +e.target.value } }))} className="range range-cyan range-xs" />
                                        {errors.limit && <p className="text-error text-sm mt-1">{errors.limit}</p>}
                                    </label>
                                </>
                            )}

                            {values.requestType !== 'new_card' && (
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Select Existing Card</span>
                                    <select name="details.existingCardId" value={values.details.existingCardId} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, existingCardId: e.target.value } }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="">Select a card</option>
                                        {corporateCards.map(card => (
                                            <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                        ))}
                                    </select>
                                </label>
                            )}

                            {values.requestType === 'limit_increase' && (
                                <label className="form-control">
                                    <span className="label-text text-gray-300">New Requested Limit ({formatCurrency(values.details.limit || 0)})</span>
                                    <input type="range" min="100" max="20000" step="100" name="details.limit" value={values.details.limit} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, limit: +e.target.value } }))} className="range range-cyan range-xs" />
                                </label>
                            )}


                            <label className="form-control">
                                <span className="label-text text-gray-300">Reason for Request</span>
                                <textarea name="details.reason" value={values.details.reason} onChange={e => setValues(prev => ({ ...prev, details: { ...prev.details, reason: e.target.value } }))} placeholder="Provide a detailed reason..." className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                                {errors.reason && <p className="text-error text-sm mt-1">{errors.reason}</p>}
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsRequestModalOpen(false)} disabled={isSubmitting || isLoading}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isLoading}>
                                    {(isSubmitting || isLoading) && <span className="loading loading-spinner"></span>}
                                    Submit Request
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const SpendingAnalyticsPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("SpendingAnalyticsPanel must be within AdvancedCardProvider and DataProvider");

    const { corporateCards } = dataContext;
    const { data: advancedData, actions: advancedActions } = advancedContext;

    const allTransactions = useMemo(() => corporateCards.flatMap(card => card.transactions), [corporateCards]);

    // Aggregate data for different charts
    const spendingByCategory = useMemo(() => {
        const categories: { [key: string]: number } = {};
        allTransactions.forEach(tx => {
            categories[tx.category] = (categories[tx.category] || 0) + tx.amount;
        });
        return Object.entries(categories).map(([name, value]) => ({ name, value }));
    }, [allTransactions]);

    const spendingByCardholder = useMemo(() => {
        const cardholders: { [key: string]: number } = {};
        corporateCards.forEach(card => {
            cardholders[card.holderName] = card.transactions.reduce((sum, tx) => sum + tx.amount, 0);
        });
        return Object.entries(cardholders).map(([name, value]) => ({ name, value }));
    }, [corporateCards]);

    const monthlySpendingTrends = useMemo(() => {
        const monthlyData: { [key: string]: number } = {};
        allTransactions.forEach(tx => {
            const date = new Date(tx.date);
            const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
            monthlyData[monthYear] = (monthlyData[monthYear] || 0) + tx.amount;
        });

        return Object.entries(monthlyData)
            .map(([monthYear, spent]) => {
                const [year, month] = monthYear.split('-').map(Number);
                return { date: new Date(year, month - 1), spent };
            })
            .sort((a, b) => a.date.getTime() - b.date.getTime())
            .map(item => ({ name: formatDate(item.date, { month: 'short', year: 'numeric' }), spent: item.spent }));
    }, [allTransactions]);

    const spendingBreakdownByBudget = useMemo(() => {
        const budgetSpent: { [key: string]: number } = {};
        advancedData.budgets.forEach(budget => {
            budgetSpent[budget.name] = budget.spentAmount; // Using mock spent amount from budget
        });
        return Object.entries(budgetSpent).map(([name, value]) => ({ name, value }));
    }, [advancedData.budgets]);


    const [reportParams, setReportParams] = useState({
        reportType: 'Spending Overview',
        startDate: new Date(new Date().setMonth(new Date().getMonth() - 3)).toISOString().split('T')[0],
        endDate: new Date().toISOString().split('T')[0],
        cardId: '',
        category: '',
    });
    const [generatingReport, setGeneratingReport] = useState(false);
    const [generatedReport, setGeneratedReport] = useState<ComplianceReport | null>(null);

    const handleGenerateCustomReport = async () => {
        setGeneratingReport(true);
        setGeneratedReport(null);
        // In a real app, this would involve complex filtering and data aggregation server-side
        const report = await advancedActions.generateComplianceReport(reportParams);
        setGeneratedReport(report);
        setGeneratingReport(false);
        alert('Custom report generated!');
    };

    return (
        <div className="space-y-6">
            <h2 className="text-3xl font-bold text-white tracking-wider mb-6">Spending Analytics & Reports</h2>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <Card title="Spending by Category">
                    {spendingByCategory.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <PieChart>
                                <Pie data={spendingByCategory} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={100} label>
                                    {spendingByCategory.map((entry, index) => (
                                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                    ))}
                                </Pie>
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} />
                                <Legend />
                            </PieChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">No spending data to categorize.</div>
                    )}
                </Card>

                <Card title="Spending by Cardholder">
                    {spendingByCardholder.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <BarChart data={spendingByCardholder} margin={{ top: 5, right: 20, left: -10, bottom: 5 }}>
                                <XAxis dataKey="name" stroke="#9ca3af" fontSize={12} />
                                <YAxis stroke="#9ca3af" tickFormatter={(value) => formatCurrency(value, 'USD', 'en-US')} />
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} formatter={(value: number) => formatCurrency(value, 'USD', 'en-US')} />
                                <Bar dataKey="value" fill="#67e8f9" name="Amount Spent" />
                            </BarChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">No cardholder spending data.</div>
                    )}
                </Card>

                <Card title="Monthly Spending Trend (All Cards)">
                    {monthlySpendingTrends.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <LineChart data={monthlySpendingTrends} margin={{ top: 5, right: 30, left: 0, bottom: 5 }}>
                                <XAxis dataKey="name" stroke="#9ca3af" fontSize={12} />
                                <YAxis stroke="#9ca3af" tickFormatter={(value) => formatCurrency(value, 'USD', 'en-US')} />
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} formatter={(value: number) => formatCurrency(value, 'USD', 'en-US')} />
                                <Legend />
                                <Line type="monotone" dataKey="spent" stroke="#06b6d4" activeDot={{ r: 8 }} />
                            </LineChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">Not enough historical data for trend analysis.</div>
                    )}
                </Card>

                <Card title="Spending vs. Budget Allocation">
                    {spendingBreakdownByBudget.length > 0 ? (
                        <ResponsiveContainer width="100%" height={300}>
                            <BarChart data={spendingBreakdownByBudget} margin={{ top: 5, right: 20, left: -10, bottom: 5 }}>
                                <XAxis dataKey="name" stroke="#9ca3af" fontSize={12} />
                                <YAxis stroke="#9ca3af" tickFormatter={(value) => formatCurrency(value, 'USD', 'en-US')} />
                                <Tooltip contentStyle={{ backgroundColor: 'rgba(31, 41, 55, 0.8)', borderColor: '#4b5563' }} formatter={(value: number) => formatCurrency(value, 'USD', 'en-US')} />
                                <Bar dataKey="value" fill="#8b5cf6" name="Budget Spent" />
                            </BarChart>
                        </ResponsiveContainer>
                    ) : (
                        <div className="text-gray-400 text-center py-4">No budget data available.</div>
                    )}
                </Card>
            </div>

            <Card title="Custom Report Generator">
                <div className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <label className="form-control">
                            <span className="label-text text-gray-300">Report Type</span>
                            <select
                                className="select select-bordered bg-gray-700 text-white border-gray-600"
                                value={reportParams.reportType}
                                onChange={(e) => setReportParams(prev => ({ ...prev, reportType: e.target.value }))}
                            >
                                <option>Spending Overview</option>
                                <option>Transaction Details</option>
                                <option>Category Breakdown</option>
                                <option>Cardholder Performance</option>
                                <option>Policy Compliance</option>
                            </select>
                        </label>
                        <label className="form-control">
                            <span className="label-text text-gray-300">Start Date</span>
                            <input
                                type="date"
                                className="input input-bordered bg-gray-700 text-white border-gray-600"
                                value={reportParams.startDate}
                                onChange={(e) => setReportParams(prev => ({ ...prev, startDate: e.target.value }))}
                            />
                        </label>
                        <label className="form-control">
                            <span className="label-text text-gray-300">End Date</span>
                            <input
                                type="date"
                                className="input input-bordered bg-gray-700 text-white border-gray-600"
                                value={reportParams.endDate}
                                onChange={(e) => setReportParams(prev => ({ ...prev, endDate: e.target.value }))}
                            />
                        </label>
                        <label className="form-control">
                            <span className="label-text text-gray-300">Specific Card (Optional)</span>
                            <select
                                className="select select-bordered bg-gray-700 text-white border-gray-600"
                                value={reportParams.cardId}
                                onChange={(e) => setReportParams(prev => ({ ...prev, cardId: e.target.value }))}
                            >
                                <option value="">All Cards</option>
                                {corporateCards.map(card => (
                                    <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                ))}
                            </select>
                        </label>
                        <label className="form-control">
                            <span className="label-text text-gray-300">Category (Optional)</span>
                            <select
                                className="select select-bordered bg-gray-700 text-white border-gray-600"
                                value={reportParams.category}
                                onChange={(e) => setReportParams(prev => ({ ...prev, category: e.target.value }))}
                            >
                                <option value="">All Categories</option>
                                {Array.from(new Set(allTransactions.map(tx => tx.category))).map(cat => (
                                    <option key={cat} value={cat}>{cat}</option>
                                ))}
                            </select>
                        </label>
                    </div>
                    <div className="mt-6">
                        <button
                            onClick={handleGenerateCustomReport}
                            className={`btn btn-cyan w-full ${generatingReport ? 'btn-disabled' : ''}`}
                            disabled={generatingReport}
                        >
                            {generatingReport && <span className="loading loading-spinner"></span>}
                            Generate Report
                        </button>
                    </div>
                    {generatedReport && (
                        <div className="mt-4 p-4 bg-gray-700 rounded-md">
                            <p className="text-white">Report Generated: <span className="font-semibold">{generatedReport.name}</span></p>
                            <p className="text-gray-400 text-sm">Status: <span className="text-green-400">{capitalizeFirstLetter(generatedReport.status)}</span></p>
                            {generatedReport.downloadUrl && (
                                <a href={generatedReport.downloadUrl} target="_blank" rel="noopener noreferrer" className="btn btn-sm btn-outline btn-info mt-2">
                                    Download Report
                                </a>
                            )}
                        </div>
                    )}
                </div>
            </Card>
        </div>
    );
};

export const PolicyEnforcementPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("PolicyEnforcementPanel must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = useContext(DataContext)!;

    const [isPolicyModalOpen, setIsPolicyModalOpen] = useState(false);
    const [editingPolicy, setEditingPolicy] = useState<PolicyRule | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const initialPolicyFormState: PolicyRule = {
        id: '',
        name: '',
        description: '',
        type: 'limit',
        isActive: true,
        priority: 1,
        configuration: {},
        appliesTo: 'all_cards',
        targetIds: [],
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingPolicy || initialPolicyFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.name) newErrors.name = 'Policy name is required.';
        if (!vals.description) newErrors.description = 'Description is required.';
        if (vals.appliesTo !== 'all_cards' && (vals.targetIds === undefined || vals.targetIds.length === 0)) newErrors.targetIds = 'Please select at least one target for this policy.';

        // Specific validation for each policy type
        if (vals.type === 'limit' && (!vals.configuration.monthlyLimit || vals.configuration.monthlyLimit <= 0)) newErrors.monthlyLimit = 'Monthly limit must be positive.';
        if (vals.type === 'category_block' && (!vals.configuration.blockedMcc || vals.configuration.blockedMcc.length === 0)) newErrors.blockedMcc = 'At least one category must be blocked.';

        return newErrors;
    });

    useEffect(() => {
        setValues(editingPolicy || initialPolicyFormState);
    }, [editingPolicy]);

    const onSubmitPolicy = async (formValues: PolicyRule) => {
        setIsLoading(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        if (formValues.id) {
            advancedActions.updatePolicyRule(formValues.id, formValues);
        } else {
            advancedActions.addPolicyRule(formValues);
        }
        setIsLoading(false);
        setIsPolicyModalOpen(false);
        setEditingPolicy(null);
        setValues(initialPolicyFormState); // Reset form
        alert(`Policy ${formValues.id ? 'updated' : 'created'} successfully!`);
    };

    const handleEditPolicy = (policy: PolicyRule) => {
        setEditingPolicy(policy);
        setIsPolicyModalOpen(true);
    };

    const handleDeletePolicy = async (id: string) => {
        if (!confirm('Are you sure you want to delete this policy?')) return;
        setIsLoading(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deletePolicyRule(id);
        setIsLoading(false);
        alert('Policy deleted.');
    };

    const policyColumns = useMemo(() => [
        { header: 'Name', accessor: 'name' },
        { header: 'Description', accessor: 'description' },
        { header: 'Type', accessor: (p: PolicyRule) => capitalizeFirstLetter(p.type.replace(/_/g, ' ')) },
        { header: 'Applies To', accessor: (p: PolicyRule) => capitalizeFirstLetter(p.appliesTo.replace(/_/g, ' ')) },
        { header: 'Status', accessor: (p: PolicyRule) => (
            <span className={`badge ${p.isActive ? 'badge-success' : 'badge-warning'}`}>{p.isActive ? 'Active' : 'Inactive'}</span>
        )},
    ], []);

    const filterOptions = {
        type: {
            label: 'Type',
            options: [
                { value: 'limit', label: 'Limit' },
                { value: 'category_block', label: 'Category Block' },
                { value: 'time_restriction', label: 'Time Restriction' },
                { value: 'geo_restriction', label: 'Geo Restriction' },
                { value: 'transaction_approval', label: 'Transaction Approval' },
            ]
        },
        appliesTo: {
            label: 'Applies To',
            options: [
                { value: 'all_cards', label: 'All Cards' },
                { value: 'specific_cards', label: 'Specific Cards' },
                { value: 'specific_holders', label: 'Specific Holders' },
            ]
        },
        isActive: {
            label: 'Status',
            options: [
                { value: true, label: 'Active' },
                { value: false, label: 'Inactive' },
            ]
        }
    };

    return (
        <Card title="Policy Enforcement & Management">
            <div className="flex justify-end mb-6">
                <button onClick={() => { setEditingPolicy(null); setIsPolicyModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    New Policy Rule
                </button>
            </div>

            <PaginatedTable
                title="All Policy Rules"
                data={advancedData.policyRules}
                columns={policyColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'description', 'type', 'appliesTo']}
                filterOptions={filterOptions}
                emptyMessage="No policy rules configured."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditPolicy(item)} className="btn btn-xs btn-info">Edit</button>
                        <button onClick={() => handleDeletePolicy(item.id)} className="btn btn-xs btn-error">Delete</button>
                    </div>
                )}
            />

            {isPolicyModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsPolicyModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingPolicy ? 'Edit Policy Rule' : 'Create New Policy Rule'}</h3>
                        <form onSubmit={handleSubmit(onSubmitPolicy)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Policy Name</span>
                                <input type="text" name="name" value={values.name} onChange={handleChange} placeholder="e.g., Block Weekend Spending" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.name && <p className="text-error text-sm mt-1">{errors.name}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Description</span>
                                <textarea name="description" value={values.description} onChange={handleChange} placeholder="Briefly describe the policy." className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                                {errors.description && <p className="text-error text-sm mt-1">{errors.description}</p>}
                            </label>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Policy Type</span>
                                    <select name="type" value={values.type} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="limit">Spending Limit</option>
                                        <option value="category_block">Category Block</option>
                                        <option value="time_restriction">Time Restriction</option>
                                        <option value="geo_restriction">Geolocation Restriction</option>
                                        <option value="transaction_approval">Transaction Approval</option>
                                    </select>
                                </label>
                                <label className="form-control flex items-center justify-between flex-row pt-8">
                                    <span className="label-text text-gray-300">Is Active</span>
                                    <input type="checkbox" name="isActive" checked={values.isActive} onChange={handleChange} className="toggle toggle-cyan" />
                                </label>
                            </div>

                            {/* Configuration based on policy type */}
                            <div className="p-4 border border-gray-700 rounded-md bg-gray-700/50 space-y-3">
                                <h4 className="text-md font-semibold text-gray-300">Policy Configuration</h4>
                                {values.type === 'limit' && (
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Monthly Limit ({formatCurrency(values.configuration.monthlyLimit || 0)})</span>
                                        <input type="range" min="100" max="100000" step="100" name="configuration.monthlyLimit" value={values.configuration.monthlyLimit || 0}
                                            onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, monthlyLimit: +e.target.value } }))}
                                            className="range range-cyan range-xs" />
                                        {errors.monthlyLimit && <p className="text-error text-sm mt-1">{errors.monthlyLimit}</p>}
                                    </label>
                                )}
                                {values.type === 'category_block' && (
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Blocked Categories</span>
                                        <select multiple name="configuration.blockedMcc" value={values.configuration.blockedMcc || []}
                                            onChange={e => {
                                                const options = Array.from(e.target.options);
                                                const value = options.filter(option => option.selected).map(option => option.value);
                                                setValues(prev => ({ ...prev, configuration: { ...prev.configuration, blockedMcc: value } }));
                                            }}
                                            className="select select-bordered bg-gray-700 text-white border-gray-600 h-32"
                                        >
                                            {advancedData.merchantCategories.map(mc => (
                                                <option key={mc.id} value={mc.code}>{mc.name} ({mc.code})</option>
                                            ))}
                                        </select>
                                        {errors.blockedMcc && <p className="text-error text-sm mt-1">{errors.blockedMcc}</p>}
                                        <p className="text-xs text-gray-500 mt-1">Select categories to block for this policy.</p>
                                    </label>
                                )}
                                {values.type === 'time_restriction' && (
                                    <>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Start Time</span>
                                            <input type="time" name="configuration.startTime" value={values.configuration.startTime || '09:00'} onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, startTime: e.target.value } }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        </label>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">End Time</span>
                                            <input type="time" name="configuration.endTime" value={values.configuration.endTime || '17:00'} onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, endTime: e.target.value } }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        </label>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Days of Week (0=Sun, 6=Sat)</span>
                                            <input type="text" name="configuration.daysOfWeek" value={values.configuration.daysOfWeek?.join(',') || ''} onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, daysOfWeek: e.target.value.split(',').map(Number) } }))} placeholder="e.g., 1,2,3,4,5 for Mon-Fri" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        </label>
                                    </>
                                )}
                                {values.type === 'geo_restriction' && (
                                    <>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Allowed Countries (comma-separated ISO codes)</span>
                                            <input type="text" name="configuration.allowedCountries" value={values.configuration.allowedCountries?.join(',') || ''} onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, allowedCountries: e.target.value.split(',') } }))} placeholder="e.g., US,CA,GB" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        </label>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Blocked Countries (comma-separated ISO codes)</span>
                                            <input type="text" name="configuration.blockedCountries" value={values.configuration.blockedCountries?.join(',') || ''} onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, blockedCountries: e.target.value.split(',') } }))} placeholder="e.g., RU,IR" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                        </label>
                                    </>
                                )}
                                {values.type === 'transaction_approval' && (
                                    <>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Minimum Amount for Approval ({formatCurrency(values.configuration.minAmount || 0)})</span>
                                            <input type="range" min="10" max="5000" step="10" name="configuration.minAmount" value={values.configuration.minAmount || 0}
                                                onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, minAmount: +e.target.value } }))}
                                                className="range range-cyan range-xs" />
                                        </label>
                                        <label className="form-control">
                                            <span className="label-text text-gray-300">Approver Role</span>
                                            <select name="configuration.approverRole" value={values.configuration.approverRole || ''}
                                                onChange={e => setValues(prev => ({ ...prev, configuration: { ...prev.configuration, approverRole: e.target.value } }))}
                                                className="select select-bordered bg-gray-700 text-white border-gray-600"
                                            >
                                                <option value="">Select Role</option>
                                                {advancedData.userPermissionProfiles.map(profile => (
                                                    <option key={profile.id} value={profile.name}>{profile.name}</option>
                                                ))}
                                            </select>
                                        </label>
                                    </>
                                )}
                            </div>


                            <label className="form-control">
                                <span className="label-text text-gray-300">Applies To</span>
                                <select name="appliesTo" value={values.appliesTo} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="all_cards">All Corporate Cards</option>
                                    <option value="specific_cards">Specific Cards</option>
                                    <option value="specific_holders">Specific Cardholders</option>
                                </select>
                            </label>

                            {values.appliesTo !== 'all_cards' && (
                                <label className="form-control">
                                    <span className="label-text text-gray-300">{values.appliesTo === 'specific_cards' ? 'Select Cards' : 'Select Cardholders'}</span>
                                    <select multiple name="targetIds" value={values.targetIds || []}
                                        onChange={e => {
                                            const options = Array.from(e.target.options);
                                            const value = options.filter(option => option.selected).map(option => option.value);
                                            setValues(prev => ({ ...prev, targetIds: value }));
                                        }}
                                        className="select select-bordered bg-gray-700 text-white border-gray-600 h-32"
                                    >
                                        {values.appliesTo === 'specific_cards' ? (
                                            corporateCards.map(card => (
                                                <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                            ))
                                        ) : (
                                            MOCK_CARDHOLDERS.map(holder => (
                                                <option key={holder.id} value={holder.id}>{holder.name} ({holder.role})</option>
                                            ))
                                        )}
                                    </select>
                                    {errors.targetIds && <p className="text-error text-sm mt-1">{errors.targetIds}</p>}
                                </label>
                            )}

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsPolicyModalOpen(false)} disabled={isSubmitting || isLoading}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isLoading}>
                                    {(isSubmitting || isLoading) && <span className="loading loading-spinner"></span>}
                                    {editingPolicy ? 'Update Policy' : 'Create Policy'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const AuditTrailPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("AuditTrailPanel must be within AdvancedCardProvider");

    const { data: advancedData } = advancedContext;

    const auditLogColumns = useMemo(() => [
        { header: 'Timestamp', accessor: (log: AuditLogEntry) => formatDate(log.timestamp) },
        { header: 'Actor', accessor: (log: AuditLogEntry) => MOCK_CARDHOLDERS.find(h => h.id === log.actorId)?.name || 'System' },
        { header: 'Action', accessor: 'action' },
        { header: 'Target Type', accessor: 'targetType' },
        { header: 'Target ID', accessor: 'targetId', className: 'font-mono' },
        { header: 'Description', accessor: 'description' },
    ], []);

    const filterOptions = {
        targetType: {
            label: 'Target Type',
            options: [
                { value: 'card', label: 'Card' },
                { value: 'card_request', label: 'Card Request' },
                { value: 'policy', label: 'Policy' },
                { value: 'user', label: 'User' },
                { value: 'virtual_card', label: 'Virtual Card' },
            ]
        },
        action: {
            label: 'Action',
            options: Array.from(new Set(advancedData.auditLogs.map(log => log.action))).map(action => ({ value: action, label: action.replace(/_/g, ' ') }))
        },
    };

    return (
        <Card title="Audit Trail">
            <p className="text-gray-300 mb-4">A comprehensive log of all actions performed within the card management system, including who did what and when.</p>
            <PaginatedTable
                data={advancedData.auditLogs.sort((a,b) => b.timestamp.getTime() - a.timestamp.getTime())}
                columns={auditLogColumns}
                rowKeyExtractor={(log) => log.id}
                searchableKeys={['action', 'description', 'targetId']}
                filterOptions={filterOptions}
                itemsPerPage={10}
                emptyMessage="No audit log entries found."
            />
        </Card>
    );
};

export const VirtualCardCreator: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("VirtualCardCreator must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [editingVirtualCard, setEditingVirtualCard] = useState<VirtualCard | null>(null);

    const initialVirtualCardForm: Omit<VirtualCard, 'id' | 'cardNumberMask' | 'generationDate' | 'transactions'> = {
        holderName: MOCK_CARDHOLDERS[0].name, // Default to first mock holder
        purpose: 'Software Subscription',
        limit: 100,
        balance: 0,
        currency: 'USD',
        status: 'Active',
        frozen: false,
        isSingleUse: false,
        expiration: new Date(new Date().setFullYear(new Date().getFullYear() + 1)), // 1 year from now
        controls: { monthlyLimit: 100, atm: false, online: true, contactless: false },
        issueDate: new Date(),
        expirationDate: new Date(new Date().setFullYear(new Date().getFullYear() + 1)), // Redundant with 'expiration', keep for interface consistency
        type: 'Virtual',
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingVirtualCard || initialVirtualCardForm, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.holderName) newErrors.holderName = 'Holder name is required.';
        if (!vals.purpose) newErrors.purpose = 'Purpose is required.';
        if (!vals.limit || vals.limit <= 0) newErrors.limit = 'Limit must be positive.';
        if (new Date(vals.expiration).getTime() < Date.now()) newErrors.expiration = 'Expiration date must be in the future.';
        return newErrors;
    });

    useEffect(() => {
        setValues(editingVirtualCard || initialVirtualCardForm);
    }, [editingVirtualCard]);

    const onSubmitVirtualCard = async (formValues: typeof initialVirtualCardForm) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        const finalValues = {
            ...formValues,
            // Ensure dates are correctly formatted or handled for API
            expiration: new Date(formValues.expiration),
            issueDate: new Date(), // Always current date for new virtual cards
            expirationDate: new Date(formValues.expiration), // Match expiration
            status: formValues.frozen ? 'Frozen' : 'Active',
        };

        if (editingVirtualCard) {
            advancedActions.updateVirtualCard(editingVirtualCard.id, finalValues);
        } else {
            advancedActions.createVirtualCard(finalValues);
        }

        setIsSaving(false);
        setIsCreateModalOpen(false);
        setEditingVirtualCard(null);
        setValues(initialVirtualCardForm); // Reset form
        alert(`Virtual card ${editingVirtualCard ? 'updated' : 'created'} successfully!`);
    };

    const handleEditVirtualCard = (card: VirtualCard) => {
        setEditingVirtualCard(card);
        setIsCreateModalOpen(true);
    };

    const handleDeleteVirtualCard = async (id: string) => {
        if (!confirm('Are you sure you want to terminate this virtual card?')) return;
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deleteVirtualCard(id);
        setIsSaving(false);
        alert('Virtual card terminated.');
    };

    const handleToggleFreeze = async (cardId: string, currentFrozenStatus: boolean) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.updateVirtualCard(cardId, { frozen: !currentFrozenStatus, status: !currentFrozenStatus ? 'Frozen' : 'Active' });
        setIsSaving(false);
    };

    const virtualCardColumns = useMemo(() => [
        { header: 'Holder', accessor: 'holderName' },
        { header: 'Purpose', accessor: 'purpose' },
        { header: 'Number', accessor: 'cardNumberMask', className: 'font-mono' },
        { header: 'Limit', accessor: (vc: VirtualCard) => formatCurrency(vc.limit) },
        { header: 'Balance', accessor: (vc: VirtualCard) => formatCurrency(vc.balance) },
        { header: 'Expires', accessor: (vc: VirtualCard) => formatDate(new Date(vc.expiration), { year: 'numeric', month: 'short', day: 'numeric' }) },
        { header: 'Status', accessor: (vc: VirtualCard) => (
            <span className={`badge ${
                vc.status === 'Active' ? 'badge-success' :
                vc.status === 'Frozen' ? 'badge-info' :
                vc.status === 'Expired' ? 'badge-warning' : 'badge-neutral'
            }`}>
                {vc.status}
            </span>
        )},
    ], []);

    const filterOptions = {
        status: {
            label: 'Status',
            options: [
                { value: 'Active', label: 'Active' },
                { value: 'Frozen', label: 'Frozen' },
                { value: 'Expired', label: 'Expired' },
            ]
        },
        isSingleUse: {
            label: 'Type',
            options: [
                { value: true, label: 'Single-Use' },
                { value: false, label: 'Multi-Use' },
            ]
        }
    };

    return (
        <Card title="Virtual Card Management">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Generate and manage virtual cards for secure, specific spending needs.</p>
                <button onClick={() => { setEditingVirtualCard(null); setIsCreateModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    Create Virtual Card
                </button>
            </div>

            <PaginatedTable
                title="Active Virtual Cards"
                data={advancedData.virtualCards.sort((a,b) => b.generationDate.getTime() - a.generationDate.getTime())}
                columns={virtualCardColumns}
                rowKeyExtractor={(vc) => vc.id}
                searchableKeys={['holderName', 'purpose', 'cardNumberMask']}
                filterOptions={filterOptions}
                emptyMessage="No virtual cards created yet."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleToggleFreeze(item.id, item.frozen)} className={`btn btn-xs ${item.frozen ? 'btn-info' : 'btn-warning'}`}>
                            {item.frozen ? 'Unfreeze' : 'Freeze'}
                        </button>
                        <button onClick={() => handleEditVirtualCard(item)} className="btn btn-xs btn-outline btn-primary">Edit</button>
                        <button onClick={() => handleDeleteVirtualCard(item.id)} className="btn btn-xs btn-error">Terminate</button>
                    </div>
                )}
            />

            {isCreateModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsCreateModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingVirtualCard ? 'Edit Virtual Card' : 'Create New Virtual Card'}</h3>
                        <form onSubmit={handleSubmit(onSubmitVirtualCard)} className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Card Holder Name</span>
                                    <input type="text" name="holderName" value={values.holderName} onChange={handleChange} placeholder="Virtual Card User" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.holderName && <p className="text-error text-sm mt-1">{errors.holderName}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Purpose / Project</span>
                                    <input type="text" name="purpose" value={values.purpose} onChange={handleChange} placeholder="e.g., Q3 Marketing Campaign" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.purpose && <p className="text-error text-sm mt-1">{errors.purpose}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Limit ({formatCurrency(values.limit)})</span>
                                    <input type="range" min="10" max="10000" step="10" name="limit" value={values.limit} onChange={handleChange} className="range range-cyan range-xs" />
                                    {errors.limit && <p className="text-error text-sm mt-1">{errors.limit}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Expiration Date</span>
                                    <input type="date" name="expiration" value={new Date(values.expiration).toISOString().split('T')[0]} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.expiration && <p className="text-error text-sm mt-1">{errors.expiration}</p>}
                                </label>
                                <label className="form-control flex items-center justify-between flex-row pt-8">
                                    <span className="label-text text-gray-300">Single Use Card</span>
                                    <input type="checkbox" name="isSingleUse" checked={values.isSingleUse} onChange={handleChange} className="toggle toggle-cyan" />
                                </label>
                                <label className="form-control flex items-center justify-between flex-row pt-8">
                                    <span className="label-text text-gray-300">Frozen on Creation</span>
                                    <input type="checkbox" name="frozen" checked={values.frozen} onChange={handleChange} className="toggle toggle-cyan" />
                                </label>
                            </div>

                            <label className="form-control">
                                <span className="label-text text-gray-300">Link to Physical Card (Optional)</span>
                                <select name="parentCardId" value={values.parentCardId || ''} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="">No parent card</option>
                                    {corporateCards.map(card => (
                                        <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                    ))}
                                </select>
                                <p className="text-xs text-gray-500 mt-1">If linked, funds might be drawn from the parent card's budget/limit, or inherit some controls.</p>
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsCreateModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    {editingVirtualCard ? 'Update Virtual Card' : 'Create Virtual Card'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const UserPermissionsPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("UserPermissionsPanel must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [isRoleModalOpen, setIsRoleModalOpen] = useState(false);
    const [editingRole, setEditingRole] = useState<UserPermissionProfile | null>(null);
    const [isSaving, setIsSaving] = useState(false);

    const initialRoleFormState: UserPermissionProfile = {
        id: '', name: '', description: '',
        permissions: {
            canViewAllCards: false, canManageOwnCards: false, canManageTeamCards: false,
            canManageAllCards: false, canCreateCards: false, canApproveRequests: false,
            canManagePolicies: false, canViewAuditLogs: false, canManageUserPermissions: false,
            canAccessReporting: false, canManageIntegrations: false,
        }
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingRole || initialRoleFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.name) newErrors.name = 'Role name is required.';
        if (!vals.description) newErrors.description = 'Description is required.';
        return newErrors;
    });

    useEffect(() => {
        setValues(editingRole || initialRoleFormState);
    }, [editingRole]);

    const onSubmitRole = async (formValues: UserPermissionProfile) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        if (formValues.id) {
            advancedActions.updateUserPermissionProfile(formValues.id, formValues);
        } else {
            advancedActions.addUserPermissionProfile(formValues);
        }
        setIsSaving(false);
        setIsRoleModalOpen(false);
        setEditingRole(null);
        setValues(initialRoleFormState);
        alert(`Role ${formValues.id ? 'updated' : 'created'} successfully!`);
    };

    const handleEditRole = (role: UserPermissionProfile) => {
        setEditingRole(role);
        setIsRoleModalOpen(true);
    };

    const handleDeleteRole = async (id: string) => {
        if (!confirm('Are you sure you want to delete this role? This cannot be undone.')) return;
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deleteUserPermissionProfile(id);
        setIsSaving(false);
        alert('Role deleted.');
    };

    const permissionNames: Array<{ key: keyof UserPermissionProfile['permissions']; label: string }> = [
        { key: 'canViewAllCards', label: 'View All Cards' },
        { key: 'canManageOwnCards', label: 'Manage Own Cards' },
        { key: 'canManageTeamCards', label: 'Manage Team Cards' },
        { key: 'canManageAllCards', label: 'Manage All Cards' },
        { key: 'canCreateCards', label: 'Create New Cards' },
        { key: 'canApproveRequests', label: 'Approve Card Requests' },
        { key: 'canManagePolicies', label: 'Manage Policies' },
        { key: 'canViewAuditLogs', label: 'View Audit Logs' },
        { key: 'canManageUserPermissions', label: 'Manage User Permissions' },
        { key: 'canAccessReporting', label: 'Access Advanced Reporting' },
        { key: 'canManageIntegrations', label: 'Manage Integrations' },
    ];

    const roleColumns = useMemo(() => [
        { header: 'Role Name', accessor: 'name' },
        { header: 'Description', accessor: 'description' },
        { header: 'Permissions', accessor: (role: UserPermissionProfile) => (
            <div className="flex flex-wrap gap-1">
                {permissionNames.filter(p => role.permissions[p.key]).map(p => (
                    <span key={p.key} className="badge badge-outline badge-info badge-xs">{p.label.replace('Can ', '')}</span>
                ))}
            </div>
        ) },
    ], [permissionNames]);

    return (
        <Card title="User Roles & Permissions">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Define and manage user roles and their associated permissions for card management features.</p>
                <button onClick={() => { setEditingRole(null); setIsRoleModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    New Role
                </button>
            </div>

            <PaginatedTable
                title="Configured User Roles"
                data={advancedData.userPermissionProfiles}
                columns={roleColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'description']}
                emptyMessage="No user roles configured yet."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditRole(item)} className="btn btn-xs btn-info">Edit</button>
                        <button onClick={() => handleDeleteRole(item.id)} className="btn btn-xs btn-error">Delete</button>
                    </div>
                )}
            />

            {isRoleModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsRoleModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingRole ? 'Edit User Role' : 'Create New User Role'}</h3>
                        <form onSubmit={handleSubmit(onSubmitRole)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Role Name</span>
                                <input type="text" name="name" value={values.name} onChange={handleChange} placeholder="e.g., Finance Manager" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.name && <p className="text-error text-sm mt-1">{errors.name}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Description</span>
                                <textarea name="description" value={values.description} onChange={handleChange} placeholder="Describe the responsibilities of this role." className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                                {errors.description && <p className="text-error text-sm mt-1">{errors.description}</p>}
                            </label>

                            <div className="divider"></div>
                            <h4 className="text-lg font-semibold text-cyan-300">Permissions</h4>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2">
                                {permissionNames.map(p => (
                                    <label key={p.key} className="flex items-center justify-between">
                                        <span className="text-sm text-gray-300">{p.label}</span>
                                        <input
                                            type="checkbox"
                                            name={`permissions.${p.key}`}
                                            checked={values.permissions[p.key]}
                                            onChange={e => setValues(prev => ({ ...prev, permissions: { ...prev.permissions, [p.key]: e.target.checked } }))}
                                            className="toggle toggle-cyan"
                                        />
                                    </label>
                                ))}
                            </div>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsRoleModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    {editingRole ? 'Update Role' : 'Create Role'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const AlertSettingsPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("AlertSettingsPanel must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
    const [editingAlert, setEditingAlert] = useState<AlertConfiguration | null>(null);
    const [isSaving, setIsSaving] = useState(false);

    const initialAlertFormState: AlertConfiguration = {
        id: '', name: '', description: '', type: 'spending_threshold', isActive: true, channels: ['email'],
        threshold: 100, period: 'monthly', targetCards: [], targetUsers: [MOCK_CARDHOLDERS[0].id]
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingAlert || initialAlertFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.name) newErrors.name = 'Alert name is required.';
        if (!vals.description) newErrors.description = 'Description is required.';
        if (vals.channels.length === 0) newErrors.channels = 'At least one notification channel is required.';
        if ((vals.type === 'spending_threshold' || vals.type === 'low_balance') && (!vals.threshold || vals.threshold <= 0)) newErrors.threshold = 'Threshold must be positive.';
        return newErrors;
    });

    useEffect(() => {
        setValues(editingAlert || initialAlertFormState);
    }, [editingAlert]);

    const onSubmitAlert = async (formValues: AlertConfiguration) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        if (formValues.id) {
            advancedActions.updateAlertConfiguration(formValues.id, formValues);
        } else {
            advancedActions.addAlertConfiguration(formValues);
        }
        setIsSaving(false);
        setIsAlertModalOpen(false);
        setEditingAlert(null);
        setValues(initialAlertFormState);
        alert(`Alert ${formValues.id ? 'updated' : 'created'} successfully!`);
    };

    const handleEditAlert = (alert: AlertConfiguration) => {
        setEditingAlert(alert);
        setIsAlertModalOpen(true);
    };

    const handleDeleteAlert = async (id: string) => {
        if (!confirm('Are you sure you want to delete this alert?')) return;
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deleteAlertConfiguration(id);
        setIsSaving(false);
        alert('Alert deleted.');
    };

    const handleChannelToggle = (channel: 'email' | 'slack' | 'sms') => {
        setValues(prev => {
            const currentChannels = prev.channels || [];
            const newChannels = currentChannels.includes(channel)
                ? currentChannels.filter(c => c !== channel)
                : [...currentChannels, channel];
            return { ...prev, channels: newChannels };
        });
    };

    const alertColumns = useMemo(() => [
        { header: 'Name', accessor: 'name' },
        { header: 'Type', accessor: (a: AlertConfiguration) => capitalizeFirstLetter(a.type.replace(/_/g, ' ')) },
        { header: 'Description', accessor: 'description' },
        { header: 'Threshold', accessor: (a: AlertConfiguration) => a.threshold ? formatCurrency(a.threshold) : 'N/A' },
        { header: 'Channels', accessor: (a: AlertConfiguration) => (
            <div className="flex flex-wrap gap-1">
                {a.channels.map(channel => (
                    <span key={channel} className="badge badge-outline badge-primary badge-xs">{capitalizeFirstLetter(channel)}</span>
                ))}
            </div>
        )},
        { header: 'Status', accessor: (a: AlertConfiguration) => (
            <span className={`badge ${a.isActive ? 'badge-success' : 'badge-warning'}`}>{a.isActive ? 'Active' : 'Inactive'}</span>
        )},
    ], []);

    const filterOptions = {
        type: {
            label: 'Type',
            options: [
                { value: 'spending_threshold', label: 'Spending Threshold' },
                { value: 'unusual_transaction', label: 'Unusual Transaction' },
                { value: 'policy_violation', label: 'Policy Violation' },
                { value: 'card_status_change', label: 'Card Status Change' },
                { value: 'low_balance', label: 'Low Balance' },
            ]
        },
        isActive: {
            label: 'Status',
            options: [
                { value: true, label: 'Active' },
                { value: false, label: 'Inactive' },
            ]
        }
    };

    return (
        <Card title="Alerts & Notifications">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Configure real-time alerts for critical card activities and spending patterns.</p>
                <button onClick={() => { setEditingAlert(null); setIsAlertModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    New Alert
                </button>
            </div>

            <PaginatedTable
                title="Configured Alerts"
                data={advancedData.alertConfigurations}
                columns={alertColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'description', 'type']}
                filterOptions={filterOptions}
                emptyMessage="No alerts configured yet."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditAlert(item)} className="btn btn-xs btn-info">Edit</button>
                        <button onClick={() => handleDeleteAlert(item.id)} className="btn btn-xs btn-error">Delete</button>
                    </div>
                )}
            />

            {isAlertModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsAlertModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingAlert ? 'Edit Alert Configuration' : 'Create New Alert'}</h3>
                        <form onSubmit={handleSubmit(onSubmitAlert)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Alert Name</span>
                                <input type="text" name="name" value={values.name} onChange={handleChange} placeholder="e.g., High Spending Alert" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.name && <p className="text-error text-sm mt-1">{errors.name}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Description</span>
                                <textarea name="description" value={values.description} onChange={handleChange} placeholder="What should this alert notify about?" className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                                {errors.description && <p className="text-error text-sm mt-1">{errors.description}</p>}
                            </label>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Alert Type</span>
                                    <select name="type" value={values.type} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="spending_threshold">Spending Threshold Exceeded</option>
                                        <option value="unusual_transaction">Unusual Transaction Detected</option>
                                        <option value="policy_violation">Policy Violation</option>
                                        <option value="card_status_change">Card Status Change (e.g., Freeze)</option>
                                        <option value="low_balance">Low Card Balance</option>
                                    </select>
                                </label>
                                <label className="form-control flex items-center justify-between flex-row pt-8">
                                    <span className="label-text text-gray-300">Is Active</span>
                                    <input type="checkbox" name="isActive" checked={values.isActive} onChange={handleChange} className="toggle toggle-cyan" />
                                </label>
                            </div>

                            {(values.type === 'spending_threshold' || values.type === 'low_balance') && (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Threshold Amount ({formatCurrency(values.threshold || 0)})</span>
                                        <input type="range" min="10" max="5000" step="10" name="threshold" value={values.threshold || 0} onChange={handleChange} className="range range-cyan range-xs" />
                                        {errors.threshold && <p className="text-error text-sm mt-1">{errors.threshold}</p>}
                                    </label>
                                    <label className="form-control">
                                        <span className="label-text text-gray-300">Monitoring Period</span>
                                        <select name="period" value={values.period} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                            <option value="transaction">Per Transaction</option>
                                            <option value="daily">Daily</option>
                                            <option value="weekly">Weekly</option>
                                            <option value="monthly">Monthly</option>
                                        </select>
                                    </label>
                                </div>
                            )}

                            <label className="form-control">
                                <span className="label-text text-gray-300">Target Cards (Optional)</span>
                                <select multiple name="targetCards" value={values.targetCards || []}
                                    onChange={e => {
                                        const options = Array.from(e.target.options);
                                        const value = options.filter(option => option.selected).map(option => option.value);
                                        setValues(prev => ({ ...prev, targetCards: value }));
                                    }}
                                    className="select select-bordered bg-gray-700 text-white border-gray-600 h-24"
                                >
                                    {corporateCards.map(card => (
                                        <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                    ))}
                                </select>
                                <p className="text-xs text-gray-500 mt-1">If no cards selected, alert applies to all cards.</p>
                            </label>

                            <label className="form-control">
                                <span className="label-text text-gray-300">Notify Users</span>
                                <select multiple name="targetUsers" value={values.targetUsers || []}
                                    onChange={e => {
                                        const options = Array.from(e.target.options);
                                        const value = options.filter(option => option.selected).map(option => option.value);
                                        setValues(prev => ({ ...prev, targetUsers: value }));
                                    }}
                                    className="select select-bordered bg-gray-700 text-white border-gray-600 h-24"
                                >
                                    {MOCK_CARDHOLDERS.map(user => (
                                        <option key={user.id} value={user.id}>{user.name} ({user.role})</option>
                                    ))}
                                </select>
                                <p className="text-xs text-gray-500 mt-1">Select users to receive this notification.</p>
                            </label>

                            <label className="form-control">
                                <span className="label-text text-gray-300">Notification Channels</span>
                                <div className="flex flex-wrap gap-4 mt-2">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={values.channels.includes('email')} onChange={() => handleChannelToggle('email')} className="checkbox checkbox-cyan" />
                                        <span className="text-white">Email</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={values.channels.includes('slack')} onChange={() => handleChannelToggle('slack')} className="checkbox checkbox-cyan" />
                                        <span className="text-white">Slack</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={values.channels.includes('sms')} onChange={() => handleChannelToggle('sms')} className="checkbox checkbox-cyan" />
                                        <span className="text-white">SMS</span>
                                    </label>
                                </div>
                                {errors.channels && <p className="text-error text-sm mt-1">{errors.channels}</p>}
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsAlertModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    {editingAlert ? 'Update Alert' : 'Create Alert'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const MerchantCategoryControlPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("MerchantCategoryControlPanel must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [isSaving, setIsSaving] = useState(false);
    const [localCategories, setLocalCategories] = useState<MerchantCategory[]>(advancedData.merchantCategories);

    useEffect(() => {
        setLocalCategories(advancedData.merchantCategories);
    }, [advancedData.merchantCategories]);

    const handleToggleBlockedByDefault = (id: string) => {
        setLocalCategories(prev =>
            prev.map(cat =>
                cat.id === id ? { ...cat, blockedByDefault: !cat.blockedByDefault } : cat
            )
        );
    };

    const handleSaveAllChanges = async () => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate API call
        localCategories.forEach(cat => {
            const original = advancedData.merchantCategories.find(oc => oc.id === cat.id);
            if (original && original.blockedByDefault !== cat.blockedByDefault) {
                advancedActions.updateMerchantCategory(cat.id, { blockedByDefault: cat.blockedByDefault });
            }
        });
        setIsSaving(false);
        alert('Merchant Category settings updated globally.');
    };

    const categoryColumns = useMemo(() => [
        { header: 'Category Name', accessor: 'name' },
        { header: 'MCC Code', accessor: 'code', className: 'font-mono' },
        { header: 'Description', accessor: 'description' },
        { header: 'Blocked by Default', accessor: (cat: MerchantCategory) => (
            <input
                type="checkbox"
                className="toggle toggle-cyan"
                checked={cat.blockedByDefault}
                onChange={() => handleToggleBlockedByDefault(cat.id)}
            />
        )},
    ], []);

    return (
        <Card title="Merchant Category Controls">
            <p className="text-gray-300 mb-6">
                Manage global settings for Merchant Category Codes (MCCs). Mark categories to be blocked by default for all new cards,
                or as a default suggestion for existing cards, improving compliance and reducing unwanted spending.
            </p>

            <PaginatedTable
                title="Configured Merchant Categories"
                data={localCategories}
                columns={categoryColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'code', 'description']}
                emptyMessage="No merchant categories defined."
                itemsPerPage={10}
            />

            <div className="mt-6 flex justify-end">
                <button
                    onClick={handleSaveAllChanges}
                    className={`btn btn-cyan ${isSaving ? 'btn-disabled' : ''}`}
                    disabled={isSaving}
                >
                    {isSaving && <span className="loading loading-spinner"></span>}
                    Save Global Category Settings
                </button>
            </div>
        </Card>
    );
};

export const RecurringSubscriptionView: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("RecurringSubscriptionView must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isSubscriptionModalOpen, setIsSubscriptionModalOpen] = useState(false);
    const [editingSubscription, setEditingSubscription] = useState<Subscription | null>(null);
    const [isSaving, setIsSaving] = useState(false);

    const initialSubscriptionFormState: Omit<Subscription, 'id'> = {
        cardId: corporateCards[0]?.id || '', // Default to first card if available
        merchantName: '',
        amount: 50,
        currency: 'USD',
        billingCycle: 'monthly',
        nextBillingDate: new Date(new Date().setMonth(new Date().getMonth() + 1)),
        status: 'active',
        category: 'Software',
        startDate: new Date(),
        notes: '',
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingSubscription || initialSubscriptionFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.cardId) newErrors.cardId = 'Card is required.';
        if (!vals.merchantName) newErrors.merchantName = 'Merchant name is required.';
        if (!vals.amount || vals.amount <= 0) newErrors.amount = 'Amount must be positive.';
        if (new Date(vals.nextBillingDate).getTime() < Date.now()) newErrors.nextBillingDate = 'Next billing date must be in the future.';
        return newErrors;
    });

    useEffect(() => {
        setValues(editingSubscription || initialSubscriptionFormState);
    }, [editingSubscription]);

    const onSubmitSubscription = async (formValues: Omit<Subscription, 'id'>) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        const finalValues = {
            ...formValues,
            nextBillingDate: new Date(formValues.nextBillingDate),
            startDate: new Date(formValues.startDate || new Date()),
        };
        if (editingSubscription) {
            advancedActions.updateSubscription(editingSubscription.id, finalValues);
        } else {
            advancedActions.addSubscription(finalValues);
        }
        setIsSaving(false);
        setIsSubscriptionModalOpen(false);
        setEditingSubscription(null);
        setValues(initialSubscriptionFormState);
        alert(`Subscription ${editingSubscription ? 'updated' : 'added'} successfully!`);
    };

    const handleEditSubscription = (sub: Subscription) => {
        setEditingSubscription(sub);
        setIsSubscriptionModalOpen(true);
    };

    const handleDeleteSubscription = async (id: string) => {
        if (!confirm('Are you sure you want to delete this subscription record?')) return;
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deleteSubscription(id);
        setIsSaving(false);
        alert('Subscription record deleted.');
    };

    const subscriptionColumns = useMemo(() => [
        { header: 'Merchant', accessor: 'merchantName' },
        { header: 'Card', accessor: (sub: Subscription) => corporateCards.find(c => c.id === sub.cardId)?.holderName || 'N/A' },
        { header: 'Amount', accessor: (sub: Subscription) => formatCurrency(sub.amount, sub.currency) },
        { header: 'Billing Cycle', accessor: 'billingCycle' },
        { header: 'Next Billing', accessor: (sub: Subscription) => formatDate(new Date(sub.nextBillingDate), { year: 'numeric', month: 'short', day: 'numeric' }) },
        { header: 'Status', accessor: (sub: Subscription) => (
            <span className={`badge ${
                sub.status === 'active' ? 'badge-success' :
                sub.status === 'cancelled' ? 'badge-error' : 'badge-warning'
            }`}>
                {capitalizeFirstLetter(sub.status)}
            </span>
        )},
    ], [corporateCards]);

    const filterOptions = {
        status: {
            label: 'Status',
            options: [
                { value: 'active', label: 'Active' },
                { value: 'cancelled', label: 'Cancelled' },
                { value: 'paused', label: 'Paused' },
            ]
        },
        billingCycle: {
            label: 'Billing Cycle',
            options: [
                { value: 'monthly', label: 'Monthly' },
                { value: 'annually', label: 'Annually' },
                { value: 'quarterly', label: 'Quarterly' },
            ]
        },
    };

    return (
        <Card title="Recurring Subscriptions & Bills">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Track and manage all recurring charges on corporate cards.</p>
                <button onClick={() => { setEditingSubscription(null); setIsSubscriptionModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    Add Subscription
                </button>
            </div>

            <PaginatedTable
                title="All Tracked Subscriptions"
                data={advancedData.subscriptions.sort((a,b) => b.nextBillingDate.getTime() - a.nextBillingDate.getTime())}
                columns={subscriptionColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['merchantName', 'category', 'notes']}
                filterOptions={filterOptions}
                emptyMessage="No recurring subscriptions tracked."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditSubscription(item)} className="btn btn-xs btn-info">Edit</button>
                        <button onClick={() => handleDeleteSubscription(item.id)} className="btn btn-xs btn-error">Delete</button>
                    </div>
                )}
            />

            {isSubscriptionModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsSubscriptionModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingSubscription ? 'Edit Subscription' : 'Add New Subscription'}</h3>
                        <form onSubmit={handleSubmit(onSubmitSubscription)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Linked Card</span>
                                <select name="cardId" value={values.cardId} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="">Select a Card</option>
                                    {corporateCards.map(card => (
                                        <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                    ))}
                                </select>
                                {errors.cardId && <p className="text-error text-sm mt-1">{errors.cardId}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Merchant Name</span>
                                <input type="text" name="merchantName" value={values.merchantName} onChange={handleChange} placeholder="e.g., Zoom Inc." className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.merchantName && <p className="text-error text-sm mt-1">{errors.merchantName}</p>}
                            </label>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Amount ({formatCurrency(values.amount, values.currency)})</span>
                                    <input type="number" min="1" step="0.01" name="amount" value={values.amount} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.amount && <p className="text-error text-sm mt-1">{errors.amount}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Billing Cycle</span>
                                    <select name="billingCycle" value={values.billingCycle} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="monthly">Monthly</option>
                                        <option value="quarterly">Quarterly</option>
                                        <option value="annually">Annually</option>
                                    </select>
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Next Billing Date</span>
                                    <input type="date" name="nextBillingDate" value={new Date(values.nextBillingDate).toISOString().split('T')[0]} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.nextBillingDate && <p className="text-error text-sm mt-1">{errors.nextBillingDate}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Status</span>
                                    <select name="status" value={values.status} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="active">Active</option>
                                        <option value="cancelled">Cancelled</option>
                                        <option value="paused">Paused</option>
                                    </select>
                                </label>
                            </div>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Category</span>
                                <input type="text" name="category" value={values.category} onChange={handleChange} placeholder="e.g., Software, Marketing" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Notes (Optional)</span>
                                <textarea name="notes" value={values.notes} onChange={handleChange} placeholder="Any specific details about this subscription." className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsSubscriptionModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    {editingSubscription ? 'Update Subscription' : 'Add Subscription'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};


export const BudgetAllocationView: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("BudgetAllocationView must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isBudgetModalOpen, setIsBudgetModalOpen] = useState(false);
    const [editingBudget, setEditingBudget] = useState<Budget | null>(null);
    const [isSaving, setIsSaving] = useState(false);

    const initialBudgetFormState: Omit<Budget, 'id' | 'allocatedAmount' | 'spentAmount'> = {
        name: '',
        period: 'monthly',
        totalAmount: 5000,
        startDate: new Date(),
        endDate: new Date(new Date().setMonth(new Date().getMonth() + 1)), // Default to 1 month ahead
        cardsLinked: [],
        departmentId: 'dept-1', // Default
        projectId: '',
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingBudget ? { ...editingBudget, startDate: new Date(editingBudget.startDate), endDate: new Date(editingBudget.endDate) } : initialBudgetFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.name) newErrors.name = 'Budget name is required.';
        if (!vals.totalAmount || vals.totalAmount <= 0) newErrors.totalAmount = 'Total amount must be positive.';
        if (new Date(vals.endDate).getTime() <= new Date(vals.startDate).getTime()) newErrors.endDate = 'End date must be after start date.';
        return newErrors;
    });

    useEffect(() => {
        if (editingBudget) {
            setValues({ ...editingBudget, startDate: new Date(editingBudget.startDate), endDate: new Date(editingBudget.endDate) });
        } else {
            setValues(initialBudgetFormState);
        }
    }, [editingBudget]);

    const onSubmitBudget = async (formValues: Omit<Budget, 'id' | 'allocatedAmount' | 'spentAmount'> & { allocatedAmount?: number; spentAmount?: number }) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        const finalValues = {
            ...formValues,
            startDate: new Date(formValues.startDate),
            endDate: new Date(formValues.endDate),
            allocatedAmount: editingBudget?.allocatedAmount ?? 0, // Preserve or initialize
            spentAmount: editingBudget?.spentAmount ?? 0, // Preserve or initialize
        };
        if (editingBudget) {
            advancedActions.updateBudget(editingBudget.id, finalValues);
        } else {
            advancedActions.addBudget(finalValues);
        }
        setIsSaving(false);
        setIsBudgetModalOpen(false);
        setEditingBudget(null);
        setValues(initialBudgetFormState);
        alert(`Budget ${editingBudget ? 'updated' : 'created'} successfully!`);
    };

    const handleEditBudget = (budget: Budget) => {
        setEditingBudget(budget);
        setIsBudgetModalOpen(true);
    };

    const handleDeleteBudget = async (id: string) => {
        if (!confirm('Are you sure you want to delete this budget? All linked cards will be unlinked.')) return;
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        advancedActions.deleteBudget(id);
        setIsSaving(false);
        alert('Budget deleted.');
    };

    const budgetColumns = useMemo(() => [
        { header: 'Name', accessor: 'name' },
        { header: 'Period', accessor: (b: Budget) => capitalizeFirstLetter(b.period) },
        { header: 'Total Amount', accessor: (b: Budget) => formatCurrency(b.totalAmount) },
        { header: 'Allocated', accessor: (b: Budget) => formatCurrency(b.allocatedAmount) },
        { header: 'Spent', accessor: (b: Budget) => formatCurrency(b.spentAmount) },
        { header: 'Remaining', accessor: (b: Budget) => formatCurrency(b.allocatedAmount - b.spentAmount) },
        { header: 'Cards Linked', accessor: (b: Budget) => (
            <span className="badge badge-outline badge-info">{b.cardsLinked.length}</span>
        ) },
        { header: 'End Date', accessor: (b: Budget) => formatDate(new Date(b.endDate), { year: 'numeric', month: 'short', day: 'numeric' }) },
    ], []);

    const filterOptions = {
        period: {
            label: 'Period',
            options: [
                { value: 'monthly', label: 'Monthly' },
                { value: 'quarterly', label: 'Quarterly' },
                { value: 'annually', label: 'Annually' },
            ]
        },
        departmentId: {
            label: 'Department',
            options: Array.from(new Set(MOCK_CARDHOLDERS.map(h => h.role))).map(role => ({ value: `dept-${role.toLowerCase().replace(' ', '-')}`, label: role }))
        }
    };

    return (
        <Card title="Budget Allocation">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Create and manage budgets, allocate funds to cards, and track spending against targets.</p>
                <button onClick={() => { setEditingBudget(null); setIsBudgetModalOpen(true); }} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    New Budget
                </button>
            </div>

            <PaginatedTable
                title="All Configured Budgets"
                data={advancedData.budgets.sort((a,b) => b.endDate.getTime() - a.endDate.getTime())}
                columns={budgetColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'departmentId', 'projectId']}
                filterOptions={filterOptions}
                emptyMessage="No budgets configured."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditBudget(item)} className="btn btn-xs btn-info">Edit</button>
                        <button onClick={() => handleDeleteBudget(item.id)} className="btn btn-xs btn-error">Delete</button>
                    </div>
                )}
            />

            {isBudgetModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsBudgetModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">{editingBudget ? 'Edit Budget' : 'Create New Budget'}</h3>
                        <form onSubmit={handleSubmit(onSubmitBudget)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Budget Name</span>
                                <input type="text" name="name" value={values.name} onChange={handleChange} placeholder="e.g., Marketing Q4 2024 Budget" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.name && <p className="text-error text-sm mt-1">{errors.name}</p>}
                            </label>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Total Amount ({formatCurrency(values.totalAmount)})</span>
                                    <input type="number" min="100" step="100" name="totalAmount" value={values.totalAmount} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.totalAmount && <p className="text-error text-sm mt-1">{errors.totalAmount}</p>}
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Budget Period</span>
                                    <select name="period" value={values.period} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="monthly">Monthly</option>
                                        <option value="quarterly">Quarterly</option>
                                        <option value="annually">Annually</option>
                                    </select>
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Start Date</span>
                                    <input type="date" name="startDate" value={new Date(values.startDate).toISOString().split('T')[0]} onChange={e => setValues(prev => ({ ...prev, startDate: new Date(e.target.value) }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">End Date</span>
                                    <input type="date" name="endDate" value={new Date(values.endDate).toISOString().split('T')[0]} onChange={e => setValues(prev => ({ ...prev, endDate: new Date(e.target.value) }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                    {errors.endDate && <p className="text-error text-sm mt-1">{errors.endDate}</p>}
                                </label>
                            </div>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Department (Optional)</span>
                                <select name="departmentId" value={values.departmentId} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="">None</option>
                                    {Array.from(new Set(MOCK_CARDHOLDERS.map(h => h.role))).map(role => (
                                        <option key={`dept-${role.toLowerCase().replace(' ', '-')}`} value={`dept-${role.toLowerCase().replace(' ', '-')}`}>{role}</option>
                                    ))}
                                </select>
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Project (Optional)</span>
                                <input type="text" name="projectId" value={values.projectId || ''} onChange={handleChange} placeholder="e.g., Project Falcon" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>

                            <label className="form-control">
                                <span className="label-text text-gray-300">Link Cards to this Budget (Optional)</span>
                                <select multiple name="cardsLinked" value={values.cardsLinked || []}
                                    onChange={e => {
                                        const options = Array.from(e.target.options);
                                        const value = options.filter(option => option.selected).map(option => option.value);
                                        setValues(prev => ({ ...prev, cardsLinked: value }));
                                    }}
                                    className="select select-bordered bg-gray-700 text-white border-gray-600 h-24"
                                >
                                    {corporateCards.map(card => (
                                        <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                    ))}
                                </select>
                                <p className="text-xs text-gray-500 mt-1">Cards linked here will draw from and track against this budget.</p>
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsBudgetModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    {editingBudget ? 'Update Budget' : 'Create Budget'}
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const APISettingsPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("APISettingsPanel must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
    const [editingSetting, setEditingSetting] = useState<APISetting | null>(null);
    const [isSaving, setIsSaving] = useState(false);

    const initialAPISettingFormState: APISetting = {
        id: '', name: '', description: '', apiKey: '', endpoint: '', isActive: true, lastAccessed: new Date(),
        apiSecret: '', allowedIPs: [], webhookUrl: '', eventsSubscribed: [],
    };

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(editingSetting || initialAPISettingFormState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.name) newErrors.name = 'Integration name is required.';
        if (!vals.apiKey) newErrors.apiKey = 'API Key is required.';
        if (!vals.endpoint) newErrors.endpoint = 'API Endpoint is required.';
        return newErrors;
    });

    useEffect(() => {
        setValues(editingSetting || initialAPISettingFormState);
    }, [editingSetting]);

    const onSubmitAPISetting = async (formValues: APISetting) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 800));
        // In a real app, API secret would be handled securely and likely not re-sent from frontend
        advancedActions.updateAPISetting(formValues.id, formValues);
        setIsSaving(false);
        setIsSettingsModalOpen(false);
        setEditingSetting(null);
        setValues(initialAPISettingFormState);
        alert(`API Setting for ${formValues.name} updated successfully!`);
    };

    const handleEditSetting = (setting: APISetting) => {
        setEditingSetting(setting);
        setIsSettingsModalOpen(true);
    };

    const apiSettingsColumns = useMemo(() => [
        { header: 'Integration Name', accessor: 'name' },
        { header: 'Endpoint', accessor: 'endpoint' },
        { header: 'API Key (Masked)', accessor: (s: APISetting) => `****${s.apiKey.slice(-4)}` },
        { header: 'Status', accessor: (s: APISetting) => (
            <span className={`badge ${s.isActive ? 'badge-success' : 'badge-warning'}`}>{s.isActive ? 'Active' : 'Inactive'}</span>
        )},
        { header: 'Last Accessed', accessor: (s: APISetting) => formatDate(new Date(s.lastAccessed)) },
    ], []);

    return (
        <Card title="API & Webhook Settings">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Configure and manage third-party integrations, API keys, and webhooks.</p>
                {/* For this mock, we only allow editing existing ones, not creating new from scratch to simplify form values */}
                <button className="btn btn-neutral btn-outline" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    Add New Integration
                </button>
            </div>

            <PaginatedTable
                title="Configured Integrations"
                data={advancedData.apiSettings}
                columns={apiSettingsColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'endpoint']}
                emptyMessage="No API integrations configured."
                actions={(item) => (
                    <div className="flex gap-2">
                        <button onClick={() => handleEditSetting(item)} className="btn btn-xs btn-info">Edit</button>
                    </div>
                )}
            />

            {isSettingsModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsSettingsModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">Edit API Setting: {editingSetting?.name}</h3>
                        <form onSubmit={handleSubmit(onSubmitAPISetting)} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Integration Name</span>
                                <input type="text" name="name" value={values.name} onChange={handleChange} placeholder="e.g., Expenseify ERP" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.name && <p className="text-error text-sm mt-1">{errors.name}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Description</span>
                                <textarea name="description" value={values.description} onChange={handleChange} placeholder="Details about this integration." className="textarea textarea-bordered bg-gray-700 text-white border-gray-600"></textarea>
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">API Endpoint</span>
                                <input type="url" name="endpoint" value={values.endpoint} onChange={handleChange} placeholder="https://api.external.com/v1" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.endpoint && <p className="text-error text-sm mt-1">{errors.endpoint}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">API Key</span>
                                <input type="text" name="apiKey" value={values.apiKey} onChange={handleChange} placeholder="Your API Key" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                {errors.apiKey && <p className="text-error text-sm mt-1">{errors.apiKey}</p>}
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">API Secret (optional, usually kept server-side)</span>
                                <input type="password" name="apiSecret" value={values.apiSecret || ''} onChange={handleChange} placeholder="Hidden" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control flex items-center justify-between flex-row pt-8">
                                    <span className="label-text text-gray-300">Is Active</span>
                                    <input type="checkbox" name="isActive" checked={values.isActive} onChange={handleChange} className="toggle toggle-cyan" />
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Webhook URL (Optional)</span>
                                    <input type="url" name="webhookUrl" value={values.webhookUrl || ''} onChange={handleChange} placeholder="https://your-app.com/webhook" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                </label>
                            </div>

                            <label className="form-control">
                                <span className="label-text text-gray-300">Allowed IP Addresses (comma-separated)</span>
                                <input type="text" name="allowedIPs" value={values.allowedIPs?.join(',') || ''} onChange={e => setValues(prev => ({ ...prev, allowedIPs: e.target.value.split(',').map(ip => ip.trim()).filter(Boolean) }))} placeholder="e.g., 192.168.1.1, 10.0.0.5" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Events Subscribed (comma-separated)</span>
                                <input type="text" name="eventsSubscribed" value={values.eventsSubscribed?.join(',') || ''} onChange={e => setValues(prev => ({ ...prev, eventsSubscribed: e.target.value.split(',').map(event => event.trim()).filter(Boolean) }))} placeholder="e.g., transaction.created, card.frozen" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsSettingsModalOpen(false)} disabled={isSubmitting || isSaving}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={isSubmitting || isSaving}>
                                    {(isSubmitting || isSaving) && <span className="loading loading-spinner"></span>}
                                    Update Settings
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};


export const ComplianceReportsView: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("ComplianceReportsView must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [isReportGeneratorOpen, setIsReportGeneratorOpen] = useState(false);
    const [generatingReport, setGeneratingReport] = useState(false);
    const [reportGenParams, setReportGenParams] = useState({
        reportType: 'spending_policy_adherence',
        startDate: new Date(new Date().setMonth(new Date().getMonth() - 1)).toISOString().split('T')[0],
        endDate: new Date().toISOString().split('T')[0],
        policyId: '',
        department: '',
    });

    const handleGenerateReport = async () => {
        setGeneratingReport(true);
        const newReport = await advancedActions.generateComplianceReport(reportGenParams);
        setGeneratingReport(false);
        setIsReportGeneratorOpen(false);
        alert(`Report '${newReport.name}' generated successfully!`);
    };

    const reportColumns = useMemo(() => [
        { header: 'Report Name', accessor: 'name' },
        { header: 'Type', accessor: (r: ComplianceReport) => capitalizeFirstLetter(r.reportType.replace(/_/g, ' ')) },
        { header: 'Generated By', accessor: (r: ComplianceReport) => MOCK_CARDHOLDERS.find(u => u.id === r.generatedBy)?.name || 'System' },
        { header: 'Period', accessor: (r: ComplianceReport) => `${formatDate(new Date(r.startDate), { month: 'short', day: 'numeric' })} - ${formatDate(new Date(r.endDate), { month: 'short', day: 'numeric' })}` },
        { header: 'Generated Date', accessor: (r: ComplianceReport) => formatDate(new Date(r.generatedDate)) },
        { header: 'Status', accessor: (r: ComplianceReport) => (
            <span className={`badge ${
                r.status === 'completed' ? 'badge-success' :
                r.status === 'pending' ? 'badge-info' : 'badge-error'
            }`}>
                {capitalizeFirstLetter(r.status)}
            </span>
        )},
    ], []);

    const filterOptions = {
        reportType: {
            label: 'Report Type',
            options: [
                { value: 'spending_policy_adherence', label: 'Spending Policy Adherence' },
                { value: 'transaction_audits', label: 'Transaction Audits' },
                { value: 'user_activity', label: 'User Activity' },
                { value: 'financial_reconciliation', label: 'Financial Reconciliation' },
            ]
        },
        status: {
            label: 'Status',
            options: [
                { value: 'completed', label: 'Completed' },
                { value: 'pending', label: 'Pending' },
                { value: 'failed', label: 'Failed' },
            ]
        }
    };

    return (
        <Card title="Compliance & Audit Reports">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Generate detailed reports to ensure compliance with internal policies and external regulations.</p>
                <button onClick={() => setIsReportGeneratorOpen(true)} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    Generate New Report
                </button>
            </div>

            <PaginatedTable
                title="Historical Reports"
                data={advancedData.complianceReports.sort((a,b) => b.generatedDate.getTime() - a.generatedDate.getTime())}
                columns={reportColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['name', 'reportType', 'generatedBy']}
                filterOptions={filterOptions}
                emptyMessage="No compliance reports have been generated yet."
                actions={(item) => (
                    item.downloadUrl ? (
                        <a href={item.downloadUrl} target="_blank" rel="noopener noreferrer" className="btn btn-xs btn-outline btn-info">Download</a>
                    ) : (
                        <span className="text-gray-500 text-xs">N/A</span>
                    )
                )}
            />

            {isReportGeneratorOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsReportGeneratorOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">Generate New Compliance Report</h3>
                        <form onSubmit={(e) => { e.preventDefault(); handleGenerateReport(); }} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Report Type</span>
                                <select name="reportType" value={reportGenParams.reportType} onChange={e => setReportGenParams(prev => ({ ...prev, reportType: e.target.value as ComplianceReport['reportType'] }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="spending_policy_adherence">Spending Policy Adherence</option>
                                    <option value="transaction_audits">Transaction Audits</option>
                                    <option value="user_activity">User Activity</option>
                                    <option value="financial_reconciliation">Financial Reconciliation</option>
                                </select>
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">Start Date</span>
                                <input type="date" name="startDate" value={reportGenParams.startDate} onChange={e => setReportGenParams(prev => ({ ...prev, startDate: e.target.value }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>
                            <label className="form-control">
                                <span className="label-text text-gray-300">End Date</span>
                                <input type="date" name="endDate" value={reportGenParams.endDate} onChange={e => setReportGenParams(prev => ({ ...prev, endDate: e.target.value }))} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                            </label>

                            {reportGenParams.reportType === 'spending_policy_adherence' && (
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Specific Policy (Optional)</span>
                                    <select name="policyId" value={reportGenParams.policyId} onChange={e => setReportGenParams(prev => ({ ...prev, policyId: e.target.value }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        <option value="">All Policies</option>
                                        {advancedData.policyRules.map(policy => (
                                            <option key={policy.id} value={policy.id}>{policy.name}</option>
                                        ))}
                                    </select>
                                </label>
                            )}
                            {reportGenParams.reportType === 'transaction_audits' && (
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Department (Optional)</span>
                                    <input type="text" name="department" value={reportGenParams.department} onChange={e => setReportGenParams(prev => ({ ...prev, department: e.target.value }))} placeholder="e.g., Sales" className="input input-bordered bg-gray-700 text-white border-gray-600" />
                                </label>
                            )}

                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsReportGeneratorOpen(false)} disabled={generatingReport}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={generatingReport}>
                                    {generatingReport && <span className="loading loading-spinner"></span>}
                                    Generate Report
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const StatementGenerationView: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    const dataContext = useContext(DataContext);
    if (!advancedContext || !dataContext) throw new Error("StatementGenerationView must be within AdvancedCardProvider and DataProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const { corporateCards } = dataContext;

    const [isGenerateModalOpen, setIsGenerateModalOpen] = useState(false);
    const [generatingStatement, setGeneratingStatement] = useState(false);
    const [statementGenParams, setStatementGenParams] = useState({
        cardId: corporateCards[0]?.id || '',
        month: new Date().getMonth() + 1, // Current month
        year: new Date().getFullYear(),
    });

    const handleGenerateStatement = async () => {
        setGeneratingStatement(true);
        const newStatement = await advancedActions.generateStatement(statementGenParams.cardId, statementGenParams.month, statementGenParams.year);
        setGeneratingStatement(false);
        setIsGenerateModalOpen(false);
        alert(`Statement for card ${newStatement.cardId} (${newStatement.statementDate.getMonth()+1}/${newStatement.statementDate.getFullYear()}) generated successfully!`);
    };

    const statementColumns = useMemo(() => [
        { header: 'Card Holder', accessor: (s: Statement) => corporateCards.find(c => c.id === s.cardId)?.holderName || 'N/A' },
        { header: 'Card Number', accessor: (s: Statement) => corporateCards.find(c => c.id === s.cardId)?.cardNumberMask || 'N/A' },
        { header: 'Statement Date', accessor: (s: Statement) => formatDate(new Date(s.statementDate), { year: 'numeric', month: 'short', day: 'numeric' }) },
        { header: 'Period', accessor: (s: Statement) => `${formatDate(new Date(s.startDate), { month: 'short', day: 'numeric' })} - ${formatDate(new Date(s.endDate), { month: 'short', day: 'numeric' })}` },
        { header: 'Total Spent', accessor: (s: Statement) => formatCurrency(s.totalSpent) },
        { header: 'Closing Balance', accessor: (s: Statement) => formatCurrency(s.closingBalance) },
        { header: 'Status', accessor: (s: Statement) => (
            <span className={`badge ${
                s.status === 'generated' ? 'badge-info' :
                s.status === 'reviewed' ? 'badge-primary' : 'badge-success'
            }`}>
                {capitalizeFirstLetter(s.status)}
            </span>
        )},
    ], [corporateCards]);

    const filterOptions = {
        status: {
            label: 'Status',
            options: [
                { value: 'generated', label: 'Generated' },
                { value: 'reviewed', label: 'Reviewed' },
                { value: 'approved', label: 'Approved' },
            ]
        },
        cardId: {
            label: 'Card Holder',
            options: corporateCards.map(card => ({ value: card.id, label: card.holderName }))
        }
    };

    const months = Array.from({ length: 12 }, (_, i) => ({ value: i + 1, label: new Date(0, i).toLocaleString('en-US', { month: 'long' }) }));
    const years = Array.from({ length: 3 }, (_, i) => ({ value: new Date().getFullYear() - i, label: String(new Date().getFullYear() - i) }));

    return (
        <Card title="Statement Generation">
            <div className="flex justify-between items-center mb-6">
                <p className="text-gray-300">Generate monthly statements for individual corporate cards.</p>
                <button onClick={() => setIsGenerateModalOpen(true)} className="btn btn-cyan">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" /></svg>
                    Generate New Statement
                </button>
            </div>

            <PaginatedTable
                title="Historical Statements"
                data={advancedData.statements.sort((a,b) => b.statementDate.getTime() - a.statementDate.getTime())}
                columns={statementColumns}
                rowKeyExtractor={(item) => item.id}
                searchableKeys={['id']} // Can improve by searching holderName but need to map
                filterOptions={filterOptions}
                emptyMessage="No statements have been generated yet."
                actions={(item) => (
                    <a href={item.downloadUrl} target="_blank" rel="noopener noreferrer" className="btn btn-xs btn-outline btn-info">Download</a>
                )}
            />

            {isGenerateModalOpen && (
                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={() => setIsGenerateModalOpen(false)}>
                    <div className="bg-gray-800 rounded-lg shadow-2xl max-w-xl w-full border border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                        <h3 className="text-xl font-semibold text-white mb-4">Generate Card Statement</h3>
                        <form onSubmit={(e) => { e.preventDefault(); handleGenerateStatement(); }} className="space-y-4">
                            <label className="form-control">
                                <span className="label-text text-gray-300">Select Card</span>
                                <select name="cardId" value={statementGenParams.cardId} onChange={e => setStatementGenParams(prev => ({ ...prev, cardId: e.target.value }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                    <option value="">Select a card</option>
                                    {corporateCards.map(card => (
                                        <option key={card.id} value={card.id}>{card.holderName} (...{card.cardNumberMask})</option>
                                    ))}
                                </select>
                            </label>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Month</span>
                                    <select name="month" value={statementGenParams.month} onChange={e => setStatementGenParams(prev => ({ ...prev, month: +e.target.value }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        {months.map(m => <option key={m.value} value={m.value}>{m.label}</option>)}
                                    </select>
                                </label>
                                <label className="form-control">
                                    <span className="label-text text-gray-300">Year</span>
                                    <select name="year" value={statementGenParams.year} onChange={e => setStatementGenParams(prev => ({ ...prev, year: +e.target.value }))} className="select select-bordered bg-gray-700 text-white border-gray-600">
                                        {years.map(y => <option key={y.value} value={y.value}>{y.label}</option>)}
                                    </select>
                                </label>
                            </div>
                            <div className="modal-action">
                                <button type="button" className="btn btn-ghost" onClick={() => setIsGenerateModalOpen(false)} disabled={generatingStatement}>Cancel</button>
                                <button type="submit" className="btn btn-cyan" disabled={generatingStatement || !statementGenParams.cardId}>
                                    {generatingStatement && <span className="loading loading-spinner"></span>}
                                    Generate Statement
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
        </Card>
    );
};

export const AppGeneralSettingsPanel: React.FC = () => {
    const advancedContext = useContext(AdvancedCardContext);
    if (!advancedContext) throw new Error("AppGeneralSettingsPanel must be within AdvancedCardProvider");

    const { data: advancedData, actions: advancedActions } = advancedContext;
    const [isSaving, setIsSaving] = useState(false);

    const initialConfigState: AppConfig = advancedData.appConfig;

    const {
        values,
        setValues,
        errors,
        handleChange,
        handleSubmit,
        isSubmitting
    } = useFormValidation(initialConfigState, (vals) => {
        const newErrors: FormValidationState = {};
        if (!vals.defaultCurrency) newErrors.defaultCurrency = 'Default currency is required.';
        if (vals.auditLogRetentionDays <= 0) newErrors.auditLogRetentionDays = 'Retention days must be positive.';
        return newErrors;
    });

    useEffect(() => {
        setValues(advancedData.appConfig);
    }, [advancedData.appConfig]);

    const onSubmitConfig = async (formValues: AppConfig) => {
        setIsSaving(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        advancedActions.updateAppConfig(formValues);
        setIsSaving(false);
        alert('Application settings updated successfully!');
    };

    return (
        <Card title="Application General Settings">
            <p className="text-gray-300 mb-6">Configure global settings for the corporate card management application.</p>
            <form onSubmit={handleSubmit(onSubmitConfig)} className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <label className="form-control">
                        <span className="label-text text-gray-300">Default Currency</span>
                        <select name="defaultCurrency" value={values.defaultCurrency} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                            <option value="USD">USD - United States Dollar</option>
                            <option value="EUR">EUR - Euro</option>
                            <option value="GBP">GBP - British Pound</option>
                            <option value="CAD">CAD - Canadian Dollar</option>
                            <option value="AUD">AUD - Australian Dollar</option>
                        </select>
                        {errors.defaultCurrency && <p className="text-error text-sm mt-1">{errors.defaultCurrency}</p>}
                    </label>
                    <label className="form-control">
                        <span className="label-text text-gray-300">Audit Log Retention (Days)</span>
                        <input type="number" name="auditLogRetentionDays" min="30" max="730" step="30" value={values.auditLogRetentionDays} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                        {errors.auditLogRetentionDays && <p className="text-error text-sm mt-1">{errors.auditLogRetentionDays}</p>}
                    </label>
                    <label className="form-control">
                        <span className="label-text text-gray-300">Card Request Approval Workflow</span>
                        <select name="cardRequestApprovalWorkflow" value={values.cardRequestApprovalWorkflow} onChange={handleChange} className="select select-bordered bg-gray-700 text-white border-gray-600">
                            <option value="single_approver">Single Approver</option>
                            <option value="multi_approver">Multi-level Approval</option>
                            <option value="auto_approve">Auto-Approve (for low-value)</option>
                        </select>
                    </label>
                    <label className="form-control">
                        <span className="label-text text-gray-300">Max Virtual Cards Per User</span>
                        <input type="number" name="maxVirtualCardsPerUser" min="1" max="100" step="1" value={values.maxVirtualCardsPerUser} onChange={handleChange} className="input input-bordered bg-gray-700 text-white border-gray-600" />
                    </label>
                    <label className="flex items-center justify-between col-span-1 md:col-span-2 p-3 bg-gray-700 rounded-md">
                        <span className="text-sm text-gray-300">Enable Multi-Factor Authentication (MFA)</span>
                        <input type="checkbox" name="enableMultiFactorAuthentication" checked={values.enableMultiFactorAuthentication} onChange={handleChange} className="toggle toggle-cyan" />
                    </label>
                </div>
                <div className="mt-8">
                    <button
                        type="submit"
                        className={`btn btn-cyan w-full ${isSaving ? 'btn-disabled' : ''}`}
                        disabled={isSaving || isSubmitting}
                    >
                        {isSaving && <span className="loading loading-spinner"></span>}
                        Save Global Settings
                    </button>
                </div>
            </form>
        </Card>
    );
};

// --- END: NEW EXPORTED COMPONENTS ---

// Main CardManagementView component
const CardManagementView: React.FC = () => {
    const context = useContext(DataContext);
    const advancedContext = useContext(AdvancedCardContext);

    if (!context || !advancedContext) throw new Error("CardManagementView must be within a DataProvider and AdvancedCardProvider");

    const { corporateCards, toggleCorporateCardFreeze, updateCorporateCardControls } = context;
    const { data: advancedData, actions: advancedActions } = advancedContext;

    const [selectedCardIdForModal, setSelectedCardIdForModal] = useState<string | null>(null);

    // This state and function are lifted to here to control the visibility of the modal
    // It's called from within the JSX loop for each card
    const openCardDetailModal = useCallback((card: CorporateCard) => {
        setSelectedCardIdForModal(card.id);
    }, []);

    const closeCardDetailModal = useCallback(() => {
        setSelectedCardIdForModal(null);
    }, []);

    // Memoize chart data to avoid recalculations on every render
    const chartData = useMemo(() => {
        return corporateCards.map(card => ({
            name: card.holderName.split(' ')[0],
            spent: card.balance, // Assuming balance is spent amount for simplicity in this chart
            limit: card.limit,
        }));
    }, [corporateCards]);

    // This is the card detail modal, now controlled by the parent view.
    const CardDetailModalComponent: React.FC = () => {
        const selected = useMemo(() => {
            return corporateCards.find(card => card.id === selectedCardIdForModal) || null;
        }, [selectedCardIdForModal, corporateCards]);

        if (!selected || !selectedCardIdForModal) return null;

        const [controls, setControls] = useState<CorporateCardControls>(selected.controls);

        const handleSave = () => {
            updateCorporateCardControls(selected.id, controls);

--- FILE: InsuranceHubView.tsx ---

import React, { useState, useContext, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { GoogleGenAI, Type } from "@google/genai";
import { DataContext } from '../../../../context/DataContext';
import type { InsuranceClaim } from '../../../../types';

// --- New Types and Interfaces (Exported) ---

/**
 * Represents a customer in the insurance system.
 * @interface Customer
 * @property {string} id - Unique identifier for the customer.
 * @property {string} name - Full name of the customer.
 * @property {string} email - Email address of the customer.
 * @property {string} phone - Phone number of the customer.
 * @property {string} address - Physical address of the customer.
 * @property {Date} dateOfBirth - Customer's date of birth.
 * @property {string} [maritalStatus] - Marital status (optional).
 * @property {string} [occupation] - Customer's occupation (optional).
 * @property {string} memberSince - Date the customer became a member.
 * @property {boolean} hasActivePolicy - Indicates if the customer currently holds an active policy.
 * @property {number} totalPolicies - Total number of policies ever held by this customer.
 * @property {number} totalClaimsFiled - Total number of claims ever filed by this customer.
 * @property {number} customerLifetimeValue - Estimated lifetime value of the customer.
 */
export interface Customer {
    id: string;
    name: string;
    email: string;
    phone: string;
    address: string;
    dateOfBirth: Date;
    maritalStatus?: 'Single' | 'Married' | 'Divorced' | 'Widowed';
    occupation?: string;
    memberSince: string;
    hasActivePolicy: boolean;
    totalPolicies: number;
    totalClaimsFiled: number;
    customerLifetimeValue: number;
}

/**
 * Represents a policy held by a customer.
 * @interface InsurancePolicy
 * @property {string} id - Unique policy ID.
 * @property {string} customerId - ID of the customer holding the policy.
 * @property {string} policyHolderName - Name of the policy holder.
 * @property {'Auto' | 'Home' | 'Life' | 'Health' | 'Business'} type - Type of insurance policy.
 * @property {Date} startDate - Policy start date.
 * @property {Date} endDate - Policy end date.
 * @property {number} premiumAmount - Monthly or annual premium amount.
 * @property {number} deductible - Deductible amount.
 * @property {number} coverageAmount - Total coverage amount.
 * @property {'Active' | 'Lapsed' | 'Cancelled' | 'Pending'} status - Current status of the policy.
 * @property {string[]} coveredItems - List of items covered by the policy (e.g., vehicle VIN, property address).
 * @property {Date} lastRenewed - Date of the last renewal.
 * @property {Date | null} nextRenewal - Date of the next renewal (null if lapsed/cancelled).
 * @property {string} [agentId] - ID of the agent managing this policy.
 * @property {string} [underwriterNotes] - Notes from the underwriter.
 * @property {InsuranceCoverage[]} coverages - Detailed breakdown of coverages.
 * @property {string} [applicationId] - ID of the original application, if any.
 * @property {string} [paymentFrequency] - How often premiums are paid.
 */
export interface InsurancePolicy {
    id: string;
    customerId: string;
    policyHolderName: string;
    type: 'Auto' | 'Home' | 'Life' | 'Health' | 'Business';
    startDate: Date;
    endDate: Date;
    premiumAmount: number;
    deductible: number;
    coverageAmount: number;
    status: 'Active' | 'Lapsed' | 'Cancelled' | 'Pending';
    coveredItems: string[];
    lastRenewed: Date;
    nextRenewal: Date | null;
    agentId?: string;
    underwriterNotes?: string;
    coverages: InsuranceCoverage[];
    applicationId?: string;
    paymentFrequency?: 'Monthly' | 'Quarterly' | 'Annually';
}

/**
 * Represents a specific coverage within an insurance policy.
 * @interface InsuranceCoverage
 * @property {string} name - Name of the coverage (e.g., "Collision", "Dwelling").
 * @property {number} limit - Maximum payout for this coverage.
 * @property {number} deductible - Specific deductible for this coverage, if different from policy.
 * @property {boolean} active - Whether this specific coverage is active.
 * @property {string} [description] - A brief description of the coverage.
 * @property {string} [policyTermsRef] - Reference to a section in policy terms.
 */
export interface InsuranceCoverage {
    name: string;
    limit: number;
    deductible?: number;
    active: boolean;
    description?: string;
    policyTermsRef?: string;
}

/**
 * Represents a task for an insurance agent or user.
 * @interface AgentTask
 * @property {string} id - Unique task ID.
 * @property {string} title - Title of the task.
 * @property {string} description - Detailed description of the task.
 * @property {'Pending' | 'In Progress' | 'Completed' | 'Deferred' | 'Cancelled'} status - Current status of the task.
 * @property {string} assignedTo - ID of the user/agent assigned to the task.
 * @property {'High' | 'Medium' | 'Low'} priority - Priority level of the task.
 * @property {Date} dueDate - Due date for the task.
 * @property {Date} createdAt - Date the task was created.
 * @property {string | null} relatedClaimId - Optional ID of a related claim.
 * @property {string | null} relatedPolicyId - Optional ID of a related policy.
 * @property {string | null} relatedCustomerId - Optional ID of a related customer.
 * @property {Date | null} completedAt - Timestamp when the task was completed.
 * @property {string[]} tags - Arbitrary tags for task categorization.
 */
export interface AgentTask {
    id: string;
    title: string;
    description: string;
    status: 'Pending' | 'In Progress' | 'Completed' | 'Deferred' | 'Cancelled';
    assignedTo: string; // User ID
    priority: 'High' | 'Medium' | 'Low';
    dueDate: Date;
    createdAt: Date;
    relatedClaimId: string | null;
    relatedPolicyId: string | null;
    relatedCustomerId: string | null;
    completedAt: Date | null;
    tags: string[];
}

/**
 * Represents a notification for a user.
 * @interface Notification
 * @property {string} id - Unique notification ID.
 * @property {string} message - The notification message.
 * @property {'info' | 'warning' | 'error' | 'success' | 'alert'} type - Type of notification.
 * @property {Date} timestamp - When the notification occurred.
 * @property {boolean} read - Whether the notification has been read.
 * @property {string | null} link - Optional link to a related resource.
 * @property {string[]} recipients - List of user IDs who should receive this notification.
 */
export interface Notification {
    id: string;
    message: string;
    type: 'info' | 'warning' | 'error' | 'success' | 'alert';
    timestamp: Date;
    read: boolean;
    link: string | null;
    recipients: string[];
}

/**
 * Represents a document associated with a claim or policy.
 * @interface Document
 * @property {string} id - Unique document ID.
 * @property {string} fileName - Original file name.
 * @property {string} fileType - MIME type of the file.
 * @property {string} url - URL to access the document (simulated).
 * @property {Date} uploadedAt - Date the document was uploaded.
 * @property {string} uploadedBy - User who uploaded the document.
 * @property {'Claim' | 'Policy' | 'Customer' | 'Underwriting' | 'General' | 'Other'} category - Category of the document.
 * @property {string | null} relatedEntityId - ID of the related claim, policy, or customer.
 * @property {string} [aiSummary] - AI-generated summary of the document content.
 * @property {string[]} [tags] - AI-generated or manual tags.
 * @property {'Pending Review' | 'Reviewed' | 'Needs Attention'} [processingStatus] - Status of document processing.
 */
export interface Document {
    id: string;
    fileName: string;
    fileType: string;
    url: string;
    uploadedAt: Date;
    uploadedBy: string;
    category: 'Claim' | 'Policy' | 'Customer' | 'Underwriting' | 'General' | 'Other';
    relatedEntityId: string | null;
    aiSummary?: string;
    tags?: string[];
    processingStatus?: 'Pending Review' | 'Reviewed' | 'Needs Attention';
}

/**
 * Represents a financial transaction related to a claim or policy.
 * @interface FinancialTransaction
 * @property {string} id - Unique transaction ID.
 * @property {string} entityId - ID of the related claim or policy.
 * @property {'Claim' | 'Policy'} entityType - Type of entity the transaction relates to.
 * @property {Date} transactionDate - Date of the transaction.
 * @property {number} amount - Amount of the transaction.
 * @property {'Payout' | 'Premium' | 'Deductible' | 'Refund' | 'Fee' | 'Commission'} type - Type of transaction.
 * @property {'Pending' | 'Completed' | 'Failed' | 'Reversed'} status - Status of the transaction.
 * @property {string} description - Description of the transaction.
 * @property {string | null} referenceId - External reference ID for the transaction.
 */
export interface FinancialTransaction {
    id: string;
    entityId: string;
    entityType: 'Claim' | 'Policy';
    transactionDate: Date;
    amount: number;
    type: 'Payout' | 'Premium' | 'Deductible' | 'Refund' | 'Fee' | 'Commission';
    status: 'Pending' | 'Completed' | 'Failed' | 'Reversed';
    description: string;
    referenceId: string | null;
}

/**
 * Represents a user of the system (e.g., an agent, admin).
 * @interface UserProfile
 * @property {string} id - Unique user ID.
 * @property {string} name - User's name.
 * @property {string} email - User's email.
 * @property {'Agent' | 'Underwriter' | 'Adjuster' | 'Admin' | 'CustomerService' | 'Manager'} role - User's role.
 * @property {string[]} managedPolicyIds - IDs of policies this user manages.
 * @property {string[]} managedClaimIds - IDs of claims this user is assigned to.
 * @property {string[]} skills - List of skills or specializations.
 * @property {Date} lastLogin - Last login timestamp.
 * @property {boolean} isActive - Is the user account currently active.
 * @property {string | null} department - Department the user belongs to.
 */
export interface UserProfile {
    id: string;
    name: string;
    email: string;
    role: 'Agent' | 'Underwriter' | 'Adjuster' | 'Admin' | 'CustomerService' | 'Manager';
    managedPolicyIds: string[];
    managedClaimIds: string[];
    skills: string[];
    lastLogin: Date;
    isActive: boolean;
    department: string | null;
}

/**
 * Represents an AI model configuration.
 * @interface AIModelConfig
 * @property {string} id - Unique config ID.
 * @property {string} name - Name of the AI model.
 * @property {string} description - Description of its purpose.
 * @property {'Claim Assessment' | 'Underwriting' | 'Fraud Detection' | 'Document OCR' | 'Sentiment Analysis' | 'Chatbot'} type - Type of AI application.
 * @property {string} modelId - Actual identifier for the AI model (e.g., 'gemini-2.5-flash').
 * @property {number} temperature - Model temperature setting. (0.0 - 1.0)
 * @property {number} topP - Top P setting. (0.0 - 1.0)
 * @property {number} maxOutputTokens - Max output tokens.
 * @property {boolean} enabled - Whether the model is active.
 * @property {Date} lastUpdated - Last update timestamp.
 * @property {string} updatedBy - User who last updated it.
 * @property {number} [confidenceThreshold] - Minimum confidence score for auto-action (e.g., for fraud detection).
 */
export interface AIModelConfig {
    id: string;
    name: string;
    description: string;
    type: 'Claim Assessment' | 'Underwriting' | 'Fraud Detection' | 'Document OCR' | 'Sentiment Analysis' | 'Chatbot';
    modelId: string;
    temperature: number;
    topP: number;
    maxOutputTokens: number;
    enabled: boolean;
    lastUpdated: Date;
    updatedBy: string;
    confidenceThreshold?: number;
}

/**
 * Represents an audit log entry for system actions.
 * @interface AuditLogEntry
 * @property {string} id - Unique log entry ID.
 * @property {Date} timestamp - When the action occurred.
 * @property {string} userId - ID of the user who performed the action.
 * @property {string} userName - Name of the user.
 * @property {string} action - Description of the action (e.g., "Updated Claim Status").
 * @property {string} entityType - Type of entity affected (e.g., 'Claim', 'Policy').
 * @property {string} entityId - ID of the affected entity.
 * @property {string | null} oldValue - Previous value of the changed field (JSON string or simple value).
 * @property {string | null} newValue - New value of the changed field (JSON string or simple value).
 * @property {string | null} ipAddress - IP address from which the action originated.
 */
export interface AuditLogEntry {
    id: string;
    timestamp: Date;
    userId: string;
    userName: string;
    action: string;
    entityType: 'Claim' | 'Policy' | 'Customer' | 'Task' | 'Document' | 'AIConfig' | 'User';
    entityId: string;
    oldValue: string | null;
    newValue: string | null;
    ipAddress: string | null;
}

/**
 * Represents a simulated message in a communication thread for a customer.
 * @interface CommunicationMessage
 * @property {string} id - Unique message ID.
 * @property {string} customerId - ID of the customer involved.
 * @property {string} senderId - ID of the sender (user or customer).
 * @property {string} senderType - 'User' or 'Customer'.
 * @property {Date} timestamp - When the message was sent.
 * @property {string} content - The message content.
 * @property {'Email' | 'Chat' | 'Call Log' | 'Internal Note'} channel - Communication channel.
 * @property {string | null} relatedClaimId - Optional related claim.
 * @property {string | null} relatedPolicyId - Optional related policy.
 * @property {string} [aiSentiment] - AI-derived sentiment ('Positive', 'Neutral', 'Negative').
 */
export interface CommunicationMessage {
    id: string;
    customerId: string;
    senderId: string;
    senderType: 'User' | 'Customer';
    timestamp: Date;
    content: string;
    channel: 'Email' | 'Chat' | 'Call Log' | 'Internal Note';
    relatedClaimId: string | null;
    relatedPolicyId: string | null;
    aiSentiment?: 'Positive' | 'Neutral' | 'Negative';
}


// --- Mock Data Generation (Exported) ---

/**
 * Generates a random UUID.
 * @returns {string} A UUID string.
 */
export const generateUUID = (): string => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

/**
 * Generates a random date within a given range.
 * @param {Date} start - Start date.
 * @param {Date} end - End date.
 * @returns {Date} A random Date object.
 */
export const getRandomDate = (start: Date, end: Date): Date => {
    return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
};

/**
 * Generates mock customer data.
 * @param {number} count - Number of customers to generate.
 * @returns {Customer[]} Array of mock customers.
 */
export const generateMockCustomers = (count: number): Customer[] => {
    const customers: Customer[] = [];
    const names = ['Alice Smith', 'Bob Johnson', 'Charlie Brown', 'Diana Prince', 'Eve Adams', 'Frank White', 'Grace Hopper', 'Harry Potter', 'Ivy Queen', 'Jack Ryan', 'Karen Lee', 'Liam Miller', 'Mia Davis', 'Noah Wilson', 'Olivia Taylor', 'Peter Clark', 'Quinn Lewis', 'Rachel Hall', 'Sam White', 'Tina Green'];
    const domains = ['example.com', 'test.org', 'mail.net', 'company.io'];
    const addresses = ['123 Main St', '456 Oak Ave', '789 Pine Ln', '101 Elm Rd', '202 Birch Blvd', '303 Cedar Dr', '404 Maple Ct', '505 Willow Way'];
    const maritalStatuses = ['Single', 'Married', 'Divorced', 'Widowed'];
    const occupations = ['Engineer', 'Doctor', 'Teacher', 'Artist', 'Programmer', 'Manager', 'Analyst', 'Consultant', 'Chef', 'Pilot', 'Nurse', 'Student'];

    for (let i = 0; i < count; i++) {
        const name = names[Math.floor(Math.random() * names.length)] + (Math.random() > 0.5 ? ` #${Math.floor(Math.random() * 100)}` : '');
        const firstName = name.split(' ')[0].toLowerCase();
        const lastName = name.split(' ')[1]?.toLowerCase() || 'user';
        const email = `${firstName}.${lastName}@${domains[Math.floor(Math.random() * domains.length)]}`;
        const phone = `+1-${Math.floor(100 + Math.random() * 900)}-${Math.floor(100 + Math.random() * 900)}-${Math.floor(1000 + Math.random() * 9000)}`;
        const dob = getRandomDate(new Date('1950-01-01'), new Date('2000-01-01'));
        const memberSince = getRandomDate(new Date('2010-01-01'), new Date()).toISOString().split('T')[0];

        customers.push({
            id: generateUUID(),
            name: name,
            email: email,
            phone: phone,
            address: `${Math.floor(100 + Math.random() * 900)} ${addresses[Math.floor(Math.random() * addresses.length)]}`,
            dateOfBirth: dob,
            maritalStatus: maritalStatuses[Math.floor(Math.random() * maritalStatuses.length)],
            occupation: occupations[Math.floor(Math.random() * occupations.length)],
            memberSince: memberSince,
            hasActivePolicy: Math.random() > 0.2, // 80% have active policy
            totalPolicies: Math.floor(1 + Math.random() * 5),
            totalClaimsFiled: Math.floor(Math.random() * 4), // 0-3 claims
            customerLifetimeValue: Math.floor(1000 + Math.random() * 100000)
        });
    }
    return customers;
};

/**
 * Generates mock insurance policy data.
 * @param {number} count - Number of policies to generate.
 * @param {Customer[]} customers - List of existing customers to link policies to.
 * @returns {InsurancePolicy[]} Array of mock policies.
 */
export const generateMockPolicies = (count: number, customers: Customer[]): InsurancePolicy[] => {
    const policies: InsurancePolicy[] = [];
    const policyTypes = ['Auto', 'Home', 'Life', 'Health', 'Business'];
    const policyStatuses = ['Active', 'Lapsed', 'Cancelled', 'Pending'];
    const paymentFrequencies = ['Monthly', 'Quarterly', 'Annually'];

    for (let i = 0; i < count; i++) {
        const customer = customers[Math.floor(Math.random() * customers.length)];
        const type = policyTypes[Math.floor(Math.random() * policyTypes.length)];
        const startDate = getRandomDate(new Date('2015-01-01'), new Date());
        const endDate = new Date(startDate.getFullYear() + Math.floor(1 + Math.random() * 5), startDate.getMonth(), startDate.getDate());
        const status = policyStatuses[Math.floor(Math.random() * policyStatuses.length)];
        const premium = Math.floor(100 + Math.random() * 1000);
        const deductible = Math.floor(500 + Math.random() * 2000);
        const coverage = Math.floor(50000 + Math.random() * 500000);
        const lastRenewed = getRandomDate(new Date(startDate.getTime()), new Date());
        const nextRenewal = status === 'Active' ? new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate()) : null;

        const generateCoverages = (): InsuranceCoverage[] => {
            if (type === 'Auto') {
                return [
                    { name: 'Collision', limit: coverage * 0.5, deductible: deductible, active: true, description: 'Covers damage from collision with another vehicle or object.' },
                    { name: 'Comprehensive', limit: coverage * 0.3, active: true, description: 'Covers damage from non-collision events like theft, vandalism, fire.' },
                    { name: 'Liability', limit: coverage * 0.2, active: true, description: 'Covers damages to other parties in an at-fault accident.' },
                    { name: 'Roadside Assistance', limit: 200, active: Math.random() > 0.5, description: 'Towing, jump starts, flat tire changes.' }
                ];
            } else if (type === 'Home') {
                return [
                    { name: 'Dwelling', limit: coverage * 0.7, deductible: deductible, active: true, description: 'Covers the physical structure of your home.' },
                    { name: 'Personal Property', limit: coverage * 0.2, active: true, description: 'Covers your personal belongings inside the home.' },
                    { name: 'Liability', limit: coverage * 0.1, active: true, description: 'Covers costs if someone is injured on your property.' },
                    { name: 'Water Backup', limit: 10000, active: Math.random() > 0.4, description: 'Covers damage from sewer or drain backup.' }
                ];
            } else if (type === 'Life') {
                return [
                    { name: 'Term Life', limit: coverage, active: true, description: 'Coverage for a specific period of time.' },
                    { name: 'Accidental Death', limit: coverage * 0.2, active: Math.random() > 0.3, description: 'Additional payout for accidental death.' }
                ];
            }
            return [{ name: `${type} Basic`, limit: coverage, active: true, description: `Standard coverage for ${type.toLowerCase()} insurance.` }];
        };

        policies.push({
            id: `POL-${Math.floor(100000 + Math.random() * 900000)}`,
            customerId: customer.id,
            policyHolderName: customer.name,
            type: type as any,
            startDate: startDate,
            endDate: endDate,
            premiumAmount: premium,
            deductible: deductible,
            coverageAmount: coverage,
            status: status as any,
            coveredItems: type === 'Auto' ? [`VIN: ${Math.random().toString(36).substring(2, 12).toUpperCase()}`] : [`Property Address: ${customer.address}`],
            lastRenewed: lastRenewed,
            nextRenewal: nextRenewal,
            agentId: Math.random() > 0.5 ? `USR-${Math.floor(100 + Math.random() * 900)}` : undefined,
            underwriterNotes: Math.random() > 0.7 ? `Standard risk assessment. Policy approved on ${startDate.toLocaleDateString()}.` : undefined,
            coverages: generateCoverages(),
            applicationId: `APP-${Math.floor(10000 + Math.random() * 90000)}`,
            paymentFrequency: paymentFrequencies[Math.floor(Math.random() * paymentFrequencies.length)] as any,
        });
    }
    return policies;
};

/**
 * Generates mock insurance claim data.
 * This is based on the original `InsuranceClaim` type from `types.ts`, extended with more detail.
 * @param {number} count - Number of claims to generate.
 * @param {Customer[]} customers - List of existing customers.
 * @param {InsurancePolicy[]} policies - List of existing policies.
 * @returns {InsuranceClaim[]} Array of mock claims.
 */
export const generateMockClaims = (count: number, customers: Customer[], policies: InsurancePolicy[]): InsuranceClaim[] => {
    const claims: InsuranceClaim[] = [];
    const claimDescriptions = [
        'Minor fender bender on Main Street, rear-end collision.',
        'Tree fell on roof during storm, significant damage to attic.',
        'Lost engagement ring during vacation, value $15,000.',
        'Kitchen fire due to faulty appliance, extensive smoke damage.',
        'Car stolen from driveway overnight, reported to police.',
        'Medical emergency requiring urgent care, ambulance fees and hospital stay.',
        'Business property damage due to burst pipe, inventory affected.',
        'Slip and fall injury at home, broken arm.',
        'Hail damage to vehicle windshield and hood.',
        'Water damage in basement from heavy rain, furniture ruined.'
    ];
    const claimStatuses = ['New', 'Under Review', 'Approved', 'Denied'];

    for (let i = 0; i < count; i++) {
        const customer = customers[Math.floor(Math.random() * customers.length)];
        const customerPolicies = policies.filter(p => p.customerId === customer.id && p.status === 'Active');
        const policy = customerPolicies.length > 0 ? customerPolicies[Math.floor(Math.random() * customerPolicies.length)] : null;

        const dateFiled = getRandomDate(new Date('2023-01-01'), new Date());
        const amount = Math.floor(500 + Math.random() * 25000); // Claim amount
        const status = claimStatuses[Math.floor(Math.random() * claimStatuses.length)];

        claims.push({
            id: `CLM-${Math.floor(1000 + Math.random() * 9000)}`,
            policyId: policy ? policy.id : `POL-NONE-${i}`, // Link to a real policy or a dummy one
            policyholder: customer.name,
            description: claimDescriptions[Math.floor(Math.random() * claimDescriptions.length)],
            amount: amount,
            dateFiled: dateFiled.toISOString(),
            status: status as any,
            fraudDetected: Math.random() < 0.15, // 15% chance of fraud detection
            assignedTo: Math.random() > 0.6 ? `USR-${Math.floor(100 + Math.random() * 900)}` : undefined,
            notes: Math.random() > 0.5 ? `Initial assessment suggests claim is ${status.toLowerCase()}.` : undefined,
            payoutAmount: status === 'Approved' ? Math.round(amount * (0.5 + Math.random() * 0.5)) : 0, // Payout if approved
            dateOfLoss: getRandomDate(new Date(dateFiled.getTime() - 30 * 24 * 60 * 60 * 1000), dateFiled).toISOString(), // Loss happened recently before filing
            incidentLocation: customer.address,
            incidentType: policy?.type === 'Auto' ? 'Vehicle Accident' : policy?.type === 'Home' ? 'Property Damage' : 'Other',
        });
    }
    return claims;
};

/**
 * Generates mock agent tasks.
 * @param {number} count - Number of tasks to generate.
 * @param {UserProfile[]} users - List of user profiles to assign tasks to.
 * @param {InsuranceClaim[]} claims - List of existing claims.
 * @param {InsurancePolicy[]} policies - List of existing policies.
 * @param {Customer[]} customers - List of existing customers.
 * @returns {AgentTask[]} Array of mock tasks.
 */
export const generateMockTasks = (
    count: number,
    users: UserProfile[],
    claims: InsuranceClaim[],
    policies: InsurancePolicy[],
    customers: Customer[]
): AgentTask[] => {
    const tasks: AgentTask[] = [];
    const titles = [
        'Review New Claim Submission', 'Follow Up on Policy Renewal', 'Process Policy Endorsement', 'Customer Inquiry - Update Contact Info',
        'Fraud Flag Review Required', 'Underwriting Assessment - New Application', 'Verify Document Uploads', 'Approve Claim Payout', 'Assign Subrogation Case',
        'Customer Service Call Back', 'Policy Cancellation Request', 'Premium Adjustment Review', 'Compliance Check on Policyholder',
        'Gather additional info for claim', 'Schedule adjuster visit', 'Prepare renewal offer'
    ];
    const statuses = ['Pending', 'In Progress', 'Completed', 'Deferred', 'Cancelled'];
    const priorities = ['High', 'Medium', 'Low'];
    const tags = ['Urgent', 'Follow-up', 'Investigation', 'Client-facing', 'Internal', 'Compliance'];

    for (let i = 0; i < count; i++) {
        const assignedTo = users.length > 0 ? users[Math.floor(Math.random() * users.length)].id : 'USR-DEFAULT';
        const createdAt = getRandomDate(new Date(Date.now() - 60 * 24 * 60 * 60 * 1000), new Date()); // Last 60 days
        const dueDate = getRandomDate(createdAt, new Date(Date.now() + 60 * 24 * 60 * 60 * 1000)); // Next 60 days
        const status = statuses[Math.floor(Math.random() * statuses.length)];
        const completedAt = status === 'Completed' ? getRandomDate(createdAt, new Date()) : null;

        let relatedClaimId: string | null = null;
        let relatedPolicyId: string | null = null;
        let relatedCustomerId: string | null = null;

        const relatedEntityType = Math.random();
        if (relatedEntityType < 0.3 && claims.length > 0) {
            relatedClaimId = claims[Math.floor(Math.random() * claims.length)].id;
        } else if (relatedEntityType < 0.6 && policies.length > 0) {
            relatedPolicyId = policies[Math.floor(Math.random() * policies.length)].id;
            const policy = policies.find(p => p.id === relatedPolicyId);
            if (policy) relatedCustomerId = policy.customerId;
        } else if (relatedEntityType < 0.9 && customers.length > 0) {
            relatedCustomerId = customers[Math.floor(Math.random() * customers.length)].id;
        }

        const taskTags = Array.from({ length: Math.floor(Math.random() * 3) }).map(() => tags[Math.floor(Math.random() * tags.length)]);

        tasks.push({
            id: generateUUID(),
            title: titles[Math.floor(Math.random() * titles.length)],
            description: `Detailed description for task ID ${i+1}. This task requires attention to ${relatedClaimId || relatedPolicyId || relatedCustomerId || 'a general insurance operation'}. Ensure all documentation is accurate and follow up with relevant parties.`,
            status: status as any,
            assignedTo: assignedTo,
            priority: priorities[Math.floor(Math.random() * priorities.length)] as any,
            dueDate: dueDate,
            createdAt: createdAt,
            relatedClaimId: relatedClaimId,
            relatedPolicyId: relatedPolicyId,
            relatedCustomerId: relatedCustomerId,
            completedAt: completedAt,
            tags: Array.from(new Set(taskTags)), // Remove duplicates
        });
    }
    return tasks;
};

/**
 * Generates mock notifications.
 * @param {number} count - Number of notifications to generate.
 * @param {UserProfile[]} users - List of user profiles to assign notifications to.
 * @returns {Notification[]} Array of mock notifications.
 */
export const generateMockNotifications = (count: number, users: UserProfile[]): Notification[] => {
    const notifications: Notification[] = [];
    const messages = [
        'New claim filed by [PolicyholderName]. Review required.',
        'Policy #POL-ID due for renewal in 30 days. Action needed.',
        'Urgent: Fraud flag detected on claim #CLM-ID. Immediate review.',
        'Task "[TaskTitle]" assigned to you. Due by [DueDate].',
        'System update completed successfully. New features available.',
        'Customer support inquiry from [CustomerName]. Respond within 24 hours.',
        'New document uploaded for policy #POL-ID. Verify content.',
        'Claim #CLM-ID approved for payout. Process payment.',
        'High priority task added: Underwriting for new business policy application.',
        'Manager approval required for claim #CLM-ID over $50,000.',
        'New customer [CustomerName] enrolled. Welcome email sent.'
    ];
    const types = ['info', 'warning', 'error', 'success', 'alert'];

    for (let i = 0; i < count; i++) {
        const user = users[Math.floor(Math.random() * users.length)];
        const messageTemplate = messages[Math.floor(Math.random() * messages.length)];
        const message = messageTemplate
            .replace('[PolicyholderName]', `Customer ${Math.floor(Math.random() * 100)}`)
            .replace('[PolicyName]', `Policy #${Math.floor(1000 + Math.random() * 9000)}`)
            .replace('[PolicyID]', `POL-${Math.floor(100000 + Math.random() * 900000)}`)
            .replace('[ClaimID]', `CLM-${Math.floor(1000 + Math.random() * 9000)}`)
            .replace('[TaskTitle]', `Review Claim ${Math.floor(1000 + Math.random() * 9000)}`)
            .replace('[DueDate]', getRandomDate(new Date(), new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)).toLocaleDateString())
            .replace('[CustomerName]', `Cust ${Math.floor(Math.random() * 100)}`);

        notifications.push({
            id: generateUUID(),
            message: message,
            type: types[Math.floor(Math.random() * types.length)] as any,
            timestamp: getRandomDate(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), new Date()), // Last 7 days
            read: Math.random() > 0.6, // 40% are unread
            link: Math.random() > 0.7 ? `/dashboard/details/${Math.floor(1000 + Math.random() * 9000)}` : null,
            recipients: [user.id],
        });
    }
    return notifications;
};

/**
 * Generates mock documents.
 * @param {number} count - Number of documents to generate.
 * @param {InsuranceClaim[]} claims - List of existing claims.
 * @param {InsurancePolicy[]} policies - List of existing policies.
 * @param {Customer[]} customers - List of existing customers.
 * @param {UserProfile[]} users - List of system users for 'uploadedBy'.
 * @returns {Document[]} Array of mock documents.
 */
export const generateMockDocuments = (
    count: number,
    claims: InsuranceClaim[],
    policies: InsurancePolicy[],
    customers: Customer[],
    users: UserProfile[]
): Document[] => {
    const documents: Document[] = [];
    const fileNamesTemplates = [
        'accident_report_[ID].pdf', 'policy_terms_[ID].docx', 'drivers_license_[ID].jpg', 'medical_bill_[ID].pdf',
        'invoice_[ID].png', 'property_deed_[ID].pdf', 'claim_photos_[ID].zip', 'underwriting_report_[ID].xlsx',
        'customer_correspondence_[ID].eml', 'signed_agreement_[ID].pdf'
    ];
    const fileTypes = ['application/pdf', 'application/msword', 'image/jpeg', 'image/png', 'application/zip', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'message/rfc822'];
    const categories: Document['category'][] = ['Claim', 'Policy', 'Customer', 'Underwriting', 'General', 'Other'];
    const processingStatuses: Document['processingStatus'][] = ['Pending Review', 'Reviewed', 'Needs Attention'];
    const tags = ['AI_GENERATED', 'URGENT_REVIEW', 'CONFIDENTIAL', 'EXTERNAL_SOURCE', 'INTERNAL_MEMO', 'FINANCIAL'];

    for (let i = 0; i < count; i++) {
        const category = categories[Math.floor(Math.random() * categories.length)];
        let relatedEntityId: string | null = null;
        let entityNamePart: string = '';

        if (category === 'Claim' && claims.length > 0) {
            const claim = claims[Math.floor(Math.random() * claims.length)];
            relatedEntityId = claim.id;
            entityNamePart = claim.policyholder;
        } else if (category === 'Policy' && policies.length > 0) {
            const policy = policies[Math.floor(Math.random() * policies.length)];
            relatedEntityId = policy.id;
            entityNamePart = policy.policyHolderName;
        } else if (category === 'Customer' && customers.length > 0) {
            const customer = customers[Math.floor(Math.random() * customers.length)];
            relatedEntityId = customer.id;
            entityNamePart = customer.name;
        } else if (category === 'Underwriting' && policies.length > 0) {
             const policy = policies[Math.floor(Math.random() * policies.length)];
             relatedEntityId = policy.applicationId || policy.id; // Link to application or policy
             entityNamePart = policy.policyHolderName;
        }

        const fileNameTemplate = fileNamesTemplates[Math.floor(Math.random() * fileNamesTemplates.length)];
        const uniqueId = Math.floor(1000 + Math.random() * 9000);
        const fileName = fileNameTemplate.replace('[ID]', `${relatedEntityId || uniqueId}`);
        const fileType = fileTypes[Math.floor(Math.random() * fileTypes.length)];
        const uploadedBy = users.length > 0 ? users[Math.floor(Math.random() * users.length)].id : 'System_Admin';
        const docTags = Array.from({ length: Math.floor(Math.random() * 3) }).map(() => tags[Math.floor(Math.random() * tags.length)]);


        documents.push({
            id: generateUUID(),
            fileName: fileName,
            fileType: fileType,
            url: `https://example.com/docs/${generateUUID()}.${fileType.split('/').pop()}`,
            uploadedAt: getRandomDate(new Date('2022-01-01'), new Date()),
            uploadedBy: uploadedBy,
            category: category,
            relatedEntityId: relatedEntityId,
            aiSummary: Math.random() > 0.6 ? `AI summary: Key details extracted from ${fileName} relate to ${category.toLowerCase()} ${relatedEntityId || 'N/A'} for ${entityNamePart || 'an unknown entity'} and indicate [some relevant detail, e.g., damage assessment, policy terms review, contact info].` : undefined,
            tags: Array.from(new Set(docTags)),
            processingStatus: processingStatuses[Math.floor(Math.random() * processingStatuses.length)],
        });
    }
    return documents;
};

/**
 * Generates mock financial transactions.
 * @param {number} count - Number of transactions to generate.
 * @param {InsuranceClaim[]} claims - List of existing claims.
 * @param {InsurancePolicy[]} policies - List of existing policies.
 * @returns {FinancialTransaction[]} Array of mock transactions.
 */
export const generateMockFinancialTransactions = (
    count: number,
    claims: InsuranceClaim[],
    policies: InsurancePolicy[]
): FinancialTransaction[] => {
    const transactions: FinancialTransaction[] = [];
    const types = ['Payout', 'Premium', 'Deductible', 'Refund', 'Fee', 'Commission'];
    const statuses = ['Pending', 'Completed', 'Failed', 'Reversed'];

    for (let i = 0; i < count; i++) {
        const entityType = Math.random() > 0.5 ? 'Claim' : 'Policy';
        let entityId: string = '';
        if (entityType === 'Claim' && claims.length > 0) {
            entityId = claims[Math.floor(Math.random() * claims.length)].id;
        } else if (entityType === 'Policy' && policies.length > 0) {
            entityId = policies[Math.floor(Math.random() * policies.length)].id;
        } else {
            // Fallback if no claims/policies exist, or just skip this iteration
            continue;
        }

        const type = types[Math.floor(Math.random() * types.length)];
        let amount = 0;
        if (type === 'Payout') amount = Math.floor(1000 + Math.random() * 50000);
        else if (type === 'Premium') amount = Math.floor(50 + Math.random() * 500);
        else if (type === 'Deductible') amount = Math.floor(250 + Math.random() * 1000);
        else if (type === 'Refund') amount = Math.floor(50 + Math.random() * 1000);
        else if (type === 'Fee') amount = Math.floor(10 + Math.random() * 200);
        else if (type === 'Commission') amount = Math.floor(20 + Math.random() * 1000);


        transactions.push({
            id: generateUUID(),
            entityId: entityId,
            entityType: entityType,
            transactionDate: getRandomDate(new Date('2023-01-01'), new Date()),
            amount: amount,
            type: type as any,
            status: statuses[Math.floor(Math.random() * statuses.length)] as any,
            description: `${type} transaction for ${entityType} ${entityId}. Initiated by system.`,
            referenceId: `TXN-${Math.floor(1000000 + Math.random() * 9000000)}`,
        });
    }
    return transactions;
};

/**
 * Generates mock user profiles.
 * @param {number} count - Number of users to generate.
 * @returns {UserProfile[]} Array of mock user profiles.
 */
export const generateMockUserProfiles = (count: number): UserProfile[] => {
    const users: UserProfile[] = [];
    const roles = ['Agent', 'Underwriter', 'Adjuster', 'Admin', 'CustomerService', 'Manager'];
    const names = ['John Doe', 'Jane Smith', 'Peter Jones', 'Susan White', 'Mike Green', 'Emily Clark', 'David Wilson', 'Sarah Davis', 'Chris Taylor', 'Laura Brown'];
    const skills = ['Auto Insurance', 'Home Insurance', 'Life Insurance', 'Fraud Investigation', 'Customer Support', 'Risk Assessment', 'Commercial Policies', 'Claims Adjudication', 'Policy Sales'];
    const departments = ['Claims', 'Underwriting', 'Sales', 'Customer Service', 'Administration', 'IT'];

    for (let i = 0; i < count; i++) {
        const name = names[Math.floor(Math.random() * names.length)];
        const role = roles[Math.floor(Math.random() * roles.length)];
        const userSkills = Array.from({ length: Math.floor(1 + Math.random() * 3) }, () => skills[Math.floor(Math.random() * skills.length)]);

        users.push({
            id: `USR-${Math.floor(100 + Math.random() * 900)}`,
            name: name,
            email: `${name.toLowerCase().replace(' ', '.')}@insurancecorp.com`,
            role: role as any,
            managedPolicyIds: [], // Will be populated later
            managedClaimIds: [], // Will be populated later
            skills: Array.from(new Set(userSkills)), // Remove duplicates
            lastLogin: getRandomDate(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), new Date()),
            isActive: Math.random() > 0.05, // 95% active
            department: departments[Math.floor(Math.random() * departments.length)],
        });
    }
    return users;
};

/**
 * Generates mock AI model configurations.
 * @returns {AIModelConfig[]} Array of mock AI model configurations.
 */
export const generateMockAIConfigs = (): AIModelConfig[] => {
    const configs: AIModelConfig[] = [];
    const aiTypes: AIModelConfig['type'][] = ['Claim Assessment', 'Underwriting', 'Fraud Detection', 'Document OCR', 'Sentiment Analysis', 'Chatbot'];
    const modelIds = ['gemini-2.5-flash', 'gemini-1.5-pro', 'claude-3-opus', 'gpt-4o', 'llama-3-8b'];

    aiTypes.forEach((type, index) => {
        configs.push({
            id: `AI-CFG-${index + 1}`,
            name: `${type} Model`,
            description: `Configuration for the ${type.toLowerCase()} AI model. This model assists with ${type.toLowerCase()} tasks, improving efficiency and accuracy across the platform.`,
            type: type as any,
            modelId: modelIds[Math.floor(Math.random() * modelIds.length)],
            temperature: parseFloat((0.2 + Math.random() * 0.7).toFixed(1)),
            topP: parseFloat((0.5 + Math.random() * 0.4).toFixed(1)),
            maxOutputTokens: Math.floor(256 + Math.random() * 768),
            enabled: Math.random() > 0.1, // 90% enabled
            lastUpdated: getRandomDate(new Date('2023-06-01'), new Date()),
            updatedBy: 'admin_user',
            confidenceThreshold: type === 'Fraud Detection' ? parseFloat((0.7 + Math.random() * 0.2).toFixed(2)) : undefined,
        });
    });
    return configs;
};

/**
 * Generates mock audit log entries.
 * @param {number} count - Number of log entries to generate.
 * @param {UserProfile[]} users - List of users for logging.
 * @param {InsuranceClaim[]} claims - List of claims.
 * @param {InsurancePolicy[]} policies - List of policies.
 * @param {Customer[]} customers - List of customers.
 * @returns {AuditLogEntry[]} Array of mock audit log entries.
 */
export const generateMockAuditLogs = (
    count: number,
    users: UserProfile[],
    claims: InsuranceClaim[],
    policies: InsurancePolicy[],
    customers: Customer[]
): AuditLogEntry[] => {
    const logs: AuditLogEntry[] = [];
    const actions = ['Created', 'Updated Status', 'Modified Details', 'Approved', 'Denied', 'Viewed', 'Uploaded Document', 'Assigned Task', 'Deleted'];
    const entityTypes: AuditLogEntry['entityType'][] = ['Claim', 'Policy', 'Customer', 'Task', 'Document', 'AIConfig', 'User'];
    const ipAddresses = ['192.168.1.1', '10.0.0.5', '172.16.0.10', null];

    for (let i = 0; i < count; i++) {
        const user = users[Math.floor(Math.random() * users.length)];
        const action = actions[Math.floor(Math.random() * actions.length)];
        const entityType = entityTypes[Math.floor(Math.random() * entityTypes.length)];
        let entityId = '';

        if (entityType === 'Claim' && claims.length > 0) {
            entityId = claims[Math.floor(Math.random() * claims.length)].id;
        } else if (entityType === 'Policy' && policies.length > 0) {
            entityId = policies[Math.floor(Math.random() * policies.length)].id;
        } else if (entityType === 'Customer' && customers.length > 0) {
            entityId = customers[Math.floor(Math.random() * customers.length)].id;
        } else if (entityType === 'Task' && users.length > 0) { // Using users as a proxy for tasks, just for ID
            entityId = generateUUID();
        } else if (entityType === 'Document' && users.length > 0) {
            entityId = generateUUID();
        } else if (entityType === 'AIConfig' && users.length > 0) {
            entityId = `AI-CFG-${Math.floor(Math.random() * 5) + 1}`;
        } else if (entityType === 'User') {
            entityId = user.id;
        } else {
            entityId = 'N/A';
        }

        const oldValue = Math.random() > 0.5 ? JSON.stringify({ status: 'OldStatus' }) : null;
        const newValue = Math.random() > 0.5 ? JSON.stringify({ status: 'NewStatus' }) : null;

        logs.push({
            id: generateUUID(),
            timestamp: getRandomDate(new Date(Date.now() - 90 * 24 * 60 * 60 * 1000), new Date()), // Last 90 days
            userId: user.id,
            userName: user.name,
            action: `${action} ${entityType.toLowerCase()}`,
            entityType: entityType,
            entityId: entityId,
            oldValue: oldValue,
            newValue: newValue,
            ipAddress: ipAddresses[Math.floor(Math.random() * ipAddresses.length)],
        });
    }
    return logs;
};

/**
 * Generates mock communication messages.
 * @param {number} count - Number of messages to generate.
 * @param {Customer[]} customers - List of customers.
 * @param {UserProfile[]} users - List of users.
 * @param {InsuranceClaim[]} claims - List of claims.
 * @param {InsurancePolicy[]} policies - List of policies.
 * @returns {CommunicationMessage[]} Array of mock messages.
 */
export const generateMockCommunicationMessages = (
    count: number,
    customers: Customer[],
    users: UserProfile[],
    claims: InsuranceClaim[],
    policies: InsurancePolicy[]
): CommunicationMessage[] => {
    const messages: CommunicationMessage[] = [];
    const contents = [
        'Called customer to confirm claim details. Left voicemail.',
        'Customer emailed asking for policy renewal options.',
        'Internal note: Underwriter needs to review additional documents.',
        'Chat with customer about billing discrepancy. Resolved.',
        'Follow-up email sent regarding outstanding claim documents for CLM-ID.',
        'Customer called regarding the status of their Auto policy POL-ID.',
        'Received photos of vehicle damage for claim CLM-ID.'
    ];
    const channels = ['Email', 'Chat', 'Call Log', 'Internal Note'];
    const sentiments = ['Positive', 'Neutral', 'Negative'];

    for (let i = 0; i < count; i++) {
        const customer = customers[Math.floor(Math.random() * customers.length)];
        const senderType = Math.random() > 0.7 ? 'Customer' : 'User';
        const senderId = senderType === 'User' ? users[Math.floor(Math.random() * users.length)].id : customer.id;
        const timestamp = getRandomDate(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), new Date());
        const contentTemplate = contents[Math.floor(Math.random() * contents.length)];
        const channel = channels[Math.floor(Math.random() * channels.length)] as any;
        const aiSentiment = sentiments[Math.floor(Math.random() * sentiments.length)] as any;

        let relatedClaimId: string | null = null;
        let relatedPolicyId: string | null = null;

        if (Math.random() > 0.5 && claims.length > 0) {
            relatedClaimId = claims[Math.floor(Math.random() * claims.length)].id;
        } else if (Math.random() > 0.5 && policies.length > 0) {
            relatedPolicyId = policies[Math.floor(Math.random() * policies.length)].id;
        }

        const content = contentTemplate
            .replace('CLM-ID', relatedClaimId || `CLM-${Math.floor(1000 + Math.random() * 9000)}`)
            .replace('POL-ID', relatedPolicyId || `POL-${Math.floor(100000 + Math.random() * 900000)}`);

        messages.push({
            id: generateUUID(),
            customerId: customer.id,
            senderId: senderId,
            senderType: senderType,
            timestamp: timestamp,
            content: content,
            channel: channel,
            relatedClaimId: relatedClaimId,
            relatedPolicyId: relatedPolicyId,
            aiSentiment: Math.random() > 0.3 ? aiSentiment : undefined,
        });
    }
    return messages;
};


// --- Extended Data Context State Interface ---
/**
 * Interface for the extended data context state, including new entities.
 * @interface ExtendedDataContextState
 * @property {InsuranceClaim[]} insuranceClaims - Existing insurance claims.
 * @property {Customer[]} customers - List of customers.
 * @property {InsurancePolicy[]} insurancePolicies - List of insurance policies.
 * @property {AgentTask[]} agentTasks - List of agent tasks.
 * @property {Notification[]} notifications - List of user notifications.
 * @property {Document[]} documents - List of uploaded documents.
 * @property {FinancialTransaction[]} financialTransactions - List of financial transactions.
 * @property {UserProfile[]} userProfiles - List of system user profiles.
 * @property {AIModelConfig[]} aiConfigs - List of AI model configurations.
 * @property {AuditLogEntry[]} auditLogs - List of system audit log entries.
 * @property {CommunicationMessage[]} communicationMessages - List of communication messages.
 * @property {function(InsuranceClaim): void} updateClaimStatus - Function to update claim status (simulated).
 * @property {function(AgentTask): void} updateTask - Function to update task (simulated).
 * @property {function(Notification): void} markNotificationAsRead - Function to mark notification as read (simulated).
 * @property {function(InsurancePolicy): void} updatePolicyStatus - Function to update policy status (simulated).
 * @property {function(Document): void} addDocument - Function to add a new document (simulated).
 * @property {function(AIModelConfig): void} updateAIConfig - Function to update an AI model configuration (simulated).
 * @property {function(Customer): void} updateCustomer - Function to update a customer profile (simulated).
 * @property {function(UserProfile): void} updateUserProfile - Function to update a user profile (simulated).
 * @property {function(FinancialTransaction): void} addTransaction - Function to add a new financial transaction (simulated).
 * @property {function(AgentTask): void} addTask - Function to add a new task (simulated).
 */
export interface ExtendedDataContextState {
    insuranceClaims: InsuranceClaim[];
    customers: Customer[];
    insurancePolicies: InsurancePolicy[];
    agentTasks: AgentTask[];
    notifications: Notification[];
    documents: Document[];
    financialTransactions: FinancialTransaction[];
    userProfiles: UserProfile[];
    aiConfigs: AIModelConfig[];
    auditLogs: AuditLogEntry[];
    communicationMessages: CommunicationMessage[];

    updateClaimStatus: (claim: InsuranceClaim) => void;
    updateTask: (task: AgentTask) => void;
    markNotificationAsRead: (notification: Notification) => void;
    updatePolicyStatus: (policy: InsurancePolicy) => void;
    addDocument: (document: Document) => void;
    updateAIConfig: (config: AIModelConfig) => void;
    updateCustomer: (customer: Customer) => void; // Placeholder
    updateUserProfile: (user: UserProfile) => void; // Placeholder
    addTransaction: (transaction: FinancialTransaction) => void; // Placeholder
    addTask: (task: AgentTask) => void;
}

// --- Helper Components & Hooks (Exported) ---

/**
 * Custom hook for debouncing a value.
 * @param {T} value - The value to debounce.
 * @param {number} delay - The debounce delay in milliseconds.
 * @returns {T} The debounced value.
 * @template T
 */
export function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}

/**
 * A basic search input component with debounce.
 * @param {object} props - Component props.
 * @param {string} props.placeholder - Placeholder text for the input.
 * @param {function(string): void} props.onSearch - Callback function on search term change.
 * @param {string} [props.initialValue] - Initial value for the input.
 * @returns {React.FC} SearchInput component.
 */
export const SearchInput: React.FC<{ placeholder: string; onSearch: (term: string) => void; initialValue?: string }> = ({ placeholder, onSearch, initialValue = '' }) => {
    const [searchTerm, setSearchTerm] = useState(initialValue);
    const debouncedSearchTerm = useDebounce(searchTerm, 500);

    useEffect(() => {
        onSearch(debouncedSearchTerm);
    }, [debouncedSearchTerm, onSearch]);

    return (
        <input
            type="text"
            placeholder={placeholder}
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="p-2 border border-gray-700 rounded-md bg-gray-800 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500 w-full md:w-auto"
        />
    );
};

/**
 * Pagination controls component.
 * @param {object} props - Component props.
 * @param {number} props.currentPage - The current page number (1-indexed).
 * @param {number} props.totalPages - Total number of pages.
 * @param {function(number): void} props.onPageChange - Callback function when page changes.
 * @returns {React.FC} Pagination component.
 */
export const Pagination: React.FC<{ currentPage: number; totalPages: number; onPageChange: (page: number) => void }> = ({ currentPage, totalPages, onPageChange }) => {
    const getPageNumbers = () => {
        const pages = [];
        const maxPageButtons = 5; // Max buttons to show
        let startPage = Math.max(1, currentPage - Math.floor(maxPageButtons / 2));
        let endPage = Math.min(totalPages, startPage + maxPageButtons - 1);

        if (endPage - startPage + 1 < maxPageButtons) {
            startPage = Math.max(1, endPage - maxPageButtons + 1);
        }

        for (let i = startPage; i <= endPage; i++) {
            pages.push(i);
        }
        return pages;
    };

    const pageNumbers = getPageNumbers();

    if (totalPages <= 1) return null; // Don't show pagination if only one page

    return (
        <div className="flex justify-center items-center space-x-2 mt-4 text-white">
            <button
                onClick={() => onPageChange(1)}
                disabled={currentPage === 1}
                className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs"
            >
                First
            </button>
            <button
                onClick={() => onPageChange(currentPage - 1)}
                disabled={currentPage === 1}
                className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs"
            >
                Prev
            </button>
            {pageNumbers.map(page => (
                <button
                    key={page}
                    onClick={() => onPageChange(page)}
                    className={`px-3 py-1 rounded-md text-xs ${currentPage === page ? 'bg-cyan-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}
                >
                    {page}
                </button>
            ))}
            <button
                onClick={() => onPageChange(currentPage + 1)}
                disabled={currentPage === totalPages}
                className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs"
            >
                Next
            </button>
            <button
                onClick={() => onPageChange(totalPages)}
                disabled={currentPage === totalPages}
                className="px-3 py-1 rounded-md bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed text-xs"
            >
                Last
            </button>
        </div>
    );
};

/**
 * A reusable modal component.
 * @param {object} props - Component props.
 * @param {boolean} props.isOpen - Whether the modal is open.
 * @param {function(): void} props.onClose - Callback to close the modal.
 * @param {string} props.title - Title of the modal.
 * @param {React.ReactNode} props.children - Content of the modal.
 * @param {string} [props.maxWidth] - Max width CSS class (e.g., 'max-w-xl').
 * @returns {React.FC} Modal component.
 */
export const Modal: React.FC<{ isOpen: boolean; onClose: () => void; title: string; children: React.ReactNode; maxWidth?: string }> = ({ isOpen, onClose, title, children, maxWidth = 'max-w-2xl' }) => {
    if (!isOpen) return null;

    const modalRef = useRef<HTMLDivElement>(null);

    const handleBackdropClick = (e: React.MouseEvent<HTMLDivElement>) => {
        if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
            onClose();
        }
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[100] backdrop-blur-sm p-4" onClick={handleBackdropClick}>
            <div ref={modalRef} className={`bg-gray-800 rounded-lg shadow-2xl ${maxWidth} w-full border border-gray-700 max-h-[90vh] flex flex-col`}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center flex-shrink-0">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
                </div>
                <div className="p-6 overflow-y-auto flex-grow">
                    {children}
                </div>
            </div>
        </div>
    );
};

/**
 * Pill component for displaying tags or categories.
 * @param {object} props - Component props.
 * @param {string} props.text - Text to display.
 * @param {string} [props.colorClass] - Tailwind CSS classes for background and text color.
 * @returns {React.FC} Pill component.
 */
export const Pill: React.FC<{ text: string; colorClass?: string }> = ({ text, colorClass = 'bg-blue-500/20 text-blue-300' }) => {
    return (
        <span className={`px-2 py-1 text-xs font-medium rounded-full ${colorClass}`}>
            {text}
        </span>
    );
};

/**
 * Dropdown select component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the select input.
 * @param {string} props.name - Name attribute for the select input.
 * @param {string} props.value - Current selected value.
 * @param {function(React.ChangeEvent<HTMLSelectElement>): void} props.onChange - Handler for change event.
 * @param {{value: string; label: string}[]} props.options - Array of options to display.
 * @param {boolean} [props.required] - Whether the field is required.
 * @param {string} [props.className] - Additional CSS classes.
 * @returns {React.FC} Select component.
 */
export const Select: React.FC<{
    label: string;
    name: string;
    value: string;
    onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
    options: { value: string; label: string }[];
    required?: boolean;
    className?: string;
}> = ({ label, name, value, onChange, options, required = false, className = '' }) => {
    return (
        <div className={`mb-4 ${className}`}>
            <label htmlFor={name} className="block text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
            <select
                id={name}
                name={name}
                value={value}
                onChange={onChange}
                required={required}
                className="block w-full px-3 py-2 border border-gray-700 rounded-md bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm"
            >
                {options.map((option) => (
                    <option key={option.value} value={option.value}>{option.label}</option>
                ))}
            </select>
        </div>
    );
};

/**
 * Text input component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the input.
 * @param {string} props.name - Name attribute for the input.
 * @param {string | number} props.value - Current value.
 * @param {function(React.ChangeEvent<HTMLInputElement>): void} props.onChange - Handler for change event.
 * @param {string} [props.type] - Input type (default 'text').
 * @param {boolean} [props.required] - Whether the field is required.
 * @param {string} [props.className] - Additional CSS classes.
 * @param {boolean} [props.readOnly] - Whether the input is read-only.
 * @returns {React.FC} TextInput component.
 */
export const TextInput: React.FC<{
    label: string;
    name: string;
    value: string | number;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    type?: string;
    required?: boolean;
    className?: string;
    readOnly?: boolean;
}> = ({ label, name, value, onChange, type = 'text', required = false, className = '', readOnly = false }) => {
    return (
        <div className={`mb-4 ${className}`}>
            <label htmlFor={name} className="block text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
            <input
                type={type}
                id={name}
                name={name}
                value={value}
                onChange={onChange}
                required={required}
                readOnly={readOnly}
                className={`block w-full px-3 py-2 border border-gray-700 rounded-md bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm ${readOnly ? 'bg-gray-700 cursor-not-allowed' : ''}`}
            />
        </div>
    );
};

/**
 * Date input component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the input.
 * @param {string} props.name - Name attribute for the input.
 * @param {string} props.value - Current value (ISO date string, e.g., 'YYYY-MM-DD').
 * @param {function(React.ChangeEvent<HTMLInputElement>): void} props.onChange - Handler for change event.
 * @param {boolean} [props.required] - Whether the field is required.
 * @param {string} [props.className] - Additional CSS classes.
 * @returns {React.FC} DateInput component.
 */
export const DateInput: React.FC<{
    label: string;
    name: string;
    value: string;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    required?: boolean;
    className?: string;
}> = ({ label, name, value, onChange, required = false, className = '' }) => {
    return (
        <div className={`mb-4 ${className}`}>
            <label htmlFor={name} className="block text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
            <input
                type="date"
                id={name}
                name={name}
                value={value}
                onChange={onChange}
                required={required}
                className="block w-full px-3 py-2 border border-gray-700 rounded-md bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm"
            />
        </div>
    );
};

/**
 * Textarea input component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the textarea.
 * @param {string} props.name - Name attribute for the textarea.
 * @param {string} props.value - Current value.
 * @param {function(React.ChangeEvent<HTMLTextAreaElement>): void} props.onChange - Handler for change event.
 * @param {boolean} [props.required] - Whether the field is required.
 * @param {number} [props.rows] - Number of rows for the textarea.
 * @param {string} [props.className] - Additional CSS classes.
 * @returns {React.FC} TextareaInput component.
 */
export const TextareaInput: React.FC<{
    label: string;
    name: string;
    value: string;
    onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
    required?: boolean;
    rows?: number;
    className?: string;
}> = ({ label, name, value, onChange, required = false, rows = 3, className = '' }) => {
    return (
        <div className={`mb-4 ${className}`}>
            <label htmlFor={name} className="block text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
            <textarea
                id={name}
                name={name}
                value={value}
                onChange={onChange}
                required={required}
                rows={rows}
                className="block w-full px-3 py-2 border border-gray-700 rounded-md bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm"
            />
        </div>
    );
};

/**
 * File input component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the file input.
 * @param {string} props.name - Name attribute for the file input.
 * @param {function(React.ChangeEvent<HTMLInputElement>): void} props.onChange - Handler for change event.
 * @param {boolean} [props.required] - Whether the field is required.
 * @param {string} [props.accept] - Accepted file types.
 * @param {React.RefObject<HTMLInputElement>} [props.ref] - Ref for the input element.
 * @returns {React.FC} FileInput component.
 */
export const FileInput: React.FC<{
    label: string;
    name: string;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    required?: boolean;
    accept?: string;
    ref?: React.RefObject<HTMLInputElement>;
}> = ({ label, name, onChange, required = false, accept = '*/*', ref }) => {
    return (
        <div className="mb-4">
            <label htmlFor={name} className="block text-sm font-medium text-gray-300 mb-1">{label}{required && <span className="text-red-500">*</span>}</label>
            <input
                type="file"
                id={name}
                name={name}
                onChange={onChange}
                required={required}
                accept={accept}
                ref={ref}
                className="block w-full text-sm text-gray-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-cyan-600 file:text-white
                hover:file:bg-cyan-700"
            />
        </div>
    );
};

/**
 * Toggle switch component.
 * @param {object} props - Component props.
 * @param {string} props.label - Label for the toggle.
 * @param {boolean} props.checked - Current state of the toggle.
 * @param {function(React.ChangeEvent<HTMLInputElement>): void} props.onChange - Handler for change event.
 * @param {string} [props.className] - Additional CSS classes.
 * @returns {React.FC} Toggle component.
 */
export const Toggle: React.FC<{ label: string; checked: boolean; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; className?: string }> = ({ label, checked, onChange, className = '' }) => {
    return (
        <label htmlFor={`toggle-${label.replace(/\s+/g, '-')}`} className={`flex items-center cursor-pointer mb-4 ${className}`}>
            <div className="relative">
                <input
                    type="checkbox"
                    id={`toggle-${label.replace(/\s+/g, '-')}`}
                    className="sr-only"
                    checked={checked}
                    onChange={onChange}
                />
                <div className="block bg-gray-600 w-14 h-8 rounded-full"></div>
                <div className={`dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition ${checked ? 'translate-x-full bg-cyan-500' : ''}`}></div>
            </div>
            <div className="ml-3 text-gray-300 font-medium text-sm">{label}</div>
        </label>
    );
};

/**
 * Tab Navigation Component for the main view.
 * @param {object} props - Component props.
 * @param {string} props.activeTab - Currently active tab.
 * @param {function(string): void} props.onTabChange - Callback when tab changes.
 * @param {{id: string; label: string; notificationCount?: number}[]} props.tabs - Array of tab objects with optional notification count.
 * @returns {React.FC} Tabs component.
 */
export const Tabs: React.FC<{ activeTab: string; onTabChange: (tabId: string) => void; tabs: { id: string; label: string; notificationCount?: number }[] }> = ({ activeTab, onTabChange, tabs }) => {
    return (
        <div className="border-b border-gray-700 mb-6 sticky top-0 bg-gray-900 z-10 -mx-6 px-6"> {/* Added sticky header */}
            <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                {tabs.map((tab) => (
                    <button
                        key={tab.id}
                        onClick={() => onTabChange(tab.id)}
                        className={`${activeTab === tab.id
                            ? 'border-cyan-500 text-cyan-400'
                            : 'border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500'
                            } whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm focus:outline-none flex items-center`}
                    >
                        {tab.label}
                        {tab.notificationCount && tab.notificationCount > 0 && (
                            <span className="ml-2 inline-flex items-center justify-center px-2 py-0.5 text-xs font-bold leading-none text-red-100 bg-red-600 rounded-full">
                                {tab.notificationCount}
                            </span>
                        )}
                    </button>
                ))}
            </nav>
        </div>
    );
};

// --- Data Provider Extension (Simulated) ---
/**
 * Extends the DataContext with mock data and simulated update functions.
 * This function should be called within the original DataProvider to provide extended context.
 * For the purpose of this exercise, we'll manually instantiate this data within InsuranceHubView.
 * @param {InsuranceClaim[]} initialClaims - Initial claims data from the original DataContext.
 * @returns {ExtendedDataContextState} The extended data context state.
 */
export const useExtendedDataContext = (initialClaims: InsuranceClaim[]): ExtendedDataContextState => {
    const [customers, setCustomers] = useState<Customer[]>(() => generateMockCustomers(100));
    const [userProfiles, setUserProfiles] = useState<UserProfile[]>(() => generateMockUserProfiles(15));
    const [policies, setPolicies] = useState<InsurancePolicy[]>(() => generateMockPolicies(200, customers));
    const [claims, setClaims] = useState<InsuranceClaim[]>(initialClaims.length > 0 ? initialClaims : generateMockClaims(50, customers, policies));
    const [tasks, setTasks] = useState<AgentTask[]>(() => generateMockTasks(150, userProfiles, claims, policies, customers));
    const [notifications, setNotifications] = useState<Notification[]>(() => generateMockNotifications(50, userProfiles));
    const [documents, setDocuments] = useState<Document[]>(() => generateMockDocuments(300, claims, policies, customers, userProfiles));
    const [transactions, setTransactions] = useState<FinancialTransaction[]>(() => generateMockFinancialTransactions(500, claims, policies));
    const [aiConfigs, setAiConfigs] = useState<AIModelConfig[]>(() => generateMockAIConfigs());
    const [auditLogs, setAuditLogs] = useState<AuditLogEntry[]>(() => generateMockAuditLogs(200, userProfiles, claims, policies, customers));
    const [communicationMessages, setCommunicationMessages] = useState<CommunicationMessage[]>(() => generateMockCommunicationMessages(400, customers, userProfiles, claims, policies));


    // Link policies/claims to users (simulated assignment)
    useEffect(() => {
        // This effect runs only once to initialize user's managed items
        // In a real app, this would be handled server-side or with more sophisticated state updates.
        const updatedUsers = userProfiles.map(user => {
            const userPolicies = policies.filter(p => p.agentId === user.id).map(p => p.id);
            const userClaims = claims.filter(c => c.assignedTo === user.id).map(c => c.id);
            return { ...user, managedPolicyIds: userPolicies, managedClaimIds: userClaims };
        });
        setUserProfiles(updatedUsers);
    }, [userProfiles.length, policies.length, claims.length]); // eslint-disable-line react-hooks/exhaustive-deps
    // Only re-run if underlying data array lengths change drastically, mimicking a "load once" behavior.

    const recordAuditLog = useCallback((action: string, entityType: AuditLogEntry['entityType'], entityId: string, userId: string, userName: string, oldValue: any = null, newValue: any = null) => {
        const newLog: AuditLogEntry = {
            id: generateUUID(),
            timestamp: new Date(),
            userId: userId,
            userName: userName,
            action: action,
            entityType: entityType,
            entityId: entityId,
            oldValue: oldValue ? JSON.stringify(oldValue) : null,
            newValue: newValue ? JSON.stringify(newValue) : null,
            ipAddress: '127.0.0.1', // Simulate local IP
        };
        setAuditLogs(prev => [newLog, ...prev]);
        console.log("Audit Logged:", newLog);
    }, []);

    const sendNotification = useCallback((message: string, type: Notification['type'], recipients: string[], link: string | null = null) => {
        const newNotification: Notification = {
            id: generateUUID(),
            message,
            type,
            timestamp: new Date(),
            read: false,
            link,
            recipients,
        };
        setNotifications(prev => [newNotification, ...prev]);
        console.log("Notification Sent:", newNotification);
    }, []);


    const updateClaimStatus = useCallback((updatedClaim: InsuranceClaim) => {
        const oldClaim = claims.find(c => c.id === updatedClaim.id);
        if (oldClaim?.status !== updatedClaim.status) {
            setClaims(prev => prev.map(c => c.id === updatedClaim.id ? updatedClaim : c));
            recordAuditLog('Updated Claim Status', 'Claim', updatedClaim.id, 'current_user_id', 'Current User', { status: oldClaim?.status }, { status: updatedClaim.status });
            sendNotification(`Claim ${updatedClaim.id} status updated to ${updatedClaim.status}.`, 'info', ['current_user_id', 'assigned_agent_id']);
        }
    }, [claims, recordAuditLog, sendNotification]);

    const updateTask = useCallback((updatedTask: AgentTask) => {
        const oldTask = tasks.find(t => t.id === updatedTask.id);
        setTasks(prev => prev.map(t => t.id === updatedTask.id ? updatedTask : t));
        recordAuditLog(
            oldTask ? 'Updated Task' : 'Created Task',
            'Task', updatedTask.id, 'current_user_id', 'Current User',
            oldTask, updatedTask
        );
        sendNotification(`Task "${updatedTask.title}" updated to ${updatedTask.status}.`, 'info', [updatedTask.assignedTo]);
    }, [tasks, recordAuditLog, sendNotification]);

    const addTask = useCallback((newTask: AgentTask) => {
        setTasks(prev => [newTask, ...prev]);
        recordAuditLog('Created Task', 'Task', newTask.id, 'current_user_id', 'Current User', null, newTask);
        sendNotification(`New task "${newTask.title}" assigned to you.`, 'info', [newTask.assignedTo]);
    }, [recordAuditLog, sendNotification]);

    const markNotificationAsRead = useCallback((notificationToMark: Notification) => {
        setNotifications(prev => prev.map(n => n.id === notificationToMark.id ? { ...n, read: true } : n));
        recordAuditLog('Marked Notification as Read', 'Notification', notificationToMark.id, 'current_user_id', 'Current User', { read: false }, { read: true });
    }, [recordAuditLog]);

    const updatePolicyStatus = useCallback((updatedPolicy: InsurancePolicy) => {
        const oldPolicy = policies.find(p => p.id === updatedPolicy.id);
        if (oldPolicy?.status !== updatedPolicy.status) {
            setPolicies(prev => prev.map(p => p.id === updatedPolicy.id ? updatedPolicy : p));
            recordAuditLog('Updated Policy Status', 'Policy', updatedPolicy.id, 'current_user_id', 'Current User', { status: oldPolicy?.status }, { status: updatedPolicy.status });
            sendNotification(`Policy ${updatedPolicy.id} status updated to ${updatedPolicy.status}.`, 'info', ['current_user_id', oldPolicy?.agentId || '']);
        }
    }, [policies, recordAuditLog, sendNotification]);

    const addDocument = useCallback((newDoc: Document) => {
        setDocuments(prev => [newDoc, ...prev]);
        recordAuditLog('Uploaded Document', 'Document', newDoc.id, newDoc.uploadedBy, 'Current User', null, newDoc);
        sendNotification(`New document "${newDoc.fileName}" uploaded.`, 'info', ['current_user_id']);
    }, [recordAuditLog, sendNotification]);

    const updateAIConfig = useCallback((updatedConfig: AIModelConfig) => {
        const oldConfig = aiConfigs.find(c => c.id === updatedConfig.id);
        setAiConfigs(prev => prev.map(c => c.id === updatedConfig.id ? updatedConfig : c));
        recordAuditLog('Updated AI Configuration', 'AIConfig', updatedConfig.id, 'current_user_id', updatedConfig.updatedBy, oldConfig, updatedConfig);
        sendNotification(`AI Model configuration "${updatedConfig.name}" updated.`, 'warning', ['admin_user_id']);
    }, [aiConfigs, recordAuditLog, sendNotification]);

    const updateCustomer = useCallback((updatedCustomer: Customer) => {
        const oldCustomer = customers.find(c => c.id === updatedCustomer.id);
        setCustomers(prev => prev.map(c => c.id === updatedCustomer.id ? updatedCustomer : c));
        recordAuditLog('Updated Customer Profile', 'Customer', updatedCustomer.id, 'current_user_id', 'Current User', oldCustomer, updatedCustomer);
        sendNotification(`Customer profile for ${updatedCustomer.name} updated.`, 'info', ['current_user_id']);
    }, [customers, recordAuditLog, sendNotification]);

    const updateUserProfile = useCallback((updatedUser: UserProfile) => {
        const oldUser = userProfiles.find(u => u.id === updatedUser.id);
        setUserProfiles(prev => prev.map(u => u.id === updatedUser.id ? updatedUser : u));
        recordAuditLog('Updated User Profile', 'User', updatedUser.id, 'current_user_id', 'Current User', oldUser, updatedUser);
        sendNotification(`User profile for ${updatedUser.name} updated by admin.`, 'info', [updatedUser.id]);
    }, [userProfiles, recordAuditLog, sendNotification]);

    const addTransaction = useCallback((newTransaction: FinancialTransaction) => {
        setTransactions(prev => [newTransaction, ...prev]);
        recordAuditLog('Added Financial Transaction', 'FinancialTransaction', newTransaction.id, 'system', 'System', null, newTransaction);
        sendNotification(`New financial transaction: ${newTransaction.type} for $${newTransaction.amount}.`, 'success', ['finance_dept_id']);
    }, [recordAuditLog, sendNotification]);


    return {
        insuranceClaims: claims,
        customers: customers,
        insurancePolicies: policies,
        agentTasks: tasks,
        notifications: notifications,
        documents: documents,
        financialTransactions: transactions,
        userProfiles: userProfiles,
        aiConfigs: aiConfigs,
        auditLogs: auditLogs,
        communicationMessages: communicationMessages,

        updateClaimStatus: updateClaimStatus,
        updateTask: updateTask,
        markNotificationAsRead: markNotificationAsRead,
        updatePolicyStatus: updatePolicyStatus,
        addDocument: addDocument,
        updateAIConfig: updateAIConfig,
        updateCustomer: updateCustomer,
        updateUserProfile: updateUserProfile,
        addTransaction: addTransaction,
        addTask: addTask,
    };
};

/**
 * Claim Detail Modal (Original, but potentially extended if needed)
 */
const ClaimDetailModal: React.FC<{ claim: InsuranceClaim | null; onClose: () => void; }> = ({ claim, onClose }) => {
    const [aiAssessment, setAiAssessment] = useState<any>(null);
    const [isLoadingAI, setIsLoadingAI] = useState(false);
    const extendedContext = useContext(DataContext) as ExtendedDataContextState; // Cast to extended type
    const { updateClaimStatus } = extendedContext;

    if (!claim) return null;

    const generateAssessment = async () => {
        setIsLoadingAI(true);
        setAiAssessment(null);
        try {
            // Use NEXT_PUBLIC_ for client-side environment variables in Next.js
            const ai = new GoogleGenAI({ apiKey: process.env.NEXT_PUBLIC_API_KEY as string });
            const prompt = `You are an expert insurance claims adjudication AI. Based on the claim description "${claim.description}", provide a structured damage assessment and a recommended payout amount. Also, identify any potential red flags for fraud. Output should be JSON with properties: assessment (string), recommendedPayout (number), fraudFlags (string[]), requiredDocuments (string[]), AI_confidence (number, 0-1).`;
            const schema = { type: Type.OBJECT, properties: { assessment: { type: Type.STRING }, recommendedPayout: { type: Type.NUMBER }, fraudFlags: { type: Type.ARRAY, items: { type: Type.STRING } }, requiredDocuments: { type: Type.ARRAY, items: { type: Type.STRING } }, AI_confidence: { type: Type.NUMBER } } };
            const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt, config: { responseMimeType: "application/json", responseSchema: schema } });
            setAiAssessment(JSON.parse(response.text));
        } catch (err) {
            console.error("AI assessment error:", err);
            setAiAssessment({ assessment: 'Error generating assessment.', recommendedPayout: 0, fraudFlags: ['Error in AI analysis'], requiredDocuments: [], AI_confidence: 0 });
        } finally {
            setIsLoadingAI(false);
        }
    };

    const handleStatusChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newStatus = e.target.value as InsuranceClaim['status'];
        if (claim) {
            updateClaimStatus({ ...claim, status: newStatus });
        }
    };

    const getPolicyholderName = useMemo(() => {
        return extendedContext.customers.find(c =>
            extendedContext.insurancePolicies.find(p => p.id === claim.policyId && p.customerId === c.id)
        )?.name || claim.policyholder;
    }, [claim, extendedContext.customers, extendedContext.insurancePolicies]);

    const getAssignedAgentName = useMemo(() => {
        if (!claim.assignedTo) return 'N/A';
        return extendedContext.userProfiles.find(u => u.id === claim.assignedTo)?.name || 'Unknown Agent';
    }, [claim.assignedTo, extendedContext.userProfiles]);

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full border border-gray-700 max-h-[90vh] flex flex-col" onClick={e=>e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center flex-shrink-0">
                    <h3 className="text-lg font-semibold text-white">Claim Details: {claim.id}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
                </div>
                <div className="p-6 space-y-6 overflow-y-auto flex-grow">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm bg-gray-900/50 p-4 rounded-lg">
                        <p className="text-gray-300"><strong className="text-gray-200">Policyholder:</strong> {getPolicyholderName}</p>
                        <p className="text-gray-300"><strong className="text-gray-200">Policy ID:</strong> <span className="font-mono text-cyan-300">{claim.policyId}</span></p>
                        <p className="text-gray-300"><strong className="text-gray-200">Date Filed:</strong> {new Date(claim.dateFiled).toLocaleDateString()}</p>
                        <p className="text-gray-300"><strong className="text-gray-200">Date of Loss:</strong> {new Date(claim.dateOfLoss).toLocaleDateString()}</p>
                        <p className="text-gray-300"><strong className="text-gray-200">Incident Type:</strong> {claim.incidentType}</p>
                        <p className="text-gray-300"><strong className="text-gray-200">Incident Location:</strong> {claim.incidentLocation}</p>
                        <p className="text-gray-300"><strong className="text-gray-200">Amount Claimed:</strong> <span className="font-mono text-white">${claim.amount.toLocaleString()}</span></p>
                        <p className="text-gray-300"><strong className="text-gray-200">Payout Amount:</strong> <span className="font-mono text-green-400">${(claim.payoutAmount || 0).toLocaleString()}</span></p>
                        <p className="text-gray-300"><strong className="text-gray-200">Assigned To:</strong> {getAssignedAgentName}</p>
                        <div className="flex items-center space-x-2">
                            <label htmlFor="claimStatus" className="text-sm text-gray-200">Status:</label>
                            <select
                                id="claimStatus"
                                value={claim.status}
                                onChange={handleStatusChange}
                                className="px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-1 focus:ring-cyan-500"
                            >
                                <option value="New">New</option>
                                <option value="Under Review">Under Review</option>
                                <option value="Approved">Approved</option>
                                <option value="Denied">Denied</option>
                            </select>
                        </div>
                    </div>

                    <Card title="Claim Description">
                        <p className="text-sm text-gray-300">{claim.description}</p>
                        {claim.notes && <p className="text-xs italic text-gray-400 mt-2">Internal notes: {claim.notes}</p>}
                    </Card>

                    <Card title="AI Claims Adjudicator">
                        {isLoadingAI && <p className="text-cyan-400">Analyzing claim with AI, please wait...</p>}
                        {aiAssessment && (
                            <div className="text-sm space-y-3">
                                <p><strong className="text-cyan-300">Assessment:</strong> {aiAssessment.assessment}</p>
                                <p><strong className="text-cyan-300">Recommended Payout:</strong> ${aiAssessment.recommendedPayout.toLocaleString()}</p>
                                {aiAssessment.fraudFlags && aiAssessment.fraudFlags.length > 0 && (
                                    <p className="text-red-400"><strong className="text-red-300">Fraud Flags:</strong> {aiAssessment.fraudFlags.join(', ')}</p>
                                )}
                                {aiAssessment.requiredDocuments && aiAssessment.requiredDocuments.length > 0 && (
                                    <p className="text-yellow-400"><strong className="text-yellow-300">Suggested Documents:</strong> {aiAssessment.requiredDocuments.join(', ')}</p>
                                )}
                                <p className="text-gray-500 text-xs mt-2">AI Confidence: {(aiAssessment.AI_confidence * 100).toFixed(1)}%</p>
                            </div>
                        )}
                        {!aiAssessment && !isLoadingAI && <button onClick={generateAssessment} className="text-sm text-cyan-400 hover:underline">Generate AI Assessment</button>}
                        {aiAssessment && !isLoadingAI && <button onClick={() => setAiAssessment(null)} className="ml-4 text-sm text-gray-400 hover:underline">Clear AI Assessment</button>}
                    </Card>

                    <Card title="Related Documents">
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {extendedContext.documents
                                .filter(doc => doc.relatedEntityId === claim.id)
                                .map(doc => (
                                    <li key={doc.id} className="flex items-center justify-between text-sm text-gray-300 bg-gray-900/50 p-3 rounded-lg border border-gray-700/50">
                                        <span> {doc.fileName} <Pill text={doc.category} /> {doc.tags?.map((tag, idx) => <Pill key={idx} text={tag} colorClass="bg-gray-600/20 text-gray-400" />)}</span>
                                        <a href={doc.url} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline text-xs ml-2 flex-shrink-0">View Document</a>
                                    </li>
                                ))}
                            {extendedContext.documents.filter(doc => doc.relatedEntityId === claim.id).length === 0 && (
                                <p className="text-sm text-gray-500">No documents found for this claim.</p>
                            )}
                        </ul>
                        <button className="mt-4 text-sm text-cyan-400 hover:underline" onClick={() => {/* Trigger document upload modal */}}>Upload New Document</button>
                    </Card>

                    <Card title="Financial Transactions">
                        <ul className="space-y-2 max-h-48 overflow-y-auto">
                            {extendedContext.financialTransactions
                                .filter(tx => tx.entityId === claim.id && tx.entityType === 'Claim')
                                .map(tx => (
                                    <li key={tx.id} className="flex items-center justify-between text-sm text-gray-300 bg-gray-900/50 p-3 rounded-lg border border-gray-700/50">
                                        <span>{tx.type}: <span className={`font-mono ${tx.type === 'Payout' ? 'text-green-400' : 'text-white'}`}>${tx.amount.toLocaleString()}</span> (<Pill text={tx.status} colorClass={
                                            tx.status === 'Completed' ? 'bg-green-500/20 text-green-300' :
                                            tx.status === 'Pending' ? 'bg-yellow-500/20 text-yellow-300' :
                                            'bg-red-500/20 text-red-300'
                                        } />)</span>
                                        <span className="text-xs text-gray-500 ml-2 flex-shrink-0">{new Date(tx.transactionDate).toLocaleDateString()}</span>
                                    </li>
                                ))}
                            {extendedContext.financialTransactions.filter(tx => tx.entityId === claim.id && tx.entityType === 'Claim').length === 0 && (
                                <p className="text-sm text-gray-500">No transactions for this claim.</p>
                            )}
                        </ul>
                    </Card>

                    <Card title="Communication Log">
                        <div className="space-y-3 text-sm max-h-48 overflow-y-auto">
                            {extendedContext.communicationMessages
                                .filter(msg => msg.relatedClaimId === claim.id)
                                .sort((a,b) => a.timestamp.getTime() - b.timestamp.getTime())
                                .map(msg => (
                                    <p key={msg.id} className="bg-gray-900/50 p-3 rounded-lg border border-gray-700/50">
                                        <strong className="text-cyan-300">{msg.senderType === 'User' ? extendedContext.userProfiles.find(u => u.id === msg.senderId)?.name || 'Agent' : extendedContext.customers.find(c => c.id === msg.senderId)?.name || 'Customer'}:</strong> {msg.content}
                                        <span className="block text-xs text-gray-500 mt-1">[{new Date(msg.timestamp).toLocaleString()}] Channel: {msg.channel} {msg.aiSentiment && <Pill text={`AI Sentiment: ${msg.aiSentiment}`} colorClass={
                                            msg.aiSentiment === 'Positive' ? 'bg-green-500/20 text-green-300' :
                                            msg.aiSentiment === 'Negative' ? 'bg-red-500/20 text-red-300' :
                                            'bg-blue-500/20 text-blue-300'
                                        } />}</span>
                                    </p>
                                ))}
                            {extendedContext.communicationMessages.filter(msg => msg.relatedClaimId === claim.id).length === 0 && (
                                <p className="text-sm text-gray-500">No communication logs for this claim.</p>
                            )}
                        </div>
                        <button className="mt-4 text-sm text-cyan-400 hover:underline">Add New Log Entry</button>
                    </Card>
                </div>
            </div>
        </div>
    );
};


/**
 * Policy Detail Modal component.
 * @param {object} props - Component props.
 * @param {InsurancePolicy | null} props.policy - The policy to display.
 * @param {function(): void} props.onClose - Callback to close the modal.
 * @returns {React.FC} PolicyDetailModal component.
 */
export const PolicyDetailModal: React.FC<{ policy: InsurancePolicy | null; onClose: () => void; }> = ({ policy, onClose }) => {
    const extendedContext = useContext(DataContext) as ExtendedDataContextState;
    const { updatePolicyStatus } = extendedContext;

    if (!policy) return null;

    const customer = extendedContext.customers.find(c => c.id === policy.customerId);
    const agent = extendedContext.userProfiles.find(u => u.id === policy.agentId);

    const handleStatusChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newStatus = e.target.value as InsurancePolicy['status'];
        if (policy) {
            updatePolicyStatus({ ...policy, status: newStatus });
        }
    };

    return (
        <Modal isOpen={!!policy} onClose={onClose} title={`Policy Details: ${policy.id}`} maxWidth="max-w-4xl">
            <div className="space-y-6">
                <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm bg-gray-900/50 p-4 rounded-lg">
                    <p className="text-gray-300"><strong className="text-gray-200">Policy Holder:</strong> {policy.policyHolderName}</p>
                    <p className="text-gray-300"><strong className="text-gray-200">Customer ID:</strong> <span className="font-mono text-white">{customer?.id || 'N/A'}</span></p>
                    <p className="text-gray-300"><strong className="text-gray-200">Customer Email:</strong> {customer?.email || 'N/A'}</p>
                    <p className="text-gray-300"><strong className="text-gray-200">Policy Type:</strong> <Pill text={policy.type} colorClass="bg-purple-500/20 text-purple-300" /></p>
                    <p className="text-gray-300"><strong className="text-gray-200">Start Date:</strong> {policy.startDate.toLocaleDateString()}</p>
                    <p className="text-gray-300"><strong className="text-gray-200">End Date:</strong> {policy.endDate.toLocaleDateString()}</p>
                    <p className="text-gray-300"><strong className="text-gray-200">Premium:</strong> <span className="font-mono text-white">${policy.premiumAmount.toLocaleString()}{policy.paymentFrequency ? `/${policy.paymentFrequency}` : ''}</span></p>
                    <p className="text-gray-300"><strong className="text-gray-200">Deductible:</strong> <span className="font-mono text-white">${policy.deductible.toLocaleString()}</span></p>
                    <p className="text-gray-300"><strong className="text-gray-200">Coverage Amount:</strong> <span className="font-mono text-white">${policy.coverageAmount.toLocaleString()}</span></p>
                    <p className="text-gray-300"><strong className="text-gray-200">Last Renewed:</strong> {policy.lastRenewed.toLocaleDateString()}</p>
                    {policy.nextRenewal && <p className="text-gray-300"><strong className="text-gray-200">Next Renewal:</strong> {policy.nextRenewal.toLocaleDateString()}</p>}
                    {agent && <p className="text-gray-300"><strong className="text-gray-200">Assigned Agent:</strong> {agent.name}</p>}
                    <div className="flex items-center space-x-2 col-span-full lg:col-span-1">
                        <label htmlFor="policyStatus" className="text-gray-200">Status:</label>
                        <select
                            id="policyStatus"
                            value={policy.status}
                            onChange={handleStatusChange}
                            className="px-2 py-1 bg-gray-700 border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-1 focus:ring-cyan-500"
                        >
                            <option value="Active">Active</option>
                            <option value="Lapsed">Lapsed</option>
                            <option value="Cancelled">Cancelled</option>
                            <option value="Pending">Pending</option>
                        </select

--- FILE: LoanApplicationsView.tsx ---

import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';
import {
    ChevronLeftIcon,
    ChevronRightIcon,
    MagnifyingGlassIcon,
    ArrowPathIcon,
    FunnelIcon,
    PlusIcon,
    DocumentTextIcon,
    CurrencyDollarIcon,
    CheckCircleIcon,
    XCircleIcon,
    InformationCircleIcon,
    ChartBarIcon,
    UserCircleIcon,
    ClockIcon,
    Bars3Icon,
    EllipsisVerticalIcon,
    PaperClipIcon,
    EnvelopeIcon,
    EyeIcon,
    PencilSquareIcon,
    TrashIcon,
    FolderIcon,
    ShieldCheckIcon,
    SparklesIcon,
    ExclamationTriangleIcon,
    BellIcon,
    TagIcon,
    CalculatorIcon,
    ClipboardDocumentListIcon,
    QueueListIcon,
    BuildingOfficeIcon,
    BanknotesIcon,
    CreditCardIcon,
    UsersIcon,
    HandThumbUpIcon,
    HandThumbDownIcon,
    PresentationChartLineIcon,
    GlobeAltIcon,
    StarIcon,
    ShareIcon,
    CalendarDaysIcon,
    CloudArrowUpIcon,
    CodeBracketIcon,
    ServerStackIcon,
    PhotoIcon,
    VideoCameraIcon,
    WifiIcon,
    LinkIcon,
    CubeIcon,
    BoltIcon,
    KeyIcon,
    LockClosedIcon,
    PuzzlePieceIcon,
    FingerPrintIcon,
    QuestionMarkCircleIcon,
    MegaphoneIcon,
    TruckIcon,
    ScaleIcon,
    QrCodeIcon,
    BugAntIcon,
    ChartPieIcon,
    AcademicCapIcon,
    GiftIcon,
    CurrencyEuroIcon,
    ReceiptPercentIcon,
    WalletIcon,
    TicketIcon,
    BriefcaseIcon,
    ChartBarSquareIcon,
    ArrowUpOnSquareStackIcon,
    Cog6ToothIcon,
    CloudIcon,
    ChartLineUpIcon,
    ArrowDownTrayIcon,
    PlayCircleIcon,
    ListBulletIcon,
    CubeTransparentIcon,
    WindowIcon,
    CursorArrowRaysIcon,
    BeakerIcon,
    Square3Stack3DIcon,
    RocketLaunchIcon,
    LightBulbIcon,
    SunIcon,
    MoonIcon,
    CloudArrowDownIcon,
    AdjustmentsVerticalIcon,
    PaintBrushIcon,
    DevicePhoneIcon,
    ComputerDesktopIcon,
    TvIcon,
    MicrophoneIcon,
    SpeakerWaveIcon,
    HeadphonesIcon,
    CircleStackIcon,
    BugPlayIcon,
    CodeBracketSquareIcon,
    ClipboardDocumentCheckIcon,
    DocumentChartBarIcon,
    SwatchIcon,
    VariableIcon,
    ServerIcon,
    CommandIcon,
    PowerIcon,
    FunnelIcon as FilterIcon,
    ArrowTopRightOnSquareIcon,
    ChartBarIcon as AnalyticsIcon,
    ShieldExclamationIcon,
    GlobeAmericasIcon,
    LightBulbIcon as IdeaIcon,
    PresentationChartBarIcon,
    RectangleGroupIcon,
    TableCellsIcon,
    ArrowPathRoundedSquareIcon,
    ChatBubbleLeftRightIcon,
    ChartBarSquareIcon as ReportingIcon,
    ClipboardDocumentIcon,
    UserGroupIcon,
    DocumentDuplicateIcon,
    ChartBarIcon as DashboardIcon,
    CreditCardIcon as PaymentIcon,
    ReceiptPercentIcon as DiscountIcon,
    BuildingOffice2Icon,
    ClockIcon as HistoryIcon,
    BellIcon as NotificationsIcon,
    TagIcon as CategoryIcon,
    DocumentMagnifyingGlassIcon,
    CloudArrowUpIcon as UploadIcon,
    ShieldCheckIcon as SecurityIcon,
    SparklesIcon as AutomationIcon,
    ExclamationTriangleIcon as AlertIcon,
    Cog6ToothIcon as SettingsIcon,
    InformationCircleIcon as InfoIcon,
    CurrencyDollarIcon as FundingIcon,
    ChartPieIcon as PortfolioIcon,
    UsersIcon as CustomerIcon,
    PresentationChartLineIcon as PerformanceIcon,
    StarIcon as RatingIcon,
    HandThumbUpIcon as ApproveIcon,
    HandThumbDownIcon as RejectIcon,
    BriefcaseIcon as BusinessIcon,
    ChartLineUpIcon as GrowthIcon,
    WalletIcon as PayoutIcon,
    TicketIcon as SupportIcon,
    RocketLaunchIcon as LaunchIcon,
    BeakerIcon as TestingIcon,
    AdjustmentsVerticalIcon as CustomizeIcon,
    PaintBrushIcon as ThemeIcon,
    DevicePhoneIcon as MobileIcon,
    ComputerDesktopIcon as DesktopIcon,
    MicrophoneIcon as VoiceIcon,
    SpeakerWaveIcon as AudioIcon,
    HeadphonesIcon as HeadsetIcon,
    CircleStackIcon as DatabaseIcon,
    BugPlayIcon as DebuggingIcon,
    CodeBracketSquareIcon as CodeIcon,
    ClipboardDocumentCheckIcon as VerifyIcon,
    DocumentChartBarIcon as ReportIcon,
    SwatchIcon as StyleIcon,
    VariableIcon as VariablesIcon,
    ServerIcon as APIIcon,
    CommandIcon as CLI_Icon,
    PowerIcon as PowerSettingsIcon,
    WindowIcon as UI_Icon,
    CursorArrowRaysIcon as InteractionIcon,
    Square3Stack3DIcon as _3DIcon,
    LightBulbIcon as IdeaLightIcon,
    SunIcon as DayIcon,
    MoonIcon as NightIcon,
    CloudArrowDownIcon as DownloadIcon,
    ArrowPathRoundedSquareIcon as SyncIcon,
    ChatBubbleLeftRightIcon as ChatIcon,
    GlobeAmericasIcon as GlobalIcon,
    QuestionMarkCircleIcon as HelpIcon,
    MegaphoneIcon as MarketingIcon,
    TruckIcon as LogisticsIcon,
    ScaleIcon as LegalIcon,
    QrCodeIcon as QRCodeIcon,
    BugAntIcon as IssueIcon,
    AcademicCapIcon as EducationIcon,
    GiftIcon as PromotionIcon,
    CurrencyEuroIcon as EuroIcon,
    ArrowUpOnSquareStackIcon as DeployIcon,
    ArrowDownTrayIcon as ExportIcon,
    PlayCircleIcon as DemoIcon,
    ListBulletIcon as ChecklistIcon,
    CubeTransparentIcon as TransparencyIcon,
    WindowIcon as PopUpIcon,
    BoltIcon as SpeedIcon,
    KeyIcon as AccessKeyIcon,
    LockClosedIcon as LockIcon,
    PuzzlePieceIcon as PluginIcon,
    FingerPrintIcon as BiometricIcon,
    ArchiveBoxIcon,
    InboxStackIcon,
    InboxArrowDownIcon,
    EnvelopeOpenIcon,
    CalendarIcon,
    ChartPieIcon as PieChartIcon,
    PresentationChartBarIcon as BarChartIcon,
    PresentationChartLineIcon as LineChartIcon,
    TableCellsIcon as TableIcon,
    RectangleGroupIcon as GridIcon,
    ChartBarSquareIcon as AreaChartIcon,
    ChartBarIcon as ColumnChartIcon,
    CubeIcon as ModuleIcon,
    ServerStackIcon as InfrastructureIcon,
    CloudIcon as CloudServiceIcon,
    CodeBracketIcon as DevelopmentIcon,
    WifiIcon as ConnectivityIcon,
    LinkIcon as LinkageIcon,
    PhotoIcon as ImageIcon,
    VideoCameraIcon as VideoIcon,
    GlobeAltIcon as WebIcon,
    BookmarkIcon,
    DocumentMagnifyingGlassIcon as SearchDocIcon,
    QueueListIcon as QueueIcon,
    ClipboardDocumentIcon as ClipboardIcon,
    ClipboardDocumentCheckIcon as ComplianceIcon,
    WalletIcon as TreasuryIcon,
    BuildingOfficeIcon as EnterpriseIcon,
    BanknotesIcon as CashflowIcon,
    UsersIcon as TeamIcon,
    HandThumbUpIcon as PositiveSentimentIcon,
    HandThumbDownIcon as NegativeSentimentIcon,
    ChartBarIcon as MetricsIcon,
    PresentationChartLineIcon as TrendIcon,
    GlobeAltIcon as GeolocationIcon,
    StarIcon as FavoriteIcon,
    ShareIcon as ShareActionIcon,
    CalendarDaysIcon as EventIcon,
    CloudArrowUpIcon as UploadFileIcon,
    Cog6ToothIcon as ConfigIcon,
    ArrowUpOnSquareStackIcon as PublishIcon,
    ArrowDownTrayIcon as DownloadFileIcon,
    PlayCircleIcon as PlayIcon,
    ListBulletIcon as ListIcon,
    CubeTransparentIcon as TransparentIcon,
    WindowIcon as ModalIcon,
    CursorArrowRaysIcon as ClickIcon,
    BeakerIcon as ExperimentIcon,
    Square3Stack3DIcon as _3dObjectIcon,
    RocketLaunchIcon as LaunchProcessIcon,
    LightBulbIcon as IdeaGenIcon,
    SunIcon as BrightnessIcon,
    MoonIcon as DarkModeIcon,
    CloudArrowDownIcon as CloudDownloadIcon,
    AdjustmentsVerticalIcon as TuneIcon,
    PaintBrushIcon as StyleEditorIcon,
    DevicePhoneIcon as MobileDeviceIcon,
    ComputerDesktopIcon as DesktopComputerIcon,
    TvIcon as TelevisionIcon,
    MicrophoneIcon as MicIcon,
    SpeakerWaveIcon as SpeakerIcon,
    HeadphonesIcon as HeadphoneIcon,
    CircleStackIcon as StackIcon,
    BugPlayIcon as DebugIcon,
    CodeBracketSquareIcon as CodeEditorIcon,
    ClipboardDocumentCheckIcon as ConfirmIcon,
    DocumentChartBarIcon as ReportGenIcon,
    SwatchIcon as ColorPaletteIcon,
    VariableIcon as DynamicVariableIcon,
    ServerIcon as BackendIcon,
    CommandIcon as CLICommandIcon,
    PowerIcon as PowerControlIcon,
    FunnelIcon as FilterControlIcon,
    ArrowTopRightOnSquareIcon as ExternalLinkIcon,
    ChartBarIcon as AnalyticsDashboardIcon,
    ShieldExclamationIcon as SecurityAlertIcon,
    GlobeAmericasIcon as InternationalIcon,
    LightBulbIcon as InnovationIcon,
    PresentationChartBarIcon as BusinessIntelligenceIcon,
    RectangleGroupIcon as LayoutIcon,
    TableCellsIcon as DataGridIcon,
    ArrowPathRoundedSquareIcon as RefreshIcon,
    ChatBubbleLeftRightIcon as CommunicationIcon,
    ChartBarSquareIcon as KPIIcon,
    ClipboardDocumentIcon as DocumentManagementIcon,
    UserGroupIcon as TeamManagementIcon,
    DocumentDuplicateIcon as DuplicateIcon,
    ChartBarIcon as PerformanceChartIcon,
    CreditCardIcon as PaymentGatewayIcon,
    ReceiptPercentIcon as DiscountManagementIcon,
    BuildingOffice2Icon as CorporateIcon,
    ClockIcon as TimeManagementIcon,
    BellIcon as NotificationCenterIcon,
    TagIcon as TagManagementIcon,
    DocumentMagnifyingGlassIcon as DocumentSearchIcon,
    CloudArrowUpIcon as CloudUploadIcon,
    ShieldCheckIcon as SecurityManagementIcon,
    SparklesIcon as AutomationEngineIcon,
    ExclamationTriangleIcon as WarningIcon,
    Cog6ToothIcon as SystemSettingsIcon,
    InformationCircleIcon as InfoPanelIcon,
    CurrencyDollarIcon as FinanceIcon,
    ChartPieIcon as PortfolioManagementIcon,
    UsersIcon as CustomerManagementIcon,
    PresentationChartLineIcon as TrendAnalysisIcon,
    StarIcon as FavoriteManagementIcon,
    HandThumbUpIcon as ApprovalIcon,
    HandThumbDownIcon as RejectionIcon,
    BriefcaseIcon as BusinessOperationsIcon,
    ChartLineUpIcon as GrowthMetricsIcon,
    WalletIcon as PayoutManagementIcon,
    TicketIcon as SupportTicketIcon,
    RocketLaunchIcon as ProjectLaunchIcon,
    BeakerIcon as ExperimentationIcon,
    AdjustmentsVerticalIcon as CustomizationIcon,
    PaintBrushIcon as ThemingIcon,
    DevicePhoneIcon as MobileAppIcon,
    ComputerDesktopIcon as DesktopAppIcon,
    TvIcon as TVScreenIcon,
    MicrophoneIcon as VoiceCommandIcon,
    SpeakerWaveIcon as AudioOutputIcon,
    HeadphonesIcon as HeadphoneSupportIcon,
    CircleStackIcon as DatabaseManagementIcon,
    BugPlayIcon as DebuggingToolsIcon,
    CodeBracketSquareIcon as CodeEditorToolsIcon,
    ClipboardDocumentCheckIcon as VerificationToolsIcon,
    DocumentChartBarIcon as ReportingToolsIcon,
    SwatchIcon as ColorManagementIcon,
    VariableIcon as VariableManagementIcon,
    ServerIcon as APIManagementIcon,
    CommandIcon as CLIToolsIcon,
    PowerIcon as PowerManagementIcon,
    ArchiveBoxIcon as ArchiveIcon,
    InboxStackIcon as InboxIcon,
    InboxArrowDownIcon as ReceiveIcon,
    EnvelopeOpenIcon as EmailOpenIcon,
    CalendarIcon as DatePickerIcon,
    PieChartIcon as PieChartDisplayIcon,
    BarChartIcon as BarChartDisplayIcon,
    LineChartIcon as LineChartDisplayIcon,
    TableIcon as TableDisplayIcon,
    GridIcon as GridDisplayIcon,
    AreaChartIcon as AreaChartDisplayIcon,
    ColumnChartIcon as ColumnChartDisplayIcon,
    ModuleIcon as ModuleManagementIcon,
    InfrastructureIcon as InfrastructureManagementIcon,
    CloudServiceIcon as CloudServiceManagementIcon,
    DevelopmentIcon as DevelopmentToolsIcon,
    ConnectivityIcon as ConnectivityManagementIcon,
    LinkageIcon as LinkManagementIcon,
    ImageIcon as ImageManagementIcon,
    VideoIcon as VideoManagementIcon,
    WebIcon as WebManagementIcon,
    BookmarkIcon as BookmarkManagementIcon,
    SearchDocIcon as DocumentSearchToolsIcon,
    QueueIcon as QueueManagementIcon,
    ClipboardIcon as ClipboardToolsIcon,
    ComplianceIcon as ComplianceManagementIcon,
    TreasuryIcon as TreasuryManagementIcon,
    EnterpriseIcon as EnterpriseManagementIcon,
    CashflowIcon as CashflowManagementIcon,
    TeamIcon as TeamCollaborationIcon,
    PositiveSentimentIcon as PositiveFeedbackIcon,
    NegativeSentimentIcon as NegativeFeedbackIcon,
    MetricsIcon as MetricsTrackingIcon,
    TrendIcon as TrendTrackingIcon,
    GeolocationIcon as GeolocationTrackingIcon,
    FavoriteIcon as FavoriteTrackingIcon,
    ShareActionIcon as ShareTrackingIcon,
    EventIcon as EventManagementIcon,
    UploadFileIcon as FileUploadIcon,
    ConfigIcon as ConfigurationManagementIcon,
    PublishIcon as PublicationManagementIcon,
    DownloadFileIcon as FileDownloadIcon,
    PlayIcon as MediaPlaybackIcon,
    ListIcon as ListManagementIcon,
    TransparentIcon as TransparencyFeaturesIcon,
    ModalIcon as ModalWindowIcon,
    ClickIcon as ClickTrackingIcon,
    ExperimentIcon as ExperimentationManagementIcon,
    _3dObjectIcon as _3DObjectManagementIcon,
    LaunchProcessIcon as ProcessLaunchIcon,
    IdeaGenIcon as IdeaGenerationIcon,
    BrightnessIcon as BrightnessControlIcon,
    DarkModeIcon as DarkModeToggleIcon,
    CloudDownloadIcon as CloudDownloadServiceIcon,
    TuneIcon as TuningToolsIcon,
    StyleEditorIcon as StyleEditorToolsIcon,
    MobileDeviceIcon as MobileDeviceManagementIcon,
    DesktopComputerIcon as DesktopComputerManagementIcon,
    TelevisionIcon as TelevisionIntegrationIcon,
    MicIcon as MicrophoneInputIcon,
    SpeakerIcon as SpeakerOutputIcon,
    HeadphoneIcon as HeadphoneOutputIcon,
    StackIcon as StackManagementIcon,
    DebugIcon as DebuggingFeatureIcon,
    CodeEditorIcon as CodeEditingFeatureIcon,
    ConfirmIcon as ConfirmationFeatureIcon,
    ReportGenIcon as ReportGenerationFeatureIcon,
    ColorPaletteIcon as ColorPaletteFeatureIcon,
    DynamicVariableIcon as DynamicVariableFeatureIcon,
    BackendIcon as BackendIntegrationIcon,
    CLICommandIcon as CLICommandFeatureIcon,
    PowerControlIcon as PowerControlFeatureIcon,
    FilterControlIcon as FilterControlFeatureIcon,
    ExternalLinkIcon as ExternalLinkFeatureIcon,
    AnalyticsDashboardIcon as AnalyticsDashboardFeatureIcon,
    SecurityAlertIcon as SecurityAlertFeatureIcon,
    InternationalIcon as InternationalizationFeatureIcon,
    InnovationIcon as InnovationFeatureIcon,
    BusinessIntelligenceIcon as BusinessIntelligenceFeatureIcon,
    LayoutIcon as LayoutManagementFeatureIcon,
    DataGridIcon as DataGridFeatureIcon,
    RefreshIcon as RefreshFeatureIcon,
    CommunicationIcon as CommunicationFeatureIcon,
    KPIIcon as KPIFeatureIcon,
    DocumentManagementIcon as DocumentManagementFeatureIcon,
    TeamManagementIcon as TeamManagementFeatureIcon,
    DuplicateIcon as DuplicationFeatureIcon,
    PerformanceChartIcon as PerformanceChartFeatureIcon,
    PaymentGatewayIcon as PaymentGatewayFeatureIcon,
    DiscountManagementIcon as DiscountManagementFeatureIcon,
    CorporateIcon as CorporateFeatureIcon,
    TimeManagementIcon as TimeManagementFeatureIcon,
    NotificationCenterIcon as NotificationCenterFeatureIcon,
    TagManagementIcon as TagManagementFeatureIcon,
    DocumentSearchToolsIcon as DocumentSearchFeatureIcon,
    CloudUploadIcon as CloudUploadFeatureIcon,
    SecurityManagementIcon as SecurityManagementFeatureIcon,
    AutomationEngineIcon as AutomationEngineFeatureIcon,
    WarningIcon as WarningFeatureIcon,
    SystemSettingsIcon as SystemSettingsFeatureIcon,
    InfoPanelIcon as InfoPanelFeatureIcon,
    FinanceIcon as FinanceFeatureIcon,
    PortfolioManagementIcon as PortfolioManagementFeatureIcon,
    CustomerManagementIcon as CustomerManagementFeatureIcon,
    TrendAnalysisIcon as TrendAnalysisFeatureIcon,
    FavoriteManagementIcon as FavoriteManagementFeatureIcon,
    ApprovalIcon as ApprovalFeatureIcon,
    RejectionIcon as RejectionFeatureIcon,
    BusinessOperationsIcon as BusinessOperationsFeatureIcon,
    GrowthMetricsIcon as GrowthMetricsFeatureIcon,
    PayoutManagementIcon as PayoutManagementFeatureIcon,
    SupportTicketIcon as SupportTicketFeatureIcon,
    ProjectLaunchIcon as ProjectLaunchFeatureIcon,
    ExperimentationIcon as ExperimentationFeatureIcon,
    CustomizationIcon as CustomizationFeatureIcon,
    ThemingIcon as ThemingFeatureIcon,
    MobileAppIcon as MobileAppFeatureIcon,
    DesktopAppIcon as DesktopAppFeatureIcon,
    TVScreenIcon as TVScreenFeatureIcon,
    VoiceCommandIcon as VoiceCommandFeatureIcon,
    AudioOutputIcon as AudioOutputFeatureIcon,
    HeadphoneSupportIcon as HeadphoneSupportFeatureIcon,
    DatabaseManagementIcon as DatabaseManagementFeatureIcon,
    DebuggingToolsIcon as DebuggingToolsFeatureIcon,
    CodeEditorToolsIcon as CodeEditorToolsFeatureIcon,
    VerificationToolsIcon as VerificationToolsFeatureIcon,
    ReportingToolsIcon as ReportingToolsFeatureIcon,
    ColorManagementIcon as ColorManagementFeatureIcon,
    VariableManagementIcon as VariableManagementFeatureIcon,
    APIManagementIcon as APIManagementFeatureIcon,
    CLIToolsIcon as CLIToolsFeatureIcon,
    PowerManagementIcon as PowerManagementFeatureIcon,
} from '@heroicons/react/24/outline';
import Select from 'react-select';
import { Line, Bar, Pie } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, BarElement, ArcElement, Title, Tooltip, Legend, Filler } from 'chart.js';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';

// Register Chart.js components
ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    BarElement,
    ArcElement,
    Title,
    Tooltip,
    Legend,
    Filler
);

// --- Constants and Enums ---
export enum ApplicationStatus {
    PENDING_REVIEW = 'PENDING_REVIEW',
    AI_PRE_SCREEN = 'AI_PRE_SCREEN',
    DOCUMENT_VERIFICATION = 'DOCUMENT_VERIFICATION',
    UNDERWRITING = 'UNDERWRITING',
    APPROVED = 'APPROVED',
    REJECTED = 'REJECTED',
    FUNDED = 'FUNDED',
    WITHDRAWN = 'WITHDRAWN',
    CLOSED = 'CLOSED',
    ON_HOLD = 'ON_HOLD',
    PENDING_CUSTOMER_ACTION = 'PENDING_CUSTOMER_ACTION',
    ESCALATED = 'ESCALATED',
    COLLECTION = 'COLLECTION',
    REFINANCED = 'REFINANCED',
}

export enum LoanType {
    PERSONAL = 'PERSONAL',
    BUSINESS = 'BUSINESS',
    MORTGAGE = 'MORTGAGE',
    AUTO = 'AUTO',
    STUDENT = 'STUDENT',
    SME = 'SME',
    COMMERCIAL_REAL_ESTATE = 'COMMERCIAL_REAL_ESTATE',
    EQUIPMENT_FINANCE = 'EQUIPMENT_FINANCE',
    INVOICE_FINANCE = 'INVOICE_FINANCE',
    MICRO_LOAN = 'MICRO_LOAN',
    REVOLVING_CREDIT = 'REVOLVING_CREDIT',
    BRIDGE_LOAN = 'BRIDGE_LOAN',
}

export enum RiskLevel {
    LOW = 'LOW',
    MEDIUM = 'MEDIUM',
    HIGH = 'HIGH',
    CRITICAL = 'CRITICAL',
    UNKNOWN = 'UNKNOWN',
}

export enum DocumentType {
    IDENTIFICATION = 'IDENTIFICATION',
    PROOF_OF_ADDRESS = 'PROOF_OF_ADDRESS',
    INCOME_STATEMENT = 'INCOME_STATEMENT',
    BANK_STATEMENT = 'BANK_STATEMENT',
    BUSINESS_PLAN = 'BUSINESS_PLAN',
    COLLATERAL_DOCS = 'COLLATERAL_DOCS',
    CREDIT_REPORT = 'CREDIT_REPORT',
    TAX_RETURNS = 'TAX_RETURNS',
    LEASE_AGREEMENT = 'LEASE_AGREEMENT',
    INVOICES = 'INVOICES',
    OTHER = 'OTHER',
}

export enum UnderwriterAction {
    APPROVE = 'APPROVE',
    REJECT = 'REJECT',
    REQUEST_MORE_INFO = 'REQUEST_MORE_INFO',
    ESCALATE = 'ESCALATE',
    FORWARD_TO_LEGAL = 'FORWARD_TO_LEGAL',
    CONDITIONALLY_APPROVE = 'CONDITIONALLY_APPROVE',
}

export enum CreditScoreModel {
    FICO = 'FICO',
    VANTAGESCORE = 'VANTAGESCORE',
    PROPRIETARY_AI = 'PROPRIETARY_AI',
    EXTERNAL_API = 'EXTERNAL_API',
}

export enum PaymentStatus {
    PAID = 'PAID',
    PARTIAL = 'PARTIAL',
    DUE = 'DUE',
    OVERDUE = 'OVERDUE',
    SETTLED = 'SETTLED',
    DEFAULTED = 'DEFAULTED',
    PENDING = 'PENDING',
}

export const API_BASE_URL = '/api/loan-origination';
export const ITEMS_PER_PAGE = 10;
export const LOAN_INTEREST_RATES = {
    [LoanType.PERSONAL]: { LOW: 0.05, MEDIUM: 0.08, HIGH: 0.12, CRITICAL: 0.18 },
    [LoanType.BUSINESS]: { LOW: 0.07, MEDIUM: 0.10, HIGH: 0.15, CRITICAL: 0.20 },
    [LoanType.MORTGAGE]: { LOW: 0.03, MEDIUM: 0.04, HIGH: 0.06, CRITICAL: 0.09 },
    [LoanType.AUTO]: { LOW: 0.04, MEDIUM: 0.06, HIGH: 0.09, CRITICAL: 0.14 },
    // ... add more as needed
};

// --- Interfaces for Data Models ---
export interface LoanApplicant {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    dateOfBirth: string;
    address: string;
    city: string;
    state: string;
    zipCode: string;
    nationality: string;
    nationalId: string;
    employmentStatus: string;
    annualIncome: number;
    dependents: number;
    creditScore: number;
    existingDebts: number;
    assetsValue: number;
    businessType?: string;
    yearsInBusiness?: number;
    registrationNumber?: string;
}

export interface LoanApplication {
    id: string;
    applicantId: string;
    applicantName: string; // Denormalized for display
    loanType: LoanType;
    amountRequested: number;
    termMonths: number;
    purpose: string;
    applicationDate: string;
    status: ApplicationStatus;
    aiScore: number;
    riskLevel: RiskLevel;
    assignedUnderwriterId?: string;
    assignedUnderwriterName?: string;
    lastUpdated: string;
    rejectionReason?: string;
    offerDetails?: LoanOffer;
    documents: LoanDocument[];
    notes: ApplicationNote[];
    auditTrail: AuditLog[];
    relatedTasks: LoanTask[];
    paymentSchedule?: LoanPayment[];
    collateralDetails?: Collateral[];
    sourceChannel: string; // e.g., 'Website', 'Partner API', 'Referral'
    marketingCampaignId?: string;
    processingFee?: number;
    insurancePremium?: number;
    decisionEngineOutput?: DecisionEngineOutput;
    complianceChecks?: ComplianceCheck[];
    fraudDetectionScore?: number;
    sentimentAnalysisScore?: number; // from applicant communications
    recommendedAction?: string; // AI recommendation
    customFields?: { [key: string]: string };
}

export interface LoanOffer {
    loanApplicationId: string;
    offeredAmount: number;
    interestRate: number;
    annualPercentageRate: number;
    termMonths: number;
    monthlyPayment: number;
    totalRepayment: number;
    acceptanceDeadline: string;
    offerDate: string;
    offerStatus: 'PENDING' | 'ACCEPTED' | 'REJECTED' | 'EXPIRED';
    conditions: string[];
    fees: { type: string; amount: number }[];
    amortizationSchedule: AmortizationEntry[];
}

export interface AmortizationEntry {
    month: number;
    startingBalance: number;
    interestPayment: number;
    principalPayment: number;
    totalPayment: number;
    endingBalance: number;
}

export interface LoanDocument {
    id: string;
    loanApplicationId: string;
    documentType: DocumentType;
    fileName: string;
    fileUrl: string;
    uploadDate: string;
    verificationStatus: 'PENDING' | 'VERIFIED' | 'REJECTED' | 'MISSING';
    verificationNotes?: string;
    uploadedBy: string;
    checksum?: string;
    ocrData?: { [key: string]: string }; // Extracted data from OCR
    signatureStatus?: 'SIGNED' | 'PENDING_SIGNATURE' | 'NOT_REQUIRED';
    aiVerificationScore?: number;
    sensitiveDataMasked?: boolean;
}

export interface ApplicationNote {
    id: string;
    loanApplicationId: string;
    authorId: string;
    authorName: string;
    timestamp: string;
    content: string;
    isPrivate: boolean;
    tags: string[];
}

export interface AuditLog {
    id: string;
    loanApplicationId: string;
    timestamp: string;
    userId: string;
    userName: string;
    action: string; // e.g., 'STATUS_CHANGE', 'DOCUMENT_UPLOAD', 'NOTE_ADDED'
    details: string;
    ipAddress?: string;
}

export interface LoanTask {
    id: string;
    loanApplicationId: string;
    title: string;
    description: string;
    assignedToId: string;
    assignedToName: string;
    dueDate: string;
    status: 'OPEN' | 'IN_PROGRESS' | 'COMPLETED' | 'OVERDUE';
    priority: 'LOW' | 'MEDIUM' | 'HIGH';
    creationDate: string;
    completionDate?: string;
    relatedDocumentId?: string;
}

export interface LoanPayment {
    id: string;
    loanApplicationId: string;
    paymentNumber: number;
    dueDate: string;
    amountDue: number;
    amountPaid: number;
    paymentDate?: string;
    status: PaymentStatus;
    principalAmount: number;
    interestAmount: number;
    penaltyFee?: number;
    remainingBalance: number;
}

export interface UserProfile {
    id: string;
    username: string;
    email: string;
    role: 'ADMIN' | 'UNDERWRITER' | 'SALES' | 'COLLECTIONS' | 'COMPLIANCE' | 'CUSTOMER_SERVICE' | 'DATA_ANALYST';
    firstName: string;
    lastName: string;
    isActive: boolean;
    lastLogin: string;
    assignedApplicationsCount: number;
    permissions: string[];
}

export interface Collateral {
    id: string;
    loanApplicationId: string;
    type: string; // e.g., 'Real Estate', 'Vehicle', 'Equipment'
    description: string;
    estimatedValue: number;
    valuationDate: string;
    lienStatus: 'CLEAR' | 'ENCUMBERED';
    documentIds: string[]; // IDs of related documents
    valuationReportUrl?: string;
    insurancePolicyNumber?: string;
    riskAssessment?: RiskLevel;
}

export interface DecisionEngineOutput {
    decision: 'APPROVE' | 'REJECT' | 'REFER';
    reasonCodes: string[];
    riskScore: number;
    recommendedLoanAmount?: number;
    recommendedInterestRate?: number;
    modelVersion: string;
    timestamp: string;
    rulesTriggered: string[];
    confidenceScore: number;
}

export interface ComplianceCheck {
    id: string;
    loanApplicationId: string;
    checkType: string; // e.g., 'AML', 'KYC', 'GDPR', 'Fair Lending'
    status: 'PASSED' | 'FAILED' | 'PENDING';
    details: string;
    checkedBy: string;
    checkDate: string;
    remediationActions?: string[];
    severity?: 'LOW' | 'MEDIUM' | 'HIGH';
}

export interface Notification {
    id: string;
    userId: string;
    message: string;
    type: 'ALERT' | 'INFO' | 'WARNING' | 'TASK';
    isRead: boolean;
    timestamp: string;
    link?: string;
    icon?: string;
}

export interface Alert {
    id: string;
    loanApplicationId?: string;
    type: 'FRAUD' | 'HIGH_RISK_CHANGE' | 'DEFAULT_PREDICTION' | 'COMPLIANCE_BREACH' | 'SYSTEM_ERROR' | 'ANOMALY';
    severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    message: string;
    timestamp: string;
    resolved: boolean;
    resolvedBy?: string;
    resolutionNotes?: string;
    triggerDetails: { [key: string]: any }; // Detailed context for the alert
}

export interface Settings {
    theme: 'light' | 'dark';
    notificationsEnabled: boolean;
    emailNotifications: boolean;
    smsNotifications: boolean;
    defaultCurrency: string;
    aiAutoApproveThreshold: number;
    documentVerificationThreshold: number;
    fraudDetectionSensitivity: number;
    dataRetentionPolicy: number; // in days
}

export interface ReportData {
    id: string;
    name: string;
    type: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'AD_HOC';
    generationDate: string;
    parameters: { [key: string]: any };
    downloadUrl: string;
    generatedBy: string;
}

// --- Mock Data Service (Replace with actual API calls in production) ---
const mockApplications: LoanApplication[] = Array.from({ length: 50 }, (_, i) => ({
    id: `app-${i + 1}`,
    applicantId: `user-${i + 1}`,
    applicantName: `John Doe ${i + 1}`,
    loanType: Object.values(LoanType)[Math.floor(Math.random() * Object.values(LoanType).length)],
    amountRequested: 10000 + i * 500,
    termMonths: 12 + (i % 24),
    purpose: `Personal loan for home improvement ${i + 1}`,
    applicationDate: new Date(Date.now() - i * 86400000).toISOString(),
    status: Object.values(ApplicationStatus)[Math.floor(Math.random() * Object.values(ApplicationStatus).length)],
    aiScore: 300 + i * 10,
    riskLevel: Object.values(RiskLevel)[Math.floor(Math.random() * Object.values(RiskLevel).length)],
    assignedUnderwriterId: `uw-${(i % 5) + 1}`,
    assignedUnderwriterName: `Underwriter ${Math.floor(Math.random() * 5) + 1}`,
    lastUpdated: new Date(Date.now() - i * 3600000).toISOString(),
    documents: [],
    notes: [],
    auditTrail: [],
    relatedTasks: [],
    sourceChannel: Math.random() > 0.5 ? 'Website' : 'Partner API',
    fraudDetectionScore: Math.random() * 100,
    sentimentAnalysisScore: Math.random() * 2 - 1,
    recommendedAction: Math.random() > 0.7 ? 'Approve' : 'Refer to Senior UW',
    complianceChecks: [],
    decisionEngineOutput: {
        decision: Math.random() > 0.7 ? 'APPROVE' : Math.random() > 0.5 ? 'REJECT' : 'REFER',
        reasonCodes: ['CRITICAL_RISK', 'LOW_CREDIT_SCORE', 'INSUFFICIENT_INCOME'],
        riskScore: Math.floor(Math.random() * 1000),
        modelVersion: 'v1.2.3',
        timestamp: new Date().toISOString(),
        rulesTriggered: ['Rule_A', 'Rule_B'],
        confidenceScore: Math.random(),
    },
    offerDetails: i % 3 === 0 ? {
        loanApplicationId: `app-${i + 1}`,
        offeredAmount: 10000 + i * 450,
        interestRate: parseFloat((0.05 + Math.random() * 0.1).toFixed(4)),
        annualPercentageRate: parseFloat((0.07 + Math.random() * 0.1).toFixed(4)),
        termMonths: 12 + (i % 24),
        monthlyPayment: 500 + i * 10,
        totalRepayment: 12000 + i * 1500,
        acceptanceDeadline: new Date(Date.now() + 7 * 86400000).toISOString(),
        offerDate: new Date().toISOString(),
        offerStatus: 'PENDING',
        conditions: ['Provide additional ID', 'Sign digital agreement'],
        fees: [{ type: 'Origination', amount: 250 }],
        amortizationSchedule: [], // Filled dynamically
    } : undefined,
}));

const mockUnderwriters: UserProfile[] = Array.from({ length: 5 }, (_, i) => ({
    id: `uw-${i + 1}`,
    username: `underwriter${i + 1}`,
    email: `uw${i + 1}@example.com`,
    role: 'UNDERWRITER',
    firstName: `Underwriter ${i + 1}`,
    lastName: `Lastname ${i + 1}`,
    isActive: true,
    lastLogin: new Date().toISOString(),
    assignedApplicationsCount: Math.floor(Math.random() * 10),
    permissions: ['view_all_applications', 'approve_loans', 'reject_loans', 'add_notes', 'assign_tasks'],
}));

const mockAlerts: Alert[] = Array.from({ length: 15 }, (_, i) => ({
    id: `alert-${i + 1}`,
    loanApplicationId: `app-${i + 1}`,
    type: Object.values(Alert['type'])[Math.floor(Math.random() * Object.values(Alert['type']).length)],
    severity: Object.values(Alert['severity'])[Math.floor(Math.random() * Object.values(Alert['severity']).length)],
    message: `Alert message for application ${i + 1}: Something happened.`,
    timestamp: new Date(Date.now() - i * 3600000).toISOString(),
    resolved: i % 3 === 0,
    triggerDetails: { field: 'income', oldValue: 50000, newValue: 10000 },
}));

const generateAmortizationSchedule = (principal: number, annualInterestRate: number, termMonths: number): AmortizationEntry[] => {
    const monthlyInterestRate = annualInterestRate / 12;
    const monthlyPayment = principal * (monthlyInterestRate * Math.pow(1 + monthlyInterestRate, termMonths)) / (Math.pow(1 + monthlyInterestRate, termMonths) - 1);

    const schedule: AmortizationEntry[] = [];
    let remainingBalance = principal;

    for (let month = 1; month <= termMonths; month++) {
        const interestPayment = remainingBalance * monthlyInterestRate;
        const principalPayment = monthlyPayment - interestPayment;
        remainingBalance -= principalPayment;

        schedule.push({
            month,
            startingBalance: parseFloat((remainingBalance + principalPayment).toFixed(2)),
            interestPayment: parseFloat(interestPayment.toFixed(2)),
            principalPayment: parseFloat(principalPayment.toFixed(2)),
            totalPayment: parseFloat(monthlyPayment.toFixed(2)),
            endingBalance: parseFloat(remainingBalance.toFixed(2))
        });
    }
    return schedule;
};


const fetchApplications = async (
    page: number,
    limit: number,
    filters: any,
    sort: any
): Promise<{ applications: LoanApplication[]; total: number }> => {
    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API delay
    let filtered = mockApplications;

    if (filters.status) {
        filtered = filtered.filter(app => app.status === filters.status);
    }
    if (filters.loanType) {
        filtered = filtered.filter(app => app.loanType === filters.loanType);
    }
    if (filters.search) {
        const searchTerm = filters.search.toLowerCase();
        filtered = filtered.filter(app =>
            app.applicantName.toLowerCase().includes(searchTerm) ||
            app.id.toLowerCase().includes(searchTerm) ||
            app.purpose.toLowerCase().includes(searchTerm)
        );
    }
    if (filters.minAmount) {
        filtered = filtered.filter(app => app.amountRequested >= filters.minAmount);
    }
    if (filters.maxAmount) {
        filtered = filtered.filter(app => app.amountRequested <= filters.maxAmount);
    }
    if (filters.riskLevel) {
        filtered = filtered.filter(app => app.riskLevel === filters.riskLevel);
    }
    if (filters.underwriterId) {
        filtered = filtered.filter(app => app.assignedUnderwriterId === filters.underwriterId);
    }
    if (filters.dateRange && filters.dateRange.startDate && filters.dateRange.endDate) {
        const start = new Date(filters.dateRange.startDate);
        const end = new Date(filters.dateRange.endDate);
        filtered = filtered.filter(app => {
            const appDate = new Date(app.applicationDate);
            return appDate >= start && appDate <= end;
        });
    }

    if (sort.field && sort.direction) {
        filtered.sort((a, b) => {
            const aValue = a[sort.field as keyof LoanApplication];
            const bValue = b[sort.field as keyof LoanApplication];

            if (typeof aValue === 'string' && typeof bValue === 'string') {
                return sort.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
            }
            if (typeof aValue === 'number' && typeof bValue === 'number') {
                return sort.direction === 'asc' ? aValue - bValue : bValue - aValue;
            }
            // Fallback for other types or nulls
            return 0;
        });
    }


    const start = (page - 1) * limit;
    const end = start + limit;
    const applications = filtered.slice(start, end);

    return { applications, total: filtered.length };
};

const fetchApplicationById = async (id: string): Promise<LoanApplication> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    const app = mockApplications.find(app => app.id === id);
    if (!app) {
        throw new Error('Application not found');
    }

    // Generate amortization schedule if offer exists and it's empty
    if (app.offerDetails && app.offerDetails.amortizationSchedule.length === 0) {
        app.offerDetails.amortizationSchedule = generateAmortizationSchedule(
            app.offerDetails.offeredAmount,
            app.offerDetails.interestRate,
            app.offerDetails.termMonths
        );
    }
    return app;
};

const updateApplication = async (updatedApp: LoanApplication): Promise<LoanApplication> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    const index = mockApplications.findIndex(app => app.id === updatedApp.id);
    if (index > -1) {
        mockApplications[index] = { ...mockApplications[index], ...updatedApp, lastUpdated: new Date().toISOString() };
        return mockApplications[index];
    }
    throw new Error('Application not found for update');
};

const createApplication = async (newApp: Partial<LoanApplication>): Promise<LoanApplication> => {
    await new Promise(resolve => setTimeout(resolve, 300));
    const newId = `app-${mockApplications.length + 1}`;
    const application: LoanApplication = {
        id: newId,
        applicantId: newApp.applicantId || `temp-user-${mockApplications.length + 1}`,
        applicantName: newApp.applicantName || 'New Applicant',
        loanType: newApp.loanType || LoanType.PERSONAL,
        amountRequested: newApp.amountRequested || 0,
        termMonths: newApp.termMonths || 0,
        purpose: newApp.purpose || 'Not specified',
        applicationDate: new Date().toISOString(),
        status: ApplicationStatus.PENDING_REVIEW,
        aiScore: 0,
        riskLevel: RiskLevel.UNKNOWN,
        lastUpdated: new Date().toISOString(),
        documents: [],
        notes: [],
        auditTrail: [],
        relatedTasks: [],
        sourceChannel: newApp.sourceChannel || 'Manual Entry',
        fraudDetectionScore: 0,
        sentimentAnalysisScore: 0,
        recommendedAction: 'Process manually',
        complianceChecks: [],
        decisionEngineOutput: {
            decision: 'REFER',
            reasonCodes: ['MANUAL_ENTRY'],
            riskScore: 0,
            modelVersion: 'v0.0.1',
            timestamp: new Date().toISOString(),
            rulesTriggered: [],
            confidenceScore: 0,
        },
        ...newApp,
    };
    mockApplications.unshift(application); // Add to the beginning
    return application;
};


const fetchUnderwriters = async (): Promise<UserProfile[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return mockUnderwriters.filter(uw => uw.role === 'UNDERWRITER');
};

const fetchAlerts = async (): Promise<Alert[]> => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return mockAlerts.filter(alert => !alert.resolved);
}

// --- Utility Functions ---
export const formatCurrency = (value: number, currency: string = 'USD') => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency,
    }).format(value);
};

export const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });
};

export const getStatusColor = (status: ApplicationStatus) => {
    switch (status) {
        case ApplicationStatus.APPROVED: return 'text-green-500 bg-green-900/20';
        case ApplicationStatus.FUNDED: return 'text-blue-500 bg-blue-900/20';
        case ApplicationStatus.REJECTED:
        case ApplicationStatus.WITHDRAWN: return 'text-red-500 bg-red-900/20';
        case ApplicationStatus.UNDERWRITING: return 'text-yellow-500 bg-yellow-900/20';
        case ApplicationStatus.AI_PRE_SCREEN:
        case ApplicationStatus.DOCUMENT_VERIFICATION:
        case ApplicationStatus.PENDING_REVIEW:
        case ApplicationStatus.PENDING_CUSTOMER_ACTION: return 'text-indigo-500 bg-indigo-900/20';
        case ApplicationStatus.ON_HOLD: return 'text-orange-500 bg-orange-900/20';
        case ApplicationStatus.ESCALATED: return 'text-pink-500 bg-pink-900/20';
        case ApplicationStatus.COLLECTION: return 'text-red-600 bg-red-900/30';
        case ApplicationStatus.REFINANCED: return 'text-teal-500 bg-teal-900/20';
        case ApplicationStatus.CLOSED: return 'text-gray-500 bg-gray-900/20';
        default: return 'text-gray-400 bg-gray-700/20';
    }
};

export const getRiskColor = (risk: RiskLevel) => {
    switch (risk) {
        case RiskLevel.LOW: return 'text-green-400';
        case RiskLevel.MEDIUM: return 'text-yellow-400';
        case RiskLevel.HIGH: return 'text-orange-400';
        case RiskLevel.CRITICAL: return 'text-red-400';
        default: return 'text-gray-400';
    }
};

export const getPriorityColor = (priority: 'LOW' | 'MEDIUM' | 'HIGH') => {
    switch (priority) {
        case 'LOW': return 'text-green-400';
        case 'MEDIUM': return 'text-yellow-400';
        case 'HIGH': return 'text-red-400';
        default: return 'text-gray-400';
    }
};

// --- Custom Hooks ---
export const useApplications = (page: number, limit: number, filters: any, sort: any) => {
    return useQuery<
        { applications: LoanApplication[]; total: number },
        Error
    >(
        ['loanApplications', page, limit, filters, sort],
        () => fetchApplications(page, limit, filters, sort),
        {
            keepPreviousData: true,
            staleTime: 5 * 60 * 1000, // 5 minutes
            cacheTime: 10 * 60 * 1000, // 10 minutes
        }
    );
};

export const useApplicationById = (id: string | null) => {
    return useQuery<LoanApplication, Error>(
        ['loanApplication', id],
        () => fetchApplicationById(id!),
        {
            enabled: !!id, // Only run the query if id is provided
            staleTime: 5 * 60 * 1000,
        }
    );
};

export const useUpdateApplication = () => {
    const queryClient = useQueryClient();
    return useMutation<LoanApplication, Error, LoanApplication>(
        updateApplication,
        {
            onSuccess: (data) => {
                queryClient.invalidateQueries(['loanApplications']); // Invalidate list
                queryClient.invalidateQueries(['loanApplication', data.id]); // Invalidate single application
                toast.success(`Application ${data.id} updated successfully!`);
            },
            onError: (error) => {
                toast.error(`Error updating application: ${error.message}`);
            },
        }
    );
};

export const useCreateApplication = () => {
    const queryClient = useQueryClient();
    return useMutation<LoanApplication, Error, Partial<LoanApplication>>(
        createApplication,
        {
            onSuccess: (data) => {
                queryClient.invalidateQueries(['loanApplications']);
                toast.success(`New application ${data.id} created!`);
            },
            onError: (error) => {
                toast.error(`Error creating application: ${error.message}`);
            }
        }
    )
}

export const useUnderwriters = () => {
    return useQuery<UserProfile[], Error>(
        ['underwriters'],
        fetchUnderwriters,
        {
            staleTime: Infinity, // Underwriters list doesn't change often
        }
    );
};

export const useAlerts = () => {
    return useQuery<Alert[], Error>(
        ['alerts'],
        fetchAlerts,
        {
            refetchInterval: 30 * 1000, // Refetch every 30 seconds
        }
    );
}

// --- Components ---

interface StatusBadgeProps {
    status: ApplicationStatus;
}
export const StatusBadge: React.FC<StatusBadgeProps> = ({ status }) => (
    <span className={`px-2 py-1 rounded-full text-xs font-semibold ${getStatusColor(status)}`}>
        {status.replace(/_/g, ' ')}
    </span>
);

interface RiskBadgeProps {
    riskLevel: RiskLevel;
}
export const RiskBadge: React.FC<RiskBadgeProps> = ({ riskLevel }) => (
    <span className={`px-2 py-1 rounded-full text-xs font-semibold ${getRiskColor(riskLevel)} bg-gray-900/20`}>
        <ExclamationTriangleIcon className="inline-block w-3 h-3 mr-1" />
        {riskLevel.replace(/_/g, ' ')}
    </span>
);

interface PriorityBadgeProps {
    priority: 'LOW' | 'MEDIUM' | 'HIGH';
}
export const PriorityBadge: React.FC<PriorityBadgeProps> = ({ priority }) => (
    <span className={`px-2 py-1 rounded-full text-xs font-semibold ${getPriorityColor(priority)} bg-gray-900/20`}>
        <TagIcon className="inline-block w-3 h-3 mr-1" />
        {priority}
    </span>
);

interface FilterButtonProps {
    label: string;
    icon: React.ElementType;
    onClick: () => void;
    isActive: boolean;
}
export const FilterButton: React.FC<FilterButtonProps> = ({ label, icon: Icon, onClick, isActive }) => (
    <button
        onClick={onClick}
        className={`flex items-center space-x-2 px-3 py-1.5 rounded-md text-sm font-medium transition-colors duration-200
            ${isActive
                ? 'bg-blue-600 text-white shadow-md'
                : 'bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white'
            }`}
    >
        <Icon className="w-4 h-4" />
        <span>{label}</span>
    </button>
);

interface SortableHeaderProps {
    label: string;
    field: string;
    currentSort: { field: string; direction: 'asc' | 'desc' };
    onSort: (field: string) => void;
}
export const SortableHeader: React.FC<SortableHeaderProps> = ({ label, field, currentSort, onSort }) => (
    <th
        scope="col"
        className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer select-none"
        onClick={() => onSort(field)}
    >
        <div className="flex items-center">
            {label}
            {currentSort.field === field && (
                <span className="ml-1">
                    {currentSort.direction === 'asc' ? ' ' : ' '}
                </span>
            )}
        </div>
    </th>
);

interface PaginatorProps {
    currentPage: number;
    totalPages: number;
    onPageChange: (page: number) => void;
}
export const Paginator: React.FC<PaginatorProps> = ({ currentPage, totalPages, onPageChange }) => {
    const pages = useMemo(() => {
        const p = [];
        for (let i = 1; i <= totalPages; i++) {
            p.push(i);
        }
        return p;
    }, [totalPages]);

    return (
        <nav className="flex items-center justify-between border-t border-gray-700 px-4 py-3 sm:px-6">
            <div className="flex-1 flex justify-between sm:hidden">
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium rounded-md text-gray-300 bg-gray-800 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <ChevronLeftIcon className="h-5 w-5 mr-2" /> Previous
                </button>
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages}
                    className="ml-3 relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium rounded-md text-gray-300 bg-gray-800 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Next <ChevronRightIcon className="h-5 w-5 ml-2" />
                </button>
            </div>
            <div className="hidden sm:flex-1 sm:flex sm:items-center sm:justify-between">
                <div>
                    <p className="text-sm text-gray-400">
                        Page <span className="font-medium">{currentPage}</span> of{' '}
                        <span className="font-medium">{totalPages}</span>
                    </p>
                </div>
                <div>
                    <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                        <button
                            onClick={() => onPageChange(currentPage - 1)}
                            disabled={currentPage === 1}
                            className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <span className="sr-only">Previous</span>
                            <ChevronLeftIcon className="h-5 w-5" aria-hidden="true" />
                        </button>
                        {pages.map(page => (
                            <button
                                key={page}
                                onClick={() => onPageChange(page)}
                                className={`relative inline-flex items-center px-4 py-2 border text-sm font-medium
                                    ${page === currentPage
                                        ? 'z-10 bg-blue-600 border-blue-500 text-white'
                                        : 'bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700'
                                    }`}
                            >
                                {page}
                            </button>
                        ))}
                        <button
                            onClick={() => onPageChange(currentPage + 1)}
                            disabled={currentPage === totalPages}
                            className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-300 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <span className="sr-only">Next</span>
                            <ChevronRightIcon className="h-5 w-5" aria-hidden="true" />
                        </button>
                    </nav>
                </div>
            </div>
        </nav>
    );
};

export const Modal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl';
}> = ({ isOpen, onClose, title, children, size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
    };

    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-black bg-opacity-75 flex items-center justify-center p-4">
            <div className={`relative bg-gray-800 rounded-lg shadow-xl w-full ${sizeClasses[size]}`}>
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">
                        <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div className="p-4">
                    {children}
                </div>
            </div>
        </div>
    );
};

interface TooltipProps {
    content: string;
    children: React.ReactNode;
}
export const Tooltip: React.FC<TooltipProps> = ({ content, children }) => {
    const [isVisible, setIsVisible] = useState(false);
    const ref = useRef<HTMLDivElement>(null);

    return (
        <div
            className="relative inline-block"
            onMouseEnter={() => setIsVisible(true)}
            onMouseLeave={() => setIsVisible(false)}
            ref={ref}
        >
            {children}
            {isVisible && (
                <div
                    className="absolute z-50 px-3 py-2 text-sm font-medium text-white bg-gray-700 rounded-lg shadow-sm whitespace-nowrap"
                    style={{
                        top: '100%',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        marginTop: '8px',
                    }}
                >
                    {content}
                </div>
            )}
        </div>
    );
};

export const CustomSelect: React.FC<any> = (props) => (
    <Select
        {...props}
        className="react-select-container"
        classNamePrefix="react-select"
        styles={{
            control: (base, state) => ({
                ...base,
                backgroundColor: '#374151', // gray-700
                borderColor: '#4b5563', // gray-600
                color: 'white',
                '&:hover': {
                    borderColor: '#6b7280', // gray-500
                },
            }),
            menu: (base) => ({
                ...base,
                backgroundColor: '#374151', // gray-700
            }),
            option: (base, state) => ({
                ...base,
                backgroundColor: state.isFocused ? '#4b5563' : state.isSelected ? '#1f2937' : '#374151', // gray-600, gray-800, gray-700
                color: 'white',
                '&:hover': {
                    backgroundColor: '#4b5563',
                },
            }),
            singleValue: (base) => ({
                ...base,
                color: 'white',
            }),
            input: (base) => ({
                ...base,
                color: 'white',
            }),
            placeholder: (base) => ({
                ...base,
                color: '#9ca3af', // gray-400
            }),
        }}
    />
);

export const DropdownMenu: React.FC<{ trigger: React.ReactNode; children: React.ReactNode }> = ({ trigger, children }) => {
    const [isOpen, setIsOpen] = useState(false);
    const dropdownRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    return (
        <div className="relative inline-block text-left" ref={dropdownRef}>
            <div onClick={() => setIsOpen(!isOpen)}>{trigger}</div>
            {isOpen && (
                <div className="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-50">
                    <div className="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                        {children}
                    </div>
                </div>
            )}
        </div>
    );
};

export const DropdownMenuItem: React.FC<{ onClick: () => void; icon?: React.ElementType; children: React.ReactNode }> = ({ onClick, icon: Icon, children }) => (
    <button
        onClick={onClick}
        className="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700 hover:text-white w-full text-left flex items-center space-x-2"
        role="menuitem"
    >
        {Icon && <Icon className="w-4 h-4" />}
        <span>{children}</span>
    </button>
);

// --- Detailed Views / Sub-components ---

interface LoanApplicationDetailProps {
    application: LoanApplication;
    onClose: () => void;
    onUpdate: (updatedApp: LoanApplication) => void;
}
export const LoanApplicationDetail: React.FC<LoanApplicationDetailProps> = ({ application, onClose, onUpdate }) => {
    const [currentTab, setCurrentTab] = useState<'overview' | 'documents' | 'notes' | 'tasks' | 'audit' | 'offer' | 'payments' | 'collateral' | 'compliance'>('overview');
    const [isEditingAmount, setIsEditingAmount] = useState(false);
    const [editedAmount, setEditedAmount] = useState(application.amountRequested);
    const [isEditingStatus, setIsEditingStatus] = useState(false);
    const [editedStatus, setEditedStatus] = useState<ApplicationStatus>(application.status);
    const [isAddingNote, setIsAddingNote] = useState(false);
    const [newNoteContent, setNewNoteContent] = useState('');
    const [newNoteIsPrivate, setNewNoteIsPrivate] = useState(false);
    const [isUploadingDocument, setIsUploadingDocument] = useState(false);
    const [newDocumentType, setNewDocumentType] = useState<DocumentType>(DocumentType.OTHER);
    const [newDocumentFile, setNewDocumentFile] = useState<File | null>(null);
    const [isAssigningUnderwriter, setIsAssigningUnderwriter] = useState(false);
    const [selectedUnderwriterId, setSelectedUnderwriterId] = useState<string | undefined>(application.assignedUnderwriterId);

    const { data: underwriters } = useUnderwriters();
    const updateAppMutation = useUpdateApplication();

    const handleSaveAmount = async () => {
        if (editedAmount !== application.amountRequested) {
            const updatedApp = { ...application, amountRequested: editedAmount };
            try {
                await updateAppMutation.mutateAsync(updatedApp);
                onUpdate(updatedApp); // Propagate update to parent
                toast.success('Amount updated successfully!');
            } catch (err: any) {
                toast.error(`Failed to update amount: ${err.message}`);
            }
        }
        setIsEditingAmount(false);
    };

    const handleSaveStatus = async () => {
        if (editedStatus !== application.status) {
            const updatedApp = { ...application, status: editedStatus };
            try {
                await updateAppMutation.mutateAsync(updatedApp);
                onUpdate(updatedApp);
                toast.success('Status updated successfully!');
            } catch (err: any) {
                toast.error(`Failed to update status: ${err.message}`);
            }
        }
        setIsEditingStatus(false);
    };

    const handleAssignUnderwriter = async () => {
        if (selectedUnderwriterId === application.assignedUnderwriterId) {
            setIsAssigningUnderwriter(false);
            return;
        }

        const selectedUW = underwriters?.find(uw => uw.id === selectedUnderwriterId);
        const updatedApp = {
            ...application,
            assignedUnderwriterId: selectedUnderwriterId,
            assignedUnderwriterName: selectedUW ? `${selectedUW.firstName} ${selectedUW.lastName}` : undefined,
            auditTrail: [
                ...(application.auditTrail || []),
                {
                    id: `audit-${Date.now()}`,
                    loanApplicationId: application.id,
                    timestamp: new Date().toISOString(),
                    userId: 'current_user_id', // Replace with actual user
                    userName: 'Current User',
                    action: 'UNDERWRITER_ASSIGNMENT',
                    details: `Assigned to ${selectedUW?.firstName} ${selectedUW?.lastName || 'N/A'}`,
                }
            ]
        };
        try {
            await updateAppMutation.mutateAsync(updatedApp);
            onUpdate(updatedApp);
            toast.success('Underwriter assigned successfully!');
        } catch (err: any) {
            toast.error(`Failed to assign underwriter: ${err.message}`);
        }
        setIsAssigningUnderwriter(false);
    };

    const handleAddNote = async () => {
        if (!newNoteContent.trim()) {
            toast.error('Note content cannot be empty.');
            return;
        }
        const newNote: ApplicationNote = {
            id: `note-${Date.now()}`,
            loanApplicationId: application.id,
            authorId: 'current_user_id',
            authorName: 'Current User', // Replace with actual user
            timestamp: new Date().toISOString(),
            content: newNoteContent,
            isPrivate: newNoteIsPrivate,
            tags: [],
        };
        const updatedApp = {
            ...application,
            notes: [...(application.notes || []), newNote],
            auditTrail: [
                ...(application.auditTrail || []),
                {
                    id: `audit-${Date.now() + 1}`,
                    loanApplicationId: application.id,
                    timestamp: new Date().toISOString(),
                    userId: 'current_user_id',
                    userName: 'Current User',
                    action: 'NOTE_ADDED',
                    details: `Note added: "${newNoteContent.substring(0, 50)}..."`,
                }
            ]
        };

        try {
            await updateAppMutation.mutateAsync(updatedApp);
            onUpdate(updatedApp);
            toast.success('Note added successfully!');
            setNewNoteContent('');
            setNewNoteIsPrivate(false);
            setIsAddingNote(false);
        } catch (err: any) {
            toast.error(`Failed to add note: ${err.message}`);
        }
    };

    const handleDocumentUpload = async () => {
        if (!newDocumentFile) {
            toast.error('Please select a file to upload.');
            return;
        }
        if (!newDocumentType) {
            toast.error('Please select a document type.');
            return;
        }
        // Simulate file upload
        const document: LoanDocument = {
            id: `doc-${Date.now()}`,
            loanApplicationId: application.id,
            documentType: newDocumentType,
            fileName: newDocumentFile.name,
            fileUrl: `/uploads/${application.id}/${newDocumentFile.name}`, // Placeholder URL
            uploadDate: new Date().toISOString(),
            verificationStatus: 'PENDING',
            uploadedBy: 'Current User',
            aiVerificationScore: Math.floor(Math.random() * 100),
        };

        const updatedApp = {
            ...application,
            documents: [...(application.documents || []), document],
            auditTrail: [
                ...(application.auditTrail || []),
                {
                    id: `audit-${Date.now() + 2}`,
                    loanApplicationId: application.id,
                    timestamp: new Date().toISOString(),
                    userId: 'current_user_id',
                    userName: 'Current User',
                    action: 'DOCUMENT_UPLOADED',
                    details: `Document uploaded: ${newDocumentFile.name} (${newDocumentType})`,
                }
            ]
        };

        try {
            await updateAppMutation.mutateAsync(updatedApp);
            onUpdate(updatedApp);
            toast.success('Document uploaded successfully!');
            setNewDocumentFile(null);
            setNewDocumentType(DocumentType.OTHER);
            setIsUploadingDocument(false);
        } catch (err: any) {
            toast.error(`Failed to upload document: ${err.message}`);
        }
    };

    const getTabClassName = (tabName: string) =>
        `px-4 py-2 text-sm font-medium rounded-t-md transition-colors duration-200 ${
            currentTab === tabName
                ? 'bg-blue-600 text-white'
                : 'text-gray-300 hover:bg-gray-700 hover:text-white'
        }`;

    const renderOfferDetails = (offer: LoanOffer) => {
        return (
            <div className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <Card title="Offered Amount">
                        <p className="text-xl font-bold text-green-400">{formatCurrency(offer.offeredAmount)}</p>
                    </Card>
                    <Card title="Interest Rate (APR)">
                        <p className="text-xl font-bold text-white">{(offer.annualPercentageRate * 100).toFixed(2)}%</p>
                    </Card>
                    <Card title="Term">
                        <p className="text-xl font-bold text-white">{offer.termMonths} Months</p>
                    </Card>
                    <Card title="Monthly Payment">
                        <p className="text-xl font-bold text-white">{formatCurrency(offer.monthlyPayment)}</p>
                    </Card>
                    <Card title="Total Repayment">
                        <p className="text-xl font-bold text-white">{formatCurrency(offer.totalRepayment)}</p>
                    </Card>
                    <Card title="Offer Status">
                        <span className={`px-2 py-1 rounded-full text-xs font-semibold ${offer.offerStatus === 'ACCEPTED' ? 'text-green-500 bg-green-900/20' : offer.offerStatus === 'REJECTED' ? 'text-red-500 bg-red-900/20' : 'text-indigo-500 bg-indigo-900/20'}`}>
                            {offer.offerStatus}
                        </span>
                    </Card>
                </div>

                <Card title="Offer Conditions & Fees">
                    <h4 className="font-semibold text-gray-200 mb-2">Conditions:</h4>
                    {offer.conditions && offer.conditions.length > 0 ? (
                        <ul className="list-disc list-inside text-gray-400 space-y-1">
                            {offer.conditions.map((condition, i) => <li key={i}>{condition}</li>)}
                        </ul>
                    ) : <p className="text-gray-400">No special conditions.</p>}
                    <h4 className="font-semibold text-gray-200 mt-4 mb-2">Fees:</h4>
                    {offer.fees && offer.fees.length > 0 ? (
                        <ul className="text-gray-400 space-y-1">
                            {offer.fees.map((fee, i) => <li key={i}>{fee.type}: {formatCurrency(fee.amount)}</li>)}
                        </ul>
                    ) : <p className="text-gray-400">No additional fees.</p>}
                </Card>

                <Card title="Amortization Schedule">
                    {offer.amortizationSchedule && offer.amortizationSchedule.length > 0 ? (
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-700">
                                <thead className="bg-gray-700">
                                    <tr>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Month</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Starting Balance</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Interest Payment</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Principal Payment</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Total Payment</th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Ending Balance</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-700 bg-gray-800">
                                    {offer.amortizationSchedule.map(entry => (
                                        <tr key={entry.month}>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{entry.month}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(entry.startingBalance)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(entry.interestPayment)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(entry.principalPayment)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(entry.totalPayment)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(entry.endingBalance)}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    ) : <p className="text-gray-400">No amortization schedule generated yet.</p>}
                </Card>
            </div>
        );
    };

    const renderPaymentSchedule = (payments: LoanPayment[]) => {
        if (!payments || payments.length === 0) {
            return <p className="text-gray-400">No payment schedule available.</p>;
        }

        const data = {
            labels: payments.map(p => `Month ${p.paymentNumber}`),
            datasets: [
                {
                    label: 'Amount Due',
                    data: payments.map(p => p.amountDue),
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.5)',
                    tension: 0.1,
                },
                {
                    label: 'Amount Paid',
                    data: payments.map(p => p.amountPaid),
                    borderColor: 'rgb(153, 102, 255)',
                    backgroundColor: 'rgba(153, 102, 255, 0.5)',
                    tension: 0.1,
                },
            ],
        };

        const options = {
            responsive: true,
            plugins: {
                legend: {
                    position: 'top' as const,
                    labels: {
                        color: 'white',
                    },
                },
                title: {
                    display: true,
                    text: 'Payment Schedule vs. Actual Payments',
                    color: 'white',
                },
                tooltip: {
                    callbacks: {
                        label: function (context: any) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += formatCurrency(context.parsed.y);
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)',
                    },
                    ticks: {
                        color: 'white',
                    },
                },
                y: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)',
                    },
                    ticks: {
                        color: 'white',
                        callback: function (value: any) {
                            return formatCurrency(value, '$');
                        }
                    },
                },
            },
        };

        return (
            <div className="space-y-4">
                <Card title="Payment Overview Chart">
                    <Line data={data} options={options} />
                </Card>
                <Card title="Detailed Payment Schedule">
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-700">
                            <thead className="bg-gray-700">
                                <tr>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">#</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Due Date</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Amount Due</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Amount Paid</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Remaining Balance</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-gray-700 bg-gray-800">
                                {payments.map(p => (
                                    <tr key={p.id}>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{p.paymentNumber}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatDate(p.dueDate)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(p.amountDue)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(p.amountPaid)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm">
                                            <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${p.status === PaymentStatus.PAID ? 'bg-green-100 text-green-800' : p.status === PaymentStatus.OVERDUE ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}`}>
                                                {p.status}
                                            </span>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(p.remainingBalance)}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </Card>
            </div>
        );
    };


    const renderComplianceChecks = (checks: ComplianceCheck[]) => {
        if (!checks || checks.length === 0) {
            return <p className="text-gray-400">No compliance checks recorded.</p>;
        }

        return (
            <div className="space-y-4">
                {checks.map(check => (
                    <Card key={check.id} title={check.checkType}>
                        <div className="flex items-center space-x-2 mb-2">
                            {check.status === 'PASSED' ? (
                                <CheckCircleIcon className="w-5 h-5 text-green-400" />
                            ) : check.status === 'FAILED' ? (
                                <XCircleIcon className="w-5 h-5 text-red-400" />
                            ) : (
                                <ClockIcon className="w-5 h-5 text-yellow-400" />
                            )}
                            <p className={`font-semibold ${check.status === 'PASSED' ? 'text-green-400' : check.status === 'FAILED' ? 'text-red-400' : 'text-yellow-400'}`}>
                                Status: {check.status}
                            </p>
                            {check.severity && <PriorityBadge priority={check.severity.toUpperCase() as any} />}
                        </div>
                        <p className="text-gray-400 text-sm mb-2">{check.details}</p>
                        <p className="text-gray-500 text-xs">Checked by {check.checkedBy} on {formatDate(check.checkDate)}</p>
                        {check.remediationActions && check.remediationActions.length > 0 && (
                            <div className="mt-2">
                                <h5 className="font-semibold text-gray-300">Remediation Actions:</h5>
                                <ul className="list-disc list-inside text-gray-400 text-sm">
                                    {check.remediationActions.map((action, idx) => (
                                        <li key={idx}>{action}</li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </Card>
                ))}
            </div>
        );
    };


    return (
        <div className="w-full h-full flex flex-col bg-gray-900 text-white">
            <div className="flex-shrink-0 px-6 py-4 border-b border-gray-700 flex items-center justify-between">
                <div className="flex items-center space-x-4">
                    <h3 className="text-2xl font-bold">{application.applicantName}</h3>
                    <StatusBadge status={application.status} />
                    <RiskBadge riskLevel={application.riskLevel} />
                    <span className="text-lg text-gray-400">{formatCurrency(application.amountRequested)} ({application.loanType.replace(/_/g, ' ')})</span>
                </div>
                <div className="flex items-center space-x-2">
                    <button
                        onClick={onClose}
                        className="p-2 rounded-full bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white transition-colors duration-200"
                    >
                        <XCircleIcon className="w-6 h-6" />
                    </button>
                </div>
            </div>

            {/* Tabs */}
            <div className="flex-shrink-0 px-6 pt-4 border-b border-gray-700 overflow-x-auto">
                <div className="flex space-x-2">
                    <button onClick={() => setCurrentTab('overview')} className={getTabClassName('overview')}>
                        <InformationCircleIcon className="w-4 h-4 inline-block mr-1" /> Overview
                    </button>
                    <button onClick={() => setCurrentTab('documents')} className={getTabClassName('documents')}>
                        <DocumentTextIcon className="w-4 h-4 inline-block mr-1" /> Documents ({application.documents?.length || 0})
                    </button>
                    <button onClick={() => setCurrentTab('notes')} className={getTabClassName('notes')}>
                        <PencilSquareIcon className="w-4 h-4 inline-block mr-1" /> Notes ({application.notes?.length || 0})
                    </button>
                    <button onClick={() => setCurrentTab('tasks')} className={getTabClassName('tasks')}>
                        <ClipboardDocumentListIcon className="w-4 h-4 inline-block mr-1" /> Tasks ({application.relatedTasks?.length || 0})
                    </button>
                    <button onClick={() => setCurrentTab('audit')} className={getTabClassName('audit')}>
                        <ClockIcon className="w-4 h-4 inline-block mr-1" /> Audit Trail ({application.auditTrail?.length || 0})
                    </button>
                    {application.offerDetails && (
                        <button onClick={() => setCurrentTab('offer')} className={getTabClassName('offer')}>
                            <CurrencyDollarIcon className="w-4 h-4 inline-block mr-1" /> Loan Offer
                        </button>
                    )}
                    {application.paymentSchedule && (
                        <button onClick={() => setCurrentTab('payments')} className={getTabClassName('payments')}>
                            <ReceiptPercentIcon className="w-4 h-4 inline-block mr-1" /> Payments
                        </button>
                    )}
                    {application.collateralDetails && application.collateralDetails.length > 0 && (
                        <button onClick={() => setCurrentTab('collateral')} className={getTabClassName('collateral')}>
                            <ShieldCheckIcon className="w-4 h-4 inline-block mr-1" /> Collateral
                        </button>
                    )}
                    {application.complianceChecks && application.complianceChecks.length > 0 && (
                        <button onClick={() => setCurrentTab('compliance')} className={getTabClassName('compliance')}>
                            <ScaleIcon className="w-4 h-4 inline-block mr-1" /> Compliance
                        </button>
                    )}
                </div>
            </div>

            {/* Tab Content */}
            <div className="flex-grow overflow-y-auto p-6 space-y-6">
                {currentTab === 'overview' && (
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div className="lg:col-span-2 space-y-6">
                            <Card title="Application Summary">
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 text-gray-300">
                                    <div>
                                        <p><span className="font-semibold">Application ID:</span> {application.id}</p>
                                        <p><span className="font-semibold">Applicant:</span> {application.applicantName}</p>
                                        <p><span className="font-semibold">Loan Type:</span> {application.loanType.replace(/_/g, ' ')}</p>
                                        <p className="flex items-center space-x-1">
                                            <span className="font-semibold">Requested Amount:</span>
                                            {isEditingAmount ? (
                                                <input
                                                    type="number"
                                                    value={editedAmount}
                                                    onChange={(e) => setEditedAmount(parseFloat(e.target.value) || 0)}
                                                    onBlur={handleSaveAmount}
                                                    onKeyDown={(e) => e.key === 'Enter' && handleSaveAmount()}
                                                    className="bg-gray-700 border border-gray-600 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 w-28"
                                                />
                                            ) : (
                                                <span>{formatCurrency(application.amountRequested)} <button onClick={() => setIsEditingAmount(true)} className="text-gray-400 hover:text-blue-400"><PencilSquareIcon className="w-4 h-4 inline-block" /></button></span>
                                            )}
                                        </p>
                                        <p><span className="font-semibold">Term:</span> {application.termMonths} Months</p>
                                        <p><span className="font-semibold">Purpose:</span> {application.purpose}</p>
                                    </div>
                                    <div>
                                        <p><span className="font-semibold">Application Date:</span> {formatDate(application.applicationDate)}</p>
                                        <p><span className="font-semibold">Last Updated:</span> {formatDate(application.lastUpdated)}</p>
                                        <p className="flex items-center space-x-1">
                                            <span className="font-semibold">Status:</span>
                                            {isEditingStatus ? (
                                                <CustomSelect
                                                    options={Object.values(ApplicationStatus).map(s => ({ value: s, label: s.replace(/_/g, ' ') }))}
                                                    value={{ value: editedStatus, label: editedStatus.replace(/_/g, ' ') }}
                                                    onChange={(option: any) => setEditedStatus(option.value)}
                                                    onBlur={handleSaveStatus}
                                                    className="w-48 text-black"
                                                />
                                            ) : (
                                                <span className="flex items-center">
                                                    <StatusBadge status={application.status} />
                                                    <button onClick={() => setIsEditingStatus(true)} className="ml-2 text-gray-400 hover:text-blue-400"><PencilSquareIcon className="w-4 h-4 inline-block" /></button>
                                                </span>
                                            )}
                                        </p>
                                        <p className="flex items-center space-x-1">
                                            <span className="font-semibold">Assigned Underwriter:</span>
                                            {isAssigningUnderwriter ? (
                                                <CustomSelect
                                                    options={underwriters?.map(uw => ({ value: uw.id, label: `${uw.firstName} ${uw.lastName}` })) || []}
                                                    value={selectedUnderwriterId ? { value: selectedUnderwriterId, label: underwriters?.find(uw => uw.id === selectedUnderwriterId)?.firstName + ' ' + underwriters?.find(uw => uw.id === selectedUnderwriterId)?.lastName } : null}
                                                    onChange={(option: any) => setSelectedUnderwriterId(option?.value)}
                                                    onBlur={handleAssignUnderwriter}
                                                    className="w-48 text-black"
                                                    isClearable
                                                />
                                            ) : (
                                                <span>
                                                    {application.assignedUnderwriterName || 'N/A'}
                                                    <button onClick={() => { setIsAssigningUnderwriter(true); setSelectedUnderwriterId(application.assignedUnderwriterId) }} className="ml-2 text-gray-400 hover:text-blue-400"><PencilSquareIcon className="w-4 h-4 inline-block" /></button>
                                                </span>
                                            )}
                                        </p>
                                        <p><span className="font-semibold">Source Channel:</span> {application.sourceChannel}</p>
                                        <p><span className="font-semibold">Marketing Campaign:</span> {application.marketingCampaignId || 'N/A'}</p>
                                    </div>
                                </div>
                            </Card>

                            <Card title="AI Risk & Decision Engine Insights">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-300">
                                    <div>
                                        <p><span className="font-semibold">AI Score:</span> <span className="text-xl font-bold">{application.aiScore}</span></p>
                                        <p className="flex items-center space-x-1">
                                            <span className="font-semibold">Risk Level:</span> <RiskBadge riskLevel={application.riskLevel} />
                                        </p>
                                        <p><span className="font-semibold">Recommended Action:</span> <span className="text-blue-400 font-semibold">{application.recommendedAction}</span></p>
                                        <p><span className="font-semibold">Fraud Detection Score:</span> <span className="font-bold">{application.fraudDetectionScore?.toFixed(2)}%</span></p>
                                        <p><span className="font-semibold">Sentiment Score:</span> <span className="font-bold">{application.sentimentAnalysisScore?.toFixed(2)}</span></p>
                                    </div>
                                    {application.decisionEngineOutput && (
                                        <div>
                                            <p><span className="font-semibold">Decision Engine:</span> <span className={`font-bold ${application.decisionEngineOutput.decision === 'APPROVE' ? 'text-green-400' : application.decisionEngineOutput.decision === 'REJECT' ? 'text-red-400' : 'text-yellow-400'}`}>{application.decisionEngineOutput.decision}</span></p>
                                            <p><span className="font-semibold">Reason Codes:</span> {application.decisionEngineOutput.reasonCodes.join(', ') || 'N/A'}</p>
                                            <p><span className="font-semibold">Confidence Score:</span> {(application.decisionEngineOutput.confidenceScore * 100).toFixed(2)}%</p>
                                            <p><span className="font-semibold">Model Version:</span> {application.decisionEngineOutput.modelVersion}</p>
                                        </div>
                                    )}
                                </div>
                            </Card>

                            <Card title="Applicant Profile (Details available with applicantId lookup)">
                                <p className="text-gray-400">
                                    To fetch full applicant details, use the applicant ID: <code className="bg-gray-700 px-2 py-1 rounded text-sm">{application.applicantId}</code>.
                                    This would typically involve another API call to a `/applicants/{applicantId}` endpoint.
                                </p>
                            </Card>

                        </div>
                        <div className="lg:col-span-1 space-y-6">
                            <Card title="Recent Activity">
                                <ul className="space-y-3">
                                    {application.auditTrail?.slice(0, 5).map((log) => (
                                        <li key={log.id} className="text-sm text-gray-400 border-b border-gray-700 pb-2 last:border-b-0">
                                            <p className="font-semibold text-gray-200">{log.action.replace(/_/g, ' ')}</p>
                                            <p>{log.details}</p>
                                            <p className="text-xs text-gray-500">{formatDate(log.timestamp)} by {log.userName}</p>
                                        </li>
                                    ))}
                                    {(application.auditTrail?.length || 0) === 0 && <p className="text-gray-400">No recent activity.</p>}
                                </ul>
                            </Card>

                            <Card title="Open Tasks">
                                <ul className="space-y-3">
                                    {application.relatedTasks?.filter(t => t.status !== 'COMPLETED').map((task) => (
                                        <li key={task.id} className="text-sm text-gray-400 border-b border-gray-700 pb-2 last:border-b-0">
                                            <p className="font-semibold text-gray-200">{task.title}</p>
                                            <p className="flex items-center space-x-1">
                                                <PriorityBadge priority={task.priority} />
                                                <span>Due: {formatDate(task.dueDate)}</span>
                                            </p>
                                            <p className="text-xs text-gray-500">Assigned to: {task.assignedToName}</p>
                                        </li>
                                    ))}
                                    {(application.relatedTasks?.filter(t => t.status !== 'COMPLETED').length || 0) === 0 && <p className="text-gray-400">No open tasks.</p>}
                                </ul>
                                <button className="mt-4 w-full flex items-center justify-center space-x-2 px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                    <PlusIcon className="w-5 h-5" /> Add New Task
                                </button>
                            </Card>
                        </div>
                    </div>
                )}

                {currentTab === 'documents' && (
                    <div className="space-y-4">
                        <div className="flex justify-end">
                            <button
                                onClick={() => setIsUploadingDocument(true)}
                                className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                            >
                                <CloudArrowUpIcon className="-ml-1 mr-2 h-5 w-5" />
                                Upload Document
                            </button>
                        </div>
                        {application.documents && application.documents.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {application.documents.map(doc => (
                                    <Card key={doc.id} title={doc.fileName}>
                                        <div className="flex items-center justify-between mb-2">
                                            <p className="text-sm font-medium text-gray-300 flex items-center">
                                                <PaperClipIcon className="w-4 h-4 mr-1 text-gray-400" />
                                                {doc.documentType.replace(/_/g, ' ')}
                                            </p>
                                            <span className={`px-2 py-0.5 rounded-full text-xs font-semibold ${doc.verificationStatus === 'VERIFIED' ? 'text-green-500 bg-green-900/20' : doc.verificationStatus === 'REJECTED' ? 'text-red-500 bg-red-900/20' : 'text-indigo-500 bg-indigo-900/20'}`}>
                                                {doc.verificationStatus}
                                            </span>
                                        </div>
                                        <p className="text-xs text-gray-400">Uploaded by {doc.uploadedBy} on {formatDate(doc.uploadDate)}</p>
                                        {doc.aiVerificationScore && <p className="text-xs text-gray-400">AI Verification Score: {doc.aiVerificationScore}%</p>}
                                        {doc.verificationNotes && <p className="text-xs text-gray-500 mt-1">Notes: {doc.verificationNotes}</p>}
                                        <div className="flex space-x-2 mt-3">
                                            <a href={doc.fileUrl} target="_blank" rel="noopener noreferrer" className="inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                                <EyeIcon className="-ml-0.5 mr-1 h-4 w-4" /> View
                                            </a>
                                            <button className="inline-flex items-center px-3 py-1.5 border border-gray-600 text-xs font-medium rounded-md text-gray-300 hover:bg-gray-700">
                                                <CheckCircleIcon className="-ml-0.5 mr-1 h-4 w-4" /> Verify
                                            </button>
                                            <button className="inline-flex items-center px-3 py-1.5 border border-red-600 text-xs font-medium rounded-md text-red-300 hover:bg-red-700 hover:text-white">
                                                <XCircleIcon className="-ml-0.5 mr-1 h-4 w-4" /> Reject
                                            </button>
                                        </div>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-400">No documents uploaded for this application.</p>
                        )}
                    </div>
                )}

                {currentTab === 'notes' && (
                    <div className="space-y-4">
                        <div className="flex justify-end">
                            <button
                                onClick={() => setIsAddingNote(true)}
                                className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                            >
                                <PlusIcon className="-ml-1 mr-2 h-5 w-5" />
                                Add Note
                            </button>
                        </div>
                        {application.notes && application.notes.length > 0 ? (
                            <div className="space-y-4">
                                {application.notes.map(note => (
                                    <Card key={note.id} title={`Note by ${note.authorName}`}>
                                        <p className="text-gray-300 mb-2">{note.content}</p>
                                        <p className="text-xs text-gray-500">
                                            {formatDate(note.timestamp)} {note.isPrivate && <span className="ml-2 text-red-400">(Private)</span>}
                                        </p>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-400">No notes for this application.</p>
                        )}
                    </div>
                )}

                {currentTab === 'tasks' && (
                    <div className="space-y-4">
                        <div className="flex justify-end">
                            <button className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                <PlusIcon className="-ml-1 mr-2 h-5 w-5" />
                                Create New Task
                            </button>
                        </div>
                        {application.relatedTasks && application.relatedTasks.length > 0 ? (
                            <div className="space-y-4">
                                {application.relatedTasks.map(task => (
                                    <Card key={task.id} title={task.title}>
                                        <p className="text-gray-300 mb-2">{task.description}</p>
                                        <div className="flex items-center space-x-4 text-sm text-gray-400">
                                            <p><span className="font-semibold">Assigned To:</span> {task.assignedToName}</p>
                                            <p><span className="font-semibold">Due Date:</span> {formatDate(task.dueDate)}</p>
                                            <p><span className="font-semibold">Status:</span>
                                                <span className={`ml-1 px-2 py-0.5 rounded-full text-xs font-semibold ${task.status === 'COMPLETED' ? 'text-green-500 bg-green-900/20' : task.status === 'OVERDUE' ? 'text-red-500 bg-red-900/20' : 'text-indigo-500 bg-indigo-900/20'}`}>
                                                    {task.status}
                                                </span>
                                            </p>
                                            <PriorityBadge priority={task.priority} />
                                        </div>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-400">No tasks associated with this application.</p>
                        )}
                    </div>
                )}

                {currentTab === 'audit' && (
                    <div className="space-y-4">
                        {application.auditTrail && application.auditTrail.length > 0 ? (
                            <div className="space-y-4">
                                {application.auditTrail.map(log => (
                                    <Card key={log.id} title={log.action.replace(/_/g, ' ')}>
                                        <p className="text-gray-300 mb-2">{log.details}</p>
                                        <p className="text-xs text-gray-500">
                                            {formatDate(log.timestamp)} by {log.userName} (IP: {log.ipAddress || 'N/A'})
                                        </p>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-400">No audit trail entries for this application.</p>
                        )}
                    </div>
                )}

                {currentTab === 'offer' && application.offerDetails && renderOfferDetails(application.offerDetails)}
                {currentTab === 'payments' && application.paymentSchedule && renderPaymentSchedule(application.paymentSchedule)}
                {currentTab === 'collateral' && application.collateralDetails && application.collateralDetails.length > 0 && (
                    <div className="space-y-4">
                        {application.collateralDetails.map(collateral => (
                            <Card key={collateral.id} title={`Collateral: ${collateral.type}`}>
                                <p className="text-gray-300 mb-2">{collateral.description}</p>
                                <p><span className="font-semibold text-gray-200">Estimated Value:</span> {formatCurrency(collateral.estimatedValue)}</p>
                                <p><span className="font-semibold text-gray-200">Valuation Date:</span> {formatDate(collateral.valuationDate)}</p>
                                <p><span className="font-semibold text-gray-200">Lien Status:</span> <span className={`${collateral.lienStatus === 'CLEAR' ? 'text-green-400' : 'text-red-400'}`}>{collateral.lienStatus}</span></p>
                                {collateral.riskAssessment && <p><span className="font-semibold text-gray-200">Risk Assessment:</span> <RiskBadge riskLevel={collateral.riskAssessment} /></p>}
                                <div className="mt-3 flex space-x-2">
                                    {collateral.valuationReportUrl && (
                                        <a href={collateral.valuationReportUrl} target="_blank" rel="noopener noreferrer" className="inline-flex items-center px-3 py-1.5 border border-transparent text-xs font-medium rounded-md shadow-sm text-white bg-purple-600 hover:bg-purple-700">
                                            <DocumentTextIcon className="-ml-0.5 mr-1 h-4 w-4" /> View Report
                                        </a>
                                    )}
                                    {collateral.insurancePolicyNumber && (
                                        <span className="inline-flex items-center px-3 py-1.5 text-xs font-medium rounded-md bg-gray-700 text-gray-300">
                                            <ShieldCheckIcon className="-ml-0.5 mr-1 h-4 w-4" /> Policy: {collateral.insurancePolicyNumber}
                                        </span>
                                    )}
                                </div>
                            </Card>
                        ))}
                    </div>
                )}
                {currentTab === 'compliance' && application.complianceChecks && renderComplianceChecks(application.complianceChecks)}

            </div>

            {/* Modals for Add Note / Upload Document */}
            <Modal isOpen={isAddingNote} onClose={() => setIsAddingNote(false)} title="Add New Note">
                <div className="space-y-4">
                    <div>
                        <label htmlFor="note-content" className="block text-sm font-medium text-gray-300 mb-1">Note Content</label>
                        <textarea
                            id="note-content"
                            rows={4}
                            className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-blue-500 focus:border-blue-500"
                            value={newNoteContent}
                            onChange={(e) => setNewNoteContent(e.target.value)}
                            placeholder="Type your note here..."
                        ></textarea>
                    </div>
                    <div className="flex items-center">
                        <input
                            id="private-note"
                            type="checkbox"
                            checked={newNoteIsPrivate}
                            onChange={(e) => setNewNoteIsPrivate(e.target.checked)}
                            className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-600 rounded bg-gray-700"
                        />
                        <label htmlFor="private-note" className="ml-2 block text-sm text-gray-300">
                            Mark as private (only visible to specific roles)
                        </label>
                    </div>
                    <div className="flex justify-end space-x-3">
                        <button
                            onClick={() => setIsAddingNote(false)}
                            className="px-4 py-2 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleAddNote}
                            className="px-4 py-2 text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
                        >
                            Add Note
                        </button>
                    </div>
                </div>
            </Modal>

            <Modal isOpen={isUploadingDocument} onClose={() => setIsUploadingDocument(false)} title="Upload New Document">
                <div className="space-y-4">
                    <div>
                        <label htmlFor="document-type" className="block text-sm font-medium text-gray-300 mb-1">Document Type</label>
                        <CustomSelect
                            id="document-type"
                            options={Object.values(DocumentType).map(dt => ({ value: dt, label: dt.replace(/_/g, ' ') }))}
                            value={newDocumentType ? { value: newDocumentType, label: newDocumentType.replace(/_/g, ' ') } : null}
                            onChange={(option: any) => setNewDocumentType(option?.value)}
                            placeholder="Select document type"
                        />
                    </div>
                    <div>
                        <label htmlFor="file-upload" className="block text-sm font-medium text-gray-300 mb-1">File</label>
                        <div className="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-600 border-dashed rounded-md">
                            <div className="space-y-1 text-center">
                                <svg
                                    className="mx-auto h-12 w-12 text-gray-400"
                                    stroke="currentColor"
                                    fill="none"
                                    viewBox="0 0 48 48"
                                    aria-hidden="true"
                                >
                                    <path
                                        d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m-4-4v-4m5 4H15"
                                        strokeWidth="2"
                                        strokeLinecap="round"
                                        strokeLinejoin="round"
                                    />
                                </svg>
                                <div className="flex text-sm text-gray-400">
                                    <label
                                        htmlFor="file-upload"
                                        className="relative cursor-pointer bg-gray-800 rounded-md font-medium text-blue-400 hover:text-blue-300 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-blue-500"
                                    >
                                        <span>Upload a file</span>
                                        <input
                                            id="file-upload"
                                            name="file-upload"
                                            type="file"
                                            className="sr-only"
                                            onChange={(e) => e.target.files && setNewDocumentFile(e.target.files[0])}
                                        />
                                    </label>
                                    <p className="pl-1">or drag and drop</p>
                                </div>
                                <p className="text-xs text-gray-500">
                                    {newDocumentFile ? newDocumentFile.name : 'PNG, JPG, PDF up to 10MB'}
                                </p>
                            </div>
                        </div>
                    </div>
                    <div className="flex justify-end space-x-3">
                        <button
                            onClick={() => setIsUploadingDocument(false)}
                            className="px-4 py-2 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleDocumentUpload}
                            disabled={!newDocumentFile || !newDocumentType}
                            className="px-4 py-2 text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            Upload
                        </button>
                    </div>
                </div>
            </Modal>
        </div>
    );
};

// --- Dashboard Widgets ---

export const ApplicationStatusChart: React.FC<{ applications: LoanApplication[] }> = ({ applications }) => {
    const statusCounts = applications.reduce((acc, app) => {
        acc[app.status] = (acc[app.status] || 0) + 1;
        return acc;
    }, {} as Record<ApplicationStatus, number>);

    const data = {
        labels: Object.keys(statusCounts).map(s => (s as ApplicationStatus).replace(/_/g, ' ')),
        datasets: [
            {
                data: Object.values(statusCounts),
                backgroundColor: Object.keys(statusCounts).map(s => {
                    switch (s as ApplicationStatus) {
                        case ApplicationStatus.APPROVED: return '#10B981'; // green
                        case ApplicationStatus.REJECTED: return '#EF4444'; // red
                        case ApplicationStatus.PENDING_REVIEW: return '#6366F1'; // indigo
                        case ApplicationStatus.UNDERWRITING: return '#FBBF24'; // yellow
                        case ApplicationStatus.AI_PRE_SCREEN: return '#A78BFA'; // violet
                        case ApplicationStatus.DOCUMENT_VERIFICATION: return '#EC4899'; // pink
                        case ApplicationStatus.FUNDED: return '#3B82F6'; // blue
                        case ApplicationStatus.WITHDRAWN: return '#6B7280'; // gray
                        case ApplicationStatus.ON_HOLD: return '#F97316'; // orange
                        case ApplicationStatus.PENDING_CUSTOMER_ACTION: return '#8B5CF6'; // purple
                        case ApplicationStatus.ESCALATED: return '#F43F5E'; // rose
                        case ApplicationStatus.COLLECTION: return '#DC2626'; // dark red
                        case ApplicationStatus.REFINANCED: return '#14B8A6'; // teal
                        case ApplicationStatus.CLOSED: return '#4B5563'; // dark gray
                        default: return '#9CA3AF'; // light gray
                    }
                }),
                borderColor: '#1F2937', // bg-gray-800
                borderWidth: 1,
            },
        ],
    };

    const options = {
        responsive: true,
        plugins: {
            legend: {
                position: 'right' as const,
                labels: {
                    color: 'white',
                    font: {
                        size: 10,
                    }
                },
            },
            title: {
                display: false,
            },
            tooltip: {
                callbacks: {
                    label: function(context: any) {
                        const label = context.label || '';
                        const value = context.parsed || 0;
                        const total = context.dataset.data.reduce((sum: number, val: number) => sum + val, 0);
                        const percentage = total > 0 ? ((value / total) * 100).toFixed(2) : 0;
                        return `${label}: ${value} (${percentage}%)`;
                    }
                }
            }
        },
    };

    return (
        <Card title="Application Status Distribution">
            <div className="relative h-64 flex justify-center">
                <Pie data={data} options={options} />
            </div>
        </Card>
    );
};

export const LoanTypeDistributionChart: React.FC<{ applications: LoanApplication[] }> = ({ applications }) => {
    const loanTypeCounts = applications.reduce((acc, app) => {
        acc[app.loanType] = (acc[app.loanType] || 0) + 1;
        return acc;
    }, {} as Record<LoanType, number>);

    const data = {
        labels: Object.keys(loanTypeCounts).map(lt => (lt as LoanType).replace(/_/g, ' ')),
        datasets: [
            {
                label: 'Number of Applications',
                data: Object.values(loanTypeCounts),
                backgroundColor: [
                    '#3B82F6', '#10B981', '#FBBF24', '#EF4444', '#6366F1',
                    '#EC4899', '#A78BFA', '#F97316', '#06B6D4', '#84CC16',
                    '#EAB308', '#F472B6', '#94A3B8'
                ],
                borderColor: '#1F2937',
                borderWidth: 1,
            },
        ],
    };

    const options = {
        responsive: true,
        plugins: {
            legend: {
                position: 'right' as const,
                labels: {
                    color: 'white',
                    font: {
                        size: 10,
                    }
                },
            },
            title: {
                display: false,
            },
        },
        scales: {
            x: {
                grid: {
                    display: false,
                },
                ticks: {
                    color: 'white',
                }
            },
            y: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                },
                ticks: {
                    color: 'white',
                }
            },
        }
    };

    return (
        <Card title="Loan Type Distribution">
            <div className="relative h-64 flex justify-center">
                <Bar data={data} options={options} />
            </div>
        </Card>
    );
};

export const RecentAlertsWidget: React.FC = () => {
    const { data: alerts, isLoading, error } = useAlerts();

    if (isLoading) return <Card title="Recent Alerts"><p className="text-gray-400">Loading alerts...</p></Card>;
    if (error) return <Card title="Recent Alerts"><p className="text-red-400">Error loading alerts: {error.message}</p></Card>;

    return (
        <Card title="Recent System Alerts">
            {alerts && alerts.length > 0 ? (
                <ul className="space-y-3">
                    {alerts.slice(0, 5).map(alert => (
                        <li key={alert.id} className="text-sm border-b border-gray-700 pb-2 last:border-b-0">
                            <div className="flex items-center space-x-2">
                                <ExclamationTriangleIcon className={`w-5 h-5 ${alert.severity === 'CRITICAL' ? 'text-red-500' : alert.severity === 'HIGH' ? 'text-orange-500' : 'text-yellow-500'}`} />
                                <p className={`font-semibold ${alert.severity === 'CRITICAL' ? 'text-red-400' : alert.severity === 'HIGH' ? 'text-orange-400' : 'text-yellow-400'}`}>
                                    {alert.type.replace(/_/g, ' ')} ({alert.severity})
                                </p>
                            </div>
                            <p className="text-gray-300 ml-7">{alert.message}</p>
                            {alert.loanApplicationId && (
                                <p className="text-xs text-gray-500 ml-7">Application: {alert.loanApplicationId}</p>
                            )}
                            <p className="text-xs text-gray-500 ml-7">{formatDate(alert.timestamp)}</p>
                        </li>
                    ))}
                </ul>
            ) : (
                <p className="text-gray-400">No new alerts.</p>
            )}
            <button className="mt-4 w-full flex items-center justify-center space-x-2 px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                <BellIcon className="w-5 h-5" /> View All Alerts
            </button>
        </Card>
    );
};

export const PerformanceMetricsWidget: React.FC<{ applications: LoanApplication[] }> = ({ applications }) => {
    const totalApplications = applications.length;
    const approvedCount = applications.filter(app => app.status === ApplicationStatus.APPROVED || app.status === ApplicationStatus.FUNDED).length;
    const rejectedCount = applications.filter(app => app.status === ApplicationStatus.REJECTED).length;
    const pendingCount = applications.filter(app => app.status === ApplicationStatus.PENDING_REVIEW || app.status === ApplicationStatus.UNDERWRITING || app.status === ApplicationStatus.AI_PRE_SCREEN || app.status === ApplicationStatus.DOCUMENT_VERIFICATION).length;

    const approvalRate = totalApplications > 0 ? (approvedCount / totalApplications) * 100 : 0;
    const rejectionRate = totalApplications > 0 ? (rejectedCount / totalApplications) * 100 : 0;

    const totalAmountApproved = applications
        .filter(app => app.status === ApplicationStatus.APPROVED || app.status === ApplicationStatus.FUNDED)
        .reduce((sum, app) => sum + (app.offerDetails?.offeredAmount || app.amountRequested), 0);

    const averageProcessingTime = useMemo(() => {
        const processedApps = applications.filter(app =>
            app.status === ApplicationStatus.APPROVED || app.status === ApplicationStatus.REJECTED || app.status === ApplicationStatus.FUNDED
        );
        if (processedApps.length === 0) return 'N/A';

        const totalProcessingTimeMs = processedApps.reduce((sum, app) => {
            const appDate = new Date(app.applicationDate);
            const lastUpdatedDate = new Date(app.lastUpdated);
            return sum + (lastUpdatedDate.getTime() - appDate.getTime());
        }, 0);

        const averageMs = totalProcessingTimeMs / processedApps.length;
        const averageDays = averageMs / (1000 * 60 * 60 * 24);
        return `${averageDays.toFixed(1)} days`;
    }, [applications]);

    return (
        <Card title="Lending Performance Metrics">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 text-gray-300">
                <div className="flex items-center space-x-2">
                    <Bars3Icon className="w-6 h-6 text-blue-400" />
                    <div>
                        <p className="text-sm text-gray-400">Total Applications</p>
                        <p className="text-xl font-bold text-white">{totalApplications}</p>
                    </div>
                </div>
                <div className="flex items-center space-x-2">
                    <CheckCircleIcon className="w-6 h-6 text-green-400" />
                    <div>
                        <p className="text-sm text-gray-400">Approved/Funded</p>
                        <p className="text-xl font-bold text-white">{approvedCount} ({approvalRate.toFixed(1)}%)</p>
                    </div>
                </div>
                <div className="flex items-center space-x-2">
                    <XCircleIcon className="w-6 h-6 text-red-400" />
                    <div>
                        <p className="text-sm text-gray-400">Rejected</p>
                        <p className="text-xl font-bold text-white">{rejectedCount} ({rejectionRate.toFixed(1)}%)</p>
                    </div>
                </div>
                <div className="flex items-center space-x-2">
                    <ClockIcon className="w-6 h-6 text-yellow-400" />
                    <div>
                        <p className="text-sm text-gray-400">Pending Review</p>
                        <p className="text-xl font-bold text-white">{pendingCount}</p>
                    </div>
                </div>
                <div className="flex items-center space-x-2 sm:col-span-2">
                    <CurrencyDollarIcon className="w-6 h-6 text-green-500" />
                    <div>
                        <p className="text-sm text-gray-400">Total Amount Approved</p>
                        <p className="text-xl font-bold text-white">{formatCurrency(totalAmountApproved)}</p>
                    </div>
                </div>
                <div className="flex items-center space-x-2 sm:col-span-2">
                    <HourglassBottomIcon className="w-6 h-6 text-indigo-400" /> {/* Assuming HourglassBottomIcon from somewhere */}
                    <div>
                        <p className="text-sm text-gray-400">Avg. Processing Time</p>
                        <p className="text-xl font-bold text-white">{averageProcessingTime}</p>
                    </div>
                </div>
            </div>
        </Card>
    );
};
// Add a placeholder icon import if HourglassBottomIcon isn't available from heroicons
import { HourglassBottomIcon } from '@heroicons/react/24/outline'; // Or any other suitable icon


// --- Main View Component ---

const LoanApplicationsView: React.FC = () => {
    const [currentPage, setCurrentPage] = useState(1);
    const [filters, setFilters] = useState<any>({});
    const [sort, setSort] = useState<{ field: string; direction: 'asc' | 'desc' }>({ field: 'applicationDate', direction: 'desc' });
    const [selectedApplicationId, setSelectedApplicationId] = useState<string | null>(null);
    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

    const { data: applicationsData, isLoading, error, refetch } = useApplications(currentPage, ITEMS_PER_PAGE, filters, sort);
    const { data: selectedApplication, isLoading: isLoadingSelectedApp, error: selectedAppError, refetch: refetchSelectedApp } = useApplicationById(selectedApplicationId);

    const totalApplications = applicationsData?.total || 0;
    const totalPages = Math.ceil(totalApplications / ITEMS_PER_PAGE);

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters((prev: any) => ({ ...prev, [key]: value }));
        setCurrentPage(1); // Reset to first page on filter change
    }, []);

    const handleSortChange = useCallback((field: string) => {
        setSort(prev => ({
            field,
            direction: prev.field === field && prev.direction === 'asc' ? 'desc' : 'asc',
        }));
    }, []);

    const handleClearFilters = useCallback(() => {
        setFilters({});
        setSort({ field: 'applicationDate', direction: 'desc' });
        setCurrentPage(1);
    }, []);

    const handleApplicationUpdate = useCallback(() => {
        refetch(); // Refetch the list
        if (selectedApplicationId) {
            refetchSelectedApp(); // Refetch the detailed view
        }
    }, [refetch, refetchSelectedApp, selectedApplicationId]);

    const handleCreateNewApplication = useCreateApplication();

    const handleFormSubmit = async (formData: Partial<LoanApplication>) => {
        try {
            await handleCreateNewApplication.mutateAsync(formData);
            setIsCreateModalOpen(false);
        } catch (err) {
            // Error handled by mutation hook via toast
        }
    }


    const loanTypeOptions = useMemo(() => Object.values(LoanType).map(type => ({ value: type, label: type.replace(/_/g, ' ') })), []);
    const statusOptions = useMemo(() => Object.values(ApplicationStatus).map(status => ({ value: status, label: status.replace(/_/g, ' ') })), []);
    const riskLevelOptions = useMemo(() => Object.values(RiskLevel).map(level => ({ value: level, label: level.replace(/_/g, ' ') })), []);

    const { data: underwriters } = useUnderwriters();
    const underwriterOptions = useMemo(() => underwriters?.map(uw => ({ value: uw.id, label: `${uw.firstName} ${uw.lastName}` })) || [], [underwriters]);

    return (
        <div className="space-y-6">
            <h2 className="text-3xl font-bold text-white tracking-wider">Loan Origination System</h2>

            {/* Top-level Widgets */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <Card title="Mission Brief">
                    <p className="text-gray-400">An AI-powered loan origination and management system built for speed and precision. Automate underwriting, scoring, and document verification to accelerate the entire lending lifecycle from application to closing.</p>
                </Card>
                {applicationsData?.applications && <ApplicationStatusChart applications={applicationsData.applications} />}
                {applicationsData?.applications && <LoanTypeDistributionChart applications={applicationsData.applications} />}
                <PerformanceMetricsWidget applications={applicationsData?.applications || []} />
                <RecentAlertsWidget />
                <Card title="AI Pre-Approval Scoring"><p>Get an instant, AI-driven risk assessment and pre-approval decision for new applications, cutting review times from days to seconds.</p></Card>
                <Card title="Risk-Adjusted Loan Offers"><p>Automatically generate personalized loan offers with terms dynamically adjusted for the applicant's holistic risk profile.</p></Card>
                <Card title="Predictive Default Monitoring"><p>Our AI models continuously monitor active loans to predict and flag potential defaults months before they occur, enabling proactive intervention.</p></Card>
            </div>

            {/* Loan Application Management Section */}
            <Card title="Loan Applications Overview">
                <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6">
                    <div className="relative flex-grow">
                        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <MagnifyingGlassIcon className="h-5 w-5 text-gray-400" />
                        </div>
                        <input
                            type="text"
                            placeholder="Search applications (ID, Applicant, Purpose)..."
                            className="block w-full pl-10 pr-3 py-2 border border-gray-600 rounded-md bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                            value={filters.search || ''}
                            onChange={(e) => handleFilterChange('search', e.target.value)}
                        />
                    </div>
                    <div className="flex items-center space-x-2">
                        <DropdownMenu
                            trigger={
                                <FilterButton
                                    label="Filters"
                                    icon={FilterIcon}
                                    onClick={() => {}} // No-op, dropdown handles state
                                    isActive={Object.keys(filters).length > 0}
                                />
                            }
                        >
                            <div className="p-4 space-y-3">
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Status</label>
                                    <CustomSelect
                                        options={statusOptions}
                                        value={statusOptions.find(opt => opt.value === filters.status)}
                                        onChange={(option: any) => handleFilterChange('status', option ? option.value : null)}
                                        isClearable
                                        placeholder="Select status"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Loan Type</label>
                                    <CustomSelect
                                        options={loanTypeOptions}
                                        value={loanTypeOptions.find(opt => opt.value === filters.loanType)}
                                        onChange={(option: any) => handleFilterChange('loanType', option ? option.value : null)}
                                        isClearable
                                        placeholder="Select loan type"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Risk Level</label>
                                    <CustomSelect
                                        options={riskLevelOptions}
                                        value={riskLevelOptions.find(opt => opt.value === filters.riskLevel)}
                                        onChange={(option: any) => handleFilterChange('riskLevel', option ? option.value : null)}
                                        isClearable
                                        placeholder="Select risk level"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Underwriter</label>
                                    <CustomSelect
                                        options={underwriterOptions}
                                        value={underwriterOptions.find(opt => opt.value === filters.underwriterId)}
                                        onChange={(option: any) => handleFilterChange('underwriterId', option ? option.value : null)}
                                        isClearable
                                        placeholder="Select underwriter"
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Amount Range</label>
                                    <div className="flex space-x-2">
                                        <input
                                            type="number"
                                            placeholder="Min"
                                            className="w-full px-3 py-2 border border-gray-600 rounded-md bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                                            value={filters.minAmount || ''}
                                            onChange={(e) => handleFilterChange('minAmount', parseFloat(e.target.value) || undefined)}
                                        />
                                        <input
                                            type="number"
                                            placeholder="Max"
                                            className="w-full px-3 py-2 border border-gray-600 rounded-md bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                                            value={filters.maxAmount || ''}
                                            onChange={(e) => handleFilterChange('maxAmount', parseFloat(e.target.value) || undefined)}
                                        />
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Date Range</label>
                                    <div className="flex items-center space-x-2">
                                        <DatePicker
                                            selected={filters.dateRange?.startDate ? new Date(filters.dateRange.startDate) : null}
                                            onChange={(date: Date | null) => handleFilterChange('dateRange', { ...filters.dateRange, startDate: date?.toISOString() })}
                                            placeholderText="Start Date"
                                            className="w-full px-3 py-2 border border-gray-600 rounded-md bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                                            dateFormat="MM/dd/yyyy"
                                        />
                                        <DatePicker
                                            selected={filters.dateRange?.endDate ? new Date(filters.dateRange.endDate) : null}
                                            onChange={(date: Date | null) => handleFilterChange('dateRange', { ...filters.dateRange, endDate: date?.toISOString() })}
                                            placeholderText="End Date"
                                            className="w-full px-3 py-2 border border-gray-600 rounded-md bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                                            dateFormat="MM/dd/yyyy"
                                        />
                                    </div>
                                </div>
                                <button
                                    onClick={handleClearFilters}
                                    className="w-full flex items-center justify-center space-x-2 px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-gray-300 bg-gray-600 hover:bg-gray-500"
                                >
                                    <ArrowPathIcon className="-ml-1 mr-2 h-5 w-5" /> Clear Filters
                                </button>
                            </div>
                        </DropdownMenu>
                        <button
                            onClick={() => refetch()}
                            className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                        >
                            <ArrowPathIcon className="-ml-1 mr-2 h-5 w-5" />
                            Refresh
                        </button>
                        <button
                            onClick={() => setIsCreateModalOpen(true)}
                            className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                        >
                            <PlusIcon className="-ml-1 mr-2 h-5 w-5" />
                            New Application
                        </button>
                    </div>
                </div>

                {isLoading ? (
                    <div className="text-center py-8 text-gray-400">
                        <ArrowPathIcon className="mx-auto h-12 w-12 animate-spin text-blue-500" />
                        <p className="mt-4">Loading loan applications...</p>
                    </div>
                ) : error ? (
                    <div className="text-center py-8 text-red-400">
                        <XCircleIcon className="mx-auto h-12 w-12" />
                        <p className="mt-4">Error loading applications: {error.message}</p>
                    </div>
                ) : (
                    <>
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-700">
                                <thead className="bg-gray-800">
                                    <tr>
                                        <SortableHeader label="Application ID" field="id" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Applicant Name" field="applicantName" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Loan Type" field="loanType" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Amount" field="amountRequested" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Status" field="status" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Risk Level" field="riskLevel" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Underwriter" field="assignedUnderwriterName" currentSort={sort} onSort={handleSortChange} />
                                        <SortableHeader label="Application Date" field="applicationDate" currentSort={sort} onSort={handleSortChange} />
                                        <th scope="col" className="relative px-6 py-3">
                                            <span className="sr-only">Actions</span>
                                        </th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-700 bg-gray-900">
                                    {applicationsData.applications.map((app) => (
                                        <tr key={app.id} className="hover:bg-gray-800 transition-colors duration-150">
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-300">{app.id}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{app.applicantName}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{app.loanType.replace(/_/g, ' ')}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(app.amountRequested)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <StatusBadge status={app.status} />
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <RiskBadge riskLevel={app.riskLevel} />
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{app.assignedUnderwriterName || 'N/A'}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-400">{formatDate(app.applicationDate)}</td>
                                            <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                <DropdownMenu
                                                    trigger={
                                                        <button className="text-gray-400 hover:text-white p-1 rounded-full hover:bg-gray-700">
                                                            <EllipsisVerticalIcon className="h-5 w-5" />
                                                        </button>
                                                    }
                                                >
                                                    <DropdownMenuItem onClick={() => setSelectedApplicationId(app.id)} icon={EyeIcon}>
                                                        View Details
                                                    </DropdownMenuItem>
                                                    <DropdownMenuItem onClick={() => toast.info('Edit action coming soon!')} icon={PencilSquareIcon}>
                                                        Edit Application
                                                    </DropdownMenuItem>
                                                    <DropdownMenuItem onClick={() => toast.error('Delete action coming soon!')} icon={TrashIcon}>
                                                        Delete Application
                                                    </DropdownMenuItem>
                                                </DropdownMenu>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <Paginator
                            currentPage={currentPage}
                            totalPages={totalPages}
                            onPageChange={setCurrentPage}
                        />
                    </>
                )}
            </Card>

            {/* Application Detail Modal */}
            <Modal
                isOpen={!!selectedApplicationId}
                onClose={() => setSelectedApplicationId(null)}
                title={isLoadingSelectedApp ? 'Loading Application...' : selectedApplicationError ? 'Error' : `Application: ${selectedApplication?.applicantName || ''}`}
                size="2xl"
            >
                {isLoadingSelectedApp && <div className="text-center py-8 text-gray-400"><ArrowPathIcon className="mx-auto h-12 w-12 animate-spin text-blue-500" /><p className="mt-4">Loading application details...</p></div>}
                {selectedAppError && <div className="text-center py-8 text-red-400"><XCircleIcon className="mx-auto h-12 w-12" /><p className="mt-4">Error: {selectedAppError.message}</p></div>}
                {selectedApplication && !isLoadingSelectedApp && !selectedAppError && (
                    <LoanApplicationDetail
                        application={selectedApplication}
                        onClose={() => setSelectedApplicationId(null)}
                        onUpdate={handleApplicationUpdate}
                    />
                )}
            </Modal>

            {/* Create New Application Modal */}
            <Modal
                isOpen={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
                title="Create New Loan Application"
                size="lg"
            >
                <NewLoanApplicationForm onSubmit={handleFormSubmit} onClose={() => setIsCreateModalOpen(false)} />
            </Modal>
        </div>
    );
};


// --- New Loan Application Form Component ---
export const NewLoanApplicationForm: React.FC<{ onSubmit: (data: Partial<LoanApplication>) => void; onClose: () => void }> = ({ onSubmit, onClose }) => {
    const [formData, setFormData] = useState<Partial<LoanApplication & LoanApplicant>>({
        applicantName: '',
        loanType: LoanType.PERSONAL,
        amountRequested: 0,
        termMonths: 12,
        purpose: '',
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        nationalId: '',
        annualIncome: 0,
    });
    const [currentStep, setCurrentStep] = useState(1);
    const totalSteps = 3;

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: type === 'number' ? parseFloat(value) : value,
        }));
    };

    const handleSelectChange = (name: string, option: any) => {
        setFormData(prev => ({
            ...prev,
            [name]: option ? option.value : null,
        }));
    };

    const handleNextStep = () => setCurrentStep(prev => prev + 1);
    const handlePrevStep = () => setCurrentStep(prev => prev - 1);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        // Basic validation for final step
        if (!formData.applicantName || !formData.loanType || !formData.amountRequested || !formData.termMonths || !formData.purpose) {
            toast.error('Please fill all required loan details.');
            return;
        }
        if (!formData.firstName || !formData.lastName || !formData.email || !formData.nationalId || !formData.annualIncome) {
            toast.error('Please fill all required applicant details.');
            return;
        }

        // Combine applicant and application data
        const newApplicant: LoanApplicant = {
            id: `temp-user-${Date.now()}`, // Temporary ID, could be generated on backend
            firstName: formData.firstName || '',
            lastName: formData.lastName || '',
            email: formData.email || '',
            phone: formData.phone || '',
            nationalId: formData.nationalId || '',
            annualIncome: formData.annualIncome || 0,
            dateOfBirth: '1990-01-01', // Placeholder
            address: '123 Main St',
            city: 'Anytown',
            state: 'CA',
            zipCode: '90210',
            nationality: 'US',
            employmentStatus: 'Employed',
            creditScore: Math.floor(Math.random() * (850 - 300 + 1)) + 300,
            dependents: 0,
            existingDebts: 0,
            assetsValue: 0,
        };

        const newApplication: Partial<LoanApplication> = {
            applicantId: newApplicant.id,
            applicantName: `${newApplicant.firstName} ${newApplicant.lastName}`,
            loanType: formData.loanType,
            amountRequested: formData.amountRequested,
            termMonths: formData.termMonths,
            purpose: formData.purpose,
            sourceChannel: 'Manual Entry',
            // Default values handled by the createApplication API function
        };

        // In a real app, you'd send `newApplicant` to an /applicants endpoint first,
        // then use the returned applicant ID in `newApplication`.
        // For this mock, we're passing it all together.
        onSubmit(newApplication);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-6">
            <div className="flex justify-between items-center text-sm font-medium">
                <span className={`px-3 py-1 rounded-full ${currentStep === 1 ? 'bg-blue-600' : 'bg-gray-700'} text-white`}>1. Loan Details</span>
                <div className="h-0.5 w-12 bg-gray-600"></div>
                <span className={`px-3 py-1 rounded-full ${currentStep === 2 ? 'bg-blue-600' : 'bg-gray-700'} text-white`}>2. Applicant Info</span>
                <div className="h-0.5 w-12 bg-gray-600"></div>
                <span className={`px-3 py-1 rounded-full ${currentStep === 3 ? 'bg-blue-600' : 'bg-gray-700'} text-white`}>3. Review & Submit</span>
            </div>

            {currentStep === 1 && (
                <div className="space-y-4">
                    <div>
                        <label htmlFor="applicantName" className="block text-sm font-medium text-gray-300">Applicant Full Name</label>
                        <input
                            type="text"
                            name="applicantName"
                            id="applicantName"
                            value={formData.applicantName}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="loanType" className="block text-sm font-medium text-gray-300">Loan Type</label>
                        <CustomSelect
                            id="loanType"
                            options={Object.values(LoanType).map(type => ({ value: type, label: type.replace(/_/g, ' ') }))}
                            value={loanTypeOptions.find(opt => opt.value === formData.loanType)}
                            onChange={(option: any) => handleSelectChange('loanType', option)}
                            placeholder="Select loan type"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="amountRequested" className="block text-sm font-medium text-gray-300">Amount Requested</label>
                        <input
                            type="number"
                            name="amountRequested"
                            id="amountRequested"
                            value={formData.amountRequested}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                            min="1"
                        />
                    </div>
                    <div>
                        <label htmlFor="termMonths" className="block text-sm font-medium text-gray-300">Loan Term (Months)</label>
                        <input
                            type="number"
                            name="termMonths"
                            id="termMonths"
                            value={formData.termMonths}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                            min="1"
                        />
                    </div>
                    <div>
                        <label htmlFor="purpose" className="block text-sm font-medium text-gray-300">Purpose of Loan</label>
                        <textarea
                            name="purpose"
                            id="purpose"
                            rows={3}
                            value={formData.purpose}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                        ></textarea>
                    </div>
                </div>
            )}

            {currentStep === 2 && (
                <div className="space-y-4">
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label htmlFor="firstName" className="block text-sm font-medium text-gray-300">First Name</label>
                            <input
                                type="text"
                                name="firstName"
                                id="firstName"
                                value={formData.firstName}
                                onChange={handleChange}
                                className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                                required
                            />
                        </div>
                        <div>
                            <label htmlFor="lastName" className="block text-sm font-medium text-gray-300">Last Name</label>
                            <input
                                type="text"
                                name="lastName"
                                id="lastName"
                                value={formData.lastName}
                                onChange={handleChange}
                                className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                                required
                            />
                        </div>
                    </div>
                    <div>
                        <label htmlFor="email" className="block text-sm font-medium text-gray-300">Email Address</label>
                        <input
                            type="email"
                            name="email"
                            id="email"
                            value={formData.email}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="phone" className="block text-sm font-medium text-gray-300">Phone Number</label>
                        <input
                            type="tel"
                            name="phone"
                            id="phone"
                            value={formData.phone}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                        />
                    </div>
                    <div>
                        <label htmlFor="nationalId" className="block text-sm font-medium text-gray-300">National ID/SSN</label>
                        <input
                            type="text"
                            name="nationalId"
                            id="nationalId"
                            value={formData.nationalId}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="annualIncome" className="block text-sm font-medium text-gray-300">Annual Income</label>
                        <input
                            type="number"
                            name="annualIncome"
                            id="annualIncome"
                            value={formData.annualIncome}
                            onChange={handleChange}
                            className="mt-1 block w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white shadow-sm focus:ring-blue-500 focus:border-blue-500"
                            required
                            min="0"
                        />
                    </div>
                </div>
            )}

            {currentStep === 3 && (
                <div className="space-y-4 text-gray-300">
                    <h3 className="text-xl font-semibold text-white">Review Application Details</h3>
                    <div className="border border-gray-700 rounded-md p-4 bg-gray-800 space-y-2">
                        <p><span className="font-semibold">Applicant Name:</span> {formData.applicantName}</p>
                        <p><span className="font-semibold">Loan Type:</span> {formData.loanType?.replace(/_/g, ' ')}</p>
                        <p><span className="font-semibold">Amount Requested:</span> {formatCurrency(formData.amountRequested || 0)}</p>
                        <p><span className="font-semibold">Term:</span> {formData.termMonths} Months</p>
                        <p><span className="font-semibold">Purpose:</span> {formData.purpose}</p>
                        <hr className="border-gray-700 my-2" />
                        <p><span className="font-semibold">First Name:</span> {formData.firstName}</p>
                        <p><span className="font-semibold">Last Name:</span> {formData.lastName}</p>
                        <p><span className="font-semibold">Email:</span> {formData.email}</p>
                        <p><span className="font-semibold">Phone:</span> {formData.phone || 'N/A'}</p>
                        <p><span className="font-semibold">National ID/SSN:</span> {formData.nationalId}</p>
                        <p><span className="font-semibold">Annual Income:</span> {formatCurrency(formData.annualIncome || 0)}</p>
                    </div>
                    <p className="text-gray-400 text-sm italic">
                        Upon submission, this application will enter the AI Pre-Screening phase.
                    </p>
                </div>
            )}

            <div className="flex justify-between mt-6">
                {currentStep > 1 && (
                    <button
                        type="button"
                        onClick={handlePrevStep}
                        className="px-4 py-2 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
                    >
                        <ChevronLeftIcon className="inline-block w-4 h-4 mr-1" /> Previous
                    </button>
                )}
                <div className="flex-grow"></div> {/* Spacer */}
                <div className="flex space-x-3">
                    <button
                        type="button"
                        onClick={onClose}
                        className="px-4 py-2 text-sm font-medium rounded-md text-gray-300 bg-gray-700 hover:bg-gray-600"
                    >
                        Cancel
                    </button>
                    {currentStep < totalSteps && (
                        <button
                            type="button"
                            onClick={handleNextStep}
                            className="px-4 py-2 text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
                        >
                            Next <ChevronRightIcon className="inline-block w-4 h-4 ml-1" />
                        </button>
                    )}
                    {currentStep === totalSteps && (
                        <button
                            type="submit"
                            className="px-4 py-2 text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700"
                        >
                            <CheckCircleIcon className="inline-block w-4 h-4 mr-1" /> Submit Application
                        </button>
                    )}
                </div>
            </div>
        </form>
    );
};


export default LoanApplicationsView;

--- FILE: MortgagesView.tsx ---

import React, { useState, useEffect, useCallback, useMemo, createContext, useContext } from 'react';
import Card from '../../../Card';
import { Line, Bar, Doughnut } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, BarElement, ArcElement, Title, Tooltip, Legend, Filler } from 'chart.js';
import faker from 'faker'; // Using faker for mock data generation

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, BarElement, ArcElement, Title, Tooltip, Legend, Filler);

// --- Contexts for Global State Management (Scalability) ---
interface MortgageAppContextType {
    currentUser: UserProfile | null;
    settings: AppSettings;
    notifications: Notification[];
    addNotification: (notification: Notification) => void;
    updateSettings: (newSettings: Partial<AppSettings>) => void;
    login: (user: UserProfile) => void;
    logout: () => void;
}

const MortgageAppContext = createContext<MortgageAppContextType | undefined>(undefined);

export const useMortgageApp = () => {
    const context = useContext(MortgageAppContext);
    if (context === undefined) {
        throw new Error('useMortgageApp must be used within a MortgageAppProvider');
    }
    return context;
};

// --- Data Models and Interfaces (Type Safety & Structure) ---

export interface UserProfile {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    role: 'admin' | 'loan_officer' | 'underwriter' | 'servicing_agent' | 'portfolio_manager';
    permissions: string[];
    avatarUrl?: string;
}

export interface AppSettings {
    theme: 'dark' | 'light';
    currency: 'USD' | 'EUR' | 'GBP';
    dateFormat: 'MM/DD/YYYY' | 'DD/MM/YYYY';
    notificationPreferences: {
        email: boolean;
        sms: boolean;
        inApp: boolean;
    };
    defaultPortfolioFilter: string;
}

export interface Notification {
    id: string;
    message: string;
    type: 'info' | 'warning' | 'error' | 'success';
    timestamp: Date;
    read: boolean;
    link?: string;
}

export interface MortgageLoan {
    id: string;
    loanNumber: string;
    borrower: BorrowerProfile;
    property: PropertyDetails;
    loanDetails: LoanDetails;
    status: 'application' | 'pre_approved' | 'approved' | 'funded' | 'servicing' | 'defaulted' | 'refinanced' | 'paid_off';
    currentBalance: number;
    originalBalance: number;
    originationDate: Date;
    nextPaymentDate: Date;
    nextPaymentAmount: number;
    escrowBalance: number;
    loanOfficerId: string;
    underwriterId?: string;
    servicingAgentId?: string;
    notes: LoanNote[];
    documents: LoanDocument[];
    riskScore: number; // AI-driven risk score
    aiRecommendations: AiRecommendation[];
    valuationHistory: PropertyValuation[];
    paymentHistory: LoanPayment[];
    refinanceEligibility: RefinanceEligibility;
}

export interface BorrowerProfile {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    address: Address;
    creditScore: number;
    income: number;
    employmentStatus: string;
    dependents: number;
    kycStatus: 'verified' | 'pending' | 'rejected';
}

export interface Address {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
}

export interface PropertyDetails {
    id: string;
    address: Address;
    propertyType: 'single_family' | 'multi_family' | 'condo' | 'townhouse' | 'commercial';
    yearBuilt: number;
    squareFootage: number;
    bedrooms: number;
    bathrooms: number;
    zoning: string;
    currentValue: number; // AI-based valuation
    lastAppraisalDate?: Date;
    propertyTax: number; // Annual
    homeInsurance: number; // Annual
    lienStatus: 'clear' | 'encumbered';
}

export interface LoanDetails {
    loanType: 'fixed_rate' | 'adjustable_rate' | 'fha' | 'va' | 'usd_rural';
    interestRate: number; // Annual percentage rate
    termMonths: number;
    amortizationSchedule: AmortizationPayment[];
    emi: number; // Equated Monthly Installment
    closingCosts: number;
    originationFees: number;
    pmtInsurance?: number; // Private Mortgage Insurance
    isEscrowed: boolean;
}

export interface AmortizationPayment {
    month: number;
    principalPayment: number;
    interestPayment: number;
    remainingBalance: number;
    totalPayment: number;
}

export interface LoanNote {
    id: string;
    authorId: string;
    authorName: string;
    timestamp: Date;
    content: string;
}

export interface LoanDocument {
    id: string;
    fileName: string;
    documentType: 'application' | 'income_proof' | 'credit_report' | 'appraisal' | 'deed' | 'closing_disclosure' | 'other';
    uploadDate: Date;
    url: string;
    uploadedById: string;
}

export interface PropertyValuation {
    id: string;
    timestamp: Date;
    value: number;
    source: 'AI' | 'Appraisal' | 'Manual';
    analystId?: string;
}

export interface LoanPayment {
    id: string;
    paymentDate: Date;
    amount: number;
    principalPaid: number;
    interestPaid: number;
    escrowPaid: number;
    lateFeeApplied: number;
    isLate: boolean;
}

export interface RefinanceEligibility {
    isEligible: boolean;
    suggestedRate?: number;
    estimatedSavingsMonthly?: number;
    reasonCodes: string[]; // e.g., 'Lower_Rate_Available', 'Credit_Score_Improvement', 'Property_Value_Increase'
    lastChecked: Date;
}

export interface AiRecommendation {
    id: string;
    type: 'refinance_alert' | 'risk_mitigation' | 'cross_sell_opportunity' | 'portfolio_adjustment';
    severity: 'low' | 'medium' | 'high';
    message: string;
    timestamp: Date;
    actionItems: string[];
    relatedLoanId?: string;
}

export interface MarketData {
    timestamp: Date;
    interestRate30YrFixed: number;
    interestRate15YrFixed: number;
    housingPriceIndex: number;
    inflationRate: number;
    gdpGrowth: number;
}

export interface PortfolioSummary {
    totalLoans: number;
    totalPortfolioValue: number;
    avgInterestRate: number;
    avgLTV: number;
    delinquencyRate: number;
    forecastedDefaults: number; // AI-driven
    topPerformers: string[]; // Loan IDs
    highRiskLoans: string[]; // Loan IDs
    geographicDistribution: { [state: string]: number };
    loanTypeDistribution: { [type: string]: number };
}

// --- Utility Functions (Reusable Logic) ---

export const formatCurrency = (amount: number, currency: 'USD' | 'EUR' | 'GBP' = 'USD', locale: string = 'en-US'): string => {
    return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: currency,
    }).format(amount);
};

export const formatDate = (date: Date, dateFormat: 'MM/DD/YYYY' | 'DD/MM/YYYY' = 'MM/DD/YYYY'): string => {
    const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit' };
    if (dateFormat === 'DD/MM/YYYY') {
        return new Intl.DateTimeFormat('en-GB', options).format(date);
    }
    return new Intl.DateTimeFormat('en-US', options).format(date);
};

export const calculateLTV = (loanAmount: number, propertyValue: number): number => {
    if (propertyValue === 0) return 0;
    return (loanAmount / propertyValue) * 100;
};

export const generateAmortizationSchedule = (
    principal: number,
    annualInterestRate: number,
    loanTermMonths: number
): AmortizationPayment[] => {
    const monthlyInterestRate = annualInterestRate / 12 / 100;
    const amortizationSchedule: AmortizationPayment[] = [];

    if (monthlyInterestRate === 0) {
        // Handle zero interest rate case
        const monthlyPrincipal = principal / loanTermMonths;
        for (let month = 1; month <= loanTermMonths; month++) {
            amortizationSchedule.push({
                month,
                principalPayment: monthlyPrincipal,
                interestPayment: 0,
                remainingBalance: principal - (monthlyPrincipal * month),
                totalPayment: monthlyPrincipal,
            });
        }
        return amortizationSchedule;
    }

    const emi =
        principal *
        monthlyInterestRate /
        (1 - Math.pow(1 + monthlyInterestRate, -loanTermMonths));

    let remainingBalance = principal;

    for (let month = 1; month <= loanTermMonths; month++) {
        const interestPayment = remainingBalance * monthlyInterestRate;
        const principalPayment = emi - interestPayment;
        remainingBalance -= principalPayment;

        amortizationSchedule.push({
            month,
            principalPayment,
            interestPayment,
            remainingBalance: Math.max(0, remainingBalance), // Ensure balance doesn't go negative due to rounding
            totalPayment: emi,
        });
    }
    return amortizationSchedule;
};

// --- Mock Data Generators (for development and demonstration) ---

const generateMockAddress = (): Address => ({
    street: faker.address.streetAddress(),
    city: faker.address.city(),
    state: faker.address.stateAbbr(),
    zipCode: faker.address.zipCode(),
    country: 'USA',
});

const generateMockPropertyDetails = (): PropertyDetails => ({
    id: faker.datatype.uuid(),
    address: generateMockAddress(),
    propertyType: faker.random.arrayElement(['single_family', 'multi_family', 'condo', 'townhouse']),
    yearBuilt: faker.datatype.number({ min: 1950, max: 2022 }),
    squareFootage: faker.datatype.number({ min: 800, max: 5000 }),
    bedrooms: faker.datatype.number({ min: 1, max: 6 }),
    bathrooms: faker.datatype.number({ min: 1, max: 5 }),
    zoning: faker.random.alphaNumeric(5).toUpperCase(),
    currentValue: faker.datatype.number({ min: 200000, max: 1500000 }),
    lastAppraisalDate: faker.date.recent(365),
    propertyTax: faker.datatype.number({ min: 2000, max: 15000 }),
    homeInsurance: faker.datatype.number({ min: 800, max: 4000 }),
    lienStatus: 'clear',
});

const generateMockBorrowerProfile = (): BorrowerProfile => ({
    id: faker.datatype.uuid(),
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    email: faker.internet.email(),
    phone: faker.phone.phoneNumber(),
    address: generateMockAddress(),
    creditScore: faker.datatype.number({ min: 600, max: 850 }),
    income: faker.datatype.number({ min: 50000, max: 300000 }),
    employmentStatus: faker.random.arrayElement(['employed', 'self-employed', 'retired']),
    dependents: faker.datatype.number({ min: 0, max: 5 }),
    kycStatus: faker.random.arrayElement(['verified', 'pending']),
});

const generateMockLoanDetails = (principal: number): LoanDetails => {
    const termMonths = faker.datatype.number({ min: 180, max: 360, precision: 12 });
    const annualRate = faker.datatype.float({ min: 2.5, max: 7.5, precision: 0.1 });
    const amortizationSchedule = generateAmortizationSchedule(principal, annualRate, termMonths);
    const emi = amortizationSchedule.length > 0 ? amortizationSchedule[0].totalPayment : 0;

    return {
        loanType: faker.random.arrayElement(['fixed_rate', 'adjustable_rate', 'fha', 'va']),
        interestRate: annualRate,
        termMonths: termMonths,
        amortizationSchedule: amortizationSchedule,
        emi: emi,
        closingCosts: faker.datatype.number({ min: 5000, max: 20000 }),
        originationFees: faker.datatype.number({ min: 0, max: 5000 }),
        pmtInsurance: faker.datatype.boolean() ? faker.datatype.number({ min: 50, max: 200 }) : undefined,
        isEscrowed: faker.datatype.boolean(),
    };
};

const generateMockLoanNote = (authorId: string, authorName: string): LoanNote => ({
    id: faker.datatype.uuid(),
    authorId: authorId,
    authorName: authorName,
    timestamp: faker.date.recent(30),
    content: faker.lorem.sentences(faker.datatype.number({ min: 1, max: 3 })),
});

const generateMockLoanDocument = (uploadedById: string): LoanDocument => ({
    id: faker.datatype.uuid(),
    fileName: faker.system.fileName(),
    documentType: faker.random.arrayElement(['application', 'income_proof', 'credit_report', 'appraisal', 'deed', 'closing_disclosure']),
    uploadDate: faker.date.recent(90),
    url: faker.internet.url(),
    uploadedById: uploadedById,
});

const generateMockPropertyValuation = (): PropertyValuation => ({
    id: faker.datatype.uuid(),
    timestamp: faker.date.recent(365),
    value: faker.datatype.number({ min: 250000, max: 1600000 }),
    source: faker.random.arrayElement(['AI', 'Appraisal', 'Manual']),
});

const generateMockLoanPayment = (loanId: string, originationDate: Date, emi: number, monthlyInterestRate: number, loanTermMonths: number): LoanPayment[] => {
    const payments: LoanPayment[] = [];
    let currentBalance = faker.datatype.number({ min: 100000, max: 400000 }); // Random starting balance for payments
    let paymentDate = new Date(originationDate);
    paymentDate.setMonth(paymentDate.getMonth() + 1); // First payment one month after origination

    const numPayments = faker.datatype.number({ min: 1, max: Math.min(loanTermMonths, 60) }); // Max 5 years of history

    for (let i = 0; i < numPayments; i++) {
        const principalPayment = faker.datatype.float({ min: emi * 0.3, max: emi * 0.7 });
        const interestPayment = emi - principalPayment;
        const escrowPaid = faker.datatype.number({ min: 100, max: 500 });
        const isLate = faker.datatype.boolean({ probability: 0.05 });
        const lateFee = isLate ? faker.datatype.number({ min: 25, max: 100 }) : 0;

        payments.push({
            id: faker.datatype.uuid(),
            paymentDate: new Date(paymentDate),
            amount: emi + lateFee + escrowPaid,
            principalPaid: principalPayment,
            interestPaid: interestPayment,
            escrowPaid: escrowPaid,
            lateFeeApplied: lateFee,
            isLate: isLate,
        });

        paymentDate.setMonth(paymentDate.getMonth() + 1);
    }
    return payments;
};

const generateMockRefinanceEligibility = (): RefinanceEligibility => ({
    isEligible: faker.datatype.boolean({ probability: 0.7 }),
    suggestedRate: faker.datatype.float({ min: 2.0, max: 6.0, precision: 0.1 }),
    estimatedSavingsMonthly: faker.datatype.number({ min: 50, max: 500 }),
    reasonCodes: faker.random.arrayElements(['Lower_Rate_Available', 'Credit_Score_Improvement', 'Property_Value_Increase', 'Market_Conditions'], faker.datatype.number({ min: 1, max: 3 })),
    lastChecked: faker.date.recent(30),
});

const generateMockAiRecommendation = (loanId: string): AiRecommendation => ({
    id: faker.datatype.uuid(),
    type: faker.random.arrayElement(['refinance_alert', 'risk_mitigation', 'cross_sell_opportunity', 'portfolio_adjustment']),
    severity: faker.random.arrayElement(['low', 'medium', 'high']),
    message: faker.lorem.sentence(),
    timestamp: faker.date.recent(7),
    actionItems: faker.random.arrayElements([faker.lorem.word(), faker.lorem.word()], faker.datatype.number({ min: 1, max: 3 })),
    relatedLoanId: loanId,
});

export const generateMockMortgageLoan = (loanOfficerId: string): MortgageLoan => {
    const borrower = generateMockBorrowerProfile();
    const property = generateMockPropertyDetails();
    const originalBalance = faker.datatype.number({ min: 150000, max: 1000000 });
    const loanDetails = generateMockLoanDetails(originalBalance);
    const originationDate = faker.date.past(5);

    const loan: MortgageLoan = {
        id: faker.datatype.uuid(),
        loanNumber: faker.finance.account(10),
        borrower: borrower,
        property: property,
        loanDetails: loanDetails,
        status: faker.random.arrayElement(['application', 'pre_approved', 'approved', 'funded', 'servicing', 'defaulted', 'refinanced', 'paid_off']),
        originalBalance: originalBalance,
        currentBalance: faker.datatype.number({ min: originalBalance * 0.2, max: originalBalance * 0.95 }),
        originationDate: originationDate,
        nextPaymentDate: faker.date.future(0.5, originationDate),
        nextPaymentAmount: loanDetails.emi + (loanDetails.isEscrowed ? faker.datatype.number({ min: 100, max: 500 }) : 0),
        escrowBalance: faker.datatype.number({ min: 0, max: 3000 }),
        loanOfficerId: loanOfficerId,
        underwriterId: faker.datatype.uuid(),
        servicingAgentId: faker.datatype.uuid(),
        notes: [generateMockLoanNote(loanOfficerId, `${faker.name.firstName()} ${faker.name.lastName()}`)],
        documents: [generateMockLoanDocument(loanOfficerId)],
        riskScore: faker.datatype.number({ min: 1, max: 100 }),
        aiRecommendations: [],
        valuationHistory: [generateMockPropertyValuation()],
        paymentHistory: [],
        refinanceEligibility: generateMockRefinanceEligibility(),
    };
    loan.aiRecommendations = [generateMockAiRecommendation(loan.id)];
    loan.paymentHistory = generateMockLoanPayment(loan.id, loan.originationDate, loan.loanDetails.emi, loan.loanDetails.interestRate / 100 / 12, loan.loanDetails.termMonths);
    return loan;
};

export const generateMockMarketData = (days: number): MarketData[] => {
    const data: MarketData[] = [];
    let currentDate = new Date();
    let base30Yr = 3.5;
    let base15Yr = 3.0;
    let baseHPI = 200;

    for (let i = 0; i < days; i++) {
        currentDate.setDate(currentDate.getDate() - 1);
        base30Yr += faker.datatype.float({ min: -0.05, max: 0.05, precision: 0.01 });
        base15Yr += faker.datatype.float({ min: -0.04, max: 0.04, precision: 0.01 });
        baseHPI += faker.datatype.float({ min: -1, max: 2, precision: 0.1 });

        data.unshift({
            timestamp: new Date(currentDate),
            interestRate30YrFixed: parseFloat(base30Yr.toFixed(2)),
            interestRate15YrFixed: parseFloat(base15Yr.toFixed(2)),
            housingPriceIndex: parseFloat(baseHPI.toFixed(1)),
            inflationRate: faker.datatype.float({ min: 1.5, max: 4.5, precision: 0.1 }),
            gdpGrowth: faker.datatype.float({ min: -1.0, max: 3.0, precision: 0.1 }),
        });
    }
    return data;
};

// --- Mock API Service Layer (Simulate Backend Interactions) ---

export const mockApiService = {
    fetchMortgageLoans: async (userId: string, filter?: string): Promise<MortgageLoan[]> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const loans = Array.from({ length: 50 }, () => generateMockMortgageLoan(userId));
                resolve(loans);
            }, 500);
        });
    },
    fetchLoanById: async (loanId: string): Promise<MortgageLoan | null> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const mockLoan = generateMockMortgageLoan(faker.datatype.uuid());
                if (mockLoan.id === loanId) { // Simulate finding by ID
                    resolve(mockLoan);
                } else { // Return a consistent one if not found, for demonstration
                    const consistentLoan = generateMockMortgageLoan(faker.datatype.uuid());
                    consistentLoan.id = loanId;
                    resolve(consistentLoan);
                }
            }, 300);
        });
    },
    updateLoanStatus: async (loanId: string, status: MortgageLoan['status']): Promise<MortgageLoan> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const mockLoan = generateMockMortgageLoan(faker.datatype.uuid()); // Simulate update by returning new object
                mockLoan.id = loanId;
                mockLoan.status = status;
                resolve(mockLoan);
            }, 300);
        });
    },
    fetchMarketData: async (period: '7d' | '30d' | '90d' | '1y'): Promise<MarketData[]> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                let days = 0;
                switch (period) {
                    case '7d': days = 7; break;
                    case '30d': days = 30; break;
                    case '90d': days = 90; break;
                    case '1y': days = 365; break;
                }
                resolve(generateMockMarketData(days));
            }, 400);
        });
    },
    fetchPortfolioSummary: async (userId: string): Promise<PortfolioSummary> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const loans = Array.from({ length: 50 }, () => generateMockMortgageLoan(userId));
                const totalLoans = loans.length;
                const totalPortfolioValue = loans.reduce((sum, loan) => sum + loan.currentBalance, 0);
                const avgInterestRate = loans.reduce((sum, loan) => sum + loan.loanDetails.interestRate, 0) / totalLoans;
                const avgLTV = loans.reduce((sum, loan) => sum + calculateLTV(loan.currentBalance, loan.property.currentValue), 0) / totalLoans;
                const delinquencyRate = loans.filter(loan => loan.status === 'defaulted' || (loan.paymentHistory.length > 0 && loan.paymentHistory[loan.paymentHistory.length - 1].isLate)).length / totalLoans;
                const forecastedDefaults = faker.datatype.number({ min: 1, max: 5 });
                const topPerformers = faker.random.arrayElements(loans.map(l => l.id), 3);
                const highRiskLoans = faker.random.arrayElements(loans.filter(l => l.riskScore > 70).map(l => l.id), 5);

                const geographicDistribution: { [state: string]: number } = {};
                loans.forEach(loan => {
                    const state = loan.property.address.state;
                    geographicDistribution[state] = (geographicDistribution[state] || 0) + 1;
                });

                const loanTypeDistribution: { [type: string]: number } = {};
                loans.forEach(loan => {
                    const type = loan.loanDetails.loanType;
                    loanTypeDistribution[type] = (loanTypeDistribution[type] || 0) + 1;
                });

                resolve({
                    totalLoans,
                    totalPortfolioValue,
                    avgInterestRate,
                    avgLTV,
                    delinquencyRate: parseFloat(delinquencyRate.toFixed(2)),
                    forecastedDefaults,
                    topPerformers,
                    highRiskLoans,
                    geographicDistribution,
                    loanTypeDistribution,
                });
            }, 600);
        });
    },
    fetchAiRecommendations: async (userId: string, loanId?: string): Promise<AiRecommendation[]> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                const recommendations = Array.from({ length: faker.datatype.number({ min: 5, max: 15 }) }, () => generateMockAiRecommendation(loanId || faker.datatype.uuid()));
                resolve(recommendations);
            }, 300);
        });
    },
    fetchUserProfile: async (userId: string): Promise<UserProfile> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    id: userId,
                    firstName: "Jane",
                    lastName: "Doe",
                    email: "jane.doe@megacorp.com",
                    role: "portfolio_manager",
                    permissions: ["view_all_loans", "manage_portfolio", "approve_refinance"],
                    avatarUrl: "https://i.pravatar.cc/150?img=3"
                });
            }, 200);
        });
    },
    fetchAppSettings: async (userId: string): Promise<AppSettings> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    theme: 'dark',
                    currency: 'USD',
                    dateFormat: 'MM/DD/YYYY',
                    notificationPreferences: {
                        email: true,
                        sms: false,
                        inApp: true,
                    },
                    defaultPortfolioFilter: 'all',
                });
            }, 200);
        });
    },
    saveAppSettings: async (userId: string, settings: AppSettings): Promise<AppSettings> => {
        return new Promise((resolve) => {
            setTimeout(() => {
                // In a real app, this would persist
                resolve(settings);
            }, 200);
        });
    },
    // Add other API methods as needed (e.g., addLoan, updateLoan, uploadDocument, processPayment, etc.)
};

// --- Custom Hooks (Encapsulate Component Logic) ---

export const useLoans = (userId: string, initialFilter?: string) => {
    const [loans, setLoans] = useState<MortgageLoan[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [filter, setFilter] = useState<string>(initialFilter || 'all');

    const fetchLoans = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const data = await mockApiService.fetchMortgageLoans(userId, filter);
            setLoans(data);
        } catch (err) {
            setError('Failed to fetch mortgage loans.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    }, [userId, filter]);

    useEffect(() => {
        fetchLoans();
    }, [fetchLoans]);

    const updateLoanStatus = useCallback(async (loanId: string, status: MortgageLoan['status']) => {
        try {
            const updatedLoan = await mockApiService.updateLoanStatus(loanId, status);
            setLoans(prevLoans => prevLoans.map(loan => loan.id === loanId ? updatedLoan : loan));
            return updatedLoan;
        } catch (err) {
            setError('Failed to update loan status.');
            console.error(err);
            throw err;
        }
    }, []);

    return { loans, loading, error, setFilter, updateLoanStatus, refreshLoans: fetchLoans };
};

export const useMarketData = (period: '7d' | '30d' | '90d' | '1y') => {
    const [marketData, setMarketData] = useState<MarketData[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await mockApiService.fetchMarketData(period);
                setMarketData(data);
            } catch (err) {
                setError('Failed to fetch market data.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, [period]);

    return { marketData, loading, error };
};

export const usePortfolioSummary = (userId: string) => {
    const [summary, setSummary] = useState<PortfolioSummary | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchSummary = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await mockApiService.fetchPortfolioSummary(userId);
                setSummary(data);
            } catch (err) {
                setError('Failed to fetch portfolio summary.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchSummary();
    }, [userId]);

    return { summary, loading, error };
};

export const useAiRecommendations = (userId: string, loanId?: string) => {
    const [recommendations, setRecommendations] = useState<AiRecommendation[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchRecommendations = async () => {
            setLoading(true);
            setError(null);
            try {
                const data = await mockApiService.fetchAiRecommendations(userId, loanId);
                setRecommendations(data);
            } catch (err) {
                setError('Failed to fetch AI recommendations.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchRecommendations();
    }, [userId, loanId]);

    return { recommendations, loading, error };
};

// --- MortgageAppProvider for Global State ---
export const MortgageAppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [currentUser, setCurrentUser] = useState<UserProfile | null>(null);
    const [settings, setSettings] = useState<AppSettings>({
        theme: 'dark',
        currency: 'USD',
        dateFormat: 'MM/DD/YYYY',
        notificationPreferences: { email: true, sms: false, inApp: true },
        defaultPortfolioFilter: 'all',
    });
    const [notifications, setNotifications] = useState<Notification[]>([]);

    useEffect(() => {
        // Simulate user login and fetching initial settings
        const initApp = async () => {
            const mockUserId = 'user-123'; // In a real app, this would come from auth
            const user = await mockApiService.fetchUserProfile(mockUserId);
            setCurrentUser(user);
            const userSettings = await mockApiService.fetchAppSettings(user.id);
            setSettings(userSettings);
        };
        initApp();
    }, []);

    const addNotification = useCallback((notification: Notification) => {
        setNotifications(prev => [...prev, { ...notification, id: faker.datatype.uuid(), timestamp: new Date(), read: false }]);
    }, []);

    const updateSettings = useCallback(async (newSettings: Partial<AppSettings>) => {
        if (currentUser) {
            const updated = await mockApiService.saveAppSettings(currentUser.id, { ...settings, ...newSettings });
            setSettings(updated);
            addNotification({ type: 'success', message: 'Settings updated successfully.', id: 'temp', timestamp: new Date(), read: false });
        }
    }, [currentUser, settings, addNotification]);

    const login = useCallback((user: UserProfile) => {
        setCurrentUser(user);
        // Fetch user-specific settings here in a real app
    }, []);

    const logout = useCallback(() => {
        setCurrentUser(null);
        // Clear tokens, etc.
    }, []);

    const contextValue = useMemo(() => ({
        currentUser,
        settings,
        notifications,
        addNotification,
        updateSettings,
        login,
        logout,
    }), [currentUser, settings, notifications, addNotification, updateSettings, login, logout]);

    return (
        <MortgageAppContext.Provider value={contextValue}>
            {children}
        </MortgageAppContext.Provider>
    );
};

// --- UI Components (Modular & Reusable) ---

export const LoadingSpinner: React.FC = () => (
    <div className="flex justify-center items-center p-4">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
        <p className="ml-3 text-gray-400">Loading...</p>
    </div>
);

export const ErrorMessage: React.FC<{ message: string }> = ({ message }) => (
    <div className="bg-red-800 p-3 rounded-lg text-white">
        <p className="font-bold">Error:</p>
        <p>{message}</p>
    </div>
);

export const NotificationCenter: React.FC = () => {
    const { notifications, addNotification } = useMortgageApp(); // Assuming a method to mark as read would exist

    const [isOpen, setIsOpen] = useState(false);

    const unreadCount = notifications.filter(n => !n.read).length;

    // Simulate new notifications
    useEffect(() => {
        const interval = setInterval(() => {
            if (Math.random() < 0.3) { // 30% chance every 10 seconds
                const types: Notification['type'][] = ['info', 'warning', 'success'];
                const messages = [
                    'New loan application received: Jane Doe',
                    'High-risk alert for Loan #1234567890',
                    'Interest rate forecast updated: rates expected to rise.',
                    'Refinance opportunity detected for client John Smith!',
                    'Portfolio summary generated successfully.'
                ];
                addNotification({
                    id: 'temp',
                    message: faker.random.arrayElement(messages),
                    type: faker.random.arrayElement(types),
                    timestamp: new Date(),
                    read: false,
                });
            }
        }, 10000); // Every 10 seconds
        return () => clearInterval(interval);
    }, [addNotification]);


    if (notifications.length === 0 && !isOpen) return null;

    return (
        <div className="relative">
            <button
                className="relative p-2 rounded-full bg-gray-700 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                onClick={() => setIsOpen(!isOpen)}
            >
                <i className="fas fa-bell text-white"></i>
                {unreadCount > 0 && (
                    <span className="absolute top-0 right-0 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-red-100 bg-red-600 rounded-full">
                        {unreadCount}
                    </span>
                )}
            </button>
            {isOpen && (
                <div className="absolute right-0 mt-2 w-80 bg-gray-800 rounded-lg shadow-xl z-50 max-h-96 overflow-y-auto border border-gray-700">
                    <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                        <h3 className="font-semibold text-white">Notifications ({unreadCount} unread)</h3>
                        <button className="text-blue-400 text-sm hover:underline">Mark all as read</button>
                    </div>
                    {notifications.length === 0 ? (
                        <p className="text-gray-400 p-4 text-center">No new notifications.</p>
                    ) : (
                        <ul>
                            {notifications.map((notification, index) => (
                                <li key={notification.id || index} className={`p-3 border-b border-gray-700 last:border-b-0 ${notification.read ? 'bg-gray-800' : 'bg-gray-700/50'}`}>
                                    <div className="flex justify-between items-start">
                                        <p className={`text-sm ${notification.read ? 'text-gray-400' : 'text-white font-medium'}`}>
                                            <span className={`inline-block w-2 h-2 rounded-full mr-2 ${notification.type === 'info' ? 'bg-blue-500' : notification.type === 'warning' ? 'bg-yellow-500' : notification.type === 'error' ? 'bg-red-500' : 'bg-green-500'}`}></span>
                                            {notification.message}
                                        </p>
                                        <span className="text-xs text-gray-500 ml-2 whitespace-nowrap">{formatDate(notification.timestamp, 'MM/DD/YYYY')}</span>
                                    </div>
                                    {notification.link && (
                                        <a href={notification.link} className="text-blue-400 text-xs hover:underline mt-1 block">View Details</a>
                                    )}
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            )}
        </div>
    );
};

export const UserProfileDropdown: React.FC = () => {
    const { currentUser, logout, settings } = useMortgageApp();
    const [isOpen, setIsOpen] = useState(false);

    if (!currentUser) return null;

    return (
        <div className="relative">
            <button
                className="flex items-center space-x-2 text-white p-2 rounded-full hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                onClick={() => setIsOpen(!isOpen)}
            >
                <img src={currentUser.avatarUrl || `https://i.pravatar.cc/150?u=${currentUser.id}`} alt="User Avatar" className="w-8 h-8 rounded-full border border-gray-500" />
                <span className="hidden md:block">{currentUser.firstName}</span>
                <i className="fas fa-caret-down text-sm"></i>
            </button>

            {isOpen && (
                <div className="absolute right-0 mt-2 w-48 bg-gray-800 rounded-lg shadow-xl z-50 border border-gray-700">
                    <div className="p-3 border-b border-gray-700">
                        <p className="text-white font-semibold">{currentUser.firstName} {currentUser.lastName}</p>
                        <p className="text-gray-400 text-sm">{currentUser.role.replace(/_/g, ' ').toUpperCase()}</p>
                    </div>
                    <ul className="py-1">
                        <li><a href="#" className="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">Profile Settings</a></li>
                        <li><a href="#" className="block px-4 py-2 text-sm text-gray-300 hover:bg-gray-700">App Settings</a></li>
                        <li><button onClick={logout} className="block w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-gray-700">Logout</button></li>
                    </ul>
                </div>
            )}
        </div>
    );
};

export const AppHeader: React.FC = () => {
    return (
        <header className="flex justify-between items-center py-4 px-6 bg-gray-900 border-b border-gray-700">
            <h1 className="text-2xl font-bold text-white">Mortgage Dashboard</h1>
            <div className="flex items-center space-x-4">
                <NotificationCenter />
                <UserProfileDropdown />
            </div>
        </header>
    );
};

export const MarketTrendChart: React.FC = () => {
    const [timePeriod, setTimePeriod] = useState<'7d' | '30d' | '90d' | '1y'>('30d');
    const { marketData, loading, error } = useMarketData(timePeriod);

    const data = useMemo(() => {
        const labels = marketData.map(d => formatDate(d.timestamp, 'MM/DD/YYYY'));
        const interestRates = marketData.map(d => d.interestRate30YrFixed);
        const hpi = marketData.map(d => d.housingPriceIndex);

        return {
            labels,
            datasets: [
                {
                    label: '30-Year Fixed Rate',
                    data: interestRates,
                    borderColor: 'rgb(53, 162, 235)',
                    backgroundColor: 'rgba(53, 162, 235, 0.5)',
                    yAxisID: 'y',
                    fill: false,
                    tension: 0.3
                },
                {
                    label: 'Housing Price Index',
                    data: hpi,
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.5)',
                    yAxisID: 'y1',
                    fill: false,
                    tension: 0.3
                },
            ],
        };
    }, [marketData]);

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'top' as const,
                labels: {
                    color: 'white',
                }
            },
            title: {
                display: true,
                text: 'Key Market Trends',
                color: 'white',
                font: {
                    size: 16
                }
            },
            tooltip: {
                callbacks: {
                    label: function (context: any) {
                        let label = context.dataset.label || '';
                        if (label) {
                            label += ': ';
                        }
                        if (context.dataset.yAxisID === 'y') {
                            label += `${context.raw}%`;
                        } else {
                            label += context.raw;
                        }
                        return label;
                    }
                }
            }
        },
        scales: {
            x: {
                ticks: { color: 'rgb(156, 163, 175)' },
                grid: { color: 'rgba(255,255,255,0.1)' },
            },
            y: {
                type: 'linear' as const,
                display: true,
                position: 'left' as const,
                title: {
                    display: true,
                    text: 'Interest Rate (%)',
                    color: 'rgb(53, 162, 235)'
                },
                ticks: { color: 'rgb(53, 162, 235)' },
                grid: { color: 'rgba(255,255,255,0.1)' },
            },
            y1: {
                type: 'linear' as const,
                display: true,
                position: 'right' as const,
                title: {
                    display: true,
                    text: 'Housing Price Index',
                    color: 'rgb(255, 99, 132)'
                },
                grid: {
                    drawOnChartArea: false, // only want the grid lines for the first dataset to show
                    color: 'rgba(255,255,255,0.1)'
                },
                ticks: { color: 'rgb(255, 99, 132)' },
            },
        },
    };

    return (
        <Card title="Market Trends & AI Forecast">
            <div className="flex justify-end space-x-2 mb-4">
                {['7d', '30d', '90d', '1y'].map(period => (
                    <button
                        key={period}
                        className={`px-3 py-1 text-sm rounded-md ${timePeriod === period ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
                        onClick={() => setTimePeriod(period as typeof timePeriod)}
                    >
                        {period.toUpperCase()}
                    </button>
                ))}
            </div>
            {loading ? <LoadingSpinner /> : error ? <ErrorMessage message={error} /> : (
                <div style={{ height: '300px' }}>
                    <Line data={data} options={options} />
                </div>
            )}
            <p className="text-gray-400 text-sm mt-4">AI models provide forward-looking insights on rate changes and property value shifts to guide your strategy.</p>
        </Card>
    );
};

export const AiRecommendationList: React.FC = () => {
    const { currentUser } = useMortgageApp();
    const { recommendations, loading, error } = useAiRecommendations(currentUser?.id || 'mock-user-id');

    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorMessage message={error} />;
    if (recommendations.length === 0) return <p className="text-gray-400">No AI recommendations at this time.</p>;

    return (
        <Card title="AI Insights & Actionable Recommendations">
            <ul className="space-y-3">
                {recommendations.map(rec => (
                    <li key={rec.id} className="bg-gray-800 p-4 rounded-lg border border-gray-700">
                        <div className="flex items-center justify-between mb-2">
                            <span className={`text-xs font-semibold px-2 py-1 rounded-full ${rec.severity === 'high' ? 'bg-red-900 text-red-200' : rec.severity === 'medium' ? 'bg-yellow-900 text-yellow-200' : 'bg-blue-900 text-blue-200'}`}>
                                {rec.severity.toUpperCase()}
                            </span>
                            <span className="text-gray-500 text-xs">{formatDate(rec.timestamp, 'MM/DD/YYYY')}</span>
                        </div>
                        <h4 className="font-semibold text-white mb-1">{rec.type.replace(/_/g, ' ')}</h4>
                        <p className="text-gray-300 text-sm">{rec.message}</p>
                        {rec.relatedLoanId && (
                            <p className="text-gray-400 text-xs mt-1">Related Loan: <a href={`/loans/${rec.relatedLoanId}`} className="text-blue-400 hover:underline">#{rec.relatedLoanId.substring(0, 8)}</a></p>
                        )}
                        {rec.actionItems.length > 0 && (
                            <div className="mt-2">
                                <p className="text-gray-400 text-sm font-medium">Action Items:</p>
                                <ul className="list-disc list-inside text-gray-300 text-sm pl-2">
                                    {rec.actionItems.map((item, i) => <li key={i}>{item}</li>)}
                                </ul>
                            </div>
                        )}
                    </li>
                ))}
            </ul>
        </Card>
    );
};

export const PortfolioOverview: React.FC = () => {
    const { currentUser } = useMortgageApp();
    const { summary, loading, error } = usePortfolioSummary(currentUser?.id || 'mock-user-id');
    const { settings } = useMortgageApp();

    const geographicData = useMemo(() => {
        if (!summary) return null;
        const labels = Object.keys(summary.geographicDistribution);
        const dataValues = Object.values(summary.geographicDistribution);
        return {
            labels: labels,
            datasets: [
                {
                    data: dataValues,
                    backgroundColor: [
                        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9900', '#C9CBCF',
                        '#FFCCBC', '#BDBDBD', '#8D6E63', '#4DD0E1', '#F48FB1', '#AED581', '#FFD700'
                    ],
                    hoverBackgroundColor: [
                        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9900', '#C9CBCF',
                        '#FFCCBC', '#BDBDBD', '#8D6E63', '#4DD0E1', '#F48FB1', '#AED581', '#FFD700'
                    ],
                },
            ],
        };
    }, [summary]);

    const loanTypeData = useMemo(() => {
        if (!summary) return null;
        const labels = Object.keys(summary.loanTypeDistribution).map(type => type.replace(/_/g, ' '));
        const dataValues = Object.values(summary.loanTypeDistribution);
        return {
            labels: labels,
            datasets: [
                {
                    data: dataValues,
                    backgroundColor: [
                        '#50C878', '#FFD700', '#AEC6CF', '#FF6961', '#7FFFD4'
                    ],
                    hoverBackgroundColor: [
                        '#50C878', '#FFD700', '#AEC6CF', '#FF6961', '#7FFFD4'
                    ],
                },
            ],
        };
    }, [summary]);

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'right' as const,
                labels: {
                    color: 'white'
                }
            },
            title: {
                display: false,
            },
        },
    };


    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorMessage message={error} />;
    if (!summary) return null;

    return (
        <Card title="Portfolio Performance Overview">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <p className="text-gray-400 text-sm">Total Loans</p>
                    <p className="text-white text-2xl font-bold">{summary.totalLoans}</p>
                </div>
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <p className="text-gray-400 text-sm">Portfolio Value</p>
                    <p className="text-white text-2xl font-bold">{formatCurrency(summary.totalPortfolioValue, settings.currency)}</p>
                </div>
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <p className="text-gray-400 text-sm">Avg. Interest Rate</p>
                    <p className="text-white text-2xl font-bold">{summary.avgInterestRate.toFixed(2)}%</p>
                </div>
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <p className="text-gray-400 text-sm">Delinquency Rate</p>
                    <p className="text-white text-2xl font-bold text-yellow-400">{summary.delinquencyRate.toFixed(2)}%</p>
                </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <h3 className="text-white text-lg font-semibold mb-3">Geographic Distribution</h3>
                    {geographicData && (
                        <div style={{ height: '250px' }}>
                            <Doughnut data={geographicData} options={chartOptions} />
                        </div>
                    )}
                </div>
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <h3 className="text-white text-lg font-semibold mb-3">Loan Type Distribution</h3>
                    {loanTypeData && (
                        <div style={{ height: '250px' }}>
                            <Doughnut data={loanTypeData} options={chartOptions} />
                        </div>
                    )}
                </div>
            </div>

            <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <h3 className="text-white text-lg font-semibold mb-3">High-Risk Loans (AI-identified)</h3>
                    {summary.highRiskLoans.length > 0 ? (
                        <ul className="space-y-2">
                            {summary.highRiskLoans.map(loanId => (
                                <li key={loanId} className="flex items-center text-red-400">
                                    <i className="fas fa-exclamation-triangle mr-2"></i>
                                    <a href={`/loans/${loanId}`} className="hover:underline text-sm">Loan ID: {loanId.substring(0, 8)}</a>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-gray-400 text-sm">No high-risk loans identified at this time.</p>
                    )}
                </div>
                <div className="bg-gray-800 p-4 rounded-lg shadow border border-gray-700">
                    <h3 className="text-white text-lg font-semibold mb-3">Forecasted Defaults (Next 90 Days)</h3>
                    <p className="text-red-400 text-3xl font-bold">{summary.forecastedDefaults}</p>
                    <p className="text-gray-400 text-sm mt-2">Our AI predicts potential defaults, allowing for proactive intervention.</p>
                </div>
            </div>
        </Card>
    );
};

export const LoanListingTable: React.FC = () => {
    const { currentUser, settings } = useMortgageApp();
    const { loans, loading, error, setFilter, updateLoanStatus } = useLoans(currentUser?.id || 'mock-user-id');
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedLoan, setSelectedLoan] = useState<MortgageLoan | null>(null);

    const filteredLoans = useMemo(() => {
        return loans.filter(loan =>
            loan.borrower.firstName.toLowerCase().includes(searchTerm.toLowerCase()) ||
            loan.borrower.lastName.toLowerCase().includes(searchTerm.toLowerCase()) ||
            loan.loanNumber.toLowerCase().includes(searchTerm.toLowerCase()) ||
            loan.property.address.zipCode.includes(searchTerm)
        );
    }, [loans, searchTerm]);

    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorMessage message={error} />;

    return (
        <Card title="All Mortgage Loans">
            <div className="flex flex-col md:flex-row justify-between items-center mb-4 space-y-3 md:space-y-0">
                <input
                    type="text"
                    placeholder="Search by borrower name, loan #, or zip..."
                    className="p-2 bg-gray-700 text-white rounded-md border border-gray-600 focus:ring-blue-500 focus:border-blue-500 w-full md:w-auto"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                />
                <div className="flex space-x-2">
                    {/* Example filter buttons */}
                    <button onClick={() => setFilter('all')} className="px-3 py-1 text-sm bg-gray-700 text-gray-300 rounded-md hover:bg-gray-600">All</button>
                    <button onClick={() => setFilter('servicing')} className="px-3 py-1 text-sm bg-gray-700 text-gray-300 rounded-md hover:bg-gray-600">Servicing</button>
                    <button onClick={() => setFilter('defaulted')} className="px-3 py-1 text-sm bg-gray-700 text-gray-300 rounded-md hover:bg-gray-600">Defaulted</button>
                </div>
            </div>
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-800">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Loan #</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Borrower</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Property Address</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Current Balance</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Interest Rate</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Risk Score</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-900 divide-y divide-gray-800">
                        {filteredLoans.map((loan) => (
                            <tr key={loan.id} className="hover:bg-gray-800">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{loan.loanNumber}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{loan.borrower.firstName} {loan.borrower.lastName}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{loan.property.address.city}, {loan.property.address.state}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatCurrency(loan.currentBalance, settings.currency)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{loan.loanDetails.interestRate}%</td>
                                <td className="px-6 py-4 whitespace-nowrap">
                                    <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                        loan.status === 'servicing' ? 'bg-green-100 text-green-800' :
                                        loan.status === 'funded' ? 'bg-blue-100 text-blue-800' :
                                        loan.status === 'defaulted' ? 'bg-red-100 text-red-800' :
                                        'bg-gray-100 text-gray-800'
                                    }`}>{loan.status.replace(/_/g, ' ')}</span>
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{loan.riskScore}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => setSelectedLoan(loan)} className="text-blue-400 hover:text-blue-600 mr-3">View</button>
                                    <button onClick={() => updateLoanStatus(loan.id, 'defaulted')} className="text-red-400 hover:text-red-600">Flag</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {selectedLoan && (
                <LoanDetailsModal loan={selectedLoan} onClose={() => setSelectedLoan(null)} />
            )}
        </Card>
    );
};

export const LoanDetailsModal: React.FC<{ loan: MortgageLoan; onClose: () => void }> = ({ loan, onClose }) => {
    const { settings } = useMortgageApp();
    const [activeTab, setActiveTab] = useState<'overview' | 'amortization' | 'payments' | 'documents' | 'notes'>('overview');

    const chartData = useMemo(() => {
        const principalBalances = loan.loanDetails.amortizationSchedule.map(p => p.remainingBalance);
        const labels = loan.loanDetails.amortizationSchedule.map(p => p.month);
        return {
            labels,
            datasets: [
                {
                    label: 'Remaining Balance',
                    data: principalBalances,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    fill: true,
                    tension: 0.1,
                },
            ],
        };
    }, [loan.loanDetails.amortizationSchedule]);

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'top' as const,
                labels: {
                    color: 'white'
                }
            },
            title: {
                display: true,
                text: 'Amortization Schedule',
                color: 'white'
            },
        },
        scales: {
            x: {
                title: {
                    display: true,
                    text: 'Month',
                    color: 'white'
                },
                ticks: { color: 'rgb(156, 163, 175)' },
                grid: { color: 'rgba(255,255,255,0.1)' },
            },
            y: {
                title: {
                    display: true,
                    text: 'Balance',
                    color: 'white'
                },
                ticks: {
                    color: 'rgb(156, 163, 175)',
                    callback: function(value: any) {
                        return formatCurrency(value, settings.currency);
                    }
                },
                grid: { color: 'rgba(255,255,255,0.1)' },
            },
        },
    };

    return (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <h3 className="text-2xl font-bold text-white">Loan Details: {loan.loanNumber}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>

                <div className="flex border-b border-gray-700">
                    {['overview', 'amortization', 'payments', 'documents', 'notes'].map(tab => (
                        <button
                            key={tab}
                            className={`py-2 px-4 text-sm font-medium ${activeTab === tab ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-400 hover:text-white'}`}
                            onClick={() => setActiveTab(tab as typeof activeTab)}
                        >
                            {tab.charAt(0).toUpperCase() + tab.slice(1)}
                        </button>
                    ))}
                </div>

                <div className="p-6 flex-grow overflow-y-auto custom-scrollbar">
                    {activeTab === 'overview' && (
                        <div className="space-y-6">
                            <h4 className="text-xl font-semibold text-white">Borrower & Property Info</h4>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 bg-gray-700 p-4 rounded-lg">
                                <div>
                                    <p className="text-gray-400">Borrower: <span className="text-white">{loan.borrower.firstName} {loan.borrower.lastName}</span></p>
                                    <p className="text-gray-400">Email: <span className="text-white">{loan.borrower.email}</span></p>
                                    <p className="text-gray-400">Credit Score: <span className="text-white">{loan.borrower.creditScore}</span></p>
                                    <p className="text-gray-400">Income: <span className="text-white">{formatCurrency(loan.borrower.income, settings.currency)}</span></p>
                                </div>
                                <div>
                                    <p className="text-gray-400">Property Address: <span className="text-white">{loan.property.address.street}, {loan.property.address.city}, {loan.property.address.state} {loan.property.address.zipCode}</span></p>
                                    <p className="text-gray-400">Property Type: <span className="text-white">{loan.property.propertyType.replace(/_/g, ' ')}</span></p>
                                    <p className="text-gray-400">Current Value: <span className="text-white">{formatCurrency(loan.property.currentValue, settings.currency)}</span></p>
                                    <p className="text-gray-400">Year Built: <span className="text-white">{loan.property.yearBuilt}</span></p>
                                </div>
                            </div>

                            <h4 className="text-xl font-semibold text-white mt-6">Loan Details</h4>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 bg-gray-700 p-4 rounded-lg">
                                <div>
                                    <p className="text-gray-400">Original Balance: <span className="text-white">{formatCurrency(loan.originalBalance, settings.currency)}</span></p>
                                    <p className="text-gray-400">Current Balance: <span className="text-white">{formatCurrency(loan.currentBalance, settings.currency)}</span></p>
                                    <p className="text-gray-400">Interest Rate: <span className="text-white">{loan.loanDetails.interestRate}%</span></p>
                                    <p className="text-gray-400">Loan Type: <span className="text-white">{loan.loanDetails.loanType.replace(/_/g, ' ')}</span></p>
                                    <p className="text-gray-400">Term: <span className="text-white">{loan.loanDetails.termMonths} Months</span></p>
                                    <p className="text-gray-400">EMI: <span className="text-white">{formatCurrency(loan.loanDetails.emi, settings.currency)}</span></p>
                                </div>
                                <div>
                                    <p className="text-gray-400">Origination Date: <span className="text-white">{formatDate(loan.originationDate, settings.dateFormat)}</span></p>
                                    <p className="text-gray-400">Next Payment Date: <span className="text-white">{formatDate(loan.nextPaymentDate, settings.dateFormat)}</span></p>
                                    <p className="text-gray-400">Next Payment Amount: <span className="text-white">{formatCurrency(loan.nextPaymentAmount, settings.currency)}</span></p>
                                    <p className="text-gray-400">Escrow Balance: <span className="text-white">{formatCurrency(loan.escrowBalance, settings.currency)}</span></p>
                                    <p className="text-gray-400">Status: <span className="text-white">{loan.status.replace(/_/g, ' ')}</span></p>
                                    <p className="text-gray-400">Risk Score: <span className="text-white font-bold">{loan.riskScore}</span></p>
                                </div>
                            </div>

                            {loan.refinanceEligibility.isEligible && (
                                <div className="mt-6 bg-blue-900/50 p-4 rounded-lg border border-blue-700">
                                    <h4 className="text-xl font-semibold text-blue-200 flex items-center">
                                        <i className="fas fa-magic mr-2"></i> Refinance Opportunity!
                                    </h4>
                                    <p className="text-blue-300 mt-2">
                                        This loan is eligible for refinancing with a suggested rate of <span className="font-bold">{loan.refinanceEligibility.suggestedRate}%</span>,
                                        potentially saving the borrower <span className="font-bold">{formatCurrency(loan.refinanceEligibility.estimatedSavingsMonthly || 0, settings.currency)}</span> per month.
                                    </p>
                                    <p className="text-blue-400 text-sm mt-1">Reasons: {loan.refinanceEligibility.reasonCodes.map(r => r.replace(/_/g, ' ')).join(', ')}</p>
                                    <button className="mt-3 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Explore Refinance Options</button>
                                </div>
                            )}

                             {loan.aiRecommendations.length > 0 && (
                                <div className="mt-6 bg-purple-900/50 p-4 rounded-lg border border-purple-700">
                                    <h4 className="text-xl font-semibold text-purple-200 flex items-center">
                                        <i className="fas fa-robot mr-2"></i> AI Recommendations
                                    </h4>
                                    <ul className="mt-2 space-y-2">
                                        {loan.aiRecommendations.map(rec => (
                                            <li key={rec.id} className="text-purple-300 text-sm">
                                                <span className={`inline-block w-2 h-2 rounded-full mr-2 ${rec.severity === 'high' ? 'bg-red-500' : rec.severity === 'medium' ? 'bg-yellow-500' : 'bg-blue-500'}`}></span>
                                                {rec.message} - <span className="text-purple-400">Action: {rec.actionItems.join(', ')}</span>
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            )}
                        </div>
                    )}

                    {activeTab === 'amortization' && (
                        <div className="space-y-4">
                            <h4 className="text-xl font-semibold text-white mb-4">Amortization Schedule</h4>
                            <div style={{ height: '400px' }}>
                                <Line data={chartData} options={chartOptions} />
                            </div>
                            <div className="overflow-x-auto max-h-80 custom-scrollbar mt-4">
                                <table className="min-w-full divide-y divide-gray-700">
                                    <thead className="bg-gray-700 sticky top-0">
                                        <tr>
                                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Month</th>
                                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Total Payment</th>
                                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Principal</th>
                                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Interest</th>
                                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Remaining Balance</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-700">
                                        {loan.loanDetails.amortizationSchedule.map((p, index) => (
                                            <tr key={index} className="hover:bg-gray-700/50">
                                                <td className="px-4 py-2 whitespace-nowrap text-sm text-gray-300">{p.month}</td>
                                                <td className="px-4 py-2 whitespace-nowrap text-sm text-white">{formatCurrency(p.totalPayment, settings.currency)}</td>
                                                <td className="px-4 py-2 whitespace-nowrap text-sm text-green-300">{formatCurrency(p.principalPayment, settings.currency)}</td>
                                                <td className="px-4 py-2 whitespace-nowrap text-sm text-red-300">{formatCurrency(p.interestPayment, settings.currency)}</td>
                                                <td className="px-4 py-2 whitespace-nowrap text-sm text-white">{formatCurrency(p.remainingBalance, settings.currency)}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}

                    {activeTab === 'payments' && (
                        <div className="space-y-4">
                            <h4 className="text-xl font-semibold text-white mb-4">Payment History</h4>
                            {loan.paymentHistory.length === 0 ? (
                                <p className="text-gray-400">No payment history available.</p>
                            ) : (
                                <div className="overflow-x-auto max-h-96 custom-scrollbar">
                                    <table className="min-w-full divide-y divide-gray-700">
                                        <thead className="bg-gray-700 sticky top-0">
                                            <tr>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Date</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Amount</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Principal</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Interest</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Escrow</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Late Fee</th>
                                                <th className="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase">Status</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-gray-700">
                                            {loan.paymentHistory.map((payment) => (
                                                <tr key={payment.id} className="hover:bg-gray-700/50">
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-gray-300">{formatDate(payment.paymentDate, settings.dateFormat)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-white">{formatCurrency(payment.amount, settings.currency)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-green-300">{formatCurrency(payment.principalPaid, settings.currency)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-red-300">{formatCurrency(payment.interestPaid, settings.currency)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-blue-300">{formatCurrency(payment.escrowPaid, settings.currency)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap text-sm text-yellow-300">{formatCurrency(payment.lateFeeApplied, settings.currency)}</td>
                                                    <td className="px-4 py-2 whitespace-nowrap">
                                                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${payment.isLate ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}`}>
                                                            {payment.isLate ? 'Late' : 'On Time'}
                                                        </span>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>
                    )}

                    {activeTab === 'documents' && (
                        <div className="space-y-4">
                            <h4 className="text-xl font-semibold text-white mb-4">Loan Documents</h4>
                            {loan.documents.length === 0 ? (
                                <p className="text-gray-400">No documents available.</p>
                            ) : (
                                <ul className="space-y-3">
                                    {loan.documents.map((doc) => (
                                        <li key={doc.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                                            <div>
                                                <p className="text-white font-medium">{doc.fileName}</p>
                                                <p className="text-gray-400 text-sm">Type: {doc.documentType.replace(/_/g, ' ')} | Uploaded: {formatDate(doc.uploadDate, settings.dateFormat)}</p>
                                            </div>
                                            <a href={doc.url} target="_blank" rel="noopener noreferrer" className="px-3 py-1 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700">View</a>
                                        </li>
                                    ))}
                                </ul>
                            )}
                            <button className="mt-4 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Upload New Document</button>
                        </div>
                    )}

                    {activeTab === 'notes' && (
                        <div className="space-y-4">
                            <h4 className="text-xl font-semibold text-white mb-4">Internal Notes</h4>
                            {loan.notes.length === 0 ? (
                                <p className="text-gray-400">No notes available.</p>
                            ) : (
                                <ul className="space-y-3">
                                    {loan.notes.map((note) => (
                                        <li key={note.id} className="bg-gray-700 p-3 rounded-lg">
                                            <p className="text-white text-sm mb-1">{note.content}</p>
                                            <p className="text-gray-400 text-xs">By {note.authorName} on {formatDate(note.timestamp, settings.dateFormat)}</p>
                                        </li>
                                    ))}
                                </ul>
                            )}
                            <div className="mt-4">
                                <textarea
                                    className="w-full p-2 bg-gray-700 text-white rounded-md border border-gray-600 focus:ring-blue-500 focus:border-blue-500"
                                    rows={3}
                                    placeholder="Add a new note..."
                                ></textarea>
                                <button className="mt-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Add Note</button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

// --- Main MortgagesView Component ---
const MortgagesView: React.FC = () => {
    return (
        <MortgageAppProvider>
            <div className="min-h-screen bg-gray-900 flex flex-col">
                <AppHeader />
                <main className="flex-1 p-6 space-y-6">
                    <h2 className="text-4xl font-extrabold text-white tracking-wider mb-8">Mortgage Command Center <i className="fas fa-home ml-2 text-blue-400"></i></h2>

                    {/* Mission Briefing Section (Enhanced) */}
                    <Card title="Mission Brief: AI-Powered Mortgage Ecosystem">
                        <p className="text-gray-400 leading-relaxed">
                            Welcome to your advanced Mortgage Command Center. This comprehensive platform integrates mortgage origination, servicing, and portfolio management with cutting-edge AI.
                            Leverage AI-driven forecasting for interest rates, real-time property valuations, and predictive refinancing alerts to optimize your operations and client engagement.
                            Our system empowers you to make data-informed decisions, mitigate risks, and uncover new growth opportunities in a dynamic housing market.
                        </p>
                        <div className="mt-4 pt-4 border-t border-gray-700 flex flex-wrap gap-4">
                            <span className="bg-blue-800 text-blue-200 text-xs px-2 py-1 rounded-full flex items-center"><i className="fas fa-robot mr-1"></i> AI-Driven Forecasting</span>
                            <span className="bg-green-800 text-green-200 text-xs px-2 py-1 rounded-full flex items-center"><i className="fas fa-chart-line mr-1"></i> Real-time Analytics</span>
                            <span className="bg-purple-800 text-purple-200 text-xs px-2 py-1 rounded-full flex items-center"><i className="fas fa-user-friends mr-1"></i> Enhanced Client Lifecycle</span>
                            <span className="bg-red-800 text-red-200 text-xs px-2 py-1 rounded-full flex items-center"><i className="fas fa-shield-alt mr-1"></i> Proactive Risk Management</span>
                        </div>
                    </Card>

                    {/* Key Metrics and AI Insights */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <MarketTrendChart />
                        <AiRecommendationList />
                    </div>

                    {/* Portfolio Overview */}
                    <PortfolioOverview />

                    {/* Loan Listing and Management */}
                    <LoanListingTable />

                    {/* Add more sections as needed, e.g., Application Pipeline, Delinquency Management, Document Workflow */}
                    <Card title="Advanced Features & Modules">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-cogs text-blue-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Automated Underwriting Workflow</h4>
                                    <p className="text-gray-400 text-sm">Streamline application processing with AI-assisted document verification and rule-based decisioning.</p>
                                </div>
                            </div>
                            <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-bullhorn text-green-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Client Engagement Hub</h4>
                                    <p className="text-gray-400 text-sm">Personalized communication, self-service portals, and AI-driven cross-selling.</p>
                                </div>
                            </div>
                            <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-file-invoice-dollar text-yellow-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Delinquency Prediction & Management</h4>
                                    <p className="text-gray-400 text-sm">Predict potential defaults and automate early intervention strategies.</p>
                                </div>
                            </div>
                             <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-chart-pie text-red-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Stress Testing & Scenario Analysis</h4>
                                    <p className="text-gray-400 text-sm">Simulate market downturns and interest rate shocks to assess portfolio resilience.</p>
                                </div>
                            </div>
                            <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-shield-alt text-purple-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Regulatory Compliance Dashboard</h4>
                                    <p className="text-gray-400 text-sm">Monitor compliance with evolving mortgage regulations and generate audit reports.</p>
                                </div>
                            </div>
                            <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center space-x-3">
                                <i className="fas fa-hand-holding-usd text-teal-400 text-2xl"></i>
                                <div>
                                    <h4 className="font-semibold text-white">Secondary Market Analytics</h4>
                                    <p className="text-gray-400 text-sm">Analyze loan pools for securitization and optimize sales strategies.</p>
                                </div>
                            </div>
                        </div>
                    </Card>
                </main>
                <footer className="bg-gray-900 border-t border-gray-700 p-4 text-center text-gray-500 text-sm">
                     {new Date().getFullYear()} MegaCorp Mortgage. All rights reserved. Powered by AI.
                </footer>
            </div>
        </MortgageAppProvider>
    );
};

export default MortgagesView;

--- FILE: TaxCenterView.tsx ---

// components/views/megadashboard/finance/TaxCenterView.tsx
import React, { useState, useContext, useEffect, useCallback, useMemo } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI, Type } from "@google/genai";

// --- ENUMERATIONS AND TYPE DEFINITIONS (Approximately 1000 lines) ---

/**
 * @typedef {object} Transaction
 * @property {string} id - Unique identifier for the transaction.
 * @property {string} description - A brief description of the transaction.
 * @property {number} amount - The monetary value of the transaction.
 * @property {Date} date - The date of the transaction.
 * @property {string} type - 'income' or 'expense'.
 * @property {string} [category] - Optional category assigned to the transaction.
 * @property {string} [merchant] - Optional merchant name.
 * @property {string} [currency] - Currency of the transaction (e.g., 'USD').
 */
export interface Transaction {
    id: string;
    description: string;
    amount: number;
    date: Date;
    type: 'income' | 'expense';
    category?: string;
    merchant?: string;
    currency?: string;
    rawDetails?: string; // Additional raw data for AI analysis
}

/**
 * @typedef {object} Deduction
 * @property {string} id - Unique identifier for the deduction.
 * @property {string} description - Detailed description of the deduction.
 * @property {number} amount - The deductible amount.
 * @property {DeductionCategory} category - The tax deduction category.
 * @property {string} justification - AI-generated or user-provided justification.
 * @property {string[]} [transactionIds] - IDs of transactions supporting this deduction.
 * @property {boolean} [isApproved] - Whether the user has approved this deduction.
 * @property {boolean} [isAIRecommended] - Whether this deduction was initially AI-recommended.
 * @property {string} [receiptUrl] - URL to an uploaded receipt.
 * @property {string} [notes] - User notes about the deduction.
 * @property {Date} [dateAdded] - Date the deduction was added.
 */
export interface Deduction {
    id: string;
    description: string;
    amount: number;
    category: DeductionCategory;
    justification: string;
    transactionIds?: string[];
    isApproved?: boolean;
    isAIRecommended?: boolean;
    receiptUrl?: string;
    notes?: string;
    dateAdded?: Date;
}

/**
 * @typedef {object} IncomeSource
 * @property {string} id - Unique ID.
 * @property {string} name - Name of the income source (e.g., "Client A", "Salary").
 * @property {IncomeType} type - Type of income (W2, 1099-NEC, etc.).
 * @property {number} amountYTD - Year-to-date income from this source.
 * @property {string} [employerId] - For W2 income.
 * @property {string} [ein] - For 1099 income (Employer Identification Number).
 * @property {boolean} [isPassive] - If income is passive (e.g., rental, investments).
 * @property {string} [notes] - Additional notes.
 */
export interface IncomeSource {
    id: string;
    name: string;
    type: IncomeType;
    amountYTD: number;
    employerId?: string;
    ein?: string;
    isPassive?: boolean;
    notes?: string;
}

/**
 * @typedef {object} TaxProfile
 * @property {string} userId - User's ID.
 * @property {number} taxYear - The current tax year.
 * @property {FilingStatus} filingStatus - User's tax filing status.
 * @property {number} dependents - Number of dependents.
 * @property {string} stateOfResidence - User's primary state of residence.
 * @property {boolean} hasHealthInsurance - Whether the user has health insurance.
 * @property {boolean} isSelfEmployed - True if the user is self-employed.
 * @property {number} [estimatedAGI] - Estimated Adjusted Gross Income for the year.
 * @property {number} [federalTaxWithheldYTD] - Total federal tax withheld YTD.
 * @property {number} [stateTaxWithheldYTD] - Total state tax withheld YTD.
 * @property {number} [federalEstimatedTaxPaid] - Total federal estimated tax payments made.
 * @property {number} [stateEstimatedTaxPaid] - Total state estimated tax payments made.
 * @property {number} [priorYearAGI] - AGI from previous tax year (for safe harbor).
 * @property {boolean} [isFirstTimeFiler] - If the user is filing for the first time.
 * @property {boolean} [isStudent] - If the user is a student.
 * @property {boolean} [isHomeowner] - If the user owns a home.
 * @property {boolean} [hasInvestments] - If the user has investment income/losses.
 * @property {boolean} [hasRentalIncome] - If the user has rental property income.
 */
export interface TaxProfile {
    userId: string;
    taxYear: number;
    filingStatus: FilingStatus;
    dependents: number;
    stateOfResidence: string;
    hasHealthInsurance: boolean;
    isSelfEmployed: boolean;
    estimatedAGI?: number;
    federalTaxWithheldYTD?: number;
    stateTaxWithheldYTD?: number;
    federalEstimatedTaxPaid?: number;
    stateEstimatedTaxPaid?: number;
    priorYearAGI?: number;
    isFirstTimeFiler?: boolean;
    isStudent?: boolean;
    isHomeowner?: boolean;
    hasInvestments?: boolean;
    hasRentalIncome?: boolean;
}

/**
 * @typedef {object} EstimatedPayment
 * @property {string} id - Unique ID.
 * @property {number} quarter - Tax quarter (1-4).
 * @property {number} amountFederal - Federal estimated tax paid for this quarter.
 * @property {number} amountState - State estimated tax paid for this quarter.
 * @property {Date} paymentDate - Date the payment was made.
 * @property {boolean} isPaid - Whether the payment has been made.
 * @property {Date} dueDate - Due date for the estimated payment.
 */
export interface EstimatedPayment {
    id: string;
    quarter: number;
    amountFederal: number;
    amountState: number;
    paymentDate?: Date;
    isPaid: boolean;
    dueDate: Date;
}

/**
 * @typedef {object} AuditFactor
 * @property {string} name - Name of the audit factor (e.g., "High Deductions relative to Income").
 * @property {number} score - A numerical score indicating risk level (0-100).
 * @property {AuditRiskLevel} level - Categorical risk level.
 * @property {string} explanation - A brief explanation of the factor.
 * @property {string[]} recommendations - Actionable steps to mitigate risk.
 */
export interface AuditFactor {
    name: string;
    score: number;
    level: AuditRiskLevel;
    explanation: string;
    recommendations: string[];
}

/**
 * @typedef {object} TaxScenario
 * @property {string} id - Unique ID.
 * @property {string} name - Name of the scenario (e.g., "Buy a house", "Increase 401k").
 * @property {TaxProfile} profileChanges - Changes to the tax profile for this scenario.
 * @property {number} incomeChanges - Delta in income for the scenario.
 * @property {Deduction[]} newDeductions - Deductions added in this scenario.
 * @property {number} estimatedTaxImpact - Calculated impact on tax liability.
 * @property {Date} dateCreated - Date the scenario was created.
 */
export interface TaxScenario {
    id: string;
    name: string;
    profileChanges: Partial<TaxProfile>;
    incomeChanges: number;
    newDeductions: Partial<Deduction>[];
    estimatedTaxImpact: number;
    dateCreated: Date;
}

/**
 * @typedef {object} TaxConceptExplanation
 * @property {string} concept - The tax concept being explained.
 * @property {string} explanation - Detailed explanation.
 * @property {string} [example] - An example illustrating the concept.
 * @property {string[]} [relatedConcepts] - Other related tax topics.
 * @property {string[]} [keywords] - Keywords for searchability.
 */
export interface TaxConceptExplanation {
    concept: string;
    explanation: string;
    example?: string;
    relatedConcepts?: string[];
    keywords?: string[];
}

/**
 * @typedef {object} TaxAlert
 * @property {string} id - Unique ID.
 * @property {string} title - Title of the alert.
 * @property {string} description - Detailed description of the alert.
 * @property {TaxAlertSeverity} severity - Severity level of the alert.
 * @property {Date} dateIssued - Date the alert was issued.
 * @property {boolean} isRead - Whether the user has read the alert.
 * @property {string[]} [relatedTaxYears] - Tax years relevant to the alert.
 * @property {string[]} [affectedStates] - States affected by the alert.
 * @property {string} [callToAction] - Optional call to action.
 * @property {string} [learnMoreUrl] - URL for more information.
 */
export interface TaxAlert {
    id: string;
    title: string;
    description: string;
    severity: TaxAlertSeverity;
    dateIssued: Date;
    isRead: boolean;
    relatedTaxYears?: string[];
    affectedStates?: string[];
    callToAction?: string;
    learnMoreUrl?: string;
}

/**
 * @typedef {object} Receipt
 * @property {string} id - Unique ID.
 * @property {string} fileName - Original file name.
 * @property {string} url - URL to the stored receipt image/PDF.
 * @property {Date} uploadDate - Date of upload.
 * @property {string[]} [linkedDeductionIds] - IDs of deductions linked to this receipt.
 * @property {string} [extractedText] - Text extracted by OCR (if applicable).
 * @property {string} [aiSummary] - AI-generated summary of the receipt.
 * @property {number} [amount] - Amount parsed from receipt.
 * @property {Date} [transactionDate] - Date parsed from receipt.
 */
export interface Receipt {
    id: string;
    fileName: string;
    url: string;
    uploadDate: Date;
    linkedDeductionIds?: string[];
    extractedText?: string;
    aiSummary?: string;
    amount?: number;
    transactionDate?: Date;
}

export enum DeductionCategory {
    HomeOffice = 'Home Office',
    BusinessTravel = 'Business Travel',
    ProfessionalDevelopment = 'Professional Development',
    SoftwareSubscriptions = 'Software & Subscriptions',
    ClientEntertainment = 'Client Entertainment',
    MarketingAdvertising = 'Marketing & Advertising',
    VehicleExpenses = 'Vehicle Expenses',
    HealthInsurancePremiums = 'Health Insurance Premiums',
    RetirementContributions = 'Retirement Contributions',
    OfficeSupplies = 'Office Supplies',
    LegalProfessionalFees = 'Legal & Professional Fees',
    Utilities = 'Utilities',
    OtherBusinessExpense = 'Other Business Expense',
    MedicalExpenses = 'Medical Expenses',
    CharitableContributions = 'Charitable Contributions',
    StateLocalTaxes = 'State & Local Taxes',
    MortgageInterest = 'Mortgage Interest',
    StudentLoanInterest = 'Student Loan Interest',
    ChildCareExpenses = 'Child Care Expenses',
    EducationalExpenses = 'Educational Expenses',
    InvestmentExpenses = 'Investment Expenses',
    RealEstateTaxes = 'Real Estate Taxes',
    CasualtyLosses = 'Casualty Losses',
    AlimonyPayments = 'Alimony Payments',
    OtherItemizedDeduction = 'Other Itemized Deduction',
}

export enum IncomeType {
    W2 = 'W2 Salary',
    NEC1099 = '1099-NEC (Non-employee Compensation)',
    K1 = 'K-1 (Partnership/S-Corp)',
    Dividends = 'Dividends (1099-DIV)',
    Interest = 'Interest (1099-INT)',
    CapitalGains = 'Capital Gains (1099-B)',
    RentalIncome = 'Rental Income',
    SocialSecurity = 'Social Security',
    PensionAnnuity = 'Pension/Annuity',
    Unemployment = 'Unemployment Benefits',
    Other = 'Other Income',
}

export enum FilingStatus {
    Single = 'Single',
    MarriedFilingJointly = 'Married Filing Jointly',
    MarriedFilingSeparately = 'Married Filing Separately',
    HeadOfHousehold = 'Head of Household',
    QualifyingWidow = 'Qualifying Widow(er)',
}

export enum AuditRiskLevel {
    Low = 'Low',
    Medium = 'Medium',
    High = 'High',
    VeryHigh = 'Very High',
}

export enum TaxAlertSeverity {
    Info = 'Info',
    Warning = 'Warning',
    Critical = 'Critical',
}

export enum TaxFormType {
    Form1040 = 'Form 1040',
    ScheduleC = 'Schedule C',
    ScheduleSE = 'Schedule SE',
    Form1040ES = 'Form 1040-ES',
    ScheduleA = 'Schedule A',
    Form8829 = 'Form 8829', // Home Office Expenses
    Form4562 = 'Form 4562', // Depreciation
    FormW2 = 'Form W-2',
    Form1099NEC = 'Form 1099-NEC',
}

export enum FinancialMetric {
    TotalIncome = 'Total Income',
    TotalExpenses = 'Total Expenses',
    NetProfit = 'Net Profit',
    TotalDeductions = 'Total Deductions',
    EstimatedTaxLiability = 'Estimated Tax Liability',
    EffectiveTaxRate = 'Effective Tax Rate',
    EstimatedQuarterlyPayment = 'Estimated Quarterly Payment',
}

// --- CONSTANTS AND MOCK DATA (Approximately 500 lines) ---

export const TAX_YEAR = 2024; // Current tax year for calculations

export const DEDUCTION_CATEGORIES_OPTIONS = Object.values(DeductionCategory).map(cat => ({ value: cat, label: cat }));
export const INCOME_TYPE_OPTIONS = Object.values(IncomeType).map(type => ({ value: type, label: type }));
export const FILING_STATUS_OPTIONS = Object.values(FilingStatus).map(status => ({ value: status, label: status }));

// Mock Federal Tax Brackets (Simplified for demonstration)
// In a real app, this would be fetched/updated annually and be much more complex,
// considering long-term capital gains, different income types, etc.
export const FEDERAL_TAX_BRACKETS_SINGLE = [
    { income: 0, rate: 0.10, limit: 11600 },
    { income: 11601, rate: 0.12, limit: 47150 },
    { income: 47151, rate: 0.22, limit: 100525 },
    { income: 100526, rate: 0.24, limit: 191950 },
    { income: 191951, rate: 0.32, limit: 243725 },
    { income: 243726, rate: 0.35, limit: 609350 },
    { income: 609351, rate: 0.37, limit: Infinity },
];

export const FEDERAL_TAX_BRACKETS_MFJ = [ // Married Filing Jointly
    { income: 0, rate: 0.10, limit: 23200 },
    { income: 23201, rate: 0.12, limit: 94300 },
    { income: 94301, rate: 0.22, limit: 201050 },
    { income: 201051, rate: 0.24, limit: 383900 },
    { income: 383901, rate: 0.32, limit: 487450 },
    { income: 487451, rate: 0.35, limit: 731200 },
    { income: 731201, rate: 0.37, limit: Infinity },
];

export const STANDARD_DEDUCTION_2024: Record<FilingStatus, number> = {
    [FilingStatus.Single]: 14600,
    [FilingStatus.MarriedFilingJointly]: 29200,
    [FilingStatus.MarriedFilingSeparately]: 14600,
    [FilingStatus.HeadOfHousehold]: 21900,
    [FilingStatus.QualifyingWidow]: 29200,
};

export const SELF_EMPLOYMENT_TAX_RATE = 0.153; // 12.4% SS + 2.9% Medicare
export const SS_MAX_EARNINGS = 168600; // Social Security wage base limit 2024
export const SE_DEDUCTION_PERCENTAGE = 0.5; // Deduction for one-half of SE tax

// Mock State Tax Brackets (Simplified for California - Example)
export const CA_STATE_TAX_BRACKETS_SINGLE = [
    { income: 0, rate: 0.01, limit: 10412 },
    { income: 10413, rate: 0.02, limit: 24684 },
    { income: 24685, rate: 0.04, limit: 38959 },
    { income: 38960, rate: 0.06, limit: 53909 },
    { income: 53910, rate: 0.08, limit: 68179 },
    { income: 68180, rate: 0.093, limit: 348637 },
    { income: 348638, rate: 0.103, limit: 418361 },
    { income: 418362, rate: 0.113, limit: 697268 },
    { income: 697269, rate: 0.123, limit: 1000000 },
    { income: 1000001, rate: 0.133, limit: Infinity }, // Includes 1% mental health tax
];

export const QUARTERLY_DUE_DATES: { [key: number]: Date } = {
    1: new Date(TAX_YEAR, 3, 15), // April 15
    2: new Date(TAX_YEAR, 5, 15), // June 15
    3: new Date(TAX_YEAR, 8, 15), // September 15
    4: new Date(TAX_YEAR + 1, 0, 15), // January 15 of next year
};

export const MOCK_ALERTS: TaxAlert[] = [
    {
        id: 'alert1',
        title: 'New Health Insurance Deduction Limit for Self-Employed',
        description: 'The IRS has updated the maximum deductible amount for self-employed health insurance premiums. Review your entries to ensure compliance.',
        severity: TaxAlertSeverity.Warning,
        dateIssued: new Date(TAX_YEAR, 0, 10),
        isRead: false,
        relatedTaxYears: [`${TAX_YEAR}`],
        callToAction: 'Update Deduction',
        learnMoreUrl: 'https://www.irs.gov/newsroom/self-employed-health-insurance-deduction',
    },
    {
        id: 'alert2',
        title: 'Q2 Estimated Tax Payment Due Soon!',
        description: `Your second quarter estimated tax payment for ${TAX_YEAR} is due on June 15th. Ensure you have sufficient funds and consider making your payment to avoid penalties.`,
        severity: TaxAlertSeverity.Critical,
        dateIssued: new Date(TAX_YEAR, 4, 20),
        isRead: false,
        relatedTaxYears: [`${TAX_YEAR}`],
        callToAction: 'Make Payment',
        learnMoreUrl: 'https://www.irs.gov/payments/pay-as-you-go- withholding-estimated-tax',
    },
    {
        id: 'alert3',
        title: 'New State Tax Relief Program for Small Businesses (CA)',
        description: 'California has introduced a new tax credit for small businesses investing in employee training. Check eligibility requirements.',
        severity: TaxAlertSeverity.Info,
        dateIssued: new Date(TAX_YEAR, 2, 1),
        isRead: true,
        relatedTaxYears: [`${TAX_YEAR}`],
        affectedStates: ['CA'],
        callToAction: 'View Details',
        learnMoreUrl: 'https://www.ftb.ca.gov/taxes/business/credits/',
    },
];

export const MOCK_RECEIPTS: Receipt[] = [
    {
        id: 'rec1',
        fileName: 'uber_receipt_1.pdf',
        url: '/receipts/rec1.pdf',
        uploadDate: new Date(TAX_YEAR, 1, 15),
        linkedDeductionIds: ['ded123'],
        extractedText: 'Uber trip to client office. Amount: $45.50. Date: Feb 10, 2024.',
        aiSummary: 'Business travel expense for client meeting.',
        amount: 45.50,
        transactionDate: new Date(TAX_YEAR, 1, 10),
    },
    {
        id: 'rec2',
        fileName: 'adobe_cc_invoice.png',
        url: '/receipts/rec2.png',
        uploadDate: new Date(TAX_YEAR, 2, 10),
        linkedDeductionIds: ['ded456'],
        extractedText: 'Adobe Creative Cloud subscription. Amount: $52.99. Monthly. March 2024.',
        aiSummary: 'Software subscription for professional use.',
        amount: 52.99,
        transactionDate: new Date(TAX_YEAR, 2, 5),
    },
];

// --- HELPER FUNCTIONS AND TAX CALCULATION LOGIC (Approximately 4000 lines) ---

/**
 * Generates a unique ID (simple UUID-like for client-side use).
 * @returns {string} A unique identifier.
 */
export const generateUniqueId = (): string => {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};

/**
 * Formats a number as currency.
 * @param {number} amount - The amount to format.
 * @returns {string} Formatted currency string.
 */
export const formatCurrency = (amount: number | undefined): string => {
    if (typeof amount !== 'number' || isNaN(amount)) {
        return '$0.00';
    }
    return `$${amount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
};

/**
 * Calculates federal tax liability based on taxable income and filing status.
 * (Simplified progressive tax calculation)
 * @param {number} taxableIncome - The income subject to federal tax.
 * @param {FilingStatus} filingStatus - The taxpayer's filing status.
 * @returns {number} The calculated federal tax.
 */
export const calculateFederalTax = (taxableIncome: number, filingStatus: FilingStatus): number => {
    if (taxableIncome <= 0) return 0;

    let tax = 0;
    const brackets = filingStatus === FilingStatus.Single ? FEDERAL_TAX_BRACKETS_SINGLE : FEDERAL_TAX_BRACKETS_MFJ; // Add more for other statuses

    for (const bracket of brackets) {
        if (taxableIncome > bracket.income) {
            const incomeInBracket = Math.min(taxableIncome, bracket.limit) - bracket.income;
            tax += incomeInBracket * bracket.rate;
        } else {
            break;
        }
    }
    return tax;
};

/**
 * Calculates state tax liability based on taxable income and state of residence.
 * (Simplified for CA only)
 * @param {number} taxableIncome - The income subject to state tax.
 * @param {string} stateOfResidence - The taxpayer's state of residence.
 * @param {FilingStatus} filingStatus - The taxpayer's filing status.
 * @returns {number} The calculated state tax.
 */
export const calculateStateTax = (taxableIncome: number, stateOfResidence: string, filingStatus: FilingStatus): number => {
    if (taxableIncome <= 0) return 0;

    let tax = 0;
    // This function would typically involve a large switch statement or external data
    // for all 50 states and their respective brackets and rules.
    switch (stateOfResidence) {
        case 'CA':
            const caBrackets = filingStatus === FilingStatus.Single ? CA_STATE_TAX_BRACKETS_SINGLE : CA_STATE_TAX_BRACKETS_SINGLE; // Simplified: assuming same for MFJ for now
            for (const bracket of caBrackets) {
                if (taxableIncome > bracket.income) {
                    const incomeInBracket = Math.min(taxableIncome, bracket.limit) - bracket.income;
                    tax += incomeInBracket * bracket.rate;
                } else {
                    break;
                }
            }
            return tax;
        // Add more states here
        default:
            return 0; // No state income tax or not implemented
    }
};

/**
 * Calculates net self-employment earnings for Schedule SE.
 * @param {number} totalSelfEmploymentIncome - Total income from 1099-NEC sources.
 * @param {number} totalBusinessExpenses - Total deductible business expenses.
 * @returns {number} Net earnings from self-employment.
 */
export const calculateNetSelfEmploymentEarnings = (totalSelfEmploymentIncome: number, totalBusinessExpenses: number): number => {
    const netProfit = totalSelfEmploymentIncome - totalBusinessExpenses;
    // Multiply by 0.9235 (1 - 0.0765) as only 92.35% of net earnings are subject to SE tax
    return Math.max(0, netProfit * 0.9235);
};

/**
 * Calculates self-employment tax.
 * @param {number} netSelfEmploymentEarnings - Net earnings from self-employment.
 * @returns {number} Self-employment tax.
 */
export const calculateSETax = (netSelfEmploymentEarnings: number): number => {
    const ssEarnings = Math.min(netSelfEmploymentEarnings, SS_MAX_EARNINGS);
    const medicareEarnings = netSelfEmploymentEarnings; // No limit for Medicare

    const ssTax = ssEarnings * 0.124; // Social Security portion
    const medicareTax = medicareEarnings * 0.029; // Medicare portion

    return ssTax + medicareTax;
};

/**
 * Calculates the deduction for one-half of self-employment tax.
 * @param {number} seTax - Total self-employment tax.
 * @returns {number} The deductible portion.
 */
export const calculateSEDeduction = (seTax: number): number => {
    return seTax * SE_DEDUCTION_PERCENTAGE;
};

/**
 * Calculates Adjusted Gross Income (AGI).
 * @param {number} totalIncome - Sum of all income sources.
 * @param {number} aboveTheLineDeductions - Deductions taken before AGI (e.g., SE tax deduction, student loan interest, HSA contributions).
 * @returns {number} Adjusted Gross Income.
 */
export const calculateAGI = (totalIncome: number, aboveTheLineDeductions: number): number => {
    return Math.max(0, totalIncome - aboveTheLineDeductions);
};

/**
 * Calculates total itemized deductions.
 * @param {Deduction[]} approvedDeductions - List of approved deductions.
 * @param {TaxProfile} taxProfile - User's tax profile.
 * @returns {number} Total itemized deductions.
 */
export const calculateItemizedDeductions = (approvedDeductions: Deduction[], taxProfile: TaxProfile): number => {
    // This is a simplified example. Real itemized deductions are much more complex
    // with AGI limitations (e.g., medical expenses > 7.5% AGI, state/local tax cap).
    let total = 0;
    for (const d of approvedDeductions) {
        // Exclude business expenses already accounted for in Schedule C
        if (d.category !== DeductionCategory.HomeOffice &&
            d.category !== DeductionCategory.BusinessTravel &&
            d.category !== DeductionCategory.ProfessionalDevelopment &&
            d.category !== DeductionCategory.SoftwareSubscriptions &&
            d.category !== DeductionCategory.ClientEntertainment &&
            d.category !== DeductionCategory.MarketingAdvertising &&
            d.category !== DeductionCategory.VehicleExpenses &&
            d.category !== DeductionCategory.OfficeSupplies &&
            d.category !== DeductionCategory.LegalProfessionalFees &&
            d.category !== DeductionCategory.Utilities &&
            d.category !== DeductionCategory.OtherBusinessExpense) {
            total += d.amount;
        }
    }
    // Add specific itemized deduction types if present in taxProfile (e.g., mortgage interest)
    // For now, only using 'other' types
    return total;
};

/**
 * Determines the greater of standard or itemized deductions.
 * @param {number} totalItemizedDeductions - Calculated total itemized deductions.
 * @param {FilingStatus} filingStatus - The taxpayer's filing status.
 * @returns {number} The higher deduction amount.
 */
export const getApplicableDeduction = (totalItemizedDeductions: number, filingStatus: FilingStatus): number => {
    const standardDeduction = STANDARD_DEDUCTION_2024[filingStatus] || STANDARD_DEDUCTION_2024[FilingStatus.Single];
    return Math.max(standardDeduction, totalItemizedDeductions);
};

/**
 * Calculates total income from all sources.
 * @param {IncomeSource[]} incomeSources - List of all income sources.
 * @returns {number} Total gross income.
 */
export const calculateTotalGrossIncome = (incomeSources: IncomeSource[]): number => {
    return incomeSources.reduce((sum, source) => sum + source.amountYTD, 0);
};

/**
 * Calculates Schedule C business income and expenses.
 * @param {IncomeSource[]} incomeSources - All income sources.
 * @param {Deduction[]} approvedDeductions - All approved deductions.
 * @returns {{ businessIncome: number, businessExpenses: number, netBusinessProfit: number }}
 */
export const calculateScheduleCDetails = (incomeSources: IncomeSource[], approvedDeductions: Deduction[]) => {
    const businessIncome = incomeSources
        .filter(s => s.type === IncomeType.NEC1099 || s.type === IncomeType.Other)
        .reduce((sum, s) => sum + s.amountYTD, 0);

    const businessExpenses = approvedDeductions
        .filter(d =>
            d.isApproved && (
                d.category === DeductionCategory.HomeOffice ||
                d.category === DeductionCategory.BusinessTravel ||
                d.category === DeductionCategory.ProfessionalDevelopment ||
                d.category === DeductionCategory.SoftwareSubscriptions ||
                d.category === DeductionCategory.ClientEntertainment ||
                d.category === DeductionCategory.MarketingAdvertising ||
                d.category === DeductionCategory.VehicleExpenses ||
                d.category === DeductionCategory.OfficeSupplies ||
                d.category === DeductionCategory.LegalProfessionalFees ||
                d.category === DeductionCategory.Utilities ||
                d.category === DeductionCategory.OtherBusinessExpense
            )
        )
        .reduce((sum, d) => sum + d.amount, 0);

    const netBusinessProfit = businessIncome - businessExpenses;
    return { businessIncome, businessExpenses, netBusinessProfit };
};


/**
 * Core function to calculate the full estimated tax liability.
 * This is a highly simplified model and would involve hundreds of rules, credits, and forms in a real application.
 * @param {IncomeSource[]} incomeSources - All income sources.
 * @param {Deduction[]} approvedDeductions - All approved deductions.
 * @param {TaxProfile} taxProfile - User's tax profile.
 * @returns {{
 *   totalGrossIncome: number;
 *   scheduleCIncome: number;
 *   scheduleCExpenses: number;
 *   netBusinessProfit: number;
 *   netSelfEmploymentEarnings: number;
 *   selfEmploymentTax: number;
 *   seTaxDeduction: number;
 *   totalAboveTheLineDeductions: number;
 *   agi: number;
 *   totalItemizedDeductions: number;
 *   applicableDeduction: number;
 *   taxableIncome: number;
 *   federalTaxLiability: number;
 *   stateTaxLiability: number;
 *   totalEstimatedTaxLiability: number;
 *   federalTaxWithheldYTD: number;
 *   stateTaxWithheldYTD: number;
 *   netFederalTaxDue: number;
 *   netStateTaxDue: number;
 *   effectiveTaxRate: number;
 * }} Detailed tax calculation breakdown.
 */
export const calculateFullTaxLiability = (
    incomeSources: IncomeSource[],
    approvedDeductions: Deduction[],
    taxProfile: TaxProfile
) => {
    // 1. Calculate Total Gross Income
    const totalGrossIncome = calculateTotalGrossIncome(incomeSources);

    // 2. Calculate Schedule C (Business Income/Expenses)
    const { businessIncome, businessExpenses, netBusinessProfit } = calculateScheduleCDetails(incomeSources, approvedDeductions);

    // 3. Calculate Self-Employment Tax (Schedule SE)
    const netSelfEmploymentEarnings = calculateNetSelfEmploymentEarnings(businessIncome, businessExpenses);
    const selfEmploymentTax = calculateSETax(netSelfEmploymentEarnings);
    const seTaxDeduction = calculateSEDeduction(selfEmploymentTax);

    // 4. Other Above-the-Line Deductions (Simplified)
    // Add logic for HSA, Student Loan Interest, etc.
    const otherAboveTheLineDeductions = approvedDeductions
        .filter(d => d.isApproved && (
            d.category === DeductionCategory.HealthInsurancePremiums || // Self-employed health insurance
            d.category === DeductionCategory.RetirementContributions || // SEP IRA, Solo 401k for SE
            d.category === DeductionCategory.StudentLoanInterest // Student loan interest
        ))
        .reduce((sum, d) => sum + d.amount, 0);

    const totalAboveTheLineDeductions = seTaxDeduction + otherAboveTheLineDeductions;

    // 5. Calculate Adjusted Gross Income (AGI)
    const agi = calculateAGI(totalGrossIncome, totalAboveTheLineDeductions);

    // 6. Itemized vs. Standard Deductions
    const totalItemizedDeductions = calculateItemizedDeductions(approvedDeductions, taxProfile);
    const applicableDeduction = getApplicableDeduction(totalItemizedDeductions, taxProfile.filingStatus);

    // 7. Calculate Taxable Income
    const taxableIncome = Math.max(0, agi - applicableDeduction);

    // 8. Calculate Federal Income Tax Liability
    const federalTaxLiability = calculateFederalTax(taxableIncome, taxProfile.filingStatus);

    // 9. Calculate State Income Tax Liability
    const stateTaxLiability = calculateStateTax(taxableIncome, taxProfile.stateOfResidence, taxProfile.filingStatus);

    // 10. Total Estimated Tax Liability (Federal Income Tax + SE Tax + State Income Tax - Credits)
    // This assumes all SE tax is federal. Some states also have SE tax components.
    // Add logic for various tax credits (Child Tax Credit, EITC, etc.)
    const totalEstimatedTaxLiability = federalTaxLiability + selfEmploymentTax + stateTaxLiability;

    // 11. Calculate Net Tax Due/Refund
    const federalTaxWithheldYTD = taxProfile.federalTaxWithheldYTD || 0;
    const stateTaxWithheldYTD = taxProfile.stateTaxWithheldYTD || 0;
    const federalEstimatedTaxPaidYTD = taxProfile.federalEstimatedTaxPaid || 0;
    const stateEstimatedTaxPaidYTD = taxProfile.stateEstimatedTaxPaid || 0;

    const netFederalTaxDue = totalEstimatedTaxLiability - federalTaxWithheldYTD - federalEstimatedTaxPaidYTD;
    const netStateTaxDue = stateTaxLiability - stateTaxWithheldYTD - stateEstimatedTaxPaidYTD;

    // 12. Effective Tax Rate
    const effectiveTaxRate = totalGrossIncome > 0 ? (totalEstimatedTaxLiability / totalGrossIncome) * 100 : 0;

    return {
        totalGrossIncome,
        scheduleCIncome: businessIncome,
        scheduleCExpenses: businessExpenses,
        netBusinessProfit,
        netSelfEmploymentEarnings,
        selfEmploymentTax,
        seTaxDeduction,
        totalAboveTheLineDeductions,
        agi,
        totalItemizedDeductions,
        applicableDeduction,
        taxableIncome,
        federalTaxLiability,
        stateTaxLiability,
        totalEstimatedTaxLiability,
        federalTaxWithheldYTD,
        stateTaxWithheldYTD,
        netFederalTaxDue,
        netStateTaxDue,
        effectiveTaxRate,
    };
};

/**
 * Calculates estimated quarterly tax payments.
 * (Simplified 1040-ES calculation, assumes equal distribution for simplicity)
 * In a real app, this would consider annualized income, prior year tax, etc.
 * @param {number} totalEstimatedTaxLiability - Total projected tax liability for the year.
 * @param {number} federalTaxWithheldYTD - Federal tax already withheld YTD.
 * @param {number} stateTaxWithheldYTD - State tax already withheld YTD.
 * @param {number} federalEstimatedTaxPaid - Federal estimated tax already paid.
 * @param {number} stateEstimatedTaxPaid - State estimated tax already paid.
 * @returns {EstimatedPayment[]} An array of estimated payments for the remaining quarters.
 */
export const calculateEstimatedQuarterlyPayments = (
    totalEstimatedTaxLiability: number,
    federalTaxWithheldYTD: number,
    stateTaxWithheldYTD: number,
    federalEstimatedTaxPaid: number,
    stateEstimatedTaxPaid: number
): EstimatedPayment[] => {
    const today = new Date();
    const currentMonth = today.getMonth(); // 0-11

    const remainingFederalTax = totalEstimatedTaxLiability - federalTaxWithheldYTD - federalEstimatedTaxPaid;
    const remainingStateTax = totalEstimatedTaxLiability - stateTaxWithheldYTD - stateEstimatedTaxPaid; // Assuming state tax also reduces total estimated

    const payments: EstimatedPayment[] = [];
    let quartersRemaining = 0;

    if (currentMonth < 3) quartersRemaining = 4; // Before April 15
    else if (currentMonth < 5) quartersRemaining = 3; // Before June 15
    else if (currentMonth < 8) quartersRemaining = 2; // Before Sept 15
    else if (currentMonth < 11) quartersRemaining = 1; // Before Jan 15 of next year

    for (let q = 1; q <= 4; q++) {
        const dueDate = QUARTERLY_DUE_DATES[q];
        const isPaid = (dueDate < today && q <= (4 - quartersRemaining)); // Very simplified paid check

        let amountFederal = 0;
        let amountState = 0;

        if (!isPaid && quartersRemaining > 0) {
            amountFederal = remainingFederalTax / quartersRemaining;
            amountState = remainingStateTax / quartersRemaining;
        }

        payments.push({
            id: generateUniqueId(),
            quarter: q,
            amountFederal: Math.max(0, amountFederal),
            amountState: Math.max(0, amountState),
            paymentDate: isPaid ? new Date() : undefined, // Mock payment date
            isPaid: isPaid,
            dueDate: dueDate,
        });
    }

    return payments;
};

/**
 * Simulates AI audit risk assessment based on various factors.
 * In a real application, this would use a more sophisticated ML model.
 * @param {number} income - User's total income.
 * @param {number} deductionsTotal - Total value of all deductions.
 * @param {number} homeOfficeDeduction - Amount of home office deduction.
 * @param {number} mealsEntertainmentDeduction - Amount of meals and entertainment deductions.
 * @param {number} businessTravelDeduction - Amount of business travel deductions.
 * @returns {AuditFactor[]} A list of audit factors with scores and recommendations.
 */
export const assessAuditRiskAI = (
    income: number,
    deductionsTotal: number,
    homeOfficeDeduction: number,
    mealsEntertainmentDeduction: number,
    businessTravelDeduction: number,
    priorYearAGI: number = 0, // for large income fluctuations
    cryptoTransactions: boolean = false,
    foreignAccounts: boolean = false
): AuditFactor[] => {
    const factors: AuditFactor[] = [];
    let overallRiskScore = 0;

    // Factor 1: High Deductions Relative to Income
    const deductionToIncomeRatio = income > 0 ? deductionsTotal / income : 0;
    if (deductionToIncomeRatio > 0.4) { // More than 40% of income is deducted
        const score = Math.min(100, (deductionToIncomeRatio - 0.4) * 200); // Scale the risk
        factors.push({
            name: 'High Deductions Relative to Income',
            score: score,
            level: score > 70 ? AuditRiskLevel.VeryHigh : (score > 40 ? AuditRiskLevel.High : AuditRiskLevel.Medium),
            explanation: `Your total deductions (${formatCurrency(deductionsTotal)}) represent a significant portion (${(deductionToIncomeRatio * 100).toFixed(1)}%) of your income (${formatCurrency(income)}). This can be a flag for IRS scrutiny.`,
            recommendations: ['Ensure all deductions are properly documented with receipts and clear business purpose.', 'Review each deduction for accuracy and eligibility.', 'Consider consulting a tax professional for complex situations.'],
        });
        overallRiskScore += score * 0.3; // Weight this factor
    }

    // Factor 2: Home Office Deduction (common audit trigger)
    if (homeOfficeDeduction > 0) {
        const score = Math.min(100, homeOfficeDeduction / 500); // Simple heuristic: higher amount = higher risk
        factors.push({
            name: 'Home Office Deduction',
            score: score,
            level: score > 60 ? AuditRiskLevel.High : (score > 30 ? AuditRiskLevel.Medium : AuditRiskLevel.Low),
            explanation: `You are claiming a home office deduction of ${formatCurrency(homeOfficeDeduction)}. The IRS frequently reviews this deduction for strict compliance with "exclusive and regular use" rules.`,
            recommendations: ['Maintain detailed records of home office expenses (utilities, rent/mortgage interest, repairs).', 'Ensure the space is used *exclusively* and *regularly* for business.', 'Take photos of your dedicated workspace.', 'Familiarize yourself with the simplified vs. actual expense method rules.'],
        });
        overallRiskScore += score * 0.2;
    }

    // Factor 3: Large Meals and Entertainment Deductions
    if (mealsEntertainmentDeduction > income * 0.05 && mealsEntertainmentDeduction > 2000) { // Over 5% of income and significant amount
        const score = Math.min(100, (mealsEntertainmentDeduction / income * 100) * 2);
        factors.push({
            name: 'Significant Meals & Entertainment Expenses',
            score: score,
            level: score > 70 ? AuditRiskLevel.VeryHigh : (score > 40 ? AuditRiskLevel.High : AuditRiskLevel.Medium),
            explanation: `Your reported meals and entertainment expenses (${formatCurrency(mealsEntertainmentDeduction)}) are substantial relative to your income. These deductions are often scrutinized.`,
            recommendations: ['For each expense, record the date, place, amount, business purpose, and business relationship of the people entertained.', 'Remember only 50% of qualifying business meals are deductible.', 'Keep all receipts, even for small amounts.'],
        });
        overallRiskScore += score * 0.15;
    }

    // Factor 4: Large Travel Expenses
    if (businessTravelDeduction > income * 0.1 && businessTravelDeduction > 5000) { // Over 10% of income and significant amount
        const score = Math.min(100, (businessTravelDeduction / income * 100));
        factors.push({
            name: 'Significant Business Travel Expenses',
            score: score,
            level: score > 60 ? AuditRiskLevel.High : (score > 30 ? AuditRiskLevel.Medium : AuditRiskLevel.Low),
            explanation: `Your business travel expenses (${formatCurrency(businessTravelDeduction)}) are notable. The IRS looks for clear distinctions between business and personal travel.`,
            recommendations: ['Keep detailed logs of travel, including dates, destinations, business purpose, and expenses incurred.', 'Separate personal and business portions of trips clearly.', 'Retain all transportation and lodging receipts.'],
        });
        overallRiskScore += score * 0.1;
    }

    // Factor 5: Large Fluctuations in Income
    if (priorYearAGI > 0 && Math.abs(income - priorYearAGI) > priorYearAGI * 0.25 && Math.abs(income - priorYearAGI) > 20000) { // >25% change and >$20k
        const score = Math.min(100, Math.abs(income - priorYearAGI) / priorYearAGI * 50);
        factors.push({
            name: 'Significant Income Fluctuations',
            score: score,
            level: score > 70 ? AuditRiskLevel.VeryHigh : (score > 40 ? AuditRiskLevel.High : AuditRiskLevel.Medium),
            explanation: `Your income has significantly changed from the prior year (prior AGI: ${formatCurrency(priorYearAGI)}, current: ${formatCurrency(income)}). While often legitimate, large shifts can sometimes prompt IRS review.`,
            recommendations: ['Be prepared to explain the reasons for income changes (e.g., new client, business expansion/contraction, major project completion).', 'Ensure all income sources are accurately reported.'],
        });
        overallRiskScore += score * 0.1;
    }

    // Factor 6: Cryptocurrencies (growing area of IRS focus)
    if (cryptoTransactions) {
        factors.push({
            name: 'Cryptocurrency Transactions',
            score: 70, // Automatically high if present due to IRS focus
            level: AuditRiskLevel.High,
            explanation: 'The IRS is increasingly scrutinizing cryptocurrency transactions. Ensure all gains, losses, and income from crypto are accurately reported.',
            recommendations: ['Keep meticulous records of all crypto transactions (purchase dates/prices, sale dates/prices, fees, basis).', 'Use tax software that integrates with crypto exchanges for accurate reporting.', 'Understand the difference between capital gains and ordinary income for crypto.'],
        });
        overallRiskScore += 70 * 0.1;
    }

    // Factor 7: Foreign Bank Accounts / Assets (FBAR, FATCA)
    if (foreignAccounts) {
        factors.push({
            name: 'Foreign Bank Accounts or Assets',
            score: 85, // Very high due to severe penalties for non-compliance
            level: AuditRiskLevel.VeryHigh,
            explanation: 'Holding foreign bank accounts or assets (above certain thresholds) requires specific reporting to the IRS (e.g., FBAR, Form 8938). Non-compliance carries severe penalties.',
            recommendations: ['Consult a tax professional specializing in international tax law.', 'Ensure all required forms (FBAR, Form 8938) are filed correctly and on time.', 'Understand the reporting thresholds and definitions of foreign assets.'],
        });
        overallRiskScore += 85 * 0.15;
    }

    // Default Low Risk if no specific high-risk factors found
    if (factors.length === 0) {
        factors.push({
            name: 'General Audit Risk',
            score: 10,
            level: AuditRiskLevel.Low,
            explanation: 'Based on your current financial data and common IRS audit triggers, your overall audit risk appears low.',
            recommendations: ['Continue maintaining diligent records for all income and expenses.', 'Stay informed about tax law changes relevant to your situation.'],
        });
    }

    // Sort factors by score for display
    factors.sort((a, b) => b.score - a.score);

    return factors;
};

/**
 * Summarizes current tax situation and provides actionable insights using AI.
 * (Placeholder for more advanced AI interaction)
 * @param {any} taxSummaryData - The data object from calculateFullTaxLiability.
 * @param {string[]} topDeductions - Top identified deductions.
 * @param {AuditFactor[]} auditFactors - List of audit risk factors.
 * @returns {Promise<string>} An AI-generated summary string.
 */
export const getAISummaryAndInsights = async (
    taxSummaryData: ReturnType<typeof calculateFullTaxLiability>,
    topDeductions: Deduction[],
    auditFactors: AuditFactor[]
): Promise<string> => {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
    const prompt = `You are an expert tax advisor AI. Provide a concise summary of the user's current tax situation and actionable insights based on the following data.
    
    User Profile: Self-employed consultant, ${taxSummaryData.taxProfile.filingStatus}, ${taxSummaryData.taxProfile.dependents} dependents, residing in ${taxSummaryData.taxProfile.stateOfResidence}.
    
    Financial Summary:
    - Total Gross Income: ${formatCurrency(taxSummaryData.totalGrossIncome)}
    - Net Business Profit (Schedule C): ${formatCurrency(taxSummaryData.netBusinessProfit)}
    - Total Approved Deductions: ${formatCurrency(taxSummaryData.approvedDeductions.reduce((sum, d) => sum + d.amount, 0))}
    - AGI: ${formatCurrency(taxSummaryData.agi)}
    - Estimated Total Tax Liability: ${formatCurrency(taxSummaryData.totalEstimatedTaxLiability)}
    - Estimated Effective Tax Rate: ${taxSummaryData.effectiveTaxRate.toFixed(2)}%
    - Net Federal Tax Due (after YTD payments): ${formatCurrency(taxSummaryData.netFederalTaxDue)}
    - Net State Tax Due (after YTD payments): ${formatCurrency(taxSummaryData.netStateTaxDue)}
    
    Top Deductions identified/approved:
    ${topDeductions.map(d => `- ${d.category}: ${formatCurrency(d.amount)}`).join('\n')}
    
    Audit Risk Factors:
    ${auditFactors.map(f => `- ${f.name} (Risk: ${f.level}): ${f.explanation}`).join('\n')}
    
    Focus on key numbers, actionable advice for reducing liability or improving compliance, and specific tips based on audit risks. Keep it professional and encouraging.`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: { responseMimeType: "text/plain" }
        });
        return response.text;
    } catch (err) {
        console.error("AI Summary generation failed:", err);
        return "Failed to generate AI summary. Please check your API key and network connection.";
    }
};

/**
 * Simulates AI-powered receipt processing.
 * @param {string} receiptUrl - URL of the receipt image/PDF.
 * @returns {Promise<Partial<Receipt>>} Extracted data from the receipt.
 */
export const processReceiptWithAI = async (receiptUrl: string): Promise<Partial<Receipt>> => {
    // In a real application, this would involve sending the image to an OCR + NLU API.
    // Here, we'll simulate a delayed response with structured data.
    console.log(`Simulating AI processing for receipt: ${receiptUrl}`);
    return new Promise((resolve) => {
        setTimeout(() => {
            const mockData = MOCK_RECEIPTS.find(r => r.url === receiptUrl) || {
                fileName: receiptUrl.split('/').pop() || 'unknown_receipt.pdf',
                url: receiptUrl,
                extractedText: 'Simulated text extraction: generic business expense, $100.00, date: 2024-03-01.',
                aiSummary: 'AI identified as a general business expense.',
                amount: 100.00,
                transactionDate: new Date(TAX_YEAR, 2, 1),
            };
            resolve({
                ...mockData,
                id: generateUniqueId(),
                uploadDate: new Date(),
                linkedDeductionIds: [],
            });
        }, 2000); // Simulate network delay
    });
};

/**
 * Function to fetch or generate a mock W-2 form for a given year.
 * In a real application, this would connect to payroll systems or user uploads.
 * @param {string} userId - The user ID.
 * @param {number} taxYear - The tax year for the W-2.
 * @returns {Promise<any>} Mock W-2 data.
 */
export const fetchMockW2Data = async (userId: string, taxYear: number): Promise<any> => {
    console.log(`Fetching mock W-2 data for user ${userId}, year ${taxYear}`);
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                taxYear,
                employerName: "Acme Corp",
                employerEIN: "XX-XXXXXXX",
                employeeSSN: "XXX-XX-XXXX",
                wagesTipsOtherCompensation: 75000,
                federalIncomeTaxWithheld: 8000,
                socialSecurityWages: 75000,
                socialSecurityTaxWithheld: 4650,
                medicareWages: 75000,
                medicareTaxWithheld: 1087.50,
                stateWage: 75000,
                stateTaxWithheld: 2500,
                stateAbbreviation: "CA",
                localWage: 0,
                localTaxWithheld: 0
            });
        }, 1500);
    });
};

/**
 * Function to fetch or generate a mock 1099-NEC form for a given year.
 * @param {string} userId - The user ID.
 * @param {number} taxYear - The tax year for the 1099-NEC.
 * @param {string} payerName - The payer's name.
 * @returns {Promise<any>} Mock 1099-NEC data.
 */
export const fetchMock1099NECData = async (userId: string, taxYear: number, payerName: string): Promise<any> => {
    console.log(`Fetching mock 1099-NEC data for user ${userId}, year ${taxYear}, payer ${payerName}`);
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                taxYear,
                payerName,
                payerEIN: "YY-YYYYYYY",
                recipientSSN: "XXX-XX-XXXX",
                nonemployeeCompensation: 25000 + Math.floor(Math.random() * 5000), // Vary compensation
                federalIncomeTaxWithheld: 0,
                stateIncomeTaxWithheld: 0,
                stateAbbreviation: "CA",
                payerStreet: "123 Business Rd",
                payerCityStateZip: "Biztown, CA 90210"
            });
        }, 1500);
    });
};

// --- MAIN TAX CENTER VIEW COMPONENT (Approximately 4000 lines) ---

export const TaxCenterView: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("TaxCenterView must be within a DataProvider");

    const { transactions: globalTransactions, userId } = context;

    // --- State Management ---
    const [deductions, setDeductions] = useState<Deduction[]>([]);
    const [isLoadingAI, setIsLoadingAI] = useState(false);
    const [taxProfile, setTaxProfile] = useState<TaxProfile>(() => ({
        userId: userId || 'mock-user-123',
        taxYear: TAX_YEAR,
        filingStatus: FilingStatus.Single,
        dependents: 0,
        stateOfResidence: 'CA',
        hasHealthInsurance: true,
        isSelfEmployed: true,
        estimatedAGI: 0,
        federalTaxWithheldYTD: 0,
        stateTaxWithheldYTD: 0,
        federalEstimatedTaxPaid: 0,
        stateEstimatedTaxPaid: 0,
        priorYearAGI: 70000, // Mock for audit risk
        isHomeowner: false,
        hasInvestments: false,
        hasRentalIncome: false,
        isStudent: false,
    }));
    const [incomeSources, setIncomeSources] = useState<IncomeSource[]>([]);
    const [estimatedPayments, setEstimatedPayments] = useState<EstimatedPayment[]>([]);
    const [auditFactors, setAuditFactors] = useState<AuditFactor[]>([]);
    const [aiSummary, setAiSummary] = useState<string>('');
    const [taxAlerts, setTaxAlerts] = useState<TaxAlert[]>(MOCK_ALERTS);
    const [receipts, setReceipts] = useState<Receipt[]>(MOCK_RECEIPTS);

    // UI State for tabs/sections
    const [activeTab, setActiveTab] = useState<'overview' | 'deductions' | 'income' | 'estimated' | 'audit' | 'planning' | 'alerts' | 'receipts'>('overview');
    const [showAddDeductionModal, setShowAddDeductionModal] = useState(false);
    const [newDeduction, setNewDeduction] = useState<Partial<Deduction>>({ category: DeductionCategory.OtherBusinessExpense, isApproved: true, dateAdded: new Date() });
    const [isProcessingReceipt, setIsProcessingReceipt] = useState(false);
    const [showExplanationModal, setShowExplanationModal] = useState(false);
    const [currentTaxConcept, setCurrentTaxConcept] = useState<string>('');
    const [explanationLoading, setExplanationLoading] = useState(false);
    const [taxConceptExplanation, setTaxConceptExplanation] = useState<TaxConceptExplanation | null>(null);

    // AI instance
    const ai = useMemo(() => new GoogleGenAI({ apiKey: process.env.NEXT_PUBLIC_API_KEY as string }), []);

    // --- Derived State & Memoized Calculations ---
    const transactions: Transaction[] = useMemo(() => {
        // Map global transactions to our internal Transaction type
        return globalTransactions.map(t => ({
            id: t.id.toString(), // Assuming t.id can be number or string
            description: t.description,
            amount: t.amount,
            date: new Date(t.date), // Ensure date is Date object
            type: t.amount > 0 ? 'income' : 'expense', // Simple classification
            category: t.category,
            merchant: t.merchant,
            currency: 'USD',
            rawDetails: JSON.stringify(t), // Store raw details for AI
        }));
    }, [globalTransactions]);

    const approvedDeductions = useMemo(() => deductions.filter(d => d.isApproved), [deductions]);

    // Aggregate income from transactions for initial income sources
    useEffect(() => {
        const incomeMap = new Map<string, IncomeSource>();
        transactions.forEach(t => {
            if (t.type === 'income') {
                const sourceName = t.merchant || t.description.split(' ')[0] || 'Uncategorized Income';
                if (incomeMap.has(sourceName)) {
                    const existing = incomeMap.get(sourceName)!;
                    incomeMap.set(sourceName, { ...existing, amountYTD: existing.amountYTD + t.amount });
                } else {
                    // Try to guess type, default to 1099-NEC for freelancers
                    const incomeType = sourceName.toLowerCase().includes('salary') ? IncomeType.W2 : IncomeType.NEC1099;
                    incomeMap.set(sourceName, {
                        id: generateUniqueId(),
                        name: sourceName,
                        type: incomeType,
                        amountYTD: t.amount,
                    });
                }
            }
        });
        setIncomeSources(Array.from(incomeMap.values()));
    }, [transactions]);

    // Re-calculate full tax liability whenever key data changes
    const fullTaxSummary = useMemo(() => {
        return calculateFullTaxLiability(incomeSources, approvedDeductions, taxProfile);
    }, [incomeSources, approvedDeductions, taxProfile]);

    const {
        totalGrossIncome,
        netBusinessProfit,
        totalEstimatedTaxLiability,
        effectiveTaxRate,
        netFederalTaxDue,
        netStateTaxDue,
        selfEmploymentTax,
        agi,
        federalTaxLiability,
        stateTaxLiability,
        applicableDeduction,
        taxableIncome,
        scheduleCIncome,
        scheduleCExpenses,
    } = fullTaxSummary;

    // Update estimated payments when liability changes
    useEffect(() => {
        setEstimatedPayments(
            calculateEstimatedQuarterlyPayments(
                totalEstimatedTaxLiability,
                taxProfile.federalTaxWithheldYTD || 0,
                taxProfile.stateTaxWithheldYTD || 0,
                taxProfile.federalEstimatedTaxPaid || 0,
                taxProfile.stateEstimatedTaxPaid || 0
            )
        );
    }, [totalEstimatedTaxLiability, taxProfile]);


    // --- AI Integration Functions ---

    // Original AI deduction finder
    const findDeductions = useCallback(async () => {
        setIsLoadingAI(true);
        // Clear only AI-recommended deductions to allow user-added ones to persist
        setDeductions(prev => prev.filter(d => !d.isAIRecommended));
        try {
            const prompt = `You are an expert tax AI. Analyze this list of transactions and identify potential tax deductions for a freelance consultant operating in ${taxProfile.stateOfResidence}. For each, provide the transaction description, amount, a potential deduction category from the list [${Object.values(DeductionCategory).join(', ')}], and a brief justification. Focus on identifying legitimate business expenses. If a transaction could be split (e.g., partial personal use), recommend the business portion. Transactions:\n${transactions.map(t => `${t.id}: ${t.description} - $${t.amount} on ${t.date.toDateString()} (Category: ${t.category || 'N/A'}, Merchant: ${t.merchant || 'N/A'}, Type: ${t.type})`).join('\n')}`;
            const schema = { type: Type.OBJECT, properties: { deductions: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { transactionId: { type: Type.STRING }, description: { type: Type.STRING }, amount: { type: Type.NUMBER }, category: { type: Type.STRING, enum: Object.values(DeductionCategory) }, justification: { type: Type.STRING } } } } } };
            
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: [{ text: prompt }],
                config: { responseMimeType: "application/json", responseSchema: schema }
            });

            const aiDetectedDeductions = JSON.parse(response.text).deductions.map((d: any) => ({
                id: generateUniqueId(),
                description: d.description,
                amount: d.amount,
                category: d.category,
                justification: d.justification,
                transactionIds: [d.transactionId],
                isAIRecommended: true,
                isApproved: false, // User needs to approve
                dateAdded: new Date(),
            }));
            setDeductions(prev => [...prev, ...aiDetectedDeductions]);
        } catch (err) {
            console.error("AI Deduction scan failed:", err);
            // Fallback to simpler error handling
            setDeductions(prev => [...prev, {
                id: generateUniqueId(),
                description: "AI scan failed to identify deductions.",
                amount: 0,
                category: DeductionCategory.OtherBusinessExpense,
                justification: "Error during AI processing. Please try again or manually add deductions.",
                isAIRecommended: true,
                isApproved: false,
                dateAdded: new Date(),
            }]);
        } finally {
            setIsLoadingAI(false);
        }
    }, [transactions, taxProfile, ai]);

    // AI Audit Risk Assessment
    const runAIAuditRiskAssessment = useCallback(async () => {
        setIsLoadingAI(true);
        try {
            const homeOffice = approvedDeductions.filter(d => d.category === DeductionCategory.HomeOffice).reduce((sum, d) => sum + d.amount, 0);
            const mealsEntertainment = approvedDeductions.filter(d => d.category === DeductionCategory.ClientEntertainment).reduce((sum, d) => sum + d.amount, 0); // Simplified for this category
            const businessTravel = approvedDeductions.filter(d => d.category === DeductionCategory.BusinessTravel).reduce((sum, d) => sum + d.amount, 0);

            const factors = assessAuditRiskAI(
                totalGrossIncome,
                approvedDeductions.reduce((sum, d) => sum + d.amount, 0),
                homeOffice,
                mealsEntertainment,
                businessTravel,
                taxProfile.priorYearAGI,
                taxProfile.hasInvestments // Simplified proxy for crypto/investments
            );
            setAuditFactors(factors);

            const aiPromptForSummary = `Based on the following audit risk factors, provide an executive summary of the user's audit risk and a few top recommendations.
            ${factors.map(f => `- ${f.name} (Risk: ${f.level}, Score: ${f.score}): ${f.explanation}`).join('\n')}
            Overall audit risk: ${factors.length > 0 ? factors[0].level : AuditRiskLevel.Low}.`;

            const summaryResponse = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: [{ text: aiPromptForSummary }],
                config: { responseMimeType: "text/plain" }
            });
            setAiSummary(summaryResponse.text);

        } catch (err) {
            console.error("AI Audit Risk Assessment failed:", err);
            setAuditFactors([{
                name: 'AI Assessment Failed',
                score: 50,
                level: AuditRiskLevel.Medium,
                explanation: 'Failed to run AI audit assessment. Please try again.',
                recommendations: []
            }]);
            setAiSummary('Failed to generate AI audit risk summary.');
        } finally {
            setIsLoadingAI(false);
        }
    }, [approvedDeductions, totalGrossIncome, taxProfile, ai]);


    const generateAISummaryAndInsights = useCallback(async () => {
        if (!totalGrossIncome || !approvedDeductions.length) return; // Prevent unnecessary calls
        setIsLoadingAI(true);
        try {
            const topDeds = [...approvedDeductions].sort((a, b) => b.amount - a.amount).slice(0, 5);
            const summary = await getAISummaryAndInsights(
                { ...fullTaxSummary, taxProfile, approvedDeductions }, // Pass all relevant data
                topDeds,
                auditFactors
            );
            setAiSummary(summary);
        } catch (err) {
            console.error("Error generating AI summary:", err);
            setAiSummary("Could not generate AI summary at this time.");
        } finally {
            setIsLoadingAI(false);
        }
    }, [fullTaxSummary, approvedDeductions, taxProfile, auditFactors, totalGrossIncome, ai]);

    const getTaxConceptExplanation = useCallback(async (concept: string) => {
        setExplanationLoading(true);
        setTaxConceptExplanation(null);
        try {
            const prompt = `Explain the tax concept "${concept}" in simple terms for a non-expert, self-employed individual. Include a brief example if possible. Also suggest 3-5 related tax concepts. Respond in JSON format with properties: concept (string), explanation (string), example (string, optional), relatedConcepts (string[]), keywords (string[]).`;
            const schema = {
                type: Type.OBJECT,
                properties: {
                    concept: { type: Type.STRING },
                    explanation: { type: Type.STRING },
                    example: { type: Type.STRING, optional: true },
                    relatedConcepts: { type: Type.ARRAY, items: { type: Type.STRING } },
                    keywords: { type: Type.ARRAY, items: { type: Type.STRING } },
                }
            };

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: [{ text: prompt }],
                config: { responseMimeType: "application/json", responseSchema: schema }
            });
            setTaxConceptExplanation(JSON.parse(response.text));
        } catch (err) {
            console.error(`AI explanation for '${concept}' failed:`, err);
            setTaxConceptExplanation({
                concept,
                explanation: `Failed to retrieve explanation for "${concept}". Please try again.`,
                relatedConcepts: [],
                keywords: []
            });
        } finally {
            setExplanationLoading(false);
        }
    }, [ai]);

    useEffect(() => {
        if (activeTab === 'audit' && auditFactors.length === 0 && !isLoadingAI) {
            runAIAuditRiskAssessment();
        }
        if (activeTab === 'overview' && aiSummary === '' && !isLoadingAI && totalGrossIncome > 0) {
            generateAISummaryAndInsights();
        }
    }, [activeTab, auditFactors.length, isLoadingAI, runAIAuditRiskAssessment, generateAISummaryAndInsights, aiSummary, totalGrossIncome]);


    // --- Deduction Management Handlers ---
    const handleApproveDeduction = (id: string, approved: boolean) => {
        setDeductions(prev => prev.map(d => d.id === id ? { ...d, isApproved: approved } : d));
    };

    const handleAddDeduction = () => {
        if (newDeduction.description && newDeduction.amount && newDeduction.category) {
            setDeductions(prev => [...prev, {
                ...newDeduction as Deduction, // Type assertion after validation
                id: generateUniqueId(),
                isApproved: true,
                isAIRecommended: false,
                dateAdded: new Date(),
            }]);
            setNewDeduction({ category: DeductionCategory.OtherBusinessExpense, isApproved: true, dateAdded: new Date() });
            setShowAddDeductionModal(false);
        } else {
            alert('Please fill all required fields for the new deduction.');
        }
    };

    const handleReceiptUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            setIsProcessingReceipt(true);
            try {
                // Simulate uploading to a storage service and getting a URL
                const mockUrl = `/receipts/${file.name}`; // In real app, this would be a real S3/GCS URL
                const processedReceipt = await processReceiptWithAI(mockUrl);
                setReceipts(prev => [...prev, {
                    ...processedReceipt as Receipt,
                    id: generateUniqueId(),
                    fileName: file.name,
                    url: mockUrl,
                    uploadDate: new Date(),
                }]);
                alert('Receipt uploaded and processed successfully!');
            } catch (error) {
                console.error('Error uploading/processing receipt:', error);
                alert('Failed to upload and process receipt. Please try again.');
            } finally {
                setIsProcessingReceipt(false);
                event.target.value = ''; // Clear file input
            }
        }
    };

    const handleViewConceptExplanation = (concept: string) => {
        setCurrentTaxConcept(concept);
        setShowExplanationModal(true);
        getTaxConceptExplanation(concept);
    };


    // --- Tax Profile Handlers ---
    const handleProfileChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        setTaxProfile(prev => ({
            ...prev,
            [name]: type === 'number' ? parseFloat(value) : value,
        }));
    };

    const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, checked } = e.target;
        setTaxProfile(prev => ({
            ...prev,
            [name]: checked,
        }));
    };

    // --- Render JSX (Approximately 5000 lines, heavily nested and detailed) ---
    return (
        <div className="space-y-6 p-4 md:p-8 bg-gray-950 min-h-screen text-gray-100">
            <h2 className="text-4xl font-extrabold text-white tracking-tight mb-6 flex items-center">
                <svg className="w-10 h-10 mr-3 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                AI Tax Center <span className="text-xl ml-3 text-gray-400">({TAX_YEAR} Tax Year)</span>
            </h2>

            {/* Navigation Tabs */}
            <div className="flex flex-wrap gap-2 mb-6 border-b border-gray-700 pb-2">
                <button onClick={() => setActiveTab('overview')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'overview' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Overview</button>
                <button onClick={() => setActiveTab('deductions')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'deductions' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Deductions</button>
                <button onClick={() => setActiveTab('income')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'income' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Income & Profile</button>
                <button onClick={() => setActiveTab('estimated')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'estimated' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Estimated Payments</button>
                <button onClick={() => setActiveTab('audit')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'audit' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Audit Risk</button>
                <button onClick={() => setActiveTab('planning')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'planning' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Tax Planning</button>
                <button onClick={() => setActiveTab('receipts')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'receipts' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Receipts</button>
                <button onClick={() => setActiveTab('alerts')} className={`px-4 py-2 text-sm rounded-lg transition-colors ${activeTab === 'alerts' ? 'bg-cyan-600 text-white' : 'bg-gray-800 hover:bg-gray-700 text-gray-300'}`}>Alerts {taxAlerts.filter(a => !a.isRead).length > 0 && <span className="ml-1 px-2 py-0.5 bg-red-500 text-white text-xs rounded-full">{taxAlerts.filter(a => !a.isRead).length}</span>}</button>
            </div>

            {/* Overall Summary Cards */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <Card className="text-center bg-gradient-to-br from-purple-800 to-indigo-800">
                    <p className="text-4xl font-extrabold text-white">{formatCurrency(totalEstimatedTaxLiability)}</p>
                    <p className="text-sm text-gray-200 mt-1">Estimated Liability</p>
                    {netFederalTaxDue > 0 && <p className="text-xs text-red-300 mt-0.5">Federal Due: {formatCurrency(netFederalTaxDue)}</p>}
                    {netStateTaxDue > 0 && <p className="text-xs text-red-300">State Due: {formatCurrency(netStateTaxDue)}</p>}
                    {netFederalTaxDue < 0 && <p className="text-xs text-green-300 mt-0.5">Federal Refund: {formatCurrency(Math.abs(netFederalTaxDue))}</p>}
                    {netStateTaxDue < 0 && <p className="text-xs text-green-300">State Refund: {formatCurrency(Math.abs(netStateTaxDue))}</p>}
                </Card>
                <Card className="text-center bg-gradient-to-br from-green-700 to-emerald-700">
                    <p className="text-4xl font-extrabold text-white">{formatCurrency(approvedDeductions.reduce((sum, d) => sum + d.amount, 0))}</p>
                    <p className="text-sm text-gray-200 mt-1">Approved Deductions</p>
                    <p className="text-xs text-gray-300 mt-0.5">Saving approx. {formatCurrency(approvedDeductions.reduce((sum, d) => sum + d.amount, 0) * (effectiveTaxRate / 100))}</p>
                </Card>
                <Card className="text-center bg-gradient-to-br from-blue-700 to-cyan-700">
                    <p className="text-4xl font-extrabold text-white">{effectiveTaxRate.toFixed(2)}%</p>
                    <p className="text-sm text-gray-200 mt-1">Effective Tax Rate</p>
                    <p className="text-xs text-gray-300 mt-0.5">Taxable Income: {formatCurrency(taxableIncome)}</p>
                </Card>
                <Card className="text-center bg-gradient-to-br from-yellow-700 to-orange-700">
                    <p className="text-4xl font-extrabold text-yellow-300">{auditFactors.length > 0 ? auditFactors[0].level : AuditRiskLevel.Low}</p>
                    <p className="text-sm text-gray-200 mt-1">AI Audit Risk</p>
                    <p className="text-xs text-gray-300 mt-0.5">Score: {auditFactors.length > 0 ? auditFactors.reduce((sum, f) => sum + f.score, 0) / auditFactors.length : 10}/100</p>
                </Card>
            </div>

            {/* Conditional Tab Content */}
            {activeTab === 'overview' && (
                <div className="space-y-6">
                    <Card title="AI Tax Situation Summary">
                        {isLoadingAI && aiSummary === '' ? (
                            <div className="flex items-center justify-center py-8">
                                <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span className="text-gray-400">Generating personalized insights...</span>
                            </div>
                        ) : (
                            <div className="prose prose-invert max-w-none text-gray-300">
                                <p>{aiSummary || "Click 'Generate AI Summary' below for personalized tax insights."}</p>
                            </div>
                        )}
                        <div className="text-center mt-6">
                            <button onClick={generateAISummaryAndInsights} disabled={isLoadingAI || totalGrossIncome === 0} className="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-lg disabled:opacity-50">
                                {isLoadingAI ? 'Generating Summary...' : 'Generate AI Summary & Insights'}
                            </button>
                        </div>
                    </Card>

                    <Card title="Key Financial Metrics">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm text-gray-300">
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Total Gross Income:</strong> <span className="float-right">{formatCurrency(totalGrossIncome)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Net Business Profit:</strong> <span className="float-right">{formatCurrency(netBusinessProfit)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Adjusted Gross Income (AGI):</strong> <span className="float-right">{formatCurrency(agi)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Applicable Deduction:</strong> <span className="float-right">{formatCurrency(applicableDeduction)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Taxable Income:</strong> <span className="float-right">{formatCurrency(taxableIncome)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Self-Employment Tax:</strong> <span className="float-right">{formatCurrency(selfEmploymentTax)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Federal Tax Liability:</strong> <span className="float-right">{formatCurrency(federalTaxLiability)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>State Tax Liability:</strong> <span className="float-right">{formatCurrency(stateTaxLiability)}</span></div>
                            <div className="p-3 bg-gray-800 rounded-lg"><strong>Federal Tax Withheld YTD:</strong> <span className="float-right">{formatCurrency(taxProfile.federalTaxWithheldYTD || 0)}</span></div>
                        </div>
                    </Card>
                </div>
            )}

            {activeTab === 'deductions' && (
                <Card title="AI Deduction Finder & Management">
                    <div className="text-center mb-6">
                        <button onClick={findDeductions} disabled={isLoadingAI} className="px-6 py-2 bg-cyan-600 hover:bg-cyan-700 text-white font-semibold rounded-lg disabled:opacity-50 transition-colors mr-3">
                            {isLoadingAI ? 'Scanning Transactions...' : 'Run AI Deduction Scan'}
                        </button>
                        <button onClick={() => setShowAddDeductionModal(true)} className="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg transition-colors">
                            Add Manual Deduction
                        </button>
                    </div>

                    {isLoadingAI && <p className="text-center text-gray-500 mt-4">AI is analyzing your transactions for potential deductions. This may take a moment...</p>}

                    {deductions.length > 0 && (
                        <div className="mt-6 space-y-3 max-h-96 overflow-y-auto pr-2 custom-scrollbar">
                            {deductions.map((d, i) => (
                                <div key={d.id} className={`p-4 rounded-lg border ${d.isApproved ? 'bg-gray-800 border-green-600/50' : (d.isAIRecommended ? 'bg-gray-900/50 border-yellow-600/50' : 'bg-gray-800 border-gray-600/50')} shadow-lg transition-all`}>
                                    <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center">
                                        <div className="flex-1">
                                            <h4 className="font-semibold text-white text-lg">{d.description}</h4>
                                            <p className="text-sm text-gray-400 mt-1">{formatCurrency(d.amount)}</p>
                                        </div>
                                        <div className="mt-2 sm:mt-0 flex items-center space-x-3">
                                            <span className={`text-xs px-2 py-0.5 rounded-full ${d.isApproved ? 'bg-green-500/20 text-green-200' : 'bg-yellow-500/20 text-yellow-200'}`}>{d.category}</span>
                                            {d.isAIRecommended && <span className="text-xs bg-cyan-500/20 text-cyan-200 px-2 py-0.5 rounded-full">AI Recommended</span>}
                                            {!d.isApproved ? (
                                                <button onClick={() => handleApproveDeduction(d.id, true)} className="text-green-400 hover:text-green-300 text-sm font-medium">Approve</button>
                                            ) : (
                                                <button onClick={() => handleApproveDeduction(d.id, false)} className="text-red-400 hover:text-red-300 text-sm font-medium">Unapprove</button>
                                            )}
                                        </div>
                                    </div>
                                    <p className="text-sm text-gray-400 italic mt-2">"{d.justification}"</p>
                                    {d.receiptUrl && (
                                        <div className="mt-2 text-xs text-gray-500 flex items-center">
                                            <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13.5"></path></svg>
                                            <a href={d.receiptUrl} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">View Receipt</a>
                                        </div>
                                    )}
                                    <div className="mt-2 text-right">
                                        <button onClick={() => alert('Editing deduction ' + d.id)} className="text-gray-500 hover:text-gray-300 text-sm px-2">Edit</button>
                                        <button onClick={() => setDeductions(prev => prev.filter(item => item.id !== d.id))} className="text-red-500 hover:text-red-300 text-sm px-2">Delete</button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                    {!isLoadingAI && deductions.length === 0 && <p className="text-center text-gray-500 mt-4">Run the scan or add manually to find potential tax deductions.</p>}
                </Card>
            )}

            {activeTab === 'income' && (
                <div className="space-y-6">
                    <Card title="Tax Profile & Settings">
                        <form className="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-300">
                            <div>
                                <label htmlFor="filingStatus" className="block text-sm font-medium text-gray-400">Filing Status</label>
                                <select id="filingStatus" name="filingStatus" value={taxProfile.filingStatus} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white">
                                    {FILING_STATUS_OPTIONS.map(option => (
                                        <option key={option.value} value={option.value}>{option.label}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label htmlFor="dependents" className="block text-sm font-medium text-gray-400">Dependents</label>
                                <input type="number" id="dependents" name="dependents" value={taxProfile.dependents} onChange={handleProfileChange} min="0" className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                            </div>
                            <div>
                                <label htmlFor="stateOfResidence" className="block text-sm font-medium text-gray-400">State of Residence</label>
                                <input type="text" id="stateOfResidence" name="stateOfResidence" value={taxProfile.stateOfResidence} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                            </div>
                            <div>
                                <label htmlFor="priorYearAGI" className="block text-sm font-medium text-gray-400">Prior Year AGI</label>
                                <input type="number" id="priorYearAGI" name="priorYearAGI" value={taxProfile.priorYearAGI || 0} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                            </div>
                            <div className="col-span-1 md:col-span-2 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="isSelfEmployed" checked={taxProfile.isSelfEmployed} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Self-Employed</span>
                                </label>
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="hasHealthInsurance" checked={taxProfile.hasHealthInsurance} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Has Health Insurance</span>
                                </label>
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="isHomeowner" checked={taxProfile.isHomeowner} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Homeowner</span>
                                </label>
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="hasInvestments" checked={taxProfile.hasInvestments} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Has Investments (e.g., Crypto)</span>
                                </label>
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="hasRentalIncome" checked={taxProfile.hasRentalIncome} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Has Rental Income</span>
                                </label>
                                <label className="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" name="isStudent" checked={taxProfile.isStudent} onChange={handleCheckboxChange} className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded" />
                                    <span className="ml-2">Is Student</span>
                                </label>
                            </div>
                        </form>
                    </Card>

                    <Card title="Income Sources (YTD)">
                        <div className="text-right mb-4">
                            <button onClick={() => alert('Add new income source')} className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-semibold rounded-lg">Add Income Source</button>
                        </div>
                        {incomeSources.length === 0 ? (
                            <p className="text-center text-gray-500">No income sources found. Transactions will automatically populate some.</p>
                        ) : (
                            <div className="overflow-x-auto">
                                <table className="min-w-full divide-y divide-gray-700 text-gray-300">
                                    <thead className="bg-gray-800">
                                        <tr>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Source Name</th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Type</th>
                                            <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">Amount YTD</th>
                                            <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-gray-900 divide-y divide-gray-800">
                                        {incomeSources.map(source => (
                                            <tr key={source.id} className="hover:bg-gray-800">
                                                <td className="px-6 py-4 whitespace-nowrap">{source.name}</td>
                                                <td className="px-6 py-4 whitespace-nowrap">{source.type}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-right">{formatCurrency(source.amountYTD)}</td>
                                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                    <button onClick={() => alert('Edit income source ' + source.id)} className="text-indigo-400 hover:text-indigo-300 mr-3">Edit</button>
                                                    <button onClick={() => setIncomeSources(prev => prev.filter(s => s.id !== source.id))} className="text-red-400 hover:text-red-300">Delete</button>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                    <tfoot>
                                        <tr className="bg-gray-800 font-bold text-white">
                                            <td colSpan={2} className="px-6 py-3">Total Gross Income</td>
                                            <td className="px-6 py-3 text-right">{formatCurrency(totalGrossIncome)}</td>
                                            <td></td>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                        )}
                    </Card>

                    <Card title="W-2 and 1099 Forms (Simulated)">
                        <p className="text-gray-400 mb-4">Manually enter details or connect with payroll providers in a real application.</p>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="bg-gray-800 p-4 rounded-lg">
                                <h4 className="font-semibold text-white mb-2">Federal & State Withholding YTD</h4>
                                <label htmlFor="federalTaxWithheldYTD" className="block text-sm font-medium text-gray-400">Federal Tax Withheld YTD</label>
                                <input type="number" id="federalTaxWithheldYTD" name="federalTaxWithheldYTD" value={taxProfile.federalTaxWithheldYTD || 0} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                                <label htmlFor="stateTaxWithheldYTD" className="block text-sm font-medium text-gray-400 mt-3">State Tax Withheld YTD</label>
                                <input type="number" id="stateTaxWithheldYTD" name="stateTaxWithheldYTD" value={taxProfile.stateTaxWithheldYTD || 0} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                            </div>
                            <div className="bg-gray-800 p-4 rounded-lg">
                                <h4 className="font-semibold text-white mb-2">Estimated Tax Payments Made YTD</h4>
                                <label htmlFor="federalEstimatedTaxPaid" className="block text-sm font-medium text-gray-400">Federal Estimated Tax Paid</label>
                                <input type="number" id="federalEstimatedTaxPaid" name="federalEstimatedTaxPaid" value={taxProfile.federalEstimatedTaxPaid || 0} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                                <label htmlFor="stateEstimatedTaxPaid" className="block text-sm font-medium text-gray-400 mt-3">State Estimated Tax Paid</label>
                                <input type="number" id="stateEstimatedTaxPaid" name="stateEstimatedTaxPaid" value={taxProfile.stateEstimatedTaxPaid || 0} onChange={handleProfileChange} className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />
                            </div>
                        </div>
                    </Card>
                </div>
            )}

            {activeTab === 'estimated' && (
                <Card title="Estimated Quarterly Tax Payments (Form 1040-ES)">
                    <p className="text-gray-400 mb-4">Below are your calculated estimated tax payments for {TAX_YEAR}, based on your current income and deductions. </p>
                    <div className="overflow-x-auto mb-6">
                        <table className="min-w-full divide-y divide-gray-700 text-gray-300">
                            <thead className="bg-gray-800">
                                <tr>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Quarter</th>
                                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Due Date</th>
                                    <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">Federal Amount</th>
                                    <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">State Amount</th>
                                    <th scope="col" className="px-6 py-3 text-center text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                    <th scope="col" className="px-6 py-3 text-center text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody className="bg-gray-900 divide-y divide-gray-800">
                                {estimatedPayments.map(payment => (
                                    <tr key={payment.id} className={`hover:bg-gray-800 ${!payment.isPaid && payment.dueDate < new Date() ? 'bg-red-900/20' : ''}`}>
                                        <td className="px-6 py-4 whitespace-nowrap">{payment.quarter}</td>
                                        <td className="px-6 py-4 whitespace-nowrap">{payment.dueDate.toLocaleDateString()}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-right">{formatCurrency(payment.amountFederal)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-right">{formatCurrency(payment.amountState)}</td>
                                        <td className="px-6 py-4 whitespace-nowrap text-center">
                                            <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${payment.isPaid ? 'bg-green-500/20 text-green-200' : (payment.dueDate < new Date() ? 'bg-red-500/20 text-red-200' : 'bg-yellow-500/20 text-yellow-200')}`}>
                                                {payment.isPaid ? 'Paid' : (payment.dueDate < new Date() ? 'Overdue' : 'Upcoming')}
                                            </span>
                                        </td>
                                        <td className="px-6 py-4 whitespace-nowrap text-center text-sm font-medium">
                                            {!payment.isPaid && <button onClick={() => alert(`Marking Q${payment.quarter} as paid.`)} className="text-cyan-400 hover:text-cyan-300">Mark Paid</button>}
                                            {payment.dueDate > new Date() && <button onClick={() => alert(`Reviewing Q${payment.quarter} details.`)} className="text-gray-500 hover:text-gray-300 ml-3">Review</button>}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot>
                                <tr className="bg-gray-800 font-bold text-white">
                                    <td colSpan={2} className="px-6 py-3">Total Projected Estimated Payments</td>
                                    <td className="px-6 py-3 text-right">{formatCurrency(estimatedPayments.reduce((sum, p) => sum + p.amountFederal, 0))}</td>
                                    <td className="px-6 py-3 text-right">{formatCurrency(estimatedPayments.reduce((sum, p) => sum + p.amountState, 0))}</td>
                                    <td colSpan={2}></td>
                                </tr>
                                <tr className="bg-gray-800 font-bold text-white">
                                    <td colSpan={2} className="px-6 py-3">Net Estimated Tax Due for Year</td>
                                    <td className="px-6 py-3 text-right">{formatCurrency(Math.max(0, netFederalTaxDue))}</td>
                                    <td className="px-6 py-3 text-right">{formatCurrency(Math.max(0, netStateTaxDue))}</td>
                                    <td colSpan={2}></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <p className="text-gray-500 text-sm italic">
                        Note: This is an estimate. Actual payments should consider annualized income method, prior year tax, and other credits for accuracy. Consult a tax professional for complex situations.
                        <button onClick={() => handleViewConceptExplanation('Estimated Taxes')} className="ml-2 text-cyan-400 hover:underline text-xs">Learn more about Estimated Taxes</button>
                    </p>
                </Card>
            )}

            {activeTab === 'audit' && (
                <Card title="AI Audit Risk Assessment">
                    <div className="text-center mb-6">
                        <button onClick={runAIAuditRiskAssessment} disabled={isLoadingAI} className="px-6 py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-semibold rounded-lg disabled:opacity-50 transition-colors">
                            {isLoadingAI ? 'Analyzing Risk Factors...' : 'Run AI Audit Risk Assessment'}
                        </button>
                    </div>

                    {isLoadingAI && <p className="text-center text-gray-500 mt-4">AI is evaluating your tax data for potential audit flags...</p>}

                    {auditFactors.length > 0 && (
                        <div className="mt-6 space-y-4">
                            <h3 className="text-xl font-semibold text-white">Overall Audit Risk: <span className={`font-bold ${auditFactors[0].level === AuditRiskLevel.VeryHigh ? 'text-red-400' : auditFactors[0].level === AuditRiskLevel.High ? 'text-orange-400' : auditFactors[0].level === AuditRiskLevel.Medium ? 'text-yellow-400' : 'text-green-400'}`}>{auditFactors[0].level}</span></h3>
                            <p className="text-gray-400">{aiSummary}</p>

                            <div className="space-y-3">
                                {auditFactors.map((factor, i) => (
                                    <div key={i} className={`p-4 rounded-lg border ${factor.level === AuditRiskLevel.VeryHigh ? 'bg-red-900/20 border-red-600/50' : factor.level === AuditRiskLevel.High ? 'bg-orange-900/20 border-orange-600/50' : factor.level === AuditRiskLevel.Medium ? 'bg-yellow-900/20 border-yellow-600/50' : 'bg-gray-800 border-gray-600/50'}`}>
                                        <div className="flex justify-between items-center mb-1">
                                            <h4 className="font-semibold text-white flex items-center">
                                                {factor.name}
                                                <span className={`ml-2 text-xs px-2 py-0.5 rounded-full ${factor.level === AuditRiskLevel.VeryHigh ? 'bg-red-500/20 text-red-200' : factor.level === AuditRiskLevel.High ? 'bg-orange-500/20 text-orange-200' : factor.level === AuditRiskLevel.Medium ? 'bg-yellow-500/20 text-yellow-200' : 'bg-green-500/20 text-green-200'}`}>
                                                    {factor.level} ({factor.score})
                                                </span>
                                            </h4>
                                            {/* <span className="text-sm text-gray-400">Score: {factor.score}/100</span> */}
                                        </div>
                                        <p className="text-sm text-gray-300">{factor.explanation}</p>
                                        {factor.recommendations.length > 0 && (
                                            <div className="mt-2">
                                                <p className="text-xs font-semibold text-gray-400">Recommendations:</p>
                                                <ul className="list-disc list-inside text-xs text-gray-500 space-y-0.5">
                                                    {factor.recommendations.map((rec, idx) => <li key={idx}>{rec}</li>)}
                                                </ul>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    {!isLoadingAI && auditFactors.length === 0 && <p className="text-center text-gray-500 mt-4">Run the assessment to see potential audit risk factors.</p>}
                </Card>
            )}

            {activeTab === 'planning' && (
                <Card title="Tax Planning & Scenario Modeling (Advanced)">
                    <p className="text-gray-400 mb-6">Explore how different financial decisions might impact your tax liability. This feature allows you to simulate changes to your income, deductions, or life events.</p>

                    <h3 className="text-xl font-semibold text-white mb-4">Current Tax Breakdown (Schedule C Snapshot)</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300 mb-6">
                        <div className="p-3 bg-gray-800 rounded-lg"><strong>Gross Business Income:</strong> <span className="float-right">{formatCurrency(scheduleCIncome)}</span></div>
                        <div className="p-3 bg-gray-800 rounded-lg"><strong>Total Business Expenses:</strong> <span className="float-right">{formatCurrency(scheduleCExpenses)}</span></div>
                        <div className="p-3 bg-gray-800 rounded-lg"><strong>Net Business Profit:</strong> <span className="float-right">{formatCurrency(netBusinessProfit)}</span></div>
                        <div className="p-3 bg-gray-800 rounded-lg"><strong>Self-Employment Tax:</strong> <span className="float-right">{formatCurrency(selfEmploymentTax)}</span></div>
                    </div>

                    <h3 className="text-xl font-semibold text-white mt-8 mb-4">Simulate a Scenario</h3>
                    <div className="bg-gray-800 p-6 rounded-lg space-y-4">
                        <label className="block text-sm font-medium text-gray-400" htmlFor="scenarioName">Scenario Name</label>
                        <input type="text" id="scenarioName" placeholder="e.g., 'Increase 401k contribution by $5k'" className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />

                        <label className="block text-sm font-medium text-gray-400" htmlFor="incomeChange">Change in Annual Income ($)</label>
                        <input type="number" id="incomeChange" placeholder="e.g., 5000 for increase, -2000 for decrease" className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />

                        <label className="block text-sm font-medium text-gray-400" htmlFor="newDeductionAmount">Add Potential Deduction Amount ($)</label>
                        <input type="number" id="newDeductionAmount" placeholder="e.g., 1000 for new professional development" className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" />

                        <label className="block text-sm font-medium text-gray-400" htmlFor="newDeductionCategory">Deduction Category (Optional)</label>
                        <select id="newDeductionCategory" className="mt-1 block w-full bg-gray-900 border-gray-700 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white">
                            <option value="">Select Category</option>
                            {DEDUCTION_CATEGORIES_OPTIONS.map(option => (
                                <option key={option.value} value={option.value}>{option.label}</option>
                            ))}
                        </select>

                        <button onClick={() => alert('Simulating scenario (feature under development)!')} className="px-6 py-2 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-lg disabled:opacity-50 transition-colors">
                            Run Scenario Simulation
                        </button>
                    </div>

                    <div className="mt-8">
                        <h3 className="text-xl font-semibold text-white mb-4">Saved Scenarios (Mock Data)</h3>
                        <div className="space-y-3">
                            <div className="p-4 bg-gray-800 rounded-lg border border-gray-700">
                                <h4 className="font-semibold text-white">Scenario: Max out SEP IRA</h4>
                                <p className="text-sm text-gray-400">Increased retirement contributions by $10,000.</p>
                                <p className="text-lg font-bold text-green-400 mt-2">Estimated Tax Impact: -$2,500 (Savings)</p>
                                <button onClick={() => alert('View Scenario Details')} className="text-cyan-400 text-sm mt-1 hover:underline">View Details</button>
                            </div>
                            <div className="p-4 bg-gray-800 rounded-lg border border-gray-700">
                                <h4 className="font-semibold text-white">Scenario: Take on a new large project</h4>
                                <p className="text-sm text-gray-400">Increased business income by $25,000.</p>
                                <p className="text-lg font-bold text-red-400 mt-2">Estimated Tax Impact: +$7,000 (Increase)</p>
                                <button onClick={() => alert('View Scenario Details')} className="text-cyan-400 text-sm mt-1 hover:underline">View Details</button>
                            </div>
                        </div>
                    </div>
                </Card>
            )}

            {activeTab === 'receipts' && (
                <Card title="Receipt Management & AI Extraction">
                    <p className="text-gray-400 mb-4">Upload receipts to automatically extract key data and link them to your deductions.</p>

                    <div className="mb-6 border-2 border-dashed border-gray-700 rounded-lg p-6 text-center bg-gray-800">
                        <label htmlFor="receiptUpload" className="cursor-pointer">
                            <svg className="mx-auto h-12 w-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                            <p className="mt-2 text-sm text-gray-400">
                                {isProcessingReceipt ? (
                                    <span className="flex items-center justify-center">
                                        <svg className="animate-spin h-5 w-5 mr-3 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                        Processing Receipt...
                                    </span>
                                ) : (
                                    <>
                                        <span className="font-semibold text-cyan-400">Click to upload</span> or drag and drop
                                    </>
                                )}
                            </p>
                            <p className="text-xs text-gray-500">PNG, JPG, PDF up to 10MB</p>
                            <input id="receiptUpload" type="file" className="sr-only" onChange={handleReceiptUpload} disabled={isProcessingReceipt} accept=".png,.jpg,.jpeg,.pdf" />
                        </label>
                    </div>

                    <h3 className="text-xl font-semibold text-white mb-4">Uploaded Receipts ({receipts.length})</h3>
                    {receipts.length === 0 ? (
                        <p className="text-center text-gray-500">No receipts uploaded yet.</p>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {receipts.map(receipt => (
                                <div key={receipt.id} className="bg-gray-800 p-4 rounded-lg border border-gray-700">
                                    <div className="flex justify-between items-center mb-2">
                                        <h4 className="font-semibold text-white truncate">{receipt.fileName}</h4>
                                        <span className="text-xs text-gray-500">{receipt.uploadDate.toLocaleDateString()}</span>
                                    </div>
                                    <p className="text-sm text-gray-400">Amount: {formatCurrency(receipt.amount)}</p>
                                    <p className="text-xs text-gray-500 italic mt-1">AI Summary: {receipt.aiSummary}</p>
                                    <div className="mt-3 flex justify-between items-center">
                                        <a href={receipt.url} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline text-sm">View Receipt</a>
                                        <button onClick={() => alert('Linking receipt ' + receipt.id)} className="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-xs rounded-md">Link to Deduction</button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </Card>
            )}

            {activeTab === 'alerts' && (
                <Card title="Tax Alerts & Notifications">
                    <p className="text-gray-400 mb-4">Stay informed about important tax deadlines, law changes, and personalized warnings.</p>
                    {taxAlerts.length === 0 ? (
                        <p className="text-center text-gray-500">No active tax alerts at this time.</p>
                    ) : (
                        <div className="space-y-4">
                            {taxAlerts.map(alert => (
                                <div key={alert.id} className={`p-4 rounded-lg border ${alert.isRead ? 'bg-gray-800 border-gray-700' : 'bg-yellow-900/20 border-yellow-600/50'}`}>
                                    <div className="flex justify-between items-start mb-2">
                                        <h4 className={`font-semibold ${alert.isRead ? 'text-gray-300' : 'text-yellow-300'}`}>{alert.title}</h4>
                                        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${alert.severity === TaxAlertSeverity.Critical ? 'bg-red-500/20 text-red-200' : alert.severity === TaxAlertSeverity.Warning ? 'bg-orange-500/20 text-orange-200' : 'bg-cyan-500/20 text-cyan-200'}`}>
                                            {alert.severity}
                                        </span>
                                    </div>
                                    <p className="text-sm text-gray-400">{alert.description}</p>
                                    <div className="mt-3 flex flex-wrap gap-2 items-center text-xs">
                                        <span className="text-gray-500">Issued: {alert.dateIssued.toLocaleDateString()}</span>
                                        {alert.relatedTaxYears && alert.relatedTaxYears.length > 0 && <span className="text-gray-500">Year: {alert.relatedTaxYears.join(', ')}</span>}
                                        {alert.affectedStates && alert.affectedStates.length > 0 && <span className="text-gray-500">States: {alert.affectedStates.join(', ')}</span>}
                                    </div>
                                    <div className="mt-3 flex justify-end items-center space-x-3">
                                        {alert.callToAction && <button onClick={() => alert('Action: ' + alert.callToAction)} className="text-indigo-400 hover:underline text-sm">{alert.callToAction}</button>}
                                        {alert.learnMoreUrl && <a href={alert.learnMoreUrl} target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline text-sm">Learn More</a>}
                                        {!alert.isRead && <button onClick={() => setTaxAlerts(prev => prev.map(a => a.id === alert.id ? { ...a, isRead: true } : a))} className="text-gray-500 hover:text-gray-300 text-sm">Mark as Read</button>}
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </Card>
            )}

            {/* Add Deduction Modal */}
            {showAddDeductionModal && (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <Card className="max-w-xl w-full">
                        <h3 className="text-2xl font-bold text-white mb-4">Add New Deduction</h3>
                        <form className="space-y-4">
                            <div>
                                <label htmlFor="deductionDescription" className="block text-sm font-medium text-gray-400">Description</label>
                                <input type="text" id="deductionDescription" value={newDeduction.description || ''} onChange={(e) => setNewDeduction({ ...newDeduction, description: e.target.value })} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" required />
                            </div>
                            <div>
                                <label htmlFor="deductionAmount" className="block text-sm font-medium text-gray-400">Amount</label>
                                <input type="number" id="deductionAmount" value={newDeduction.amount || ''} onChange={(e) => setNewDeduction({ ...newDeduction, amount: parseFloat(e.target.value) })} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" required />
                            </div>
                            <div>
                                <label htmlFor="deductionCategory" className="block text-sm font-medium text-gray-400">Category</label>
                                <select id="deductionCategory" value={newDeduction.category || ''} onChange={(e) => setNewDeduction({ ...newDeduction, category: e.target.value as DeductionCategory })} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white" required>
                                    {DEDUCTION_CATEGORIES_OPTIONS.map(option => (
                                        <option key={option.value} value={option.value}>{option.label}</option>
                                    ))}
                                </select>
                            </div>
                            <div>
                                <label htmlFor="deductionJustification" className="block text-sm font-medium text-gray-400">Justification (Optional)</label>
                                <textarea id="deductionJustification" rows={3} value={newDeduction.justification || ''} onChange={(e) => setNewDeduction({ ...newDeduction, justification: e.target.value })} className="mt-1 block w-full bg-gray-800 border-gray-600 rounded-md shadow-sm focus:border-cyan-500 focus:ring-cyan-500 text-white"></textarea>
                            </div>
                            <div className="flex justify-end space-x-3 mt-6">
                                <button type="button" onClick={() => setShowAddDeductionModal(false)} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg">Cancel</button>
                                <button type="button" onClick={handleAddDeduction} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg">Add Deduction</button>
                            </div>
                        </form>
                    </Card>
                </div>
            )}

            {/* Tax Concept Explanation Modal */}
            {showExplanationModal && currentTaxConcept && (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <Card className="max-w-2xl w-full">
                        <h3 className="text-2xl font-bold text-white mb-4">Tax Concept: {currentTaxConcept}</h3>
                        {explanationLoading ? (
                            <div className="flex items-center justify-center py-8">
                                <svg className="animate-spin -ml-1 mr-3 h-6 w-6 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span className="text-gray-400">Fetching explanation...</span>
                            </div>
                        ) : taxConceptExplanation ? (
                            <div className="prose prose-invert max-w-none text-gray-300">
                                <p>{taxConceptExplanation.explanation}</p>
                                {taxConceptExplanation.example && (
                                    <>
                                        <h4 className="mt-4 text-white">Example:</h4>
                                        <p className="italic text-sm">{taxConceptExplanation.example}</p>
                                    </>
                                )}
                                {taxConceptExplanation.relatedConcepts && taxConceptExplanation.relatedConcepts.length > 0 && (
                                    <>
                                        <h4 className="mt-4 text-white">Related Concepts:</h4>
                                        <ul className="list-disc list-inside text-sm">
                                            {taxConceptExplanation.relatedConcepts.map((concept, idx) => (
                                                <li key={idx}><button onClick={() => getTaxConceptExplanation(concept)} className="text-cyan-400 hover:underline">{concept}</button></li>
                                            ))}
                                        </ul>
                                    </>
                                )}
                            </div>
                        ) : (
                            <p className="text-center text-gray-500">No explanation found.</p>
                        )}
                        <div className="flex justify-end mt-6">
                            <button type="button" onClick={() => setShowExplanationModal(false)} className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg">Close</button>
                        </div>
                    </Card>
                </div>
            )}

        </div>
    );
};

export default TaxCenterView;