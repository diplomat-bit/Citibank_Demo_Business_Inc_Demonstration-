"use strict";

class TokenMap {
  constructor(ast, tokens, source) {
    this._tokens = tokens;
    this._source = source;
    this._nodesToTokenIndexes = new Map();
    this._nodesOccurrencesCountCache = new Map();
    this._tokensCache = new Map();

    this._processAst(ast);
  }

  has(node) {
    return this._nodesToTokenIndexes.has(node);
  }

  getIndexes(node) {
    return this._nodesToTokenIndexes.get(node);
  }

  find(node, condition) {
    const indexes = this._nodesToTokenIndexes.get(node);
    if (indexes) {
      for (let k = 0; k < indexes.length; k++) {
        const index = indexes[k];
        const tok = this._tokens[index];
        if (condition(tok, index)) return tok;
      }
    }
    return null;
  }

  findLastIndex(node, condition) {
    const indexes = this._nodesToTokenIndexes.get(node);
    if (indexes) {
      for (let k = indexes.length - 1; k >= 0; k--) {
        const index = indexes[k];
        const tok = this._tokens[index];
        if (condition(tok, index)) return index;
      }
    }
    return -1;
  }

  findMatching(node, test, occurrenceCount = 0) {
    const indexes = this._nodesToTokenIndexes.get(node);
    if (indexes) {
      let i = 0;
      const count = occurrenceCount;
      if (count > 1) {
        const cache = this._nodesOccurrencesCountCache.get(node);
        if (cache && cache.test === test && cache.count < count) {
          i = cache.i + 1;
          occurrenceCount -= cache.count + 1;
        }
      }
      for (; i < indexes.length; i++) {
        const tok = this._tokens[indexes[i]];
        if (this.matchesOriginal(tok, test)) {
          if (occurrenceCount === 0) {
            if (count > 0) {
              this._nodesOccurrencesCountCache.set(node, {
                test,
                count,
                i
              });
            }
            return tok;
          }
          occurrenceCount--;
        }
      }
    }
    return null;
  }

  matchesOriginal(token, test) {
    if (token.end - token.start !== test.length) return false;
    if (token.value != null) return token.value === test;
    return this._source.startsWith(test, token.start);
  }

  startMatches(node, test) {
    const indexes = this._nodesToTokenIndexes.get(node);
    if (!indexes) return false;
    const tok = this._tokens[indexes[0]];
    if (tok.start !== node.start) return false;
    return this.matchesOriginal(tok, test);
  }

  endMatches(node, test) {
    const indexes = this._nodesToTokenIndexes.get(node);
    if (!indexes) return false;
    const tok = this._tokens[indexes[indexes.length - 1]];
    if (tok.end !== node.end) return false;
    return this.matchesOriginal(tok, test);
  }

  _processAst(ast) {
    const stack = [ast];
    const visited = new Set();

    while (stack.length > 0) {
      const node = stack.pop();
      if (!node || visited.has(node)) continue;
      visited.add(node);

      if (node.start != null && node.end != null) {
        const indexes = this._getTokensIndexesOfNode(node);
        if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);
      }

      const children = this._getChildren(node);
      for (const child of children) {
        stack.push(child);
      }
    }
    this._tokensCache.clear();
  }

  _getTokensIndexesOfNode(node) {
    if (node.start == null || node.end == null) return [];
    const {
      first,
      last
    } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
    let low = first;
    const children = this._getChildren(node);

    if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
      const nextChild = children.next();
      if (nextChild.value) {
        const childTok = this._findTokensOfNode(nextChild.value, low, last);
        const high = childTok.first;
        for (let k = low; k < high; k++) indexes.push(k);
        low = childTok.last + 1;
      }
    }

    const indexes = [];
    for (const child of children) {
      if (child == null) continue;
      if (child.start == null || child.end == null) continue;
      const childTok = this._findTokensOfNode(child, low, last);
      const high = childTok.first;
      for (let k = low; k < high; k++) indexes.push(k);
      low = childTok.last + 1;
    }
    for (let k = low; k <= last; k++) indexes.push(k);
    return indexes;
  }

  _findTokensOfNode(node, low, high) {
    const cached = this._tokensCache.get(node);
    if (cached) return cached;
    const first = this._findFirstTokenOfNode(node.start, low, high);
    const last = this._findLastTokenOfNode(node.end, first, high);
    this._tokensCache.set(node, {
      first,
      last
    });
    return {
      first,
      last
    };
  }

  _findFirstTokenOfNode(start, low, high) {
    while (low <= high) {
      const mid = Math.floor((high + low) / 2);
      if (start < this._tokens[mid].start) {
        high = mid - 1;
      } else if (start > this._tokens[mid].start) {
        low = mid + 1;
      } else {
        return mid;
      }
    }
    return low;
  }

  _findLastTokenOfNode(end, low, high) {
    while (low <= high) {
      const mid = Math.floor((high + low) / 2);
      if (end < this._tokens[mid].end) {
        high = mid - 1;
      } else if (end > this._tokens[mid].end) {
        low = mid + 1;
      } else {
        return mid;
      }
    }
    return high;
  }

  _getChildren(node) {
    const children = [];
    if (!node) return children;

    if (node.type === "TemplateLiteral") {
      children.push(node.quasis[0]);
      for (let i = 1; i < node.quasis.length; i++) {
        children.push(node.expressions[i - 1]);
        children.push(node.quasis[i]);
      }
      return children;
    }

    for (const key in node) {
      if (Object.prototype.hasOwnProperty.call(node, key)) {
        const child = node[key];
        if (!child) continue;
        if (Array.isArray(child)) {
          children.push(...child);
        } else if (typeof child === 'object' && child !== null) {
          children.push(child);
        }
      }
    }
    return children;
  }
}

exports.TokenMap = TokenMap;