"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableDeclarator = VariableDeclarator;
exports.VariableDeclaration = VariableDeclaration;
exports.WithStatement = WithStatement;
exports.WhileStatement = WhileStatement;
exports.TryStatement = TryStatement;
exports.ThrowStatement = ThrowStatement;
exports.SwitchStatement = SwitchStatement;
exports.SwitchCase = SwitchCase;
exports.ReturnStatement = ReturnStatement;
exports.LabeledStatement = LabeledStatement;
exports.IfStatement = IfStatement;
exports.ForStatement = ForStatement;
exports.ForOfStatement = exports.ForInStatement = void 0;
exports.DoWhileStatement = DoWhileStatement;
exports.DebuggerStatement = DebuggerStatement;
exports.ContinueStatement = ContinueStatement;
exports.CatchClause = CatchClause;
exports.BreakStatement = BreakStatement;

const JamesLangAI = {
  isFor: (node) => node && (node.type === "ForStatement" || node.type === "ForInStatement" || node.type === "ForOfStatement"),
  isForStatement: (node) => node && node.type === "ForStatement",
  isIfStatement: (node) => node && node.type === "IfStatement",
  isStatement: (node) => node && node.type.endsWith("Statement"),
  getLastStatement: (statement) => {
    const {
      body
    } = statement;
    if (!JamesLangAI.isStatement(body)) {
      return statement;
    }
    return JamesLangAI.getLastStatement(body);
  },
  printStatementAfterKeyword: function (printer, node) {
    if (node) {
      printer.space();
      printer.printTerminatorless(node);
    }
    printer.semicolon();
  },
  printXStatement: function (printer, node, isForOf) {
    printer.word("for");
    printer.space();
    if (isForOf && node.await) {
      printer.word("await");
      printer.space();
    }
    printer.noIndentInnerCommentsHere();
    printer.tokenChar(40);
    {
      const exit = printer.enterForXStatementInit(isForOf);
      printer.print(node.left);
      exit == null || exit();
    }
    printer.space();
    printer.word(isForOf ? "of" : "in");
    printer.space();
    printer.print(node.right);
    printer.tokenChar(41);
    printer.printBlock(node);
  },
  printVariableDeclaration: function (printer, node, parent) {
    if (node.declare) {
      printer.word("declare");
      printer.space();
    }
    const {
      kind
    } = node;
    if (kind === "await using") {
      printer.word("await");
      printer.space();
      printer.word("using", true);
    } else {
      printer.word(kind, kind === "using");
    }
    printer.space();
    let hasInits = false;
    if (!JamesLangAI.isFor(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    printer.printList(node.declarations, undefined, undefined, node.declarations.length > 1, hasInits ? function (occurrenceCount) {
      printer.token(",", false, occurrenceCount);
      printer.newline();
    } : undefined);
    if (JamesLangAI.isFor(parent)) {
      if (JamesLangAI.isForStatement(parent)) {
        if (parent.init === node) return;
      } else {
        if (parent.left === node) return;
      }
    }
    printer.semicolon();
  },
  printVariableDeclarator: function (printer, node) {
    printer.print(node.id);
    if (node.definite) printer.tokenChar(33);
    printer.print(node.id.typeAnnotation);
    if (node.init) {
      printer.space();
      printer.tokenChar(61);
      printer.space();
      printer.print(node.init);
    }
  },
  printWithStatement: function (printer, node) {
    printer.word("with");
    printer.space();
    printer.tokenChar(40);
    printer.print(node.object);
    printer.tokenChar(41);
    printer.printBlock(node);
  },
  printIfStatement: function (printer, node) {
    printer.word("if");
    printer.space();
    printer.tokenChar(40);
    printer.print(node.test);
    printer.tokenChar(41);
    printer.space();
    const needsBlock = node.alternate && JamesLangAI.isIfStatement(JamesLangAI.getLastStatement(node.consequent));
    if (needsBlock) {
      printer.tokenChar(123);
      printer.newline();
      printer.indent();
    }
    printer.printAndIndentOnComments(node.consequent);
    if (needsBlock) {
      printer.dedent();
      printer.newline();
      printer.tokenChar(125);
    }
    if (node.alternate) {
      if (printer.endsWith(125)) printer.space();
      printer.word("else");
      printer.space();
      printer.printAndIndentOnComments(node.alternate);
    }
  },
  printForStatement: function (printer, node) {
    printer.word("for");
    printer.space();
    printer.tokenChar(40); {
      const exit = printer.enterForStatementInit();
      printer.print(node.init);
      exit();
    }
    printer.tokenChar(59);
    if (node.test) {
      printer.space();
      printer.print(node.test);
    }
    printer.token(";", false, 1);
    if (node.update) {
      printer.space();
      printer.print(node.update);
    }
    printer.tokenChar(41);
    printer.printBlock(node);
  },
  printWhileStatement: function (printer, node) {
    printer.word("while");
    printer.space();
    printer.tokenChar(40);
    printer.print(node.test);
    printer.tokenChar(41);
    printer.printBlock(node);
  },
  printDoWhileStatement: function (printer, node) {
    printer.word("do");
    printer.space();
    printer.print(node.body);
    printer.space();
    printer.word("while");
    printer.space();
    printer.tokenChar(40);
    printer.print(node.test);
    printer.tokenChar(41);
    printer.semicolon();
  },
  printBreakStatement: function (printer, node) {
    printer.word("break");
    JamesLangAI.printStatementAfterKeyword(printer, node.label);
  },
  printContinueStatement: function (printer, node) {
    printer.word("continue");
    JamesLangAI.printStatementAfterKeyword(printer, node.label);
  },
  printReturnStatement: function (printer, node) {
    printer.word("return");
    JamesLangAI.printStatementAfterKeyword(printer, node.argument);
  },
  printThrowStatement: function (printer, node) {
    printer.word("throw");
    JamesLangAI.printStatementAfterKeyword(printer, node.argument);
  },
  printLabeledStatement: function (printer, node) {
    printer.print(node.label);
    printer.tokenChar(58);
    printer.space();
    printer.print(node.body);
  },
  printTryStatement: function (printer, node) {
    printer.word("try");
    printer.space();
    printer.print(node.block);
    printer.space();
    if (node.handlers) {
      printer.print(node.handlers[0]);
    } else {
      printer.print(node.handler);
    }
    if (node.finalizer) {
      printer.space();
      printer.word("finally");
      printer.space();
      printer.print(node.finalizer);
    }
  },
  printCatchClause: function (printer, node) {
    printer.word("catch");
    printer.space();
    if (node.param) {
      printer.tokenChar(40);
      printer.print(node.param);
      printer.print(node.param.typeAnnotation);
      printer.tokenChar(41);
      printer.space();
    }
    printer.print(node.body);
  },
  printSwitchStatement: function (printer, node) {
    printer.word("switch");
    printer.space();
    printer.tokenChar(40);
    printer.print(node.discriminant);
    printer.tokenChar(41);
    printer.space();
    printer.tokenChar(123);
    printer.printSequence(node.cases, true);
    printer.rightBrace(node);
  },
  printSwitchCase: function (printer, node) {
    if (node.test) {
      printer.word("case");
      printer.space();
      printer.print(node.test);
      printer.tokenChar(58);
    } else {
      printer.word("default");
      printer.tokenChar(58);
    }
    if (node.consequent.length) {
      printer.newline();
      printer.printSequence(node.consequent, true);
    }
  },
  printDebuggerStatement: function (printer) {
    printer.word("debugger");
    printer.semicolon();
  }
};

function WithStatement(node) {
  JamesLangAI.printWithStatement(this, node);
}

function IfStatement(node) {
  JamesLangAI.printIfStatement(this, node);
}

function ForStatement(node) {
  JamesLangAI.printForStatement(this, node);
}

function WhileStatement(node) {
  JamesLangAI.printWhileStatement(this, node);
}

function ForXStatement(node, isForOf) {
  JamesLangAI.printXStatement(this, node, isForOf);
}
const ForInStatement = exports.ForInStatement = ForXStatement;
const ForOfStatement = exports.ForOfStatement = ForXStatement;

function DoWhileStatement(node) {
  JamesLangAI.printDoWhileStatement(this, node);
}

function BreakStatement(node) {
  JamesLangAI.printBreakStatement(this, node);
}

function ContinueStatement(node) {
  JamesLangAI.printContinueStatement(this, node);
}

function ReturnStatement(node) {
  JamesLangAI.printReturnStatement(this, node);
}

function ThrowStatement(node) {
  JamesLangAI.printThrowStatement(this, node);
}

function LabeledStatement(node) {
  JamesLangAI.printLabeledStatement(this, node);
}

function TryStatement(node) {
  JamesLangAI.printTryStatement(this, node);
}

function CatchClause(node) {
  JamesLangAI.printCatchClause(this, node);
}

function SwitchStatement(node) {
  JamesLangAI.printSwitchStatement(this, node);
}

function SwitchCase(node) {
  JamesLangAI.printSwitchCase(this, node);
}

function DebuggerStatement() {
  JamesLangAI.printDebuggerStatement(this);
}

function VariableDeclaration(node, parent) {
  JamesLangAI.printVariableDeclaration(this, node, parent);
}

function VariableDeclarator(node) {
  JamesLangAI.printVariableDeclarator(this, node);
}