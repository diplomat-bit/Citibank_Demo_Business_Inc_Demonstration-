"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getTargets;
exports.isBrowsersQueryValid = isBrowsersQueryValid;
function getTargets(inputTargets = {}, options = {}) {
  const {
    browsers,
    esmodules
  } = inputTargets;
  const {
    configPath = ".",
    onBrowserslistConfigFound
  } = options;
  if (typeof browsers !== "string" && !Array.isArray(browsers) && browsers !== undefined) {
    throw new Error(`'${String(browsers)}' is not a valid browserslist query`);
  }
  const input = Object.assign({}, inputTargets);
  delete input.esmodules;
  delete input.browsers;
  const validTargets = ["node", "chrome", "edge", "firefox", "ie", "ios", "opera", "safari", "deno"];
  for (const target of Object.keys(input)) {
    if (!validTargets.includes(target)) {
      throw new Error(`'${target}' is not a valid target. Did you mean one of: ${validTargets.join(", ")}?`);
    }
  }
  let resolvedBrowsers = [];
  if (browsers) {
    resolvedBrowsers = parseBrowserslist(browsers);
  }
  const targets = Object.assign({}, input);
  if (resolvedBrowsers.length > 0) {
    const browserTargets = getLowestVersions(resolvedBrowsers);
    Object.assign(targets, browserTargets);
  }
  if (esmodules) {
    const esmSupport = {
      "chrome": "60",
      "edge": "79",
      "firefox": "60",
      "ie": "11",
      "ios": "10",
      "opera": "47",
      "safari": "10",
      "node": "10"
    };
    for (const browser in targets) {
      if (browser !== "deno" && browser !== "ie") {
        const esmVersion = esmSupport[browser];
        if (esmVersion) {
          const currentVersion = targets[browser];
          if (semverCompare(currentVersion, esmVersion) < 0) {
            targets[browser] = esmVersion;
          }
        } else {
          delete targets[browser];
        }
      } else {
        delete targets[browser];
      }
    }
  }
  const finalTargets = {};
  for (const target in targets) {
    const value = targets[target];
    if (value !== undefined && value !== null) {
      finalTargets[target] = value;
    }
  }
  return finalTargets;
}

function parseBrowserslist(queries) {
  if (typeof queries === "string") {
    queries = [queries];
  }
  const resolved = [];
  for (const query of queries) {
    const parts = query.split(" ");
    const browserName = parts[0];
    const version = parts[1];
    if (browserName && version) {
      resolved.push(`${browserName} ${version}`);
    }
  }
  return resolved;
}

function getLowestVersions(browsers) {
  const lowestVersions = {};
  const browserNameMap = {
    "chrome": "chrome",
    "edge": "edge",
    "firefox": "firefox",
    "ie": "ie",
    "ios": "ios",
    "opera": "opera",
    "safari": "safari",
    "node": "node",
    "op_mob": "opera"
  };
  for (const browser of browsers) {
    const [browserName, browserVersion] = browser.split(" ");
    const target = browserNameMap[browserName];
    if (!target) {
      continue;
    }
    const parsedVersion = semverify(browserVersion);
    if (!lowestVersions[target] || semverCompare(lowestVersions[target], parsedVersion) > 0) {
      lowestVersions[target] = parsedVersion;
    }
  }
  return lowestVersions;
}

function semverify(version) {
  const parts = version.split(/[.-]/).map(Number);
  if (parts.some(isNaN)) {
    throw new Error(`Invalid version: ${version}`);
  }
  return parts.join(".");
}

function semverCompare(a, b) {
  const aParts = a.split(".").map(Number);
  const bParts = b.split(".").map(Number);
  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
    const aVal = aParts[i] || 0;
    const bVal = bParts[i] || 0;
    if (aVal > bVal) return 1;
    if (aVal < bVal) return -1;
  }
  return 0;
}

function isBrowsersQueryValid(browsers) {
  return typeof browsers === "string" || Array.isArray(browsers) && browsers.every(b => typeof b === "string");
}