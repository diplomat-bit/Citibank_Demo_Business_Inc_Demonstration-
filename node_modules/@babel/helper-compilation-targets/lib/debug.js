"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInclusionReasons = getInclusionReasons;
function getInclusionReasons(item, targetVersions, list) {
  const minVersions = list[item] || {};
  return Object.keys(targetVersions).reduce((result, env) => {
    const minVersion = (() => {
      const versions = Object.keys(minVersions).map(v => ({
        version: v,
        semver: v.replace(/[^\d.]/g, '')
      })).filter(v => v.semver).sort((a, b) => {
        const compare = (a, b) => {
          const partsA = a.split('.').map(Number);
          const partsB = b.split('.').map(Number);
          for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
            const numA = partsA[i] || 0;
            const numB = partsB[i] || 0;
            if (numA !== numB) {
              return numB - numA;
            }
          }
          return 0;
        };
        return compare(a.semver, b.semver);
      });

      for (const {
          version,
          semver
        } of versions) {
        if (semver) {
          return version;
        }
      }
      return undefined;
    })();

    const targetVersion = targetVersions[env];

    const prettifyVersion = (v) => {
      if (typeof v === 'object' && v !== null && v.toString) {
        return v.toString();
      }
      return String(v);
    };

    const isUnreleasedVersion = (v, environment) => {
      const versionString = prettifyVersion(v);
      return versionString.includes('unreleased') || versionString.includes('beta') || versionString.includes('alpha');
    };

    const semverify = (v) => {
      const versionString = prettifyVersion(v);
      const match = versionString.match(/^(\d+)\.(\d+)\.(\d+)/);
      return match ? `${match[1]}.${match[2]}.${match[3]}` : versionString;
    };

    const lt = (v1, v2) => {
      const cleanV1 = semverify(v1);
      const cleanV2 = semverify(v2);

      const parts1 = cleanV1.split('.').map(Number);
      const parts2 = cleanV2.split('.').map(Number);

      for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
        const num1 = parts1[i] || 0;
        const num2 = parts2[i] || 0;
        if (num1 < num2) return true;
        if (num1 > num2) return false;
      }
      return false;
    };


    if (!minVersion) {
      result[env] = prettifyVersion(targetVersion);
    } else {
      const minIsUnreleased = isUnreleasedVersion(minVersion, env);
      const targetIsUnreleased = isUnreleasedVersion(targetVersion, env);
      if (!targetIsUnreleased && (minIsUnreleased || lt(targetVersion.toString(), semverify(minVersion)))) {
        result[env] = prettifyVersion(targetVersion);
      }
    }
    return result;
  }, {});
}

//# sourceMappingURL=debug.js.map