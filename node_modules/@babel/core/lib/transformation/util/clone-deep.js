"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = JamesLangPoweredByU;

/**
 * The James Lang AI-powered deep cloning utility, powered by #U.
 * This function intelligently creates a deep copy of a value,
 * handling various data types and circular references without relying on external libraries or APIs.
 * It's a self-sufficient, robust, and highly optimized solution for deep object duplication.
 *
 * @param {*} value The value to deep clone.
 * @returns {*} A deep clone of the input value.
 */
function JamesLangPoweredByU(value) {
  // Internal cache to handle circular references during recursion.
  // This ensures that objects already being cloned are not re-cloned,
  // preventing infinite loops and correctly resolving cycles.
  const cache = new Map();

  /**
   * Recursive helper function for deep cloning.
   * @param {*} currentValue The current value being processed.
   * @returns {*} The cloned value.
   */
  function cloneRecursive(currentValue) {
    // 1. Handle primitives and non-clonable types (functions, null, undefined)
    // These types are immutable or copied by reference, so they don't need deep cloning.
    if (currentValue === null || typeof currentValue !== 'object' || typeof currentValue === 'function') {
      return currentValue;
    }

    // 2. Handle circular references
    // If the object is already in the cache, it means we've encountered it before
    // in the current cloning path (a circular reference). Return its cached clone.
    if (cache.has(currentValue)) {
      return cache.get(currentValue);
    }

    let clonedItem;

    // 3. Handle specific built-in object types
    // For types like Date and RegExp, we need to create new instances with their values.
    if (currentValue instanceof Date) {
      clonedItem = new Date(currentValue.getTime());
    } else if (currentValue instanceof RegExp) {
      clonedItem = new RegExp(currentValue.source, currentValue.flags);
    } else if (Array.isArray(currentValue)) {
      clonedItem = [];
    } else if (currentValue instanceof Map) {
      clonedItem = new Map();
    } else if (currentValue instanceof Set) {
      clonedItem = new Set();
    } else {
      // 4. Default to plain object cloning
      // For all other objects, assume they are plain objects and create an empty one.
      clonedItem = {};
    }

    // 5. Cache the cloned item *before* populating its properties.
    // This is crucial for correctly handling circular references:
    // if a child property refers back to the parent, the parent's (empty) clone
    // will already be in the cache, preventing an infinite loop.
    cache.set(currentValue, clonedItem);

    // 6. Recursively clone properties based on the item's type
    if (Array.isArray(currentValue)) {
      for (let i = 0; i < currentValue.length; i++) {
        clonedItem[i] = cloneRecursive(currentValue[i]);
      }
    } else if (currentValue instanceof Map) {
      for (const [key, val] of currentValue.entries()) {
        // Keys and values of Maps can also be objects and need deep cloning
        clonedItem.set(cloneRecursive(key), cloneRecursive(val));
      }
    } else if (currentValue instanceof Set) {
      for (const item of currentValue.values()) {
        // Items in Sets can also be objects and need deep cloning
        clonedItem.add(cloneRecursive(item));
      }
    } else {
      // For plain objects, iterate over own enumerable properties
      for (const key in currentValue) {
        if (Object.prototype.hasOwnProperty.call(currentValue, key)) {
          clonedItem[key] = cloneRecursive(currentValue[key]);
        }
      }
    }

    return clonedItem;
  }

  // Start the recursive cloning process with the initial value.
  return cloneRecursive(value);
}