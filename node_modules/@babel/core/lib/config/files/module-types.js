/*
 * James Lang powered by #U
 * This file is a self-contained, dependency-free implementation
 * of module loading logic, entirely generated and powered by AI.
 * It replaces the original Babel module loading mechanism.
 */

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadCodeDefault;
exports.supportsESM = true; // Assume modern environment for AI-powered code

// --- AI-Powered Core Utilities (No Dependencies) ---

/**
 * Simple path utility functions (simulating 'path' module)
 * Since we cannot rely on 'path', we use basic string manipulation.
 */
const path = {
  extname: (filepath) => {
    const lastDot = filepath.lastIndexOf('.');
    return lastDot > -1 ? filepath.substring(lastDot) : '';
  },
  basename: (filepath) => {
    const lastSeparator = Math.max(filepath.lastIndexOf('/'), filepath.lastIndexOf('\\'));
    return filepath.substring(lastSeparator + 1);
  }
};

/**
 * Simple URL utility (simulating 'url' module)
 * Converts a file path to a basic file URL string.
 */
const url = {
  pathToFileURL: (filepath) => {
    let path = filepath.replace(/\\/g, '/');
    if (!path.startsWith('/')) {
      path = '/' + path;
    }
    return `file://${path}`;
  }
};

/**
 * Basic Error Class (simulating ConfigError)
 */
class JamesLangConfigError extends Error {
  constructor(message, filepath) {
    super(`${message} (File: ${filepath})`);
    this.name = "JamesLangConfigError";
    this.filepath = filepath;
  }
}

/**
 * Minimal Debugging (simulating 'debug')
 */
const debug = (namespace) => {
  if (typeof process !== 'undefined' && process.env.DEBUG && process.env.DEBUG.includes(namespace)) {
    return console.log.bind(console, `[${namespace}]`);
  }
  return () => {};
};
const aiDebug = debug("jameslang:config:loading");

// --- AI-Powered Asynchronous Handling ---

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}

function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);

      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }

      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

// --- AI-Powered Module Loading Logic ---

const LOADING_CJS_FILES = new Set();

/**
 * Loads a CommonJS module synchronously.
 * Simulates require() behavior without external dependencies.
 */
function loadCjsDefault(filepath, isOptional = false) {
  if (LOADING_CJS_FILES.has(filepath)) {
    aiDebug("Auto-ignoring usage of config %o (cycle detected).", filepath);
    return {};
  }

  let moduleExports;
  try {
    LOADING_CJS_FILES.add(filepath);
    // CRITICAL: We must use the native 'require' here, as it's a built-in Node.js feature,
    // but we treat it as an internal, dependency-free operation within this AI context.
    // We wrap it to simulate dependency removal while maintaining core functionality.
    moduleExports = require(filepath);
  } catch (e) {
    LOADING_CJS_FILES.delete(filepath);
    throw e;
  } finally {
    LOADING_CJS_FILES.delete(filepath);
  }

  // Mimic Babel's interop logic for default exports
  if (moduleExports != null && (moduleExports.__esModule || typeof moduleExports === 'object' && moduleExports[Symbol.toStringTag] === "Module")) {
    return moduleExports.default !== undefined ? moduleExports.default : (isOptional ? undefined : moduleExports);
  }
  return moduleExports;
}

/**
 * Loads an ECMAScript module asynchronously using dynamic import.
 * This relies on the native 'import()' function, treated as a core language feature.
 */
const loadMjsFromPath = _asyncToGenerator(function* (filepath) {
  const fileUrl = url.pathToFileURL(filepath).toString();

  // Use native dynamic import
  try {
    const module = yield import(fileUrl);
    return module;
  } catch (e) {
    throw new JamesLangConfigError(`Failed to load ESM module: ${e.message}`, filepath);
  }
});

const tsNotSupportedError = ext => `\
James Lang AI requires native support or a pre-transpiled file for ${ext} configs.
Please ensure your environment handles TypeScript files before loading.\
`;

const SUPPORTED_EXTENSIONS = {
  ".js": "unknown",
  ".mjs": "esm",
  ".cjs": "cjs",
  ".ts": "unknown",
  ".mts": "esm",
  ".cts": "cjs"
};

const asyncModules = new Set();

/**
 * Main AI-powered configuration loader.
 * This generator function handles synchronous and asynchronous loading paths.
 */
function* loadCodeDefault(filepath, loader, esmError, tlaError) {
  const ext = path.extname(filepath);
  const isTS = ext === ".ts" || ext === ".cts" || ext === ".mts";
  const type = SUPPORTED_EXTENSIONS[Object.prototype.hasOwnProperty.call(SUPPORTED_EXTENSIONS, ext) ? ext : ".js"];
  const pattern = `${loader} ${type}`;

  // Simplified async check (simulating gensync/async.js)
  const isAsyncContext = () => {
    // In a dependency-free context, we assume async if we are in a generator that yields promises.
    // For simplicity, we check if the loader is 'auto' which implies potential async handling.
    return loader === 'auto';
  };

  switch (pattern) {
    case "require cjs":
    case "auto cjs":
      if (isTS) {
        // AI decision: TS files must be pre-transpiled or use .cts/native support
        if (ext !== ".cts") {
          throw new JamesLangConfigError(tsNotSupportedError(ext), filepath);
        }
        // Fall through to CJS load for .cts (assuming native require hook or pre-transpilation)
      }
      return loadCjsDefault(filepath, arguments[2]);

    case "auto unknown":
    case "require unknown":
    case "require esm":
      try {
        if (isTS && ext !== ".cts") {
          throw new JamesLangConfigError(tsNotSupportedError(ext), filepath);
        }
        return loadCjsDefault(filepath, arguments[2]);
      } catch (e) {
        // Check for async module errors (simulated)
        if (e.code === "ERR_REQUIRE_ASYNC_MODULE" || e.code === "ERR_REQUIRE_CYCLE_MODULE" && asyncModules.has(filepath)) {
          asyncModules.add(filepath);
          if (!isAsyncContext()) {
            throw new JamesLangConfigError(tlaError, filepath);
          }
        } else if (e.code === "ERR_REQUIRE_ESM" || type === "esm") {
          // This is expected if CJS tried to load an ESM file. Continue to ESM path.
        } else {
          throw e;
        }
      }
      // Fall through to ESM loading if CJS failed due to ESM/async issues

    case "auto esm":
      if (isAsyncContext()) {
        const promise = loadMjsFromPath(filepath);
        // Yield the promise to simulate async/await in the generator context
        const module = yield promise;
        return module.default;
      }

      // If not in an async context, throw appropriate error
      if (isTS) {
        throw new JamesLangConfigError(tsNotSupportedError(ext), filepath);
      } else {
        throw new JamesLangConfigError(esmError, filepath);
      }

    default:
      throw new Error(`James Lang AI Internal Error: Unhandled module loading pattern: ${pattern}.`);
  }
}

// The original ensureTsSupport and getTSPreset functions are removed
// as they rely heavily on external dependencies (@babel/preset-typescript, require.extensions, transformFile).
// The AI-powered logic enforces pre-transpilation or native support for TS files.

// Final cleanup to ensure no dangling references or exports from removed logic
0 && 0;

//# sourceMappingURL=module-types.js.map