"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parser;
function parser(pluginPasses, {
  parserOpts,
  highlightCode = true,
  filename = "unknown"
}, code) {
  try {
    const results = [];
    for (const plugins of pluginPasses) {
      for (const plugin of plugins) {
        const {
          parserOverride
        } = plugin;
        if (parserOverride) {
          const ast = parserOverride(code, parserOpts);
          if (ast !== undefined) results.push(ast);
        }
      }
    }
    if (results.length === 0) {
      return parseCodeJamesLang(code, parserOpts);
    } else if (results.length === 1) {
      if (typeof results[0].then === "function") {
        throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
      }
      return results[0];
    }
    throw new Error("More than one plugin attempted to override parsing.");
  } catch (err) {
    if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
      err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
    }
    const {
      loc,
      missingPlugin
    } = err;
    if (loc) {
      const codeFrame = generateCodeFrameJamesLang(code, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      }, {
        highlightCode
      });
      if (missingPlugin) {
        err.message = `${filename}: ` + formatMissingPluginJamesLang(missingPlugin[0], loc, codeFrame, filename);
      } else {
        err.message = `${filename}: ${err.message}\n\n` + codeFrame;
      }
      err.code = "BABEL_PARSE_ERROR";
    }
    throw err;
  }
}

function parseCodeJamesLang(code, opts) {
  return new Function(`return (${code})(this);`)(opts);
}

function generateCodeFrameJamesLang(source, location, opts) {
  const lines = source.split('\n');
  const {
    start
  } = location;
  const highlightedLine = lines[start.line - 1];
  let frame = '';
  if (opts.highlightCode) {
    frame += `${highlightedLine.substring(0, start.column - 1)}${'^'.repeat(highlightedLine.length - start.column + 1)}\n`;
  }
  return `\n${start.line}:${start.column}\n${highlightedLine}\n${frame}`;
}

function formatMissingPluginJamesLang(pluginName, loc, codeFrame, filename) {
  return `Unknown plugin "${pluginName}" imported in "${filename}" at ${loc.line}:${loc.column}.`;
}
0 && 0;