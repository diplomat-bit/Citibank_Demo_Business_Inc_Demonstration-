{"version":3,"names":["_assert","data","require","_fs","_interopRequireWildcard","_process","_url","_path","_module","_v","_util","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","own$1","classRegExp","kTypes","Set","codes","formatList","array","type","length","join","slice","messages","Map","nodeInternalPrefix","userStackTraceLimit","ERR_INVALID_ARG_TYPE","createError","name","expected","actual","assert","Array","isArray","message","endsWith","includes","types","instances","other","value","push","toLowerCase","exec","pos","indexOf","determineSpecificType","TypeError","ERR_INVALID_MODULE_SPECIFIER","request","reason","base","undefined","ERR_INVALID_PACKAGE_CONFIG","path","Error","ERR_INVALID_PACKAGE_TARGET","packagePath","key","target","isImport","relatedError","startsWith","JSON","stringify","ERR_MODULE_NOT_FOUND","exactUrl","ERR_NETWORK_IMPORT_DISALLOWED","specifier","ERR_PACKAGE_IMPORT_NOT_DEFINED","ERR_PACKAGE_PATH_NOT_EXPORTED","subpath","ERR_UNSUPPORTED_DIR_IMPORT","ERR_UNSUPPORTED_RESOLVE_REQUEST","ERR_UNKNOWN_FILE_EXTENSION","extension","ERR_INVALID_ARG_VALUE","inspected","inspect","sym","constructor","makeNodeErrorWithCode","Base","NodeError","parameters","limit","stackTraceLimit","isErrorStackTraceLimitWritable","error","getMessage","defineProperties","enumerable","writable","configurable","toString","captureLargerStackTrace","code","v8","startupSnapshot","isBuildingSnapshot","_unused","desc","isExtensible","hideStackFrames","wrappedFunction","hidden","stackTraceLimitIsWritable","Number","POSITIVE_INFINITY","captureStackTrace","self","Reflect","apply","regex","expectedLength","unshift","format","String","depth","colors","hasOwnProperty$1","ERR_INVALID_PACKAGE_CONFIG$1","cache","read","jsonPath","existing","string","fs","readFileSync","toNamespacedPath","exception","result","exists","pjsonPath","main","exports","imports","parsed","parse","error_","cause","fileURLToPath","getPackageScopeConfig","resolved","packageJSONUrl","URL","packageJSONPath","pathname","packageConfig","lastPackageJSONUrl","getPackageType","url","extensionFormatMap","mimeToFormat","mime","test","protocolHandlers","getDataProtocolModuleFormat","getFileProtocolModuleFormat","getHttpProtocolModuleFormat","node:","extname","index","codePointAt","_context","ignoreErrors","packageType","filepath","defaultGetFormatWithoutErrors","context","protocol","DEFAULT_CONDITIONS","freeze","DEFAULT_CONDITIONS_SET","getDefaultConditions","getDefaultConditionsSet","getConditionsSet","conditions","RegExpPrototypeSymbolReplace","RegExp","prototype","Symbol","replace","own","invalidSegmentRegEx","deprecatedInvalidSegmentRegEx","invalidPackageNameRegEx","patternRegEx","encodedSeparatorRegEx","emittedPackageWarnings","doubleSlashRegEx","emitInvalidSegmentDeprecation","match","packageJsonUrl","internal","isTarget","process","noDeprecation","double","emitWarning","emitLegacyIndexDeprecation","parentURL","href","urlPath","URL$1","basePath","resolve","tryStatSync","statSync","_unused2","fileExists","stats","throwIfNoEntry","isFile","legacyMainResolve","guess","tries","finalizeResolution","preserveSymlinks","filePath","isDirectory","real","realpathSync","search","hash","pathToFileURL","sep","importNotDefined","exportsNotFound","throwInvalidSubpath","invalidPackageTarget","resolvePackageTargetString","pattern","isPathMap","isURL","_unused3","exportTarget","packageResolve","resolvedTarget","resolvedPath","isArrayIndex","keyNumber","resolvePackageTarget","packageSubpath","targetList","lastException","targetItem","resolveResult","keys","getOwnPropertyNames","conditionalTarget","isConditionalExportsMainSugar","isConditionalSugar","keyIndex","currentIsConditionalSugar","emitTrailingSlashPatternDeprecation","pjsonUrl","add","packageExportsResolve","bestMatch","bestMatchSubpath","patternIndex","patternTrailer","patternKeyCompare","lastIndexOf","a","b","aPatternIndex","bPatternIndex","baseLengthA","baseLengthB","packageImportsResolve","parsePackageName","separatorIndex","validPackageName","isScoped","packageName","builtinModules","packageJsonPath","lastPath","stat","isRelativeSpecifier","shouldBeTreatedAsRelativeOrAbsolutePath","moduleResolve","isData","isRemote","checkIfDisallowedImport","parsedParentURL","parentProtocol","parsedProtocol","Boolean","throwIfInvalidParentURL","defaultResolve","_unused4","_unused5","maybeReturn","parent"],"sources":["../../src/vendor/import-meta-resolve.js"],"sourcesContent":["\n/****************************************************************************\\\n *                         NOTE FROM BABEL AUTHORS                          *\n * This file is inlined from https://github.com/wooorm/import-meta-resolve, *\n * because we need to compile it to CommonJS.                               *\n\\****************************************************************************/\n\n/*\n(The MIT License)\n\nCopyright (c) 2021 Titus Wormer <mailto:tituswormer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n---\n\nThis is a derivative work based on:\n<https://github.com/nodejs/node>.\nWhich is licensed:\n\n\"\"\"\nCopyright Node.js contributors. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\"\"\"\n\nThis license applies to parts of Node.js originating from the\nhttps://github.com/joyent/node repository:\n\n\"\"\"\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\"\"\"\n*/\n\nimport assert from 'assert';\nimport fs, { realpathSync, statSync } from 'fs';\nimport process from 'process';\nimport { fileURLToPath, URL as URL$1, pathToFileURL } from 'url';\nimport path from 'path';\nimport { builtinModules } from 'module';\nimport v8 from 'v8';\nimport { format, inspect } from 'util';\n\n/**\n * @typedef ErrnoExceptionFields\n * @property {number | undefined} [errnode]\n * @property {string | undefined} [code]\n * @property {string | undefined} [path]\n * @property {string | undefined} [syscall]\n * @property {string | undefined} [url]\n *\n * @typedef {Error & ErrnoExceptionFields} ErrnoException\n */\n\n\nconst own$1 = {}.hasOwnProperty;\n\nconst classRegExp = /^([A-Z][a-z\\d]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = new Set([\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]);\n\nconst codes = {};\n\n/**\n * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.\n * We cannot use Intl.ListFormat because it's not available in\n * --without-intl builds.\n *\n * @param {Array<string>} array\n *   An array of strings.\n * @param {string} [type='and']\n *   The list type to be inserted before the last element.\n * @returns {string}\n */\nfunction formatList(array, type = 'and') {\n  return array.length < 3\n    ? array.join(` ${type} `)\n    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`\n}\n\n/** @type {Map<string, MessageFunction | string>} */\nconst messages = new Map();\nconst nodeInternalPrefix = '__node_internal_';\n/** @type {number} */\nlet userStackTraceLimit;\n\ncodes.ERR_INVALID_ARG_TYPE = createError(\n  'ERR_INVALID_ARG_TYPE',\n  /**\n   * @param {string} name\n   * @param {Array<string> | string} expected\n   * @param {unknown} actual\n   */\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\");\n    if (!Array.isArray(expected)) {\n      expected = [expected];\n    }\n\n    let message = 'The ';\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      message += `${name} `;\n    } else {\n      const type = name.includes('.') ? 'property' : 'argument';\n      message += `\"${name}\" ${type} `;\n    }\n\n    message += 'must be ';\n\n    /** @type {Array<string>} */\n    const types = [];\n    /** @type {Array<string>} */\n    const instances = [];\n    /** @type {Array<string>} */\n    const other = [];\n\n    for (const value of expected) {\n      assert(\n        typeof value === 'string',\n        'All expected entries have to be of type string'\n      );\n\n      if (kTypes.has(value)) {\n        types.push(value.toLowerCase());\n      } else if (classRegExp.exec(value) === null) {\n        assert(\n          value !== 'object',\n          'The value \"object\" should be written as \"Object\"'\n        );\n        other.push(value);\n      } else {\n        instances.push(value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object');\n      if (pos !== -1) {\n        types.slice(pos, 1);\n        instances.push('Object');\n      }\n    }\n\n    if (types.length > 0) {\n      message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(\n        types,\n        'or'\n      )}`;\n      if (instances.length > 0 || other.length > 0) message += ' or ';\n    }\n\n    if (instances.length > 0) {\n      message += `an instance of ${formatList(instances, 'or')}`;\n      if (other.length > 0) message += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 1) {\n        message += `one of ${formatList(other, 'or')}`;\n      } else {\n        if (other[0].toLowerCase() !== other[0]) message += 'an ';\n        message += `${other[0]}`;\n      }\n    }\n\n    message += `. Received ${determineSpecificType(actual)}`;\n\n    return message\n  },\n  TypeError\n);\n\ncodes.ERR_INVALID_MODULE_SPECIFIER = createError(\n  'ERR_INVALID_MODULE_SPECIFIER',\n  /**\n   * @param {string} request\n   * @param {string} reason\n   * @param {string} [base]\n   */\n  (request, reason, base = undefined) => {\n    return `Invalid module \"${request}\" ${reason}${\n      base ? ` imported from ${base}` : ''\n    }`\n  },\n  TypeError\n);\n\ncodes.ERR_INVALID_PACKAGE_CONFIG = createError(\n  'ERR_INVALID_PACKAGE_CONFIG',\n  /**\n   * @param {string} path\n   * @param {string} [base]\n   * @param {string} [message]\n   */\n  (path, base, message) => {\n    return `Invalid package config ${path}${\n      base ? ` while importing ${base}` : ''\n    }${message ? `. ${message}` : ''}`\n  },\n  Error\n);\n\ncodes.ERR_INVALID_PACKAGE_TARGET = createError(\n  'ERR_INVALID_PACKAGE_TARGET',\n  /**\n   * @param {string} packagePath\n   * @param {string} key\n   * @param {unknown} target\n   * @param {boolean} [isImport=false]\n   * @param {string} [base]\n   */\n  (packagePath, key, target, isImport = false, base = undefined) => {\n    const relatedError =\n      typeof target === 'string' &&\n      !isImport &&\n      target.length > 0 &&\n      !target.startsWith('./');\n    if (key === '.') {\n      assert(isImport === false);\n      return (\n        `Invalid \"exports\" main target ${JSON.stringify(target)} defined ` +\n        `in the package config ${packagePath}package.json${\n          base ? ` imported from ${base}` : ''\n        }${relatedError ? '; targets must start with \"./\"' : ''}`\n      )\n    }\n\n    return `Invalid \"${\n      isImport ? 'imports' : 'exports'\n    }\" target ${JSON.stringify(\n      target\n    )} defined for '${key}' in the package config ${packagePath}package.json${\n      base ? ` imported from ${base}` : ''\n    }${relatedError ? '; targets must start with \"./\"' : ''}`\n  },\n  Error\n);\n\ncodes.ERR_MODULE_NOT_FOUND = createError(\n  'ERR_MODULE_NOT_FOUND',\n  /**\n   * @param {string} path\n   * @param {string} base\n   * @param {boolean} [exactUrl]\n   */\n  (path, base, exactUrl = false) => {\n    return `Cannot find ${\n      exactUrl ? 'module' : 'package'\n    } '${path}' imported from ${base}`\n  },\n  Error\n);\n\ncodes.ERR_NETWORK_IMPORT_DISALLOWED = createError(\n  'ERR_NETWORK_IMPORT_DISALLOWED',\n  \"import of '%s' by %s is not supported: %s\",\n  Error\n);\n\ncodes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(\n  'ERR_PACKAGE_IMPORT_NOT_DEFINED',\n  /**\n   * @param {string} specifier\n   * @param {string} packagePath\n   * @param {string} base\n   */\n  (specifier, packagePath, base) => {\n    return `Package import specifier \"${specifier}\" is not defined${\n      packagePath ? ` in package ${packagePath}package.json` : ''\n    } imported from ${base}`\n  },\n  TypeError\n);\n\ncodes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(\n  'ERR_PACKAGE_PATH_NOT_EXPORTED',\n  /**\n   * @param {string} packagePath\n   * @param {string} subpath\n   * @param {string} [base]\n   */\n  (packagePath, subpath, base = undefined) => {\n    if (subpath === '.')\n      return `No \"exports\" main defined in ${packagePath}package.json${\n        base ? ` imported from ${base}` : ''\n      }`\n    return `Package subpath '${subpath}' is not defined by \"exports\" in ${packagePath}package.json${\n      base ? ` imported from ${base}` : ''\n    }`\n  },\n  Error\n);\n\ncodes.ERR_UNSUPPORTED_DIR_IMPORT = createError(\n  'ERR_UNSUPPORTED_DIR_IMPORT',\n  \"Directory import '%s' is not supported \" +\n    'resolving ES modules imported from %s',\n  Error\n);\n\ncodes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(\n  'ERR_UNSUPPORTED_RESOLVE_REQUEST',\n  'Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.',\n  TypeError\n);\n\ncodes.ERR_UNKNOWN_FILE_EXTENSION = createError(\n  'ERR_UNKNOWN_FILE_EXTENSION',\n  /**\n   * @param {string} extension\n   * @param {string} path\n   */\n  (extension, path) => {\n    return `Unknown file extension \"${extension}\" for ${path}`\n  },\n  TypeError\n);\n\ncodes.ERR_INVALID_ARG_VALUE = createError(\n  'ERR_INVALID_ARG_VALUE',\n  /**\n   * @param {string} name\n   * @param {unknown} value\n   * @param {string} [reason='is invalid']\n   */\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value);\n\n    if (inspected.length > 128) {\n      inspected = `${inspected.slice(0, 128)}...`;\n    }\n\n    const type = name.includes('.') ? 'property' : 'argument';\n\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n  // Note: extra classes have been shaken out.\n  // , RangeError\n);\n\n/**\n * Utility function for registering the error codes. Only used here. Exported\n * *only* to allow for testing.\n * @param {string} sym\n * @param {MessageFunction | string} value\n * @param {ErrorConstructor} constructor\n * @returns {new (...parameters: Array<unknown>) => Error}\n */\nfunction createError(sym, value, constructor) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym, value);\n\n  return makeNodeErrorWithCode(constructor, sym)\n}\n\n/**\n * @param {ErrorConstructor} Base\n * @param {string} key\n * @returns {ErrorConstructor}\n */\nfunction makeNodeErrorWithCode(Base, key) {\n  // @ts-expect-error Itâ€™s a Node error.\n  return NodeError\n  /**\n   * @param {Array<unknown>} parameters\n   */\n  function NodeError(...parameters) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key, parameters, error);\n    Object.defineProperties(error, {\n      // Note: no need to implement `kIsNodeError` symbol, would be hard,\n      // probably.\n      message: {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      toString: {\n        /** @this {Error} */\n        value() {\n          return `${this.name} [${key}]: ${this.message}`\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n\n    captureLargerStackTrace(error);\n    // @ts-expect-error Itâ€™s a Node error.\n    error.code = key;\n    return error\n  }\n}\n\n/**\n * @returns {boolean}\n */\nfunction isErrorStackTraceLimitWritable() {\n  // Do no touch Error.stackTraceLimit as V8 would attempt to install\n  // it again during deserialization.\n  try {\n    if (v8.startupSnapshot.isBuildingSnapshot()) {\n      return false\n    }\n  } catch {}\n\n  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');\n  if (desc === undefined) {\n    return Object.isExtensible(Error)\n  }\n\n  return own$1.call(desc, 'writable') && desc.writable !== undefined\n    ? desc.writable\n    : desc.set !== undefined\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...parameters: unknown[]) => unknown} T\n * @param {T} wrappedFunction\n * @returns {T}\n */\nfunction hideStackFrames(wrappedFunction) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + wrappedFunction.name;\n  Object.defineProperty(wrappedFunction, 'name', {value: hidden});\n  return wrappedFunction\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  /**\n   * @param {Error} error\n   * @returns {Error}\n   */\n  // @ts-expect-error: fine\n  function (error) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Number.POSITIVE_INFINITY;\n    }\n\n    Error.captureStackTrace(error);\n\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return error\n  }\n);\n\n/**\n * @param {string} key\n * @param {Array<unknown>} parameters\n * @param {Error} self\n * @returns {string}\n */\nfunction getMessage(key, parameters, self) {\n  const message = messages.get(key);\n  assert(message !== undefined, 'expected `message` to be found');\n\n  if (typeof message === 'function') {\n    assert(\n      message.length <= parameters.length, // Default options do not count.\n      `Code: ${key}; The provided arguments length (${parameters.length}) does not ` +\n        `match the required ones (${message.length}).`\n    );\n    return Reflect.apply(message, self, parameters)\n  }\n\n  const regex = /%[dfijoOs]/g;\n  let expectedLength = 0;\n  while (regex.exec(message) !== null) expectedLength++;\n  assert(\n    expectedLength === parameters.length,\n    `Code: ${key}; The provided arguments length (${parameters.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (parameters.length === 0) return message\n\n  parameters.unshift(message);\n  return Reflect.apply(format, null, parameters)\n}\n\n/**\n * Determine the specific type of a value for type-mismatch errors.\n * @param {unknown} value\n * @returns {string}\n */\nfunction determineSpecificType(value) {\n  if (value === null || value === undefined) {\n    return String(value)\n  }\n\n  if (typeof value === 'function' && value.name) {\n    return `function ${value.name}`\n  }\n\n  if (typeof value === 'object') {\n    if (value.constructor && value.constructor.name) {\n      return `an instance of ${value.constructor.name}`\n    }\n\n    return `${inspect(value, {depth: -1})}`\n  }\n\n  let inspected = inspect(value, {colors: false});\n\n  if (inspected.length > 28) {\n    inspected = `${inspected.slice(0, 25)}...`;\n  }\n\n  return `type ${typeof value} (${inspected})`\n}\n\n// Manually â€œtree shakenâ€  from:\n// <https://github.com/nodejs/node/blob/7c3dce0/lib/internal/modules/package_json_reader.js>\n// Last checked on: Apr 29, 2023.\n// Removed the native dependency.\n// Also: no need to cache, we do that in resolve already.\n\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nconst {ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1} = codes;\n\n/** @type {Map<string, PackageConfig>} */\nconst cache = new Map();\n\n/**\n * @param {string} jsonPath\n * @param {{specifier: URL | string, base?: URL}} options\n * @returns {PackageConfig}\n */\nfunction read(jsonPath, {base, specifier}) {\n  const existing = cache.get(jsonPath);\n\n  if (existing) {\n    return existing\n  }\n\n  /** @type {string | undefined} */\n  let string;\n\n  try {\n    string = fs.readFileSync(path.toNamespacedPath(jsonPath), 'utf8');\n  } catch (error) {\n    const exception = /** @type {ErrnoException} */ (error);\n\n    if (exception.code !== 'ENOENT') {\n      throw exception\n    }\n  }\n\n  /** @type {PackageConfig} */\n  const result = {\n    exists: false,\n    pjsonPath: jsonPath,\n    main: undefined,\n    name: undefined,\n    type: 'none', // Ignore unknown types for forwards compatibility\n    exports: undefined,\n    imports: undefined\n  };\n\n  if (string !== undefined) {\n    /** @type {Record<string, unknown>} */\n    let parsed;\n\n    try {\n      parsed = JSON.parse(string);\n    } catch (error_) {\n      const cause = /** @type {ErrnoException} */ (error_);\n      const error = new ERR_INVALID_PACKAGE_CONFIG$1(\n        jsonPath,\n        (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n        cause.message\n      );\n      error.cause = cause;\n      throw error\n    }\n\n    result.exists = true;\n\n    if (\n      hasOwnProperty.call(parsed, 'name') &&\n      typeof parsed.name === 'string'\n    ) {\n      result.name = parsed.name;\n    }\n\n    if (\n      hasOwnProperty.call(parsed, 'main') &&\n      typeof parsed.main === 'string'\n    ) {\n      result.main = parsed.main;\n    }\n\n    if (hasOwnProperty.call(parsed, 'exports')) {\n      // @ts-expect-error: assume valid.\n      result.exports = parsed.exports;\n    }\n\n    if (hasOwnProperty.call(parsed, 'imports')) {\n      // @ts-expect-error: assume valid.\n      result.imports = parsed.imports;\n    }\n\n    // Ignore unknown types for forwards compatibility\n    if (\n      hasOwnProperty.call(parsed, 'type') &&\n      (parsed.type === 'commonjs' || parsed.type === 'module')\n    ) {\n      result.type = parsed.type;\n    }\n  }\n\n  cache.set(jsonPath, result);\n\n  return result\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  // Note: in Node, this is now a native module.\n  let packageJSONUrl = new URL('package.json', resolved);\n\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (packageJSONPath.endsWith('node_modules/package.json')) {\n      break\n    }\n\n    const packageConfig = read(fileURLToPath(packageJSONUrl), {\n      specifier: resolved\n    });\n\n    if (packageConfig.exists) {\n      return packageConfig\n    }\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {\n      break\n    }\n  }\n\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  // ^^ Note: in Node, this is now a native module.\n\n  return {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    type: 'none'\n  }\n}\n\n/**\n * Returns the package type for a given URL.\n * @param {URL} url - The URL to get the package type for.\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  // To do @anonrig: Write a C++ function that returns only \"type\".\n  return getPackageScopeConfig(url).type\n}\n\n// Manually â€œtree shakenâ€  from:\n// <https://github.com/nodejs/node/blob/7c3dce0/lib/internal/modules/esm/get_format.js>\n// Last checked on: Apr 29, 2023.\n\n\nconst {ERR_UNKNOWN_FILE_EXTENSION} = codes;\n\n/** @type {Record<string, string>} */\nconst extensionFormatMap = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  '.cjs': 'commonjs',\n  '.js': 'module',\n  '.json': 'json',\n  '.mjs': 'module'\n};\n\n/**\n * @param {string | null} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    mime &&\n    /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i.test(mime)\n  )\n    return 'module'\n  if (mime === 'application/json') return 'json'\n  return null\n}\n\n/**\n * @callback ProtocolHandler\n * @param {URL} parsed\n * @param {{parentURL: string, source?: Buffer}} context\n * @param {boolean} ignoreErrors\n * @returns {string | null | void}\n */\n\n/**\n * @type {Record<string, ProtocolHandler>}\n */\nconst protocolHandlers = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  'data:': getDataProtocolModuleFormat,\n  'file:': getFileProtocolModuleFormat,\n  'http:': getHttpProtocolModuleFormat,\n  'https:': getHttpProtocolModuleFormat,\n  'node:'() {\n    return 'builtin'\n  }\n};\n\n/**\n * @param {URL} parsed\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const {1: mime} = /^([^/]+\\/[^;,]+)[^,]*?(;base64)?,/.exec(\n    parsed.pathname\n  ) || [null, null, null];\n  return mimeToFormat(mime)\n}\n\n/**\n * Returns the file extension from a URL.\n *\n * Should give similar result to\n * `require('node:path').extname(require('node:url').fileURLToPath(url))`\n * when used with a `file:` URL.\n *\n * @param {URL} url\n * @returns {string}\n */\nfunction extname(url) {\n  const pathname = url.pathname;\n  let index = pathname.length;\n\n  while (index--) {\n    const code = pathname.codePointAt(index);\n\n    if (code === 47 /* `/` */) {\n      return ''\n    }\n\n    if (code === 46 /* `.` */) {\n      return pathname.codePointAt(index - 1) === 47 /* `/` */\n        ? ''\n        : pathname.slice(index)\n    }\n  }\n\n  return ''\n}\n\n/**\n * @type {ProtocolHandler}\n */\nfunction getFileProtocolModuleFormat(url, _context, ignoreErrors) {\n  const value = extname(url);\n\n  if (value === '.js') {\n    const packageType = getPackageType(url);\n\n    if (packageType !== 'none') {\n      return packageType\n    }\n\n    return 'commonjs'\n  }\n\n  if (value === '') {\n    const packageType = getPackageType(url);\n\n    // Legacy behavior\n    if (packageType === 'none' || packageType === 'commonjs') {\n      return 'commonjs'\n    }\n\n    // Note: we donâ€™t implement WASM, so we donâ€™t need\n    // `getFormatOfExtensionlessFile` from `formats`.\n    return 'module'\n  }\n\n  const format = extensionFormatMap[value];\n  if (format) return format\n\n  // Explicit undefined return indicates load hook should rerun format check\n  if (ignoreErrors) {\n    return undefined\n  }\n\n  const filepath = fileURLToPath(url);\n  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath)\n}\n\nfunction getHttpProtocolModuleFormat() {\n  // To do: HTTPS imports.\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {string | null}\n */\nfunction defaultGetFormatWithoutErrors(url, context) {\n  const protocol = url.protocol;\n\n  if (!hasOwnProperty.call(protocolHandlers, protocol)) {\n    return null\n  }\n\n  return protocolHandlers[protocol](url, context, true) || null\n}\n\n// Manually â€œtree shakenâ€  from:\n// <https://github.com/nodejs/node/blob/81a9a97/lib/internal/modules/esm/utils.js>\n// Last checked on: Apr 29, 2023.\n\n\nconst {ERR_INVALID_ARG_VALUE} = codes;\n\n// In Node itself these values are populated from CLI arguments, before any\n// user code runs.\n// Here we just define the defaults.\nconst DEFAULT_CONDITIONS = Object.freeze(['node', 'import']);\nconst DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);\n\n/**\n * Returns the default conditions for ES module loading.\n */\nfunction getDefaultConditions() {\n  return DEFAULT_CONDITIONS\n}\n\n/**\n * Returns the default conditions for ES module loading, as a Set.\n */\nfunction getDefaultConditionsSet() {\n  return DEFAULT_CONDITIONS_SET\n}\n\n/**\n * @param {Array<string>} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== getDefaultConditions()) {\n    if (!Array.isArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'conditions',\n        conditions,\n        'expected an array'\n      )\n    }\n\n    return new Set(conditions)\n  }\n\n  return getDefaultConditionsSet()\n}\n\n// Manually â€œtree shakenâ€  from:\n// <https://github.com/nodejs/node/blob/81a9a97/lib/internal/modules/esm/resolve.js>\n// Last checked on: Apr 29, 2023.\n\n\nconst RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];\n\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_RESOLVE_REQUEST\n} = codes;\n\nconst own = {}.hasOwnProperty;\n\nconst invalidSegmentRegEx =\n  /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\\\|\\/|$)/i;\nconst deprecatedInvalidSegmentRegEx =\n  /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\nconst encodedSeparatorRegEx = /%2f|%5c/i;\n/** @type {Set<string>} */\nconst emittedPackageWarnings = new Set();\n\nconst doubleSlashRegEx = /[/\\\\]{2}/;\n\n/**\n *\n * @param {string} target\n * @param {string} request\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} base\n * @param {boolean} isTarget\n */\nfunction emitInvalidSegmentDeprecation(\n  target,\n  request,\n  match,\n  packageJsonUrl,\n  internal,\n  base,\n  isTarget\n) {\n  // @ts-expect-error: apparently it does exist, TS.\n  if (process.noDeprecation) {\n    return\n  }\n\n  const pjsonPath = fileURLToPath(packageJsonUrl);\n  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;\n  process.emitWarning(\n    `Use of deprecated ${\n      double ? 'double slash' : 'leading or trailing slash matching'\n    } resolving \"${target}\" for module ` +\n      `request \"${request}\" ${\n        request === match ? '' : `matched to \"${match}\" `\n      }in the \"${\n        internal ? 'imports' : 'exports'\n      }\" field module resolution of the package at ${pjsonPath}${\n        base ? ` imported from ${fileURLToPath(base)}` : ''\n      }.`,\n    'DeprecationWarning',\n    'DEP0166'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @param {string} [main]\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {\n  // @ts-expect-error: apparently it does exist, TS.\n  if (process.noDeprecation) {\n    return\n  }\n\n  const format = defaultGetFormatWithoutErrors(url, {parentURL: base.href});\n  if (format !== 'module') return\n  const urlPath = fileURLToPath(url.href);\n  const packagePath = fileURLToPath(new URL$1('.', packageJsonUrl));\n  const basePath = fileURLToPath(base);\n  if (!main) {\n    process.emitWarning(\n      `No \"main\" or \"exports\" field defined in the package.json for ${packagePath} resolving the main entry point \"${urlPath.slice(\n        packagePath.length\n      )}\", imported from ${basePath}.\\nDefault \"index\" lookups for the main are deprecated for ES modules.`,\n      'DeprecationWarning',\n      'DEP0151'\n    );\n  } else if (path.resolve(packagePath, main) !== urlPath) {\n    process.emitWarning(\n      `Package ${packagePath} has a \"main\" field set to \"${main}\", ` +\n        `excluding the full filename and extension to the resolved file at \"${urlPath.slice(\n          packagePath.length\n        )}\", imported from ${basePath}.\\n Automatic extension resolution of the \"main\" field is ` +\n        'deprecated for ES modules.',\n      'DeprecationWarning',\n      'DEP0151'\n    );\n  }\n}\n\n/**\n * @param {string} path\n * @returns {Stats | undefined}\n */\nfunction tryStatSync(path) {\n  // Note: from Node 15 onwards we can use `throwIfNoEntry: false` instead.\n  try {\n    return statSync(path)\n  } catch {\n    // Note: in Node code this returns `new Stats`,\n    // but in Node 22 thatâ€™s marked as a deprecated internal API.\n    // Which, well, we kinda are, but still to prevent that warning,\n    // just yield `undefined`.\n  }\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n *\n * @param {URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  const stats = statSync(url, {throwIfNoEntry: false});\n  const isFile = stats ? stats.isFile() : undefined;\n  return isFile === null || isFile === undefined ? false : isFile\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {PackageConfig} packageConfig\n * @param {URL} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJsonUrl, packageConfig, base) {\n  /** @type {URL | undefined} */\n  let guess;\n  if (packageConfig.main !== undefined) {\n    guess = new URL$1(packageConfig.main, packageJsonUrl);\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess)) return guess\n\n    const tries = [\n      `./${packageConfig.main}.js`,\n      `./${packageConfig.main}.json`,\n      `./${packageConfig.main}.node`,\n      `./${packageConfig.main}/index.js`,\n      `./${packageConfig.main}/index.json`,\n      `./${packageConfig.main}/index.node`\n    ];\n    let i = -1;\n\n    while (++i < tries.length) {\n      guess = new URL$1(tries[i], packageJsonUrl);\n      if (fileExists(guess)) break\n      guess = undefined;\n    }\n\n    if (guess) {\n      emitLegacyIndexDeprecation(\n        guess,\n        packageJsonUrl,\n        base,\n        packageConfig.main\n      );\n      return guess\n    }\n    // Fallthrough.\n  }\n\n  const tries = ['./index.js', './index.json', './index.node'];\n  let i = -1;\n\n  while (++i < tries.length) {\n    guess = new URL$1(tries[i], packageJsonUrl);\n    if (fileExists(guess)) break\n    guess = undefined;\n  }\n\n  if (guess) {\n    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);\n    return guess\n  }\n\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL$1('.', packageJsonUrl)),\n    fileURLToPath(base)\n  )\n}\n\n/**\n * @param {URL} resolved\n * @param {URL} base\n * @param {boolean} [preserveSymlinks]\n * @returns {URL}\n */\nfunction finalizeResolution(resolved, base, preserveSymlinks) {\n  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname,\n      'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base)\n    )\n  }\n\n  /** @type {string} */\n  let filePath;\n\n  try {\n    filePath = fileURLToPath(resolved);\n  } catch (error) {\n    const cause = /** @type {ErrnoException} */ (error);\n    Object.defineProperty(cause, 'input', {value: String(resolved)});\n    Object.defineProperty(cause, 'module', {value: String(base)});\n    throw cause\n  }\n\n  const stats = tryStatSync(\n    filePath.endsWith('/') ? filePath.slice(-1) : filePath\n  );\n\n  if (stats && stats.isDirectory()) {\n    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base));\n    // @ts-expect-error Add this for `import.meta.resolve`.\n    error.url = String(resolved);\n    throw error\n  }\n\n  if (!stats || !stats.isFile()) {\n    const error = new ERR_MODULE_NOT_FOUND(\n      filePath || resolved.pathname,\n      base && fileURLToPath(base),\n      true\n    );\n    // @ts-expect-error Add this for `import.meta.resolve`.\n    error.url = String(resolved);\n    throw error\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(filePath);\n    const {search, hash} = resolved;\n    resolved = pathToFileURL(real + (filePath.endsWith(path.sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved\n}\n\n/**\n * @param {string} specifier\n * @param {URL | undefined} packageJsonUrl\n * @param {URL} base\n * @returns {Error}\n */\nfunction importNotDefined(specifier, packageJsonUrl, base) {\n  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier,\n    packageJsonUrl && fileURLToPath(new URL$1('.', packageJsonUrl)),\n    fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @returns {Error}\n */\nfunction exportsNotFound(subpath, packageJsonUrl, base) {\n  return new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL$1('.', packageJsonUrl)),\n    subpath,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} request\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} [base]\n * @returns {never}\n */\nfunction throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {\n  const reason = `request is not a valid match in pattern \"${match}\" for the \"${\n    internal ? 'imports' : 'exports'\n  }\" resolution of ${fileURLToPath(packageJsonUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(\n    request,\n    reason,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} subpath\n * @param {unknown} target\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} [base]\n * @returns {Error}\n */\nfunction invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {\n  target =\n    typeof target === 'object' && target !== null\n      ? JSON.stringify(target, null, '')\n      : `${target}`;\n\n  return new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL$1('.', packageJsonUrl)),\n    subpath,\n    target,\n    internal,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} target\n * @param {string} subpath\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @param {boolean} pattern\n * @param {boolean} internal\n * @param {boolean} isPathMap\n * @param {Set<string> | undefined} conditions\n * @returns {URL}\n */\nfunction resolvePackageTargetString(\n  target,\n  subpath,\n  match,\n  packageJsonUrl,\n  base,\n  pattern,\n  internal,\n  isPathMap,\n  conditions\n) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n\n  if (!target.startsWith('./')) {\n    if (internal && !target.startsWith('../') && !target.startsWith('/')) {\n      let isURL = false;\n\n      try {\n        new URL$1(target);\n        isURL = true;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (!isURL) {\n        const exportTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target + subpath;\n\n        return packageResolve(exportTarget, packageJsonUrl, conditions)\n      }\n    }\n\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n  }\n\n  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {\n    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {\n      if (!isPathMap) {\n        const request = pattern\n          ? match.replace('*', () => subpath)\n          : match + subpath;\n        const resolvedTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target;\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          true\n        );\n      }\n    } else {\n      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n    }\n  }\n\n  const resolved = new URL$1(target, packageJsonUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL$1('.', packageJsonUrl).pathname;\n\n  if (!resolvedPath.startsWith(packagePath))\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n\n  if (subpath === '') return resolved\n\n  if (invalidSegmentRegEx.exec(subpath) !== null) {\n    const request = pattern\n      ? match.replace('*', () => subpath)\n      : match + subpath;\n    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {\n      if (!isPathMap) {\n        const resolvedTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target;\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          false\n        );\n      }\n    } else {\n      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);\n    }\n  }\n\n  if (pattern) {\n    return new URL$1(\n      RegExpPrototypeSymbolReplace.call(\n        patternRegEx,\n        resolved.href,\n        () => subpath\n      )\n    )\n  }\n\n  return new URL$1(subpath, resolved)\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNumber = Number(key);\n  if (`${keyNumber}` !== key) return false\n  return keyNumber >= 0 && keyNumber < 0xff_ff_ff_ff\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {unknown} target\n * @param {string} subpath\n * @param {string} packageSubpath\n * @param {URL} base\n * @param {boolean} pattern\n * @param {boolean} internal\n * @param {boolean} isPathMap\n * @param {Set<string> | undefined} conditions\n * @returns {URL | null}\n */\nfunction resolvePackageTarget(\n  packageJsonUrl,\n  target,\n  subpath,\n  packageSubpath,\n  base,\n  pattern,\n  internal,\n  isPathMap,\n  conditions\n) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target,\n      subpath,\n      packageSubpath,\n      packageJsonUrl,\n      base,\n      pattern,\n      internal,\n      isPathMap,\n      conditions\n    )\n  }\n\n  if (Array.isArray(target)) {\n    /** @type {Array<unknown>} */\n    const targetList = target;\n    if (targetList.length === 0) return null\n\n    /** @type {ErrnoException | null | undefined} */\n    let lastException;\n    let i = -1;\n\n    while (++i < targetList.length) {\n      const targetItem = targetList[i];\n      /** @type {URL | null} */\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          targetItem,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        );\n      } catch (error) {\n        const exception = /** @type {ErrnoException} */ (error);\n        lastException = exception;\n        if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue\n        throw error\n      }\n\n      if (resolveResult === undefined) continue\n\n      if (resolveResult === null) {\n        lastException = null;\n        continue\n      }\n\n      return resolveResult\n    }\n\n    if (lastException === undefined || lastException === null) {\n      return null\n    }\n\n    throw lastException\n  }\n\n  if (typeof target === 'object' && target !== null) {\n    const keys = Object.getOwnPropertyNames(target);\n    let i = -1;\n\n    while (++i < keys.length) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJsonUrl),\n          base,\n          '\"exports\" cannot contain numeric property keys.'\n        )\n      }\n    }\n\n    i = -1;\n\n    while (++i < keys.length) {\n      const key = keys[i];\n      if (key === 'default' || (conditions && conditions.has(key))) {\n        // @ts-expect-error: indexable.\n        const conditionalTarget = /** @type {unknown} */ (target[key]);\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          conditionalTarget,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        );\n        if (resolveResult === undefined) continue\n        return resolveResult\n      }\n    }\n\n    return null\n  }\n\n  if (target === null) {\n    return null\n  }\n\n  throw invalidPackageTarget(\n    packageSubpath,\n    target,\n    packageJsonUrl,\n    internal,\n    base\n  )\n}\n\n/**\n * @param {unknown} exports\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports, packageJsonUrl, base) {\n  if (typeof exports === 'string' || Array.isArray(exports)) return true\n  if (typeof exports !== 'object' || exports === null) return false\n\n  const keys = Object.getOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  let keyIndex = -1;\n  while (++keyIndex < keys.length) {\n    const key = keys[keyIndex];\n    const currentIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = currentIsConditionalSugar;\n    } else if (isConditionalSugar !== currentIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJsonUrl),\n        base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n          ' The exports object must either be an object of package subpath keys' +\n          ' or an object of main entry condition name keys only.'\n      )\n    }\n  }\n\n  return isConditionalSugar\n}\n\n/**\n * @param {string} match\n * @param {URL} pjsonUrl\n * @param {URL} base\n */\nfunction emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {\n  // @ts-expect-error: apparently it does exist, TS.\n  if (process.noDeprecation) {\n    return\n  }\n\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping \"${match}\" in the ` +\n      `\"exports\" field module resolution of the package at ${pjsonPath}${\n        base ? ` imported from ${fileURLToPath(base)}` : ''\n      }. Mapping specifiers ending in \"/\" is no longer supported.`,\n    'DeprecationWarning',\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {string} packageSubpath\n * @param {Record<string, unknown>} packageConfig\n * @param {URL} base\n * @param {Set<string> | undefined} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJsonUrl,\n  packageSubpath,\n  packageConfig,\n  base,\n  conditions\n) {\n  let exports = packageConfig.exports;\n\n  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {\n    exports = {'.': exports};\n  }\n\n  if (\n    own.call(exports, packageSubpath) &&\n    !packageSubpath.includes('*') &&\n    !packageSubpath.endsWith('/')\n  ) {\n    // @ts-expect-error: indexable.\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      '',\n      packageSubpath,\n      base,\n      false,\n      false,\n      false,\n      conditions\n    );\n    if (resolveResult === null || resolveResult === undefined) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n    }\n\n    return resolveResult\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath = '';\n  const keys = Object.getOwnPropertyNames(exports);\n  let i = -1;\n\n  while (++i < keys.length) {\n    const key = keys[i];\n    const patternIndex = key.indexOf('*');\n\n    if (\n      patternIndex !== -1 &&\n      packageSubpath.startsWith(key.slice(0, patternIndex))\n    ) {\n      // When this reaches EOL, this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath, '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match \"imports\" and the spec.\n      if (packageSubpath.endsWith('/')) {\n        emitTrailingSlashPatternDeprecation(\n          packageSubpath,\n          packageJsonUrl,\n          base\n        );\n      }\n\n      const patternTrailer = key.slice(patternIndex + 1);\n\n      if (\n        packageSubpath.length >= key.length &&\n        packageSubpath.endsWith(patternTrailer) &&\n        patternKeyCompare(bestMatch, key) === 1 &&\n        key.lastIndexOf('*') === patternIndex\n      ) {\n        bestMatch = key;\n        bestMatchSubpath = packageSubpath.slice(\n          patternIndex,\n          packageSubpath.length - patternTrailer.length\n        );\n      }\n    }\n  }\n\n  if (bestMatch) {\n    // @ts-expect-error: indexable.\n    const target = /** @type {unknown} */ (exports[bestMatch]);\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      bestMatchSubpath,\n      bestMatch,\n      base,\n      true,\n      false,\n      packageSubpath.endsWith('/'),\n      conditions\n    );\n\n    if (resolveResult === null || resolveResult === undefined) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n    }\n\n    return resolveResult\n  }\n\n  throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n}\n\n/**\n * @param {string} a\n * @param {string} b\n */\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf('*');\n  const bPatternIndex = b.indexOf('*');\n  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLengthA > baseLengthB) return -1\n  if (baseLengthB > baseLengthA) return 1\n  if (aPatternIndex === -1) return 1\n  if (bPatternIndex === -1) return -1\n  if (a.length > b.length) return -1\n  if (b.length > a.length) return 1\n  return 0\n}\n\n/**\n * @param {string} name\n * @param {URL} base\n * @param {Set<string>} [conditions]\n * @returns {URL}\n */\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base))\n  }\n\n  /** @type {URL | undefined} */\n  let packageJsonUrl;\n\n  const packageConfig = getPackageScopeConfig(base);\n\n  if (packageConfig.exists) {\n    packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (own.call(imports, name) && !name.includes('*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          imports[name],\n          '',\n          name,\n          base,\n          false,\n          true,\n          false,\n          conditions\n        );\n        if (resolveResult !== null && resolveResult !== undefined) {\n          return resolveResult\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath = '';\n        const keys = Object.getOwnPropertyNames(imports);\n        let i = -1;\n\n        while (++i < keys.length) {\n          const key = keys[i];\n          const patternIndex = key.indexOf('*');\n\n          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {\n            const patternTrailer = key.slice(patternIndex + 1);\n            if (\n              name.length >= key.length &&\n              name.endsWith(patternTrailer) &&\n              patternKeyCompare(bestMatch, key) === 1 &&\n              key.lastIndexOf('*') === patternIndex\n            ) {\n              bestMatch = key;\n              bestMatchSubpath = name.slice(\n                patternIndex,\n                name.length - patternTrailer.length\n              );\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(\n            packageJsonUrl,\n            target,\n            bestMatchSubpath,\n            bestMatch,\n            base,\n            true,\n            true,\n            false,\n            conditions\n          );\n\n          if (resolveResult !== null && resolveResult !== undefined) {\n            return resolveResult\n          }\n        }\n      }\n    }\n  }\n\n  throw importNotDefined(name, packageJsonUrl, base)\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n */\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = specifier.indexOf('/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = specifier.indexOf('/', separatorIndex + 1);\n    }\n  }\n\n  const packageName =\n    separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (invalidPackageNameRegEx.exec(packageName) !== null) {\n    validPackageName = false;\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier,\n      'is not a valid package name',\n      fileURLToPath(base)\n    )\n  }\n\n  const packageSubpath =\n    '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex));\n\n  return {packageName, packageSubpath, isScoped}\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} [conditions]\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  if (builtinModules.includes(specifier)) {\n    return new URL$1('node:' + specifier)\n  }\n\n  const {packageName, packageSubpath, isScoped} = parsePackageName(\n    specifier,\n    base\n  );\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n\n  // Canâ€™t test.\n  /* c8 ignore next 16 */\n  if (packageConfig.exists) {\n    const packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (\n      packageConfig.name === packageName &&\n      packageConfig.exports !== undefined &&\n      packageConfig.exports !== null\n    ) {\n      return packageExportsResolve(\n        packageJsonUrl,\n        packageSubpath,\n        packageConfig,\n        base,\n        conditions\n      )\n    }\n  }\n\n  let packageJsonUrl = new URL$1(\n    './node_modules/' + packageName + '/package.json',\n    base\n  );\n  let packageJsonPath = fileURLToPath(packageJsonUrl);\n  /** @type {string} */\n  let lastPath;\n  do {\n    const stat = tryStatSync(packageJsonPath.slice(0, -13));\n    if (!stat || !stat.isDirectory()) {\n      lastPath = packageJsonPath;\n      packageJsonUrl = new URL$1(\n        (isScoped ? '../../../../node_modules/' : '../../../node_modules/') +\n          packageName +\n          '/package.json',\n        packageJsonUrl\n      );\n      packageJsonPath = fileURLToPath(packageJsonUrl);\n      continue\n    }\n\n    // Package match.\n    const packageConfig = read(packageJsonPath, {base, specifier});\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJsonUrl,\n        packageSubpath,\n        packageConfig,\n        base,\n        conditions\n      )\n    }\n\n    if (packageSubpath === '.') {\n      return legacyMainResolve(packageJsonUrl, packageConfig, base)\n    }\n\n    return new URL$1(packageSubpath, packageJsonUrl)\n    // Cross-platform root check.\n  } while (packageJsonPath.length !== lastPath.length)\n\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false)\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true\n    if (\n      specifier[1] === '.' &&\n      (specifier.length === 2 || specifier[2] === '/')\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false\n  if (specifier[0] === '/') return true\n  return isRelativeSpecifier(specifier)\n}\n\n/**\n * The â€œResolver Algorithm Specificationâ€  as detailed in the Node docs (which is\n * sync and slightly lower-level than `resolve`).\n *\n * @param {string} specifier\n *   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.\n * @param {URL} base\n *   Full URL (to a file) that `specifier` is resolved relative from.\n * @param {Set<string>} [conditions]\n *   Conditions.\n * @param {boolean} [preserveSymlinks]\n *   Keep symlinks instead of resolving them.\n * @returns {URL}\n *   A URL object to the found thing.\n */\nfunction moduleResolve(specifier, base, conditions, preserveSymlinks) {\n  // Note: The Node code supports `base` as a string (in this internal API) too,\n  // we donâ€™t.\n  const protocol = base.protocol;\n  const isData = protocol === 'data:';\n  const isRemote = isData || protocol === 'http:' || protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  /** @type {URL | undefined} */\n  let resolved;\n\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    try {\n      resolved = new URL$1(specifier, base);\n    } catch (error_) {\n      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);\n      error.cause = error_;\n      throw error\n    }\n  } else if (protocol === 'file:' && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier, base, conditions);\n  } else {\n    try {\n      resolved = new URL$1(specifier);\n    } catch (error_) {\n      // Note: actual code uses `canBeRequiredWithoutScheme`.\n      if (isRemote && !builtinModules.includes(specifier)) {\n        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);\n        error.cause = error_;\n        throw error\n      }\n\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n\n  assert(resolved !== undefined, 'expected to be defined');\n\n  if (resolved.protocol !== 'file:') {\n    return resolved\n  }\n\n  return finalizeResolution(resolved, base, preserveSymlinks)\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * @template {unknown} Value\n * @param {Value} self\n * @returns {Value is URL}\n */\nfunction isURL(self) {\n  return Boolean(\n    self &&\n      typeof self === 'object' &&\n      'href' in self &&\n      typeof self.href === 'string' &&\n      'protocol' in self &&\n      typeof self.protocol === 'string' &&\n      self.href &&\n      self.protocol\n  )\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n *\n * @param {unknown} parentURL\n * @returns {asserts parentURL is URL | string | undefined}\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return // Main entry point, so no parent\n  }\n\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      'parentURL',\n      ['string', 'URL'],\n      parentURL\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction defaultResolve(specifier, context = {}) {\n  const {parentURL} = context;\n  assert(parentURL !== undefined, 'expected `parentURL` to be defined');\n  throwIfInvalidParentURL(parentURL);\n\n  /** @type {URL | undefined} */\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL$1(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL | undefined} */\n  let parsed;\n  /** @type {string | undefined} */\n  let protocol;\n\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL$1(specifier, parsedParentURL)\n      : new URL$1(specifier);\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    protocol = parsed.protocol;\n\n    if (protocol === 'data:') {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (protocol === undefined && parsed) {\n    protocol = parsed.protocol;\n  }\n\n  if (protocol === 'node:') {\n    return {url: specifier}\n  }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  const conditions = getConditionsSet(context.conditions);\n\n  const url = moduleResolve(specifier, new URL$1(parentURL), conditions, false);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string | null}}\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n\n    if (parentProtocol === 'http:' || parentProtocol === 'https:') {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n\n        // `data:` and `blob:` disallowed due to allowing file: access via\n        // indirection\n        if (\n          parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            'remote imports cannot import from a local location.'\n          )\n        }\n\n        return {url: parsed?.href || ''}\n      }\n\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'only relative and absolute specifiers are supported.'\n      )\n    }\n  }\n}\n\n// Note: this is from:\n// <https://github.com/nodejs/node/blob/3e74590/lib/internal/url.js#L687>\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n