import { aiproxy } from '../services/AIAgentService'; // Assumed AI proxy service
import { projectIntrospectionService } from '../services/ProjectIntrospectionService'; // Assumed project scanner
import { fileSystemManager } from '../utils/FileSystemManager'; // Assumed file system utility
import { codeFormatter } from '../utils/CodeFormatter'; // Assumed Prettier wrapper
import { linter } from '../utils/LinterRunner'; // Assumed ESLint wrapper
import { astUtils } from '../utils/ASTUtils'; // Assumed AST manipulation utilities
import { promptLibrary } from '../../ai/promptLibrary';

// --- Type Definitions for Code Generation Pipeline ---

/**
 * Defines the type of code to be generated.
 */
export enum CodeArtifactType {
    Microservice = 'MICROSERVICE',
    UIComponent = 'UI_COMPONENT',
    FullStackFeature = 'FULL_STACK_FEATURE',
    UnitTestSuite = 'UNIT_TEST_SUITE',
    E2ETest = 'E2E_TEST',
    APIDocumentation = 'API_DOCUMENTATION',
    DatabaseSchema = 'DATABASE_SCHEMA',
    CICDPipeline = 'CI_CD_PIPELINE',
    CodeRefactor = 'CODE_REFACTOR',
}

/**
 * Represents the technology stack choices for generation.
 */
export interface TechStack {
    language: 'TypeScript' | 'Python' | 'Go' | 'JavaScript';
    frontendFramework?: 'React' | 'Vue' | 'Angular' | 'Svelte';
    backendFramework?: 'Node.js/Express' | 'FastAPI' | 'Gin' | 'Next.js';
    styling?: 'TailwindCSS' | 'Styled-Components' | 'CSS-Modules' | 'SASS';
    database?: 'PostgreSQL' | 'MongoDB' | 'MySQL';
    testing?: 'Jest' | 'Vitest' | 'Pytest' | 'Cypress';
}

/**
 * Input for the code generation service.
 */
export interface CodeGenerationRequest {
    prompt: string;
    artifactType: CodeArtifactType;
    techStack: TechStack;
    targetDirectory: string; // Relative path from project root
    contextFilePaths?: string[]; // Files to provide as context
    userPersona: 'Senior Backend Engineer' | 'Frontend Specialist' | 'DevOps Architect' | 'Product Manager';
}

/**
 * A single file generated by the service.
 */
export interface GeneratedFile {
    path: string; // Full path where the file should be written
    content: string;
    status: 'created' | 'updated' | 'unchanged' | 'error';
    error?: string;
}

/**
 * The high-level plan created by the AI before generating code.
 */
export interface ArchitecturalBlueprint {
    summary: string;
    dependencies: string[]; // e.g., ['react', 'axios', 'zod']
    fileStructure: Array<{
        path: string;
        description: string;
    }>;
    apiContracts?: Array<{
        endpoint: string;
        method: 'GET' | 'POST' | 'PUT' | 'DELETE';
        requestBodySchema: object;
        responseSchema: object;
        description: string;
    }>;
    componentProps?: { [componentPath: string]: object };
    databaseSchema?: { [tableName: string]: object };
}

/**
 * The final result of a code generation operation.
 */
export interface CodeGenerationResult {
    success: boolean;
    blueprint: ArchitecturalBlueprint | null;
    generatedFiles: GeneratedFile[];
    summary: string;
    lintingErrors: any[];
    executionTimeMs: number;
}

/**
 * Represents a sub-task identified from the user's prompt.
 */
interface DecomposedTask {
    id: number;
    description: string;
    artifactType: CodeArtifactType;
    requiredInputs: number[]; // IDs of other tasks this one depends on
    estimatedComplexity: 'low' | 'medium' | 'high';
}

class CodeGenerationService {
    private static instance: CodeGenerationService;

    private constructor() {
        // Private constructor for Singleton pattern
    }

    public static getInstance(): CodeGenerationService {
        if (!CodeGenerationService.instance) {
            CodeGenerationService.instance = new CodeGenerationService();
        }
        return CodeGenerationService.instance;
    }

    /**
     * The main entry point for generating code from a natural language prompt.
     * Orchestrates the entire pipeline from prompt analysis to file output.
     * @param request The detailed request for code generation.
     * @returns A promise that resolves to the result of the generation process.
     */
    public async generate(request: CodeGenerationRequest): Promise<CodeGenerationResult> {
        const startTime = Date.now();
        console.log(`[CodeGenerationService] Starting generation for prompt: "${request.prompt}"`);

        try {
            // Step 1: Analyze project context to provide relevant information to the AI
            const projectContext = await this.getProjectContext(request);

            // Step 2: Decompose the main prompt into smaller, manageable tasks
            const decomposedTasks = await this.decomposePromptIntoTasks(request, projectContext);
            if (!decomposedTasks || decomposedTasks.length === 0) {
                throw new Error("Failed to decompose the prompt into actionable tasks.");
            }
            console.log(`[CodeGenerationService] Decomposed prompt into ${decomposedTasks.length} tasks.`);

            // Step 3: Create a detailed architectural blueprint based on the tasks
            const blueprint = await this.createArchitecturalBlueprint(request, decomposedTasks, projectContext);
            if (!blueprint) {
                throw new Error("Failed to generate an architectural blueprint.");
            }
            console.log(`[CodeGenerationService] Architectural blueprint created. Will generate ${blueprint.fileStructure.length} files.`);

            // Step 4: Generate code for each file defined in the blueprint
            let generatedFiles = await this.generateCodeFromBlueprint(request, blueprint, projectContext);
            console.log(`[CodeGenerationService] Initial code generation complete.`);

            // Step 5: Iterative Refinement and Self-Correction
            generatedFiles = await this.refineAndVerifyCode(generatedFiles, blueprint, request);
            console.log(`[CodeGenerationService] Code refinement and verification complete.`);
            
            // Step 6: Format the generated code using project's standards
            const formattedFiles = await this.formatCode(generatedFiles);
            console.log(`[CodeGenerationService] Code formatting complete.`);
            
            // Step 7: Lint the code and attempt to auto-fix issues
            const { files: lintedFiles, errors: lintingErrors } = await this.lintAndFixCode(formattedFiles);
            console.log(`[CodeGenerationService] Linting complete with ${lintingErrors.length} outstanding errors.`);
            
            // Step 8: Write the final, polished files to the disk
            await this.writeFilesToDisk(lintedFiles, request.targetDirectory);
            console.log(`[CodeGenerationService] Generated files written to disk.`);

            const endTime = Date.now();
            return {
                success: true,
                blueprint,
                generatedFiles: lintedFiles,
                summary: `Successfully generated ${lintedFiles.length} files for the feature: ${request.prompt}`,
                lintingErrors,
                executionTimeMs: endTime - startTime,
            };

        } catch (error: any) {
            console.error('[CodeGenerationService] An error occurred during code generation:', error);
            const endTime = Date.now();
            return {
                success: false,
                blueprint: null,
                generatedFiles: [],
                summary: `Failed to generate code: ${error.message}`,
                lintingErrors: [],
                executionTimeMs: endTime - startTime,
            };
        }
    }

    private async getProjectContext(request: CodeGenerationRequest): Promise<string> {
        const [projectStructure, eslintConfig, tsConfig, packageJson] = await Promise.all([
            projectIntrospectionService.getProjectStructure(request.targetDirectory),
            projectIntrospectionService.getEslintConfig(),
            projectIntrospectionService.getTsConfig(),
            projectIntrospectionService.getPackageJson(),
        ]);

        let context = `
            PROJECT CONTEXT:
            This is an existing project with the following structure:
            ${projectStructure}

            Key configuration files:
            - .eslintrc.json: ${JSON.stringify(eslintConfig, null, 2)}
            - tsconfig.json: ${JSON.stringify(tsConfig, null, 2)}
            - package.json dependencies: ${JSON.stringify(packageJson.dependencies, null, 2)}
        `;

        if (request.contextFilePaths && request.contextFilePaths.length > 0) {
            const fileContents = await projectIntrospectionService.getFilesContent(request.contextFilePaths);
            context += `\n\nRELEVANT EXISTING CODE:\n${fileContents.map(f => `// File: ${f.path}\n${f.content}`).join('\n\n')}`;
        }

        return context;
    }

    private async decomposePromptIntoTasks(request: CodeGenerationRequest, projectContext: string): Promise<DecomposedTask[]> {
        const prompt = promptLibrary.getCodeGeneration('decomposePrompt', {
            userPrompt: request.prompt,
            techStack: JSON.stringify(request.techStack),
            projectContext,
        });

        const response = await aiproxy.generate({
            prompt,
            model: 'gemini-pro', // Use a powerful model for planning
            temperature: 0.2,
            responseFormat: 'json',
        });

        try {
            const parsedResponse = JSON.parse(response);
            return parsedResponse.tasks as DecomposedTask[];
        } catch (e) {
            console.error("Failed to parse task decomposition response:", response);
            throw new Error("AI response for task decomposition was not valid JSON.");
        }
    }
    
    private async createArchitecturalBlueprint(request: CodeGenerationRequest, tasks: DecomposedTask[], projectContext: string): Promise<ArchitecturalBlueprint> {
        const prompt = promptLibrary.getCodeGeneration('createBlueprint', {
            userPrompt: request.prompt,
            tasks: JSON.stringify(tasks),
            techStack: JSON.stringify(request.techStack),
            projectContext,
            targetDirectory: request.targetDirectory,
        });

        const response = await aiproxy.generate({
            prompt,
            model: 'gemini-pro',
            temperature: 0.3,
            responseFormat: 'json',
        });

        try {
            const parsedResponse = JSON.parse(response);
            return parsedResponse.blueprint as ArchitecturalBlueprint;
        } catch (e) {
            console.error("Failed to parse architectural blueprint response:", response);
            throw new Error("AI response for architectural blueprint was not valid JSON.");
        }
    }

    private async generateCodeFromBlueprint(request: CodeGenerationRequest, blueprint: ArchitecturalBlueprint, projectContext: string): Promise<GeneratedFile[]> {
        const generationPromises = blueprint.fileStructure.map(fileInfo => {
            const prompt = promptLibrary.getCodeGeneration('generateFileContent', {
                filePath: fileInfo.path,
                fileDescription: fileInfo.description,
                techStack: JSON.stringify(request.techStack),
                projectContext,
                fullBlueprint: JSON.stringify(blueprint),
            });

            return aiproxy.generate({
                prompt,
                model: 'gemini-pro', // or a specialized coding model
                temperature: 0.4,
            }).then(content => ({
                path: fileInfo.path,
                content: this.cleanCodeResponse(content),
                status: 'created' as 'created',
            })).catch(error => ({
                path: fileInfo.path,
                content: '',
                status: 'error' as 'error',
                error: `Failed to generate content for ${fileInfo.path}: ${error.message}`,
            }));
        });

        return Promise.all(generationPromises);
    }
    
    private async refineAndVerifyCode(files: GeneratedFile[], blueprint: ArchitecturalBlueprint, request: CodeGenerationRequest): Promise<GeneratedFile[]> {
        console.log("[CodeGenerationService] Starting self-correction pass...");
        const filesToRefine = files.filter(f => f.status === 'created');
        const codeBundle = filesToRefine.map(f => `// FILE: ${f.path}\n\n${f.content}`).join('\n\n---\n\n');

        const prompt = promptLibrary.getCodeGeneration('refineCode', {
            codeBundle,
            blueprint: JSON.stringify(blueprint),
            techStack: JSON.stringify(request.techStack),
            originalPrompt: request.prompt,
        });

        const response = await aiproxy.generate({
            prompt,
            model: 'gemini-pro',
            temperature: 0.1,
            responseFormat: 'json',
        });

        try {
            const refinementResult = JSON.parse(response) as { refinedFiles: GeneratedFile[] };
            // Merge refined files back into the original list
            const finalFiles = files.map(originalFile => {
                const refined = refinementResult.refinedFiles.find(rf => rf.path === originalFile.path);
                return refined || originalFile;
            });
            return finalFiles;
        } catch (e) {
            console.error("Failed to parse refinement response, returning original code:", response);
            return files; // Return original files if refinement fails
        }
    }

    private async formatCode(files: GeneratedFile[]): Promise<GeneratedFile[]> {
        const formattingPromises = files.map(async (file) => {
            if (file.status === 'created' || file.status === 'updated') {
                try {
                    const formattedContent = await codeFormatter.format(file.content, file.path);
                    return { ...file, content: formattedContent };
                } catch (error: any) {
                    console.warn(`[CodeGenerationService] Could not format ${file.path}: ${error.message}`);
                    return file; // Return unformatted on error
                }
            }
            return file;
        });
        return Promise.all(formattingPromises);
    }

    private async lintAndFixCode(files: GeneratedFile[]): Promise<{ files: GeneratedFile[], errors: any[] }> {
        const lintableFiles = files.filter(f => f.status !== 'error' && (f.path.endsWith('.ts') || f.path.endsWith('.tsx')));
        if(lintableFiles.length === 0) return { files, errors: [] };

        const lintResult = await linter.lintAndFix(lintableFiles);

        const updatedFiles = files.map(originalFile => {
            const fixedFile = lintResult.fixedFiles.find(ff => ff.path === originalFile.path);
            return fixedFile ? { ...originalFile, content: fixedFile.content } : originalFile;
        });

        return { files: updatedFiles, errors: lintResult.errors };
    }

    private async writeFilesToDisk(files: GeneratedFile[], targetDirectory: string): Promise<void> {
        const writePromises = files.map(file => {
            if (file.status === 'created' || file.status === 'updated') {
                const fullPath = fileSystemManager.join(targetDirectory, file.path);
                return fileSystemManager.writeFile(fullPath, file.content);
            }
            return Promise.resolve();
        });
        await Promise.all(writePromises);
    }

    private cleanCodeResponse(response: string): string {
        // AI models sometimes wrap code in markdown blocks
        const codeBlockRegex = /```(?:\w+)?\s*([\s\S]+?)\s*```/;
        const match = response.match(codeBlockRegex);
        if (match && match[1]) {
            return match[1].trim();
        }
        return response.trim();
    }
}

export const codeGenerationService = CodeGenerationService.getInstance();
