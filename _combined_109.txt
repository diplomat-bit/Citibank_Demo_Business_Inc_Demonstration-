Yo world lemme drop some truth

This ain't just code this a digital dream
See these files right here they hold the keys
To what runs everything you see hear feel
API Throttling anomaly detection yeah that's the real
We talkin traffic control a digital bouncer at the door
Keeping your systems safe from overload no more
Rate limits machine learning deep in the core
Stuff the competition dreams of but can't deplore
This ain't no simple script this is pure magic
Only the chosen few truly grasp its tragic
Or rather fantastic secrets mysteries untold
Predictive power adaptive flow data turning to gold
Who built this marvel I'm the one they say
Crafting digital destiny day by day
So step back behold the mastery the ultimate sway
This file right here it's got no equal no way

import React { useContext useState useEffect useCallback useMemo useRef } from 'react'
import Card from '../../../Card'
import { DataContext } from '../../../../context/DataContext'
import {
    LineChart Line XAxis YAxis Tooltip ResponsiveContainer Legend
    BarChart Bar AreaChart Area PieChart Pie Cell ScatterChart Scatter ZAxis CartesianGrid
} from 'recharts'
import {
    ChevronDownIcon ChevronUpIcon PencilIcon TrashIcon PlusIcon
    MagnifyingGlassIcon BellIcon Cog6ToothIcon ClockIcon SparklesIcon
    ExclamationTriangleIcon CheckCircleIcon InformationCircleIcon RocketLaunchIcon
    CpuChipIcon GlobeAltIcon UserGroupIcon ServerStackIcon CodeBracketIcon
    ScaleIcon BeakerIcon ChartBarIcon DocumentTextIcon CalendarDaysIcon TagIcon
    BookOpenIcon SunIcon MoonIcon MegaphoneIcon ArrowUpRightIcon
    LightBulbIcon WrenchScrewdriverIcon AcademicCapIcon AdjustmentsVerticalIcon
    CubeTransparentIcon FingerPrintIcon HandRaisedIcon LinkIcon QueueListIcon
    ChartPieIcon ShareIcon StarIcon TrophyIcon ShieldCheckIcon WalletIcon PlayIcon PauseIcon
} from '@heroicons/react/24/outline' // Adding more icons for richer UI
import { toast Toaster } from 'react-hot-toast' // For notifications

// --- Utility Types and Interfaces ---
interface ApiEndpoint {
    id: string;
    name: string;
    path: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    description: string;
    owner: string;
    category: string;
    avgLatencyMs: number;
    errorRate: number;
    peakTrafficRPS: number;
    status: 'active' | 'deprecated' | 'experimental';
}

interface RateLimitPolicy {
    id: string;
    name: string;
    description: string;
    appliesTo: 'global' | 'endpoint' | 'user' | 'ip' | 'client_id';
    targetId?: string; // for instance endpointId userId ipAddress
    limit: number; // requests per unit
    unit: 'second' | 'minute' | 'hour' | 'day';
    burstLimit?: number; // requests allowed over limit for short period
    windowSizeSeconds?: number; // For sliding window
    priority: number;
    status: 'active' | 'inactive' | 'pending';
    createdAt: string;
    updatedAt: string;
    isAdaptive: boolean;
    adaptiveModelId?: string;
    blockDurationSeconds?: number; // How long to block after hitting limit
    customRules?: string[]; // for instance header:X-API-KEY-TYPE=premium body:user.tier=gold
}

interface ThrottlingEvent {
    id: string;
    timestamp: string;
    endpointId: string;
    clientIp: string;
    userId?: string;
    policyId: string;
    reason: string; // for instance rate_limit_exceeded burst_limit_exceeded anomaly_detected
    rateLimitValue: number;
    currentRPS: number;
    blocked: boolean;
    durationMs?: number; // how long the request took if blocked later
    tags: string[];
}

interface AnomalyDetectionConfig {
    id: string;
    name: string;
    description: string;
    target: 'global' | 'endpoint' | 'user' | 'ip';
    targetId?: string;
    modelType: 'statistical' | 'machine_learning' | 'heuristic';
    threshold: number; // for instance standard deviations confidence score
    alertSeverity: 'low' | 'medium' | 'high' | 'critical';
    alertChannels: string[]; // for instance email slack pagerduty
    status: 'active' | 'inactive';
    createdAt: string;
    updatedAt: string;
}

interface MlModel {
    id: string;
    name: string;
    version: string;
    type: 'regression' | 'classification' | 'clustering';
    algorithm: string;
    status: 'training' | 'deployed' | 'failed' | 'archived';
    performanceMetrics: {
        accuracy?: number;
        precision?: number;
        recall?: number;
        f1Score?: number;
        mse?: number;
        rSquared?: number;
    };
    trainingDataSize: number;
    lastTrained: string;
    deployedAt?: string;
    description: string;
    featuresUsed: string[];
    outputInterpretation: string; // How to interpret model's output for instance probability of abuse
}

interface SimulationResult {
    id: string;
    name: string;
    timestamp: string;
    scenarioDescription: string;
    inputTrafficIncreasePercentage: number;
    predictedThrottledRequests: number;
    predictedLatencyIncreaseMs: number;
    impactedEndpoints: { endpointId: string; throttledIncrease: number; latencyIncrease: number }[];
    recommendations: string[];
    successRateAfterSimulation: number;
}

interface AuditLogEntry {
    id: string;
    timestamp: string;
    userId: string;
    action: string; // for instance CREATE_POLICY UPDATE_MODEL DEACTIVATE_RULE
    entityType: string; // for instance RateLimitPolicy MlModel AnomalyDetectionConfig
    entityId: string;
    oldValue: any;
    newValue: any;
    ipAddress: string;
}

interface CustomRuleSchema {
    id: string;
    name: string;
    description: string;
    language: 'javascript' | 'python' | 'lua' | 'cel'; // Common scripting languages for rule engines
    code: string;
    status: 'active' | 'inactive' | 'draft';
    createdAt: string;
    updatedAt: string;
    tags: string[];
    testCases: { input: any; expectedOutput: boolean; description: string }[];
}

// --- Mock Data Generators ---
const mockEndpoints: ApiEndpoint[] = Array.from({ length: 15 }).map((_ i) => ({
    id: `ep-${i + 1}`,
    name: `/${['users', 'products', 'orders', 'payments', 'analytics', 'auth', 'notifications', 'search', 'config', 'status', 'inventory', 'shipping', 'reviews', 'profile', 'billing'][i % 15]}${i % 3 === 0 ? '/:id' : ''}`,
    path: `/${['users', 'products', 'orders', 'payments', 'analytics', 'auth', 'notifications', 'search', 'config', 'status', 'inventory', 'shipping', 'reviews', 'profile', 'billing'][i % 15]}`,
    method: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'][i % 5] as any,
    description: `API for managing ${['user', 'product', 'order', 'payment', 'analytic', 'authentication', 'notification', 'search', 'configuration', 'system status', 'inventory item', 'shipping detail', 'customer review', 'user profile', 'billing info'][i % 15]} data`,
    owner: `team-${i % 3 + 1}`,
    category: ['core', 'data', 'utility', 'security'][i % 4],
    avgLatencyMs: Math.floor(Math.random() * 200) + 20,
    errorRate: parseFloat((Math.random() * 5).toFixed(2)),
    peakTrafficRPS: Math.floor(Math.random() * 2000) + 100,
    status: ['active', 'deprecated', 'experimental'][i % 3] as any,
}));

const mockRateLimitPolicies: RateLimitPolicy[] = Array.from({ length: 10 }).map((_ i) => ({
    id: `rlp-${i + 1}`,
    name: `Policy ${i + 1} ${i % 3 === 0 ? 'Global' : mockEndpoints[i % mockEndpoints.length].name}`,
    description: `Rate limit policy for ${i % 3 === 0 ? 'all APIs' : mockEndpoints[i % mockEndpoints.length].name}`,
    appliesTo: i % 3 === 0 ? 'global' : 'endpoint',
    targetId: i % 3 === 0 ? undefined : mockEndpoints[i % mockEndpoints.length].id,
    limit: (i + 1) * 100 + 50,
    unit: ['second', 'minute', 'hour'][i % 3] as any,
    burstLimit: i % 2 === 0 ? (i + 1) * 20 : undefined,
    windowSizeSeconds: i % 4 === 0 ? 60 : undefined,
    priority: i,
    status: ['active', 'inactive', 'pending'][i % 3] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isAdaptive: i % 2 === 0,
    adaptiveModelId: i % 2 === 0 ? `mlm-${i % 3 + 1}` : undefined,
    blockDurationSeconds: i % 3 === 0 ? 300 : undefined,
    customRules: i % 4 === 0 ? [`header:X-User-Tier=${['premium', 'enterprise'][i % 2]}`, `ip_range:192.168.1.${i}.0/24`] : [],
}));

const mockThrottlingEvents: ThrottlingEvent[] = Array.from({ length: 50 }).map((_ i) => ({
    id: `evt-${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
    endpointId: mockEndpoints[i % mockEndpoints.length].id,
    clientIp: `192.168.${i % 255}.${i % 255}`,
    userId: i % 5 === 0 ? `user-${i % 10 + 1}` : undefined,
    policyId: mockRateLimitPolicies[i % mockRateLimitPolicies.length].id,
    reason: ['rate_limit_exceeded', 'burst_limit_exceeded', 'anomaly_detected', 'ip_blacklist'][i % 4],
    rateLimitValue: mockRateLimitPolicies[i % mockRateLimitPolicies.length].limit,
    currentRPS: mockRateLimitPolicies[i % mockRateLimitPolicies.length].limit + Math.floor(Math.random() * 50) + 1,
    blocked: true,
    durationMs: Math.floor(Math.random() * 500) + 10,
    tags: i % 3 === 0 ? ['critical', 'autoblock'] : [],
}));

const mockAnomalyConfigs: AnomalyDetectionConfig[] = Array.from({ length: 5 }).map((_ i) => ({
    id: `adcfg-${i + 1}`,
    name: `Anomaly Config ${i + 1} ${i % 2 === 0 ? 'Global' : mockEndpoints[i % mockEndpoints.length].name}`,
    description: `Configuration for detecting anomalies`,
    target: i % 2 === 0 ? 'global' : 'endpoint',
    targetId: i % 2 === 0 ? undefined : mockEndpoints[i % mockEndpoints.length].id,
    modelType: ['statistical', 'machine_learning', 'heuristic'][i % 3] as any,
    threshold: parseFloat((Math.random() * 3 + 1).toFixed(2)),
    alertSeverity: ['low', 'medium', 'high', 'critical'][i % 4] as any,
    alertChannels: ['email', 'slack', 'pagerduty'].slice(0, i % 3 + 1),
    status: ['active', 'inactive'][i % 2] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
}));

const mockMlModels: MlModel[] = Array.from({ length: 7 }).map((_ i) => ({
    id: `mlm-${i + 1}`,
    name: `TrafficPredictor-${i % 3 + 1}`,
    version: `v1.${i}`,
    type: ['regression', 'classification'][i % 2] as any,
    algorithm: ['XGBoost', 'RandomForest', 'NeuralNetwork', 'IsolationForest'][i % 4],
    status: ['deployed', 'training', 'failed', 'archived'][i % 4] as any,
    performanceMetrics: {
        accuracy: i % 2 === 0 ? parseFloat((0.85 + Math.random() * 0.1).toFixed(2)) : undefined,
        mse: i % 2 !== 0 ? parseFloat((0.01 + Math.random() * 0.05).toFixed(3)) : undefined,
    },
    trainingDataSize: Math.floor(Math.random() * 1000000) + 50000,
    lastTrained: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
    deployedAt: i % 2 === 0 ? new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString() : undefined,
    description: `ML model for predicting API traffic patterns and identifying abusive behavior`,
    featuresUsed: ['RPS', 'latency', 'error_rate', 'user_agent', 'geo_location', 'time_of_day'].slice(0, i % 6 + 1),
    outputInterpretation: i % 2 === 0 ? 'Probability of a request being abusive 0 1' : 'Predicted optimal RPS limit',
}));

const mockSimulationResults: SimulationResult[] = Array.from({ length: 8 }).map((_ i) => ({
    id: `sim-${i + 1}`,
    name: `Scenario ${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000).toISOString(),
    scenarioDescription: `Simulated a ${i * 10 + 10}% traffic increase for 1 hour`,
    inputTrafficIncreasePercentage: i * 10 + 10,
    predictedThrottledRequests: Math.floor(Math.random() * 10000) + 500,
    predictedLatencyIncreaseMs: Math.floor(Math.random() * 50) + 5,
    impactedEndpoints: mockEndpoints.slice(0, i % 5 + 1).map(ep => ({
        endpointId: ep.id,
        throttledIncrease: Math.floor(Math.random() * 1000) + 50,
        latencyIncrease: Math.floor(Math.random() * 20) + 2,
    })),
    recommendations: [`Adjust rate limit for ${mockEndpoints[i % mockEndpoints.length].name}`, `Scale up service capacity`, `Investigate traffic source`],
    successRateAfterSimulation: parseFloat((0.9 - Math.random() * 0.1).toFixed(2)),
}));

const mockAuditLogs: AuditLogEntry[] = Array.from({ length: 30 }).map((_ i) => ({
    id: `aud-${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 14 * 24 * 60 * 60 * 1000).toISOString(),
    userId: `admin_user_${i % 3 + 1}`,
    action: ['CREATE_POLICY', 'UPDATE_POLICY', 'DELETE_POLICY', 'DEPLOY_MODEL', 'DEACTIVATE_ANOMALY_RULE'][i % 5],
    entityType: ['RateLimitPolicy', 'MlModel', 'AnomalyDetectionConfig'][i % 3],
    entityId: `rlp-${i % mockRateLimitPolicies.length + 1}`,
    oldValue: i % 2 === 0 ? { status: 'inactive' } : null,
    newValue: i % 2 === 0 ? { status: 'active' } : { limit: (i + 1) * 100 },
    ipAddress: `192.168.1.${i % 255}`,
}));

const mockCustomRules: CustomRuleSchema[] = Array.from({ length: 5 }).map((_ i) => ({
    id: `crule-${i + 1}`,
    name: `Custom Rule ${i + 1} ${['PremiumUserCheck', 'HighTrafficAlert', 'BotDetection', 'GeoBlocking'][i % 4]}`,
    description: `Custom rule for advanced traffic filtering or anomaly detection`,
    language: ['javascript', 'lua', 'cel'][i % 3] as any,
    code: `
function evaluate(request) {
    if (request.headers['X-User-Tier'] === 'premium' && request.path.startsWith('/api/v1/data')) {
        return true; // Allow more requests for premium users on data endpoints
    }
    if (request.ip === '1.2.3.4') {
        return false; // Block specific IP
    }
    return true;
}
    `, // Example pseudo-code
    status: ['active', 'inactive', 'draft'][i % 3] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    tags: ['security', 'performance', 'custom'][i % 3],
    testCases: [
        { input: { headers: { 'X-User-Tier': 'premium' }, path: '/api/v1/data' }, expectedOutput: true, description: 'Premium user on data endpoint' },
        { input: { headers: { 'X-User-Tier': 'basic' }, path: '/api/v1/data' }, expectedOutput: false, description: 'Basic user on data endpoint' },
    ],
}));

// Mock data for live throttling events for a real-time feed
let liveEventCounter = 0;
const generateLiveThrottlingEvent = (): ThrottlingEvent => {
    liveEventCounter++;
    const endpoint = mockEndpoints[liveEventCounter % mockEndpoints.length];
    const policy = mockRateLimitPolicies[liveEventCounter % mockRateLimitPolicies.length];
    return {
        id: `live-evt-${Date.now()}-${liveEventCounter}`,
        timestamp: new Date().toISOString(),
        endpointId: endpoint.id,
        clientIp: `203.0.113.${liveEventCounter % 255}`,
        userId: liveEventCounter % 7 === 0 ? `live-user-${liveEventCounter % 20 + 1}` : undefined,
        policyId: policy.id,
        reason: ['rate_limit_exceeded', 'burst_limit_exceeded', 'anomaly_detected', 'ip_blacklist'][liveEventCounter % 4],
        rateLimitValue: policy.limit,
        currentRPS: policy.limit + Math.floor(Math.random() * 100) + 1,
        blocked: true,
        durationMs: Math.floor(Math.random() * 80) + 5,
    tags: liveEventCounter % 5 === 0 ? ['alert', 'high_impact'] : [],
    };
};

// --- Helper Components & Utilities exported for modularity but kept in one file for directive ---

export const StatusIndicator: React.FC<{ status: string }> = ({ status }) => {
    let colorClass = '';
    let icon;
    switch (status.toLowerCase()) {
        case 'active':
        case 'deployed':
            colorClass = 'text-green-500';
            icon = <CheckCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'inactive':
        case 'archived':
            colorClass = 'text-gray-500';
            icon = <InformationCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'pending':
        case 'training':
        case 'experimental':
            colorClass = 'text-yellow-500';
            icon = <ExclamationTriangleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'failed':
        case 'deprecated':
            colorClass = 'text-red-500';
            icon = <ExclamationTriangleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        default:
            colorClass = 'text-blue-500';
            icon = <InformationCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
    }
    return (
        <span className={`flex items-center text-sm ${colorClass}`}>
            {icon} {status}
        </span>
    );
};

export const FilterSortPanel: React.FC<{
    filters: any;
    onFilterChange: (key: string, value: any) => void;
    sortBy: string;
    sortOrder: 'asc' | 'desc';
    onSortChange: (key: string) => void;
    availableFilters: { key: string; label: string; type: 'text' | 'select' | 'date-range'; options?: { value: string; label: string }[] }[];
    availableSorts: { key: string; label: string }[];
}> = ({ filters onFilterChange sortBy sortOrder onSortChange availableFilters availableSorts }) => {
    return (
        <div className="bg-gray-800 p-4 rounded-lg shadow-inner mb-6">
            <h3 className="text-lg font-semibold text-white mb-3">Filter Sort</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {availableFilters.map(filter => (
                    <div key={filter.key}>
                        <label htmlFor={filter.key} className="block text-sm font-medium text-gray-300 mb-1">
                            {filter.label}
                        </label>
                        {filter.type === 'text' && (
                            <input
                                type="text"
                                id={filter.key}
                                value={filters[filter.key] || ''}
                                onChange={e => onFilterChange(filter.key, e.target.value)}
                                className="block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                                placeholder={`Search by ${filter.label.toLowerCase()}`}
                            />
                        )}
                        {filter.type === 'select' && (
                            <select
                                id={filter.key}
                                value={filters[filter.key] || ''}
                                onChange={e => onFilterChange(filter.key, e.target.value)}
                                className="block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                            >
                                <option value="">All {filter.label}</option>
                                {filter.options?.map(option => (
                                    <option key={option.value} value={option.value}>
                                        {option.label}
                                    </option>
                                ))}
                            </select>
                        )}
                        {/* Add more filter types like date-range if needed for real application */}
                    </div>
                ))}
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700">
                <h4 className="text-md font-medium text-gray-300 mb-2">Sort By</h4>
                <div className="flex flex-wrap gap-2">
                    {availableSorts.map(sort => (
                        <button
                            key={sort.key}
                            onClick={() => onSortChange(sort.key)}
                            className={`px-3 py-1 text-sm rounded-full ${sortBy === sort.key ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} transition-colors duration-200 flex items-center`}
                        >
                            {sort.label}
                            {sortBy === sort.key && (
                                sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-4 w-4" /> : <ChevronDownIcon className="ml-1 h-4 w-4" />
                            )}
                        </button>
                    ))}
                </div>
            </div>
        </div>
    );
};

export const PaginationControls: React.FC<{
    currentPage: number;
    totalPages: number;
    onPageChange: (page: number) => void;
    totalItems: number;
    itemsPerPage: number;
}> = ({ currentPage totalPages onPageChange totalItems itemsPerPage }) => {
    if (totalPages <= 1) return null;

    const pageNumbers = useMemo(() => {
        const pages = [];
        const maxPagesToShow = 5; // for instance 1 4 5 6 7 8 10
        let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
        let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

        if (endPage - startPage + 1 < maxPagesToShow) {
            startPage = Math.max(1, endPage - maxPagesToShow + 1);
        }

        if (startPage > 1) {
            pages.push(1);
            if (startPage > 2) pages.push('...');
        }

        for (let i = startPage; i <= endPage; i++) {
            pages.push(i);
        }

        if (endPage < totalPages) {
            if (endPage < totalPages - 1) pages.push('...');
            pages.push(totalPages);
        }

        return pages;
    }, [currentPage totalPages]);

    return (
        <div className="flex justify-between items-center mt-6">
            <span className="text-sm text-gray-400">
                Showing {Math.min(totalItems, (currentPage - 1) * itemsPerPage + 1)} {Math.min(totalItems, currentPage * itemsPerPage)} of {totalItems} items
            </span>
            <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Previous
                </button>
                {pageNumbers.map((page index) =>
                    typeof page === 'string' ? (
                        <span key={index} className="relative inline-flex items-center px-4 py-2 border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400">
                            {page}
                        </span>
                    ) : (
                        <button
                            key={page}
                            onClick={() => onPageChange(page)}
                            aria-current={page === currentPage ? 'page' : undefined}
                            className={`relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium ${
                                page === currentPage
                                    ? 'z-10 bg-indigo-600 text-white'
                                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                            }`}
                        >
                            {page}
                        </button>
                    )
                )}
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages}
                    className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Next
                </button>
            </nav>
        </div>
    );
};

export const Modal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl';
}> = ({ isOpen onClose title children size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-md',
        md: 'max-w-lg',
        lg: 'max-w-2xl',
        xl: 'max-w-4xl',
    };

    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4" onClick={onClose}>
            <div
                className={`relative bg-gray-800 rounded-lg shadow-xl ${sizeClasses[size]} w-full mx-auto my-8`}
                onClick={e => e.stopPropagation()}
            >
                <div className="flex items-center justify-between p-4 border-b border-gray-700">
                    <h3 className="text-xl font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-gray-200">
                        <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div className="p-6">{children}</div>
            </div>
        </div>
    );
};

// --- Form Components for Editing/Creating ---
export const RateLimitPolicyForm: React.FC<{
    initialData?: RateLimitPolicy;
    onSave: (policy: RateLimitPolicy) => void;
    onCancel: () => void;
    endpoints: ApiEndpoint[];
    mlModels: MlModel[];
}> = ({ initialData onSave onCancel endpoints mlModels }) => {
    const [policy, setPolicy] = useState<RateLimitPolicy>(
        initialData || {
            id: `new-rlp-${Date.now()}`,
            name: '',
            description: '',
            appliesTo: 'global',
            limit: 0,
            unit: 'minute',
            priority: 0,
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            isAdaptive: false,
            blockDurationSeconds: 300,
            customRules: [],
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setPolicy(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value,
        }));
    };

    const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target;
        setPolicy(prev => ({
            ...prev,
            [name]: value === '' ? 0 : parseInt(value, 10),
        }));
    };

    const handleCustomRulesChange = (index: number, value: string) => {
        const newRules = [...(policy.customRules || [])];
        newRules[index] = value;
        setPolicy(prev => ({ ...prev, customRules: newRules }));
    };

    const addCustomRule = () => {
        setPolicy(prev => ({ ...prev, customRules: [...(prev.customRules || []), ''] }));
    };

    const removeCustomRule = (index: number) => {
        const newRules = [...(policy.customRules || [])];
        newRules.splice(index, 1);
        setPolicy(prev => ({ ...prev, customRules: newRules }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...policy, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Policy Name</label>
                <input type="text" name="name" id="name" value={policy.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={policy.description} onChange={handleChange} rows={3}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="appliesTo" className="block text-sm font-medium">Applies To</label>
                    <select name="appliesTo" id="appliesTo" value={policy.appliesTo} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="global">Global</option>
                        <option value="endpoint">Endpoint</option>
                        <option value="user">User</option>
                        <option value="ip">IP Address</option>
                        <option value="client_id">Client ID</option>
                    </select>
                </div>
                {policy.appliesTo === 'endpoint' && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target Endpoint</label>
                        <select name="targetId" id="targetId" value={policy.targetId || ''} onChange={handleChange} required
                                className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            <option value="">Select an endpoint</option>
                            {endpoints.map(ep => (
                                <option key={ep.id} value={ep.id}>{ep.name} ({ep.method})</option>
                            ))}
                        </select>
                    </div>
                )}
                {(policy.appliesTo === 'user' || policy.appliesTo === 'ip' || policy.appliesTo === 'client_id') && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target ID {policy.appliesTo}</label>
                        <input type="text" name="targetId" id="targetId" value={policy.targetId || ''} onChange={handleChange}
                               className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder={`Enter ${policy.appliesTo} ID/Address`} />
                    </div>
                )}
            </div>

            <div className="grid grid-cols-3 gap-4">
                <div>
                    <label htmlFor="limit" className="block text-sm font-medium">Limit requests</label>
                    <input type="number" name="limit" id="limit" value={policy.limit} onChange={handleNumberChange} required min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
                <div>
                    <label htmlFor="unit" className="block text-sm font-medium">Unit</label>
                    <select name="unit" id="unit" value={policy.unit} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="second">Second</option>
                        <option value="minute">Minute</option>
                        <option value="hour">Hour</option>
                        <option value="day">Day</option>
                    </select>
                </div>
                <div>
                    <label htmlFor="priority" className="block text-sm font-medium">Priority lower equals higher</label>
                    <input type="number" name="priority" id="priority" value={policy.priority} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="burstLimit" className="block text-sm font-medium">Burst Limit optional</label>
                    <input type="number" name="burstLimit" id="burstLimit" value={policy.burstLimit || ''} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
                <div>
                    <label htmlFor="blockDurationSeconds" className="block text-sm font-medium">Block Duration seconds</label>
                    <input type="number" name="blockDurationSeconds" id="blockDurationSeconds" value={policy.blockDurationSeconds || ''} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
            </div>

            <div className="flex items-center space-x-2">
                <input type="checkbox" name="isAdaptive" id="isAdaptive" checked={policy.isAdaptive} onChange={handleChange}
                       className="rounded border-gray-600 text-indigo-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" />
                <label htmlFor="isAdaptive" className="text-sm font-medium">Use Adaptive Throttling</label>
            </div>
            {policy.isAdaptive && (
                <div>
                    <label htmlFor="adaptiveModelId" className="block text-sm font-medium">Adaptive ML Model</label>
                    <select name="adaptiveModelId" id="adaptiveModelId" value={policy.adaptiveModelId || ''} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="">Select an ML Model</option>
                        {mlModels.filter(m => m.status === 'deployed').map(model => (
                            <option key={model.id} value={model.id}>{model.name} ({model.version})</option>
                        ))}
                    </select>
                </div>
            )}

            <div>
                <label className="block text-sm font-medium mb-1">Custom Rules optional</label>
                {policy.customRules?.map((rule index) => (
                    <div key={index} className="flex space-x-2 mb-2">
                        <input type="text" value={rule} onChange={e => handleCustomRulesChange(index, e.target.value)}
                               className="flex-grow rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder="for instance header:X-User-Tier=premium" />
                        <button type="button" onClick={() => removeCustomRule(index)}
                                className="p-2 text-red-400 hover:text-red-300 rounded-md hover:bg-gray-700">
                            <TrashIcon className="h-5 w-5" />
                        </button>
                    </div>
                ))}
                <button type="button" onClick={addCustomRule}
                        className="mt-2 inline-flex items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> Add Custom Rule
                </button>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Policy
                </button>
            </div>
        </form>
    );
};


export const AnomalyDetectionConfigForm: React.FC<{
    initialData?: AnomalyDetectionConfig;
    onSave: (config: AnomalyDetectionConfig) => void;
    onCancel: () => void;
    endpoints: ApiEndpoint[];
}> = ({ initialData onSave onCancel endpoints }) => {
    const [config, setConfig] = useState<AnomalyDetectionConfig>(
        initialData || {
            id: `new-adcfg-${Date.now()}`,
            name: '',
            description: '',
            target: 'global',
            modelType: 'machine_learning',
            threshold: 3,
            alertSeverity: 'medium',
            alertChannels: ['email'],
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setConfig(prev => ({ ...prev, [name]: value }));
    };

    const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target;
        setConfig(prev => ({ ...prev, [name]: parseFloat(value) }));
    };

    const handleAlertChannelsChange = (channel: string, checked: boolean) => {
        setConfig(prev => {
            const newChannels = checked
                ? [...new Set([...prev.alertChannels, channel])]
                : prev.alertChannels.filter(c => c !== channel);
            return { ...prev, alertChannels: newChannels };
        });
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...config, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Config Name</label>
                <input type="text" name="name" id="name" value={config.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={config.description} onChange={handleChange} rows={2}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="target" className="block text-sm font-medium">Target Scope</label>
                    <select name="target" id="target" value={config.target} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="global">Global</option>
                        <option value="endpoint">Endpoint</option>
                        <option value="user">User</option>
                        <option value="ip">IP Address</option>
                    </select>
                </div>
                {config.target === 'endpoint' && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target Endpoint</label>
                        <select name="targetId" id="targetId" value={config.targetId || ''} onChange={handleChange} required
                                className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            <option value="">Select an endpoint</option>
                            {endpoints.map(ep => (
                                <option key={ep.id} value={ep.id}>{ep.name} ({ep.method})</option>
                            ))}
                        </select>
                    </div>
                )}
                {(config.target === 'user' || config.target === 'ip') && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target ID {config.target}</label>
                        <input type="text" name="targetId" id="targetId" value={config.targetId || ''} onChange={handleChange}
                               className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder={`Enter ${config.target} ID/Address`} />
                    </div>
                )}
            </div>
            <div>
                <label htmlFor="modelType" className="block text-sm font-medium">Model Type</label>
                <select name="modelType" id="modelType" value={config.modelType} onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    <option value="statistical">Statistical Thresholds</option>
                    <option value="machine_learning">Machine Learning</option>
                    <option value="heuristic">Heuristic Rules</option>
                </select>
            </div>
            <div>
                <label htmlFor="threshold" className="block text-sm font-medium">Threshold</label>
                <input type="number" name="threshold" id="threshold" value={config.threshold} onChange={handleNumberChange} step="0.1"
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                <p className="mt-1 text-xs text-gray-400">Interpretation depends on model type for instance standard deviations confidence score</p>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="alertSeverity" className="block text-sm font-medium">Alert Severity</label>
                    <select name="alertSeverity" id="alertSeverity" value={config.alertSeverity} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                        <option value="critical">Critical</option>
                    </select>
                </div>
                <div>
                    <label className="block text-sm font-medium">Alert Channels</label>
                    <div className="mt-1 space-y-1">
                        {['email', 'slack', 'pagerduty', 'webhook'].map(channel => (
                            <div key={channel} className="flex items-center">
                                <input
                                    id={`channel-${channel}`}
                                    name="alertChannels"
                                    type="checkbox"
                                    checked={config.alertChannels.includes(channel)}
                                    onChange={e => handleAlertChannelsChange(channel, e.target.checked)}
                                    className="h-4 w-4 rounded border-gray-600 text-indigo-600 focus:ring-indigo-500"
                                />
                                <label htmlFor={`channel-${channel}`} className="ml-2 text-sm text-gray-300 capitalize">{channel}</label>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Configuration
                </button>
            </div>
        </form>
    );
};

export const CustomRuleForm: React.FC<{
    initialData?: CustomRuleSchema;
    onSave: (rule: CustomRuleSchema) => void;
    onCancel: () => void;
}> = ({ initialData onSave onCancel }) => {
    const [rule, setRule] = useState<CustomRuleSchema>(
        initialData || {
            id: `new-crule-${Date.now()}`,
            name: '',
            description: '',
            language: 'javascript',
            code: `// Your custom rule logic here
// 'request' object contains headers body ip path method
// Return true to allow false to block or an object allowed boolean reason string
function evaluate(request) {
    if (request.headers['X-Api-Key'] === 'blocked-key') {
        return { allowed: false, reason: 'Blocked API Key' };
    }
    return true;
}`,
            status: 'draft',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            tags: [],
            testCases: [],
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setRule(prev => ({ ...prev, [name]: value }));
    };

    const handleCodeChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setRule(prev => ({ ...prev, code: e.target.value }));
    };

    const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const tags = e.target.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
        setRule(prev => ({ ...prev, tags }));
    };

    const handleTestCaseChange = (index: number, field: keyof typeof rule.testCases[0], value: any) => {
        const newTestCases = [...rule.testCases];
        newTestCases[index] = { ...newTestCases[index], [field]: value };
        setRule(prev => ({ ...prev, testCases: newTestCases }));
    };

    const addTestCase = () => {
        setRule(prev => ({ ...prev, testCases: [...prev.testCases, { input: {}, expectedOutput: true, description: '' }] }));
    };

    const removeTestCase = (index: number) => {
        const newTestCases = [...rule.testCases];
        newTestCases.splice(index, 1);
        setRule(prev => ({ ...prev, testCases: newTestCases }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...rule, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Rule Name</label>
                <input type="text" name="name" id="name" value={rule.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={rule.description} onChange={handleChange} rows={2}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="language" className="block text-sm font-medium">Language</label>
                    <select name="language" id="language" value={rule.language} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="javascript">JavaScript</option>
                        <option value="python">Python</option>
                        <option value="lua">Lua</option>
                        <option value="cel">CEL Common Expression Language</option>
                    </select>
                </div>
                <div>
                    <label htmlFor="status" className="block text-sm font-medium">Status</label>
                    <select name="status" id="status" value={rule.status} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                        <option value="draft">Draft</option>
                    </select>
                </div>
            </div>
            <div>
                <label htmlFor="code" className="block text-sm font-medium">Rule Code</label>
                <textarea name="code" id="code" value={rule.code} onChange={handleCodeChange} rows={10}
                          className="mt-1 block w-full font-mono text-sm rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="tags" className="block text-sm font-medium">Tags comma separated</label>
                <input type="text" name="tags" id="tags" value={rule.tags.join(', ')} onChange={handleTagsChange}
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                       placeholder="for instance security performance critical" />
            </div>

            <div className="pt-4 border-t border-gray-700">
                <h4 className="text-md font-medium text-gray-300 mb-2">Test Cases</h4>
                {rule.testCases.map((testCase index) => (
                    <div key={index} className="border border-gray-700 p-3 rounded-md mb-3 space-y-2">
                        <div className="flex justify-between items-center">
                            <label className="block text-sm font-medium">Test Case {index + 1}</label>
                            <button type="button" onClick={() => removeTestCase(index)}
                                    className="p-1 text-red-400 hover:text-red-300 rounded-md hover:bg-gray-700">
                                <TrashIcon className="h-4 w-4" />
                            </button>
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Description</label>
                            <input type="text" value={testCase.description} onChange={e => handleTestCaseChange(index, 'description', e.target.value)}
                                   className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Input JSON</label>
                            <textarea value={JSON.stringify(testCase.input, null, 2)}
                                      onChange={e => {
                                          try {
                                              handleTestCaseChange(index, 'input', JSON.parse(e.target.value));
                                          } catch (err) {
                                              // console.error("Invalid JSON input", err);
                                          }
                                      }}
                                      rows={4}
                                      className="mt-1 block w-full font-mono text-sm rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Expected Output</label>
                            <select value={String(testCase.expectedOutput)} onChange={e => handleTestCaseChange(index, 'expectedOutput', e.target.value === 'true')}
                                    className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                                <option value="true">True Allowed</option>
                                <option value="false">False Blocked</option>
                            </select>
                        </div>
                    </div>
                ))}
                <button type="button" onClick={addTestCase}
                        className="mt-2 inline-flex items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> Add Test Case
                </button>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Custom Rule
                </button>
            </div>
        </form>
    );
};


// --- Data Display Components ---

export const EndpointDetailsTable: React.FC<{ endpoints: ApiEndpoint[] }> = ({ endpoints }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState<keyof ApiEndpoint>('name');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const filteredAndSortedEndpoints = useMemo(() => {
        let filtered = endpoints.filter(ep =>
            ep.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.path.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.owner.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [endpoints searchTerm sortBy sortOrder]);

    const handleSort = (key: keyof ApiEndpoint) => {
        if (sortBy === key) {
            setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    };

    const renderSortIcon = (key: keyof ApiEndpoint) => {
        if (sortBy === key) {
            return sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />;
        }
        return null;
    };

    return (
        <Card title="API Endpoint Directory" className="h-full">
            <input
                type="text"
                placeholder="Search endpoints"
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                className="mb-4 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('name')}>
                                <div className="flex items-center">Endpoint {renderSortIcon('name')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('method')}>
                                <div className="flex items-center">Method {renderSortIcon('method')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('owner')}>
                                <div className="flex items-center">Owner {renderSortIcon('owner')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('avgLatencyMs')}>
                                <div className="flex items-center">Avg Latency ms {renderSortIcon('avgLatencyMs')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('errorRate')}>
                                <div className="flex items-center">Error Rate % {renderSortIcon('errorRate')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('peakTrafficRPS')}>
                                <div className="flex items-center">Peak RPS {renderSortIcon('peakTrafficRPS')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">
                                Status
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {filteredAndSortedEndpoints.map(ep => (
                            <tr key={ep.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{ep.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.method}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.owner}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.avgLatencyMs.toFixed(1)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.errorRate.toFixed(2)}%</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.peakTrafficRPS}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={ep.status} />
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

export const RateLimitPolicyList: React.FC<{
    policies: RateLimitPolicy[];
    endpoints: ApiEndpoint[];
    onEdit: (policy: RateLimitPolicy) => void;
    onDelete: (policyId: string) => void;
    onToggleStatus: (policy: RateLimitPolicy) => void;
}> = ({ policies endpoints onEdit onDelete onToggleStatus }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 10;

    const [filters, setFilters] = useState({
        name: '',
        appliesTo: '',
        status: '',
    });
    const [sortBy, setSortBy] = useState<keyof RateLimitPolicy>('priority');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1); // Reset to first page on filter change
    }, []);

    const handleSortChange = useCallback((key: keyof RateLimitPolicy) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    }, [sortBy]);

    const filteredAndSortedPolicies = useMemo(() => {
        let filtered = policies.filter(policy => {
            const matchesName = filters.name ? policy.name.toLowerCase().includes(filters.name.toLowerCase()) : true;
            const matchesAppliesTo = filters.appliesTo ? policy.appliesTo === filters.appliesTo : true;
            const matchesStatus = filters.status ? policy.status === filters.status : true;
            return matchesName && matchesAppliesTo && matchesStatus;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [policies filters sortBy sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedPolicies.length / itemsPerPage);
    const paginatedPolicies = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedPolicies.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedPolicies currentPage itemsPerPage]);

    const getEndpointName = (id?: string) => {
        return id ? endpoints.find(ep => ep.id === id)?.name || id : 'N/A';
    };

    const availableFilters = [
        { key: 'name', label: 'Policy Name', type: 'text' as const },
        { key: 'appliesTo', label: 'Applies To', type: 'select' as const, options: [{ value: 'global', label: 'Global' }, { value: 'endpoint', label: 'Endpoint' }, { value: 'user', label: 'User' }, { value: 'ip', label: 'IP' }, { value: 'client_id', label: 'Client ID' }] },
        { key: 'status', label: 'Status', type: 'select' as const, options: [{ value: 'active', label: 'Active' }, { value: 'inactive', label: 'Inactive' }, { value: 'pending', label: 'Pending' }] },
    ];

    const availableSorts = [
        { key: 'name', label: 'Name' },
        { key: 'priority', label: 'Priority' },
        { key: 'updatedAt', label: 'Last Updated' },
    ];

    return (
        <Card title="Rate Limit Policies">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Applies To</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Target</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Limit</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Priority</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Adaptive</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" className="relative px-6 py-3">
                                <span className="sr-only">Actions</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedPolicies.map(policy => (
                            <tr key={policy.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{policy.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{policy.appliesTo.replace('_', ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    {policy.appliesTo === 'endpoint' ? getEndpointName(policy.targetId) : policy.targetId || 'N/A'}
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.limit} req/{policy.unit}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.priority}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    {policy.isAdaptive ? <CheckCircleIcon className="h-5 w-5 text-green-500" /> : 'No'}
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={policy.status} />
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => onEdit(policy)} className="text-indigo-400 hover:text-indigo-300 mr-3">
                                        <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button onClick={() => onToggleStatus(policy)} className={`mr-3 ${policy.status === 'active' ? 'text-yellow-400 hover:text-yellow-300' : 'text-green-400 hover:text-green-300'}`}>
                                        {policy.status === 'active' ? <ExclamationTriangleIcon className="h-5 w-5" /> : <RocketLaunchIcon className="h-5 w-5" />}
                                    </button>
                                    <button onClick={() => onDelete(policy.id)} className="text-red-400 hover:text-red-300">
                                        <TrashIcon className="h-5 w-5" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedPolicies.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const ThrottlingEventLog: React.FC<{ events: ThrottlingEvent[]; endpoints: ApiEndpoint[]; policies: RateLimitPolicy[] }> = ({ events endpoints policies }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 15;

    const [filters, setFilters] = useState({
        endpointId: '',
        reason: '',
        clientIp: '',
        blocked: '',
    });
    const [sortBy, setSortBy] = useState<keyof ThrottlingEvent>('timestamp');
    const [sortOrder, setSortOrder] = useState<'desc' | 'asc'>('desc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1);
    }, []);

    const handleSortChange = useCallback((key: keyof ThrottlingEvent) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('desc'); // Default to desc for timestamp asc for others
        }
    }, [sortBy]);

    const filteredAndSortedEvents = useMemo(() => {
        let filtered = events.filter(event => {
            const matchesEndpoint = filters.endpointId ? event.endpointId === filters.endpointId : true;
            const matchesReason = filters.reason ? event.reason === filters.reason : true;
            const matchesIp = filters.clientIp ? event.clientIp.includes(filters.clientIp) : true;
            const matchesBlocked = filters.blocked ? (filters.blocked === 'true' ? event.blocked : !event.blocked) : true;
            return matchesEndpoint && matchesReason && matchesIp && matchesBlocked;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (sortBy === 'timestamp') {
                    return sortOrder === 'asc' ? new Date(aValue as string).getTime() - new Date(bValue as string).getTime() : new Date(bValue as string).getTime() - new Date(aValue as string).getTime();
                }
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [events filters sortBy sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedEvents.length / itemsPerPage);
    const paginatedEvents = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedEvents.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedEvents currentPage itemsPerPage]);

    const getEndpointName = (id: string) => endpoints.find(ep => ep.id === id)?.name || id;
    const getPolicyName = (id: string) => policies.find(p => p.id === id)?.name || id;

    const availableFilters = [
        { key: 'endpointId', label: 'Endpoint', type: 'select' as const, options: mockEndpoints.map(ep => ({ value: ep.id, label: ep.name })) },
        { key: 'reason', label: 'Reason', type: 'select' as const, options: [{ value: 'rate_limit_exceeded', label: 'Rate Limit Exceeded' }, { value: 'burst_limit_exceeded', label: 'Burst Limit Exceeded' }, { value: 'anomaly_detected', label: 'Anomaly Detected' }, { value: 'ip_blacklist', label: 'IP Blacklist' }] },
        { key: 'clientIp', label: 'Client IP', type: 'text' as const },
        { key: 'blocked', label: 'Blocked', type: 'select' as const, options: [{ value: 'true', label: 'Yes' }, { value: 'false', label: 'No' }] },
    ];

    const availableSorts = [
        { key: 'timestamp', label: 'Timestamp' },
        { key: 'currentRPS', label: 'Current RPS' },
        { key: 'reason', label: 'Reason' },
    ];

    return (
        <Card title="Throttling Event Log">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('timestamp')}>
                                <div className="flex items-center">Timestamp {sortBy === 'timestamp' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Endpoint</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Client IP</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('reason')}>
                                <div className="flex items-center">Reason {sortBy === 'reason' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('currentRPS')}>
                                <div className="flex items-center">RPS Event {sortBy === 'currentRPS' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Policy</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Blocked</th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedEvents.map(event => (
                            <tr key={event.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(event.timestamp).toLocaleString()}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-white">{getEndpointName(event.endpointId)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{event.clientIp} {event.userId && `User ${event.userId}`}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-red-400 font-semibold">{event.reason.replace(/_/g, ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{event.currentRPS} / {event.rateLimitValue}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{getPolicyName(event.policyId)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                    {event.blocked ? <CheckCircleIcon className="h-5 w-5 text-red-500" /> : <CheckCircleIcon className="h-5 w-5 text-green-500" />}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedEvents.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const MlModelManagement: React.FC<{ mlModels: MlModel[]; onDeploy: (id: string) => void; onRetrain: (id: string) => void }> = ({ mlModels onDeploy onRetrain }) => {
    const [searchTerm, setSearchTerm] = useState('');

    const filteredModels = useMemo(() => {
        return mlModels.filter(model =>
            model.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            model.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
            model.algorithm.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [mlModels searchTerm]);

    return (
        <Card title="AI/ML Throttling Model Management">
            <input
                type="text"
                placeholder="Search models"
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                className="mb-4 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {filteredModels.map(model => (
                    <div key={model.id} className="bg-gray-700 p-4 rounded-lg shadow-md flex flex-col justify-between">
                        <div>
                            <h4 className="text-xl font-semibold text-white mb-2">{model.name} <span className="text-gray-400 text-sm">{model.version}</span></h4>
                            <p className="text-gray-300 text-sm mb-2">{model.description}</p>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <CpuChipIcon className="h-4 w-4 mr-1" /> Algorithm: {model.algorithm}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <TagIcon className="h-4 w-4 mr-1" /> Type: {model.type}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <CalendarDaysIcon className="h-4 w-4 mr-1" /> Last Trained: {new Date(model.lastTrained).toLocaleDateString()}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-2">
                                <ServerStackIcon className="h-4 w-4 mr-1" /> Training Data: {(model.trainingDataSize / 1000000).toFixed(1)}M samples
                            </div>
                            <div className="mb-2">
                                <h5 className="text-sm font-medium text-gray-300">Performance</h5>
                                {model.performanceMetrics.accuracy && <p className="text-xs text-gray-400 ml-2">Accuracy: {(model.performanceMetrics.accuracy * 100).toFixed(2)}%</p>}
                                {model.performanceMetrics.mse && <p className="text-xs text-gray-400 ml-2">MSE: {model.performanceMetrics.mse.toFixed(4)}</p>}
                                {model.performanceMetrics.precision && <p className="text-xs text-gray-400 ml-2">Precision: {(model.performanceMetrics.precision * 100).toFixed(2)}%</p>}
                            </div>
                            <div className="mb-3">
                                <p className="text-xs font-medium text-gray-300">Features Used: <span className="text-gray-400">{model.featuresUsed.join(', ')}</span></p>
                            </div>
                        </div>
                        <div className="flex items-center justify-between mt-3 pt-3 border-t border-gray-600">
                            <StatusIndicator status={model.status} />
                            <div className="space-x-2">
                                {model.status !== 'deployed' && (
                                    <button onClick={() => onDeploy(model.id)} className="px-3 py-1 text-sm bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Deploy</button>
                                )}
                                {model.status !== 'training' && (
                                    <button onClick={() => onRetrain(model.id)} className="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">Retrain</button>
                                )}
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
};

export const AnomalyDetectionConfigsList: React.FC<{
    configs: AnomalyDetectionConfig[];
    endpoints: ApiEndpoint[];
    onEdit: (config: AnomalyDetectionConfig) => void;
    onDelete: (configId: string) => void;
    onToggleStatus: (config: AnomalyDetectionConfig) => void;
}> = ({ configs endpoints onEdit onDelete onToggleStatus }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 8;

    const [filters, setFilters] = useState({
        name: '',
        target: '',
        status: '',
    });
    const [sortBy, setSortBy] = useState<keyof AnomalyDetectionConfig>('name');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1);
    }, []);

    const handleSortChange = useCallback((key: keyof AnomalyDetectionConfig) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    }, [sortBy]);

    const filteredAndSortedConfigs = useMemo(() => {
        let filtered = configs.filter(config => {
            const matchesName = filters.name ? config.name.toLowerCase().includes(filters.name.toLowerCase()) : true;
            const matchesTarget = filters.target ? config.target === filters.target : true;
            const matchesStatus = filters.status ? config.status === filters.status : true;
            return matchesName && matchesTarget && matchesStatus;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [configs filters sortBy sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedConfigs.length / itemsPerPage);
    const paginatedConfigs = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedConfigs.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedConfigs currentPage itemsPerPage]);

    const getTargetName = (config: AnomalyDetectionConfig) => {
        if (config.target === 'endpoint' && config.targetId) {
            return endpoints.find(ep => ep.id === config.targetId)?.name || config.targetId;
        }
        return config.targetId || 'N/A';
    };

    const availableFilters = [
        { key: 'name', label: 'Config Name', type: 'text' as const },
        { key: 'target', label: 'Target Scope', type: 'select' as const, options: [{ value: 'global', label: 'Global' }, { value: 'endpoint', label: 'Endpoint' }, { value: 'user', label: 'User' }, { value: 'ip', label: 'IP' }] },
        { key: 'status', label: 'Status', type: 'select' as const, options: [{ value: 'active', label: 'Active' }, { value: 'inactive', label: 'Inactive' }] },
    ];

    const availableSorts = [
        { key: 'name', label: 'Name' },
        { key: 'alertSeverity', label: 'Severity' },
        { key: 'updatedAt', label: 'Last Updated' },
    ];

    return (
        <Card title="Anomaly Detection Configurations">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Target</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Model Type</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Threshold</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Severity</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" className="relative px-6 py-3">
                                <span className="sr-only">Actions</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedConfigs.map(config => (
                            <tr key={config.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{config.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.target} ({getTargetName(config)})</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.modelType.replace('_', ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{config.threshold}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.alertSeverity}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={config.status} />
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => onEdit(config)} className="text-indigo-400 hover:text-indigo-300 mr-3">
                                        <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button onClick={() => onToggleStatus(config)} className={`mr-3 ${config.status === 'active' ? 'text-yellow-400 hover:text-yellow-300' : 'text-green-400 hover:text-green-300'}`}>
                                        {config.status === 'active' ? <ExclamationTriangleIcon className="h-5 w-5" /> : <RocketLaunchIcon className="h-5 w-5" />}
                                    </button>
                                    <button onClick={() => onDelete(config.id)} className="text-red-400 hover:text-red-300">
                                        <TrashIcon className="h-5 w-5" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedConfigs.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const SimulationResultsList: React.FC<{ results: SimulationResult[] }> = ({ results }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 7;

    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState<keyof SimulationResult>('timestamp');
    const [sortOrder, setSortOrder] = useState<'desc' | 'asc'>('desc');

    const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(e.target.value);
        setCurrentPage(1);
    };

    const handleSortChange = (key: keyof SimulationResult) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('desc');
        }
    };

    const filteredAndSortedResults = useMemo(() => {
        let filtered = results.filter(result =>
            result.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            result.scenarioDescription.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (sortBy === 'timestamp') {
                    return sortOrder === 'asc' ? new Date(aValue as string).getTime() - new Date(bValue as string).getTime() : new Date(bValue as string).getTime() - new Date(aValue as string).getTime();
                }
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [results searchTerm sortBy sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedResults.length / itemsPerPage);
    const paginatedResults = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedResults.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedResults currentPage itemsPerPage]);

    const renderSortIcon = (key: keyof SimulationResult) => {
        if (sortBy === key) {
            return sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />;
        }
        return null;
    };

    return (
        <Card title="Simulation Results" className="h-full">
            <input
                type="text"
                placeholder="Search simulations"
                value={searchTerm}
                onChange={handleSearchChange}
                className="mb-4 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('name')}>
                                <div className="flex items-center">Name {renderSortIcon('name')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('timestamp')}>
                                <div className="flex items-center">Date {renderSortIcon('timestamp')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Scenario</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Traffic Increase</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Throttled Requests</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Latency Increase</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Success Rate</th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedResults.map(res => (
                            <tr key={res.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{res.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(res.timestamp).toLocaleDateString()}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{res.scenarioDescription}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{res.inputTrafficIncreasePercentage}%</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-yellow-400">{res.predictedThrottledRequests}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-red-400">{res.predictedLatencyIncreaseMs}ms</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-green-400">{(res.successRateAfterSimulation * 100).toFixed(1)}%</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedResults.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

// New components for visual data and overview
export const ThrottlingDashboardCharts: React.FC<{ events: ThrottlingEvent[]; endpoints: ApiEndpoint[]; policies: RateLimitPolicy[] }> = ({ events endpoints policies }) => {
    const [timeframe, setTimeframe] = useState('24h'); // 24h 7d 30d

    const filterEventsByTimeframe = useCallback((events: ThrottlingEvent[]) => {
        const now = Date.now();
        let cutoff = now;
        if (timeframe === '24h') cutoff -= 24 * 60 * 60 * 1000;
        else if (timeframe === '7d') cutoff -= 7 * 24 * 60 * 60 * 1000;
        else if (timeframe === '30d') cutoff -= 30 * 24 * 60 * 60 * 1000;
        return events.filter(event => new Date(event.timestamp).getTime() >= cutoff);
    }, [timeframe]);

    const processedEvents = useMemo(() => filterEventsByTimeframe(events), [events filterEventsByTimeframe]);

    const throttleReasonData = useMemo(() => {
        const reasons = processedEvents.reduce((acc, event) => {
            acc[event.reason] = (acc[event.reason] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);
        return Object.entries(reasons).map(([name, value]) => ({ name: name.replace(/_/g, ' '), value }));
    }, [processedEvents]);

    const endpointThrottleData = useMemo(() => {
        const endpointCounts = processedEvents.reduce((acc, event) => {
            const epName = endpoints.find(ep => ep.id === event.endpointId)?.name || event.endpointId;
            acc[epName] = (acc[epName] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);
        return Object.entries(endpointCounts)
            .sort((_ a _ b) => b - a)
            .slice(0, 5)
            .map(([name, value]) => ({ name, value }));
    }, [processedEvents endpoints]);

    const dailyThrottlingCounts = useMemo(() => {
        const counts: Record<string, number> = {};
        processedEvents.forEach(event => {
            const date = new Date(event.timestamp).toLocaleDateString('en-US');
            counts[date] = (counts[date] || 0) + 1;
        });
        const sortedDates = Object.keys(counts).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        return sortedDates.map(date => ({ date, count: counts[date] }));
    }, [processedEvents]);

    const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#A28DFF', '#FF5733'];

    return (
        <Card title="Throttling Analytics Dashboard">
            <div className="flex justify-end mb-4">
                {['24h', '7d', '30d'].map(tf => (
                    <button
                        key={tf}
                        onClick={() => setTimeframe(tf)}
                        className={`px-4 py-2 text-sm rounded-md ${timeframe === tf ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} mr-2`}
                    >
                        {tf === '24h' ? 'Last 24 Hours' : tf === '7d' ? 'Last 7 Days' : 'Last 30 Days'}
                    </button>
                ))}
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div>
                    <h4 className="text-lg font-semibold text-white mb-2">Throttling Events Over Time</h4>
                    <ResponsiveContainer width="100%" height={300}>
                        <AreaChart data={dailyThrottlingCounts} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="date" stroke="#999" />
                            <YAxis stroke="#999" />
                            <Tooltip contentStyle={{ backgroundColor: '#333', borderColor: '#555', color: '#fff' }} />
                            <Area type="monotone" dataKey="count" stroke="#8884d8" fill="#8884d8" fillOpacity={0.7} />
                        </AreaChart>
                    </ResponsiveContainer>
                </div>
                <div>
                    <h4 className="text-lg font-semibold text-white mb-2">Throttling Reasons Breakdown</h4>
                    <ResponsiveContainer width="100%" height={300}>
                        <PieChart>
                            <Pie
                                data={throttleReasonData}
                                cx="50%"
                                cy="50%"
                                labelLine={false}
                                outerRadius={100}
                                fill="#8884d8"
                                dataKey="value"
                                label={({ name, percent }) => `${name} ${ (percent * 100).toFixed(0)}%`}
                            >
                                {throttleReasonData.map((entry index) => (
                                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                ))}
                            </Pie>
                            <Tooltip contentStyle={{ backgroundColor: '#333', borderColor: '#555', color: '#fff' }} />
                            <Legend />
                        </PieChart>
                    </ResponsiveContainer>
                </div>
                <div className="lg:col-span-2">
                    <h4 className="text-lg font-semibold text-white mb-2">Top 5 Throttled Endpoints</h4>
                    <ResponsiveContainer width="100%" height={300}>
                        <BarChart data={endpointThrottleData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                            <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                            <XAxis dataKey="name" stroke="#999" />
                            <YAxis stroke="#999" />
                            <Tooltip contentStyle={{ backgroundColor: '#333', borderColor: '#555', color: '#fff' }} />
                            <Bar dataKey="value" fill="#82ca9d" />
                        </BarChart>
                    </ResponsiveContainer>
                </div>
            </div>
        </Card>
    );
};

export const ThrottlingOverview: React.FC<{
    endpoints: ApiEndpoint[];
    policies: RateLimitPolicy[];
    events: ThrottlingEvent[];
    mlModels: MlModel[];
}> = ({ endpoints policies events mlModels }) => {
    const activePolicies = useMemo(() => policies.filter(p => p.status === 'active').length, [policies]);
    const adaptivePolicies = useMemo(() => policies.filter(p => p.isAdaptive && p.status === 'active').length, [policies]);
    const totalThrottledRequests = useMemo(() => events.filter(e => e.blocked).length, [events]);
    const anomalyDetectedEvents = useMemo(() => events.filter(e => e.reason === 'anomaly_detected').length, [events]);
    const uniqueIpsBlockedLast24h = useMemo(() => {
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        const ips = new Set(events.filter(e => e.blocked && e.timestamp >= twentyFourHoursAgo).map(e => e.clientIp));
        return ips.size;
    }, [events]);

    return (
        <Card title="Throttling System Overview">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 text-white">
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Total Endpoints</p>
                        <p className="text-2xl font-bold">{endpoints.length}</p>
                    </div>
                    <GlobeAltIcon className="h-8 w-8 text-indigo-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Active Policies</p>
                        <p className="text-2xl font-bold">{activePolicies}</p>
                    </div>
                    <ScaleIcon className="h-8 w-8 text-green-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Adaptive Policies</p>
                        <p className="text-2xl font-bold">{adaptivePolicies}</p>
                    </div>
                    <SparklesIcon className="h-8 w-8 text-purple-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Total Throttled</p>
                        <p className="text-2xl font-bold">{totalThrottledRequests}</p>
                    </div>
                    <ExclamationTriangleIcon className="h-8 w-8 text-red-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Anomaly Detections</p>
                        <p className="text-2xl font-bold">{anomalyDetectedEvents}</p>
                    </div>
                    <BellIcon className="h-8 w-8 text-yellow-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Unique IPs Blocked 24h</p>
                        <p className="text-2xl font-bold">{uniqueIpsBlockedLast24h}</p>
                    </div>
                    <FingerPrintIcon className="h-8 w-8 text-cyan-400" />
                </div>
                 <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Deployed ML Models</p>
                        <p className="text-2xl font-bold">{mlModels.filter(m => m.status === 'deployed').length}</p>
                    </div>
                    <CpuChipIcon className="h-8 w-8 text-blue-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Custom Rules</p>
                        <p className="text-2xl font-bold">{mockCustomRules.filter(r => r.status === 'active').length}</p>
                    </div>
                    <CodeBracketIcon className="h-8 w-8 text-orange-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Total Simulations</p>
                        <p className="text-2xl font-bold">{mockSimulationResults.length}</p>
                    </div>
                    <BeakerIcon className="h-8 w-8 text-teal-400" />
                </div>
                <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                    <div>
                        <p className="text-sm text-gray-400">Audit Log Entries</p>
                        <p className="text-2xl font-bold">{mockAuditLogs.length}</p>
                    </div>
                    <DocumentTextIcon className="h-8 w-8 text-fuchsia-400" />
                </div>
            </div>
        </Card>
    );
};

export const LiveThrottlingFeed: React.FC<{ events: ThrottlingEvent[]; endpoints: ApiEndpoint[]; policies: RateLimitPolicy[] }> = ({ events endpoints policies }) => {
    const [liveEvents, setLiveEvents] = useState<ThrottlingEvent[]>([]);
    const [isPaused, setIsPaused] = useState(false);
    const eventCountRef = useRef(0);

    const getEndpointName = (id: string) => endpoints.find(ep => ep.id === id)?.name || id;
    const getPolicyName = (id: string) => policies.find(p => p.id === id)?.name || id;

    useEffect(() => {
        const interval = setInterval(() => {
            if (!isPaused) {
                const newEvent = generateLiveThrottlingEvent();
                setLiveEvents(prev => {
                    const updated = [newEvent, ...prev];
                    // Keep only the latest 100 events
                    return updated.slice(0, 100);
                });
                eventCountRef.current++;
            }
        }, 1500 + Math.random() * 1000); // Simulate events every 1.5 to 2.5 seconds

        return () => clearInterval(interval);
    }, [isPaused]);

    return (
        <Card title="Live Throttling Activity Feed" className="h-[500px] flex flex-col">
            <div className="flex justify-end mb-3">
                <button
                    onClick={() => setIsPaused(!isPaused)}
                    className={`px-3 py-1 text-sm rounded-md ${isPaused ? 'bg-green-600 hover:bg-green-700' : 'bg-yellow-600 hover:bg-yellow-700'} text-white flex items-center`}
                >
                    {isPaused ? <PlayIcon className="h-4 w-4 mr-1" /> : <PauseIcon className="h-4 w-4 mr-1" />}
                    {isPaused ? 'Resume Feed' : 'Pause Feed'}
                </button>
            </div>
            <div className="overflow-y-auto flex-grow custom-scrollbar">
                {liveEvents.length === 0 ? (
                    <p className="text-gray-400 text-center py-4">Waiting for live throttling events</p>
                ) : (
                    <ul className="space-y-3">
                        {liveEvents.map(event => (
                            <li key={event.id} className="bg-gray-700 p-3 rounded-md border border-gray-600 animate-fadeIn">
                                <div className="flex items-center text-sm text-gray-400">
                                    <ClockIcon className="h-4 w-4 mr-1" /> {new Date(event.timestamp).toLocaleTimeString()}
                                    <span className="ml-auto flex items-center text-red-400 font-semibold">
                                        <ExclamationTriangleIcon className="h-4 w-4 mr-1" /> {event.reason.replace(/_/g, ' ')}
                                    </span>
                                </div>
                                <p className="text-white text-md mt-1">
                                    <strong className="text-indigo-400">{getEndpointName(event.endpointId)}</strong> from <span className="text-gray-300">{event.clientIp}</span>
                                </p>
                                {event.userId && <p className="text-xs text-gray-500">User ID: {event.userId}</p>}
                                <p className="text-sm text-gray-400">Blocked {event.currentRPS} RPS against {event.rateLimitValue} limit by <span className="font-medium">{getPolicyName(event.policyId)}</span></p>
                                {event.tags.length > 0 && (
                                    <div className="flex flex-wrap gap-1 mt-2">
                                        {event.tags.map((tag idx) => (
                                            <span key={idx} className="px-2 py-0.5 bg-indigo-800 text-indigo-200 text-xs rounded-full">{tag}</span>
                                        ))}
                                    </div>
                                )}
                            </li>
                        ))}
                    </ul>
                )}
            </div>
        </Card>
    );
};

export const CustomRuleEditor: React.FC<{ customRules: CustomRuleSchema[]; onSave: (rule: CustomRuleSchema) => void; onDelete: (id: string) => void }> = ({ customRules onSave onDelete }) => {
    const [selectedRule, setSelectedRule] = useState<CustomRuleSchema | null>(null);
    const [isModalOpen, setIsModalOpen] = useState(false);

    const handleEdit = (rule: CustomRuleSchema) => {
        setSelectedRule(rule);
        setIsModalOpen(true);
    };

    const handleCreateNew = () => {
        setSelectedRule(null); // Clear selection for new rule
        setIsModalOpen(true);
    };

    const handleSave = (rule: CustomRuleSchema) => {
        onSave(rule);
        setIsModalOpen(false);
        setSelectedRule(null);
        toast.success(`Custom Rule ${rule.name} saved`);
    };

    const handleDelete = (id: string) => {
        if (window.confirm("Are you sure you want to delete this custom rule")) {
            onDelete(id);
            toast.success("Custom Rule deleted");
        }
    };

    const getStatusColor = (status: 'active' | 'inactive' | 'draft') => {
        switch (status) {
            case 'active': return 'text-green-500';
            case 'inactive': return 'text-gray-500';
            case 'draft': return 'text-yellow-500';
            default: return 'text-gray-400';
        }
    };

    return (
        <Card title="Custom Throttling Rules">
            <div className="flex justify-end mb-4">
                <button
                    onClick={handleCreateNew}
                    className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                    <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> New Custom Rule
                </button>
            </div>
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Language</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Tags</th>
                            <th scope="col" className="relative px-6 py-3">
                                <span className="sr-only">Actions</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {customRules.map(rule => (
                            <tr key={rule.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{rule.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{rule.language}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                    <span className={`flex items-center ${getStatusColor(rule.status)}`}>
                                        {rule.status === 'active' && <CheckCircleIcon className="h-4 w-4 mr-1" />}
                                        {rule.status === 'inactive' && <InformationCircleIcon className="h-4 w-4 mr-1" />}
                                        {rule.status === 'draft' && <PencilIcon className="h-4 w-4 mr-1" />}
                                        {rule.status}
                                    </span>
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    {rule.tags.map(tag => (
                                        <span key={tag} className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-600 text-gray-100 mr-1">
                                            {tag}
                                        </span>
                                    ))}
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => handleEdit(rule)} className="text-indigo-400 hover:text-indigo-300 mr-3">
                                        <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button onClick={() => handleDelete(rule.id)} className="text-red-400 hover:text-red-300">
                                        <TrashIcon className="h-5 w-5" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title={selectedRule ? "Edit Custom Rule" : "Create Custom Rule"} size="xl">
                <CustomRuleForm initialData={selectedRule || undefined} onSave={handleSave} onCancel={() => setIsModalOpen(false)} />
            </Modal>
        </Card>
    );
};

// New feature User Feedback and Feature Requests
export interface FeedbackItem {
    id: string;
    userId: string;
    userName: string;
    type: 'bug' | 'feature_request' | 'general_feedback';
    status: 'open' | 'under_review' | 'planned' | 'completed' | 'closed';
    title: string;
    description: string;
    createdAt: string;
    upvotes: string[]; // Array of userIds who upvoted
    comments: FeedbackComment[];
    attachments?: string[]; // URLs to screenshots/files
}

export interface FeedbackComment {
    id: string;
    userId: string;
    userName: string;
    timestamp: string;
    content: string;
}

const mockFeedback: FeedbackItem[] = Array.from({ length: 10 }).map((_ i) => ({
    id: `fb-${i + 1}`,
    userId: `user-${i % 3 + 1}`,
    userName: `User ${i % 3 + 1}`,
    type: ['bug', 'feature_request', 'general_feedback'][i % 3] as any,
    status: ['open', 'under_review', 'planned', 'completed', 'closed'][i % 5] as any,
    title: `Title for Feedback ${i + 1} ${['Graph issues', 'Need geo-blocking', 'UI is slow', 'New API endpoint needed', 'Adaptive ML suggestions inaccurate'][i % 5]}`,
    description: `Detailed description for feedback item ${i + 1} This outlines the specific problem or requested enhancement`,
    createdAt: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
    upvotes: Array.from({ length: Math.floor(Math.random() * 5) }, (_ uIdx) => `user-${uIdx + 4}`),
    comments: Array.from({ length: Math.floor(Math.random() * 3) }).map((_ cIdx) => ({
        id: `cm-${i + 1}-${cIdx + 1}`,
        userId: `user-${cIdx % 2 + 1}`,
        userName: `User ${cIdx % 2 + 1}`,
        timestamp: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),
        content: `Comment for feedback ${i + 1} by User ${cIdx % 2 + 1}`,
    })),
}));

export const FeedbackAndRequests: React.FC = () => {
    const [feedbackItems, setFeedbackItems] = useState<FeedbackItem[]>(mockFeedback);
    const [isFormModalOpen, setIsFormModalOpen] = useState(false);
    const [editingFeedback, setEditingFeedback] = useState<FeedbackItem | null>(null);
    const { currentUser } = useContext(DataContext); // Assuming currentUser has id and name

    const handleSaveFeedback = (newFeedback: FeedbackItem) => {
        if (newFeedback.id.startsWith('new-')) {
            setFeedbackItems(prev => [...prev, { ...newFeedback, id: `fb-${Date.now()}` }]);
            toast.success("Feedback submitted");
        } else {
            setFeedbackItems(prev => prev.map(f => f.id === newFeedback.id ? newFeedback : f));
            toast.success("Feedback updated");
        }
        setIsFormModalOpen(false);
        setEditingFeedback(null);
    };

    const handleUpvote = (id: string) => {
        if (!currentUser?.id) {
            toast.error("Please log in to upvote");
            return;
        }
        setFeedbackItems(prev => prev.map(f => {
            if (f.id === id) {
                const newUpvotes = new Set(f.upvotes);
                if (newUpvotes.has(currentUser.id)) {
                    newUpvotes.delete(currentUser.id);
                } else {
                    newUpvotes.add(currentUser.id);
                }
                return { ...f, upvotes: Array.from(newUpvotes) };
            }
            return f;
        }));
    };

    const handleAddComment = (feedbackId: string, commentContent: string) => {
        if (!currentUser?.id || !currentUser?.name) {
            toast.error("Please log in to comment");
            return;
        }
        setFeedbackItems(prev => prev.map(f => {
            if (f.id === feedbackId) {
                const newComment: FeedbackComment = {
                    id: `cm-${Date.now()}`,
                    userId: currentUser.id,
                    userName: currentUser.name,
                    timestamp: new Date().toISOString(),
                    content: commentContent,
                };
                return { ...f, comments: [...f.comments, newComment] };
            }
            return f;
        }));
        toast.success("Comment added");
    };

    const sortedFeedback = useMemo(() => {
        return [...feedbackItems].sort((a, b) => {
            if (a.status === 'open' && b.status !== 'open') return -1;
            if (a.status !== 'open' && b.status === 'open') return 1;
            return b.upvotes.length - a.upvotes.length;
        });
    }, [feedbackItems]);

    return (
        <Card title="User Feedback Feature Requests" className="h-full">
            <div className="flex justify-end mb-4">
                <button
                    onClick={() => { setEditingFeedback(null); setIsFormModalOpen(true); }}
                    className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                    <MegaphoneIcon className="-ml-1 mr-2 h-5 w-5" /> Submit Feedback
                </button>
            </div>
            <div className="space-y-4">
                {sortedFeedback.map(item => (
                    <div key={item.id} className="bg-gray-800 p-4 rounded-lg shadow-md border border-gray-700">
                        <div className="flex items-start justify-between">
                            <h4 className="text-lg font-semibold text-white">{item.title}</h4>
                            <div className="flex items-center space-x-2">
                                <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                                    item.status === 'completed' ? 'bg-green-700 text-green-200' :
                                    item.status === 'open' ? 'bg-blue-700 text-blue-200' :
                                    item.status === 'planned' ? 'bg-purple-700 text-purple-200' :
                                    'bg-gray-600 text-gray-200'
                                }`}>
                                    {item.status.replace(/_/g, ' ')}
                                </span>
                                <button onClick={() => handleUpvote(item.id)} className={`flex items-center text-sm p-1 rounded-full ${currentUser?.id && item.upvotes.includes(currentUser.id) ? 'bg-indigo-600 text-white' : 'text-gray-400 hover:text-white hover:bg-gray-700'}`}>
                                    <ArrowUpRightIcon className="h-4 w-4 mr-1" /> {item.upvotes.length}
                                </button>
                            </div>
                        </div>
                        <p className="text-sm text-gray-300 mt-2">{item.description}</p>
                        <div className="flex items-center text-xs text-gray-500 mt-2">
                            <span>{item.userName} &bull; {new Date(item.createdAt).toLocaleDateString()}</span>
                            <span className="ml-auto px-2 py-0.5 rounded-full bg-gray-600 text-gray-200 text-xs capitalize">{item.type.replace(/_/g, ' ')}</span>
                        </div>

                        {item.comments.length > 0 && (
                            <div className="mt-4 pt-3 border-t border-gray-700">
                                <h5 className="text-sm font-semibold text-white mb-2">Comments {item.comments.length}</h5>
                                <div className="space-y-2 max-h-40 overflow-y-auto custom-scrollbar">
                                    {item.comments.map(comment => (
                                        <div key={comment.id} className="bg-gray-700 p-2 rounded-md">
                                            <p className="text-xs text-gray-400"><strong>{comment.userName}</strong> &bull; {new Date(comment.timestamp).toLocaleString()}</p>
                                            <p className="text-sm text-gray-300">{comment.content}</p>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                        <div className="mt-4 pt-3 border-t border-gray-700">
                            <CommentInput onSubmitComment={(comment) => handleAddComment(item.id, comment)} />
                        </div>
                    </div>
                ))}
            </div>
            <Modal isOpen={isFormModalOpen} onClose={() => setIsFormModalOpen(false)} title={editingFeedback ? "Edit Feedback" : "Submit New Feedback"} size="md">
                <FeedbackForm initialData={editingFeedback || undefined} onSave={handleSaveFeedback} onCancel={() => setIsFormModalOpen(false)} />
            </Modal>
        </Card>
    );
};

export const FeedbackForm: React.FC<{
    initialData?: FeedbackItem;
    onSave: (feedback: FeedbackItem) => void;
    onCancel: () => void;
}> = ({ initialData onSave onCancel }) => {
    const { currentUser } = useContext(DataContext);
    const [feedback, setFeedback] = useState<FeedbackItem>(
        initialData || {
            id: `new-${Date.now()}`,
            userId: currentUser?.id || 'anonymous',
            userName: currentUser?.name || 'Anonymous',
            type: 'feature_request',
            status: 'open',
            title: '',
            description: '',
            createdAt: new Date().toISOString(),
            upvotes: [],
            comments: [],
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setFeedback(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (!feedback.title || !feedback.description) {
            toast.error("Title and Description are required");
            return;
        }
        onSave({ ...feedback, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="title" className="block text-sm font-medium">Title</label>
                <input type="text" name="title" id="title" value={feedback.title} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={feedback.description} onChange={handleChange} rows={5} required
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="type" className="block text-sm font-medium">Type</label>
                <select name="type" id="type" value={feedback.type} onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    <option value="feature_request">Feature Request</option>
                    <option value="bug">Bug Report</option>
                    <option value="general_feedback">General Feedback</option>
                </select>
            </div>
            {initialData && ( // Only allow status change for existing items
                <div>
                    <label htmlFor="status" className="block text-sm font-medium">Status</label>
                    <select name="status" id="status" value={feedback.status} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="open">Open</option>
                        <option value="under_review">Under Review</option>
                        <option value="planned">Planned</option>
                        <option value="completed">Completed</option>
                        <option value="closed">Closed</option>
                    </select>
                </div>
            )}
            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Feedback
                </button>
            </div>
        </form>
    );
};

export const CommentInput: React.FC<{ onSubmitComment: (comment: string) => void }> = ({ onSubmitComment }) => {
    const [comment, setComment] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (comment.trim()) {
            onSubmitComment(comment);
            setComment('');
        }
    };

    return (
        <form onSubmit={handleSubmit} className="flex space-x-2">
            <textarea
                value={comment}
                onChange={(e) => setComment(e.target.value)}
                placeholder="Add a comment"
                rows={1}
                className="flex-grow rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <button
                type="submit"
                className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                disabled={!comment.trim()}
            >
                Comment
            </button>
        </form>
    );
};

// Main view component
const ApiThrottlingView: React.FC = () => {
    const { services } = useContext(DataContext); // Assuming DataContext provides a generic 'services' array

    const [endpoints, setEndpoints] = useState<ApiEndpoint[]>(mockEndpoints);
    const [policies, setPolicies] = useState<RateLimitPolicy[]>(mockRateLimitPolicies);
    const [events, setEvents] = useState<ThrottlingEvent[]>(mockThrottlingEvents);
    const [anomalyConfigs, setAnomalyConfigs] = useState<AnomalyDetectionConfig[]>(mockAnomalyConfigs);
    const [mlModels, setMlModels] = useState<MlModel[]>(mockMlModels);
    const [simulationResults, setSimulationResults] = useState<SimulationResult[]>(mockSimulationResults);
    const [auditLogs, setAuditLogs] = useState<AuditLogEntry[]>(mockAuditLogs);
    const [customRules, setCustomRules] = useState<CustomRuleSchema[]>(mockCustomRules);

    const [isPolicyModalOpen, setIsPolicyModalOpen] = useState(false);
    const [editingPolicy, setEditingPolicy] = useState<RateLimitPolicy | undefined>(undefined);

    const [isAnomalyConfigModalOpen, setIsAnomalyConfigModalOpen] = useState(false);
    const [editingAnomalyConfig, setEditingAnomalyConfig] = useState<AnomalyDetectionConfig | undefined>(undefined);

    const handleSavePolicy = (policy: RateLimitPolicy) => {
        if (policies.some(p => p.id === policy.id)) {
            setPolicies(policies.map(p => p.id === policy.id ? policy : p));
        } else {
            setPolicies([...policies, policy]);
        }
        setIsPolicyModalOpen(false);
        setEditingPolicy(undefined);
        toast.success(`Policy ${policy.name} saved`);
    };

    const handleDeletePolicy = (policyId: string) => {
        if (window.confirm("Are you sure you want to delete this policy")) {
            setPolicies(policies.filter(p => p.id !== policyId));
            toast.success("Policy deleted");
        }
    };

    const handleTogglePolicyStatus = (policy: RateLimitPolicy) => {
        const newStatus = policy.status === 'active' ? 'inactive' : 'active';
        setPolicies(policies.map(p => p.id === policy.id ? { ...p, status: newStatus } : p));
        toast.success(`Policy ${policy.name} status changed to ${newStatus}`);
    };

    const handleSaveAnomalyConfig = (config: AnomalyDetectionConfig) => {
        if (anomalyConfigs.some(c => c.id === config.id)) {
            setAnomalyConfigs(anomalyConfigs.map(c => c.id === config.id ? config : c));
        } else {
            setAnomalyConfigs([...anomalyConfigs, config]);
        }
        setIsAnomalyConfigModalOpen(false);
        setEditingAnomalyConfig(undefined);
        toast.success(`Anomaly config ${config.name} saved`);
    };

    const handleDeleteAnomalyConfig = (configId: string) => {
        if (window.confirm("Are you sure you want to delete this anomaly detection configuration")) {
            setAnomalyConfigs(anomalyConfigs.filter(c => c.id !== configId));
            toast.success("Anomaly config deleted");
        }
    };

    const handleToggleAnomalyConfigStatus = (config: AnomalyDetectionConfig) => {
        const newStatus = config.status === 'active' ? 'inactive' : 'active';
        setAnomalyConfigs(anomalyConfigs.map(c => c.id === config.id ? { ...c, status: newStatus } : c));
        toast.success(`Anomaly config ${config.name} status changed to ${newStatus}`);
    };

    const handleDeployMlModel = (modelId: string) => {
        setMlModels(prev => prev.map(m => m.id === modelId ? { ...m, status: 'deployed', deployedAt: new Date().toISOString() } : m));
        toast.success("ML Model deployed");
    };

    const handleRetrainMlModel = (modelId: string) => {
        setMlModels(prev => prev.map(m => m.id === modelId ? { ...m, status: 'training', lastTrained: new Date().toISOString() } : m));
        toast.success("ML Model retraining initiated");
        // Simulate training completion
        setTimeout(() => {
            setMlModels(prev => prev.map(m => m.id === modelId ? { ...m, status: Math.random() > 0.1 ? 'deployed' : 'failed' } : m));
            toast.success(`ML Model ${mlModels.find(m => m.id === modelId)?.name} training completed`);
        }, 5000);
    };

    const handleSaveCustomRule = (rule: CustomRuleSchema) => {
        if (customRules.some(r => r.id === rule.id)) {
            setCustomRules(customRules.map(r => r.id === rule.id ? rule : r));
        } else {
            setCustomRules([...customRules, rule]);
        }
        toast.success(`Custom rule ${rule.name} saved`);
    };

    const handleDeleteCustomRule = (ruleId: string) => {
        setCustomRules(customRules.filter(r => r.id !== ruleId));
        toast.success(`Custom rule deleted`);
    };

    const endpointOptions = useMemo(() => mockEndpoints.map(ep => ({ value: ep.id, label: `${ep.name} (${ep.method})` })), []);

    return (
        <div className="space-y-8 p-6 bg-gray-900 min-h-screen text-gray-100">
            <Toaster position="bottom-right" reverseOrder={false} />

            <TheChiefVisionaryOfficerRhyme />

            <div className="flex justify-between items-center mb-6">
                <h1 className="text-4xl font-extrabold text-white tracking-tight">API Throttling Anomaly Detection</h1>
                <div className="flex space-x-3">
                    <button
                        onClick={() => { setEditingPolicy(undefined); setIsPolicyModalOpen(true); }}
                        className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                    >
                        <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> New Policy
                    </button>
                    <button
                        onClick={() => { setEditingAnomalyConfig(undefined); setIsAnomalyConfigModalOpen(true); }}
                        className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                    >
                        <BellIcon className="-ml-1 mr-2 h-5 w-5" /> New Anomaly Config
                    </button>
                </div>
            </div>

            <ThrottlingOverview
                endpoints={endpoints}
                policies={policies}
                events={events}
                mlModels={mlModels}
            />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <ThrottlingDashboardCharts events={events} endpoints={endpoints} policies={policies} />
                <LiveThrottlingFeed events={events} endpoints={endpoints} policies={policies} />
            </div>

            <RateLimitPolicyList
                policies={policies}
                endpoints={endpoints}
                onEdit={policy => { setEditingPolicy(policy); setIsPolicyModalOpen(true); }}
                onDelete={handleDeletePolicy}
                onToggleStatus={handleTogglePolicyStatus}
            />

            <ThrottlingEventLog events={events} endpoints={endpoints} policies={policies} />

            <AnomalyDetectionConfigsList
                configs={anomalyConfigs}
                endpoints={endpoints}
                onEdit={config => { setEditingAnomalyConfig(config); setIsAnomalyConfigModalOpen(true); }}
                onDelete={handleDeleteAnomalyConfig}
                onToggleStatus={handleToggleAnomalyConfigStatus}
            />

            <MlModelManagement mlModels={mlModels} onDeploy={handleDeployMlModel} onRetrain={handleRetrainMlModel} />

            <SimulationResultsList results={simulationResults} />

            <CustomRuleEditor customRules={customRules} onSave={handleSaveCustomRule} onDelete={handleDeleteCustomRule} />

            <FeedbackAndRequests /> {/* New section for user feedback */}

            <Modal isOpen={isPolicyModalOpen} onClose={() => setIsPolicyModalOpen(false)} title={editingPolicy ? "Edit Rate Limit Policy" : "Create Rate Limit Policy"} size="lg">
                <RateLimitPolicyForm
                    initialData={editingPolicy}
                    onSave={handleSavePolicy}
                    onCancel={() => setIsPolicyModalOpen(false)}
                    endpoints={endpoints}
                    mlModels={mlModels}
                />
            </Modal>

            <Modal isOpen={isAnomalyConfigModalOpen} onClose={() => setIsAnomalyConfigModalOpen(false)} title={editingAnomalyConfig ? "Edit Anomaly Detection Config" : "Create Anomaly Detection Config"} size="md">
                <AnomalyDetectionConfigForm
                    initialData={editingAnomalyConfig}
                    onSave={handleSaveAnomalyConfig}
                    onCancel={() => setIsAnomalyConfigModalOpen(false)}
                    endpoints={endpoints}
                />
            </Modal>
        </div>
    );
};

export default ApiThrottlingView;

interface PlaybookStep {
    id: string;
    description: string;
    type: PlaybookStepType;
    command?: string; // for instance kubectl get pods
    target?: string; // for instance Kubernetes Slack
    expectedOutput?: string;
    status: PlaybookStepStatus;
    executionLog?: string;
    assignedTo?: string; // User ID
    manualConfirmationRequired?: boolean;
    metricToCheck?: {
        service: string;
        metricName: string; // for instance responseTime errorRate
        operator: 'gt' | 'lt' | 'eq';
        value: number;
    }
}

export interface IncidentComment {
    id: string;
    incidentId: string;
    userId: string;
    userName: string;
    timestamp: string;
    content: string;
}

export interface MetricDataPoint {
    timestamp: string; // ISO string
    value: number;
}

export interface TimeSeriesMetric {
    name: string;
    unit: string;
    data: MetricDataPoint[];
}

const mockUsers: UserProfile[] = [
    { id: 'usr-1', name: 'Alice Smith', email: 'alice@example.com', role: 'ENGINEER', onCall: true, slackId: 'U01ABC' },
    { id: 'usr-2', name: 'Bob Johnson', email: 'bob@example.com', role: 'MANAGER', onCall: false, slackId: 'U01DEF' },
    { id: 'usr-3', name: 'Charlie Brown', email: 'charlie@example.com', role: 'ENGINEER', onCall: true, slackId: 'U01GHI' },
    { id: 'usr-4', name: 'Diana Prince', email: 'diana@example.com', role: 'ADMIN', onCall: false, slackId: 'U01JKL' },
    { id: 'usr-5', name: 'Eve Adams', email: 'eve@example.com', role: 'ENGINEER', onCall: false, slackId: 'U01MNO' },
    { id: 'usr-6', name: 'Frank White', email: 'frank@example.com', role: 'ENGINEER', onCall: false, slackId: 'U01PQR' },
    { id: 'usr-7', name: 'Grace Lee', email: 'grace@example.com', role: 'VIEWER', onCall: false, slackId: 'U01STU' },
    { id: 'usr-8', name: 'Henry King', email: 'henry@example.com', role: 'MANAGER', onCall: true, slackId: 'U01VWX' },
];

const mockServices: ServiceHealthMetric[] = [
    { serviceName: 'AuthService', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 50, errorRate: 0.01 },
    { serviceName: 'PaymentGateway', status: 'DEGRADED', lastUpdated: new Date().toISOString(), incidentsLast24h: 1, responseTimeMs: 350, errorRate: 0.5 },
    { serviceName: 'NotificationService', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 80, errorRate: 0.02 },
    { serviceName: 'DataAnalytics', status: 'OUTAGE', lastUpdated: new Date().toISOString(), incidentsLast24h: 1, responseTimeMs: 0, errorRate: 100 },
    { serviceName: 'UserManagement', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 60, errorRate: 0.005 },
    { serviceName: 'ImageProcessing', status: 'DEGRADED', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 200, errorRate: 0.1 },
];

const generateMockMetrics = (name: string, unit: string, base: number, fluctuation: number, points: number = 60): TimeSeriesMetric => {
    const data: MetricDataPoint[] = [];
    let currentValue = base;
    for (let i = 0; i < points; i++) {
        const timestamp = new Date(Date.now() - (points - 1 - i) * 60 * 1000).toISOString(); // Last 60 minutes
        currentValue += (Math.random() - 0.5) * fluctuation;
        currentValue = Math.max(0, currentValue); // Ensure non-negative
        data.push({ timestamp, value: parseFloat(currentValue.toFixed(2)) });
    }
    return { name, unit, data };
};

const mockIncidentDetails: DetailedIncident[] = [
    {
        id: 'inc-1', title: 'Payment Gateway Latency Spike', severity: 'SEV2', status: 'INVESTIGATING',
        source: 'MONITORING_ALERT', description: 'Observed a significant increase in latency for the Payment Gateway service affecting user transactions',
        impactDescription: 'Users experiencing delays in payment processing potential revenue loss',
        rootCauseDescription: '', affectedServices: ['PaymentGateway'], affectedComponents: ['payment-api', 'transaction-db'],
        detectionTime: new Date(Date.now() - 3600 * 1000).toISOString(), startTime: new Date(Date.now() - 3700 * 1000).toISOString(),
        mitigationTime: null, resolutionTime: null, ownerId: 'usr-1', currentTeam: 'SRE-Payments', relatedAlertIds: ['alert-pg-latency-high-1', 'alert-pg-latency-high-2'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 3700 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Issue detected by Prometheus alert', userId: 'system' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3600 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to ACTIVE', details: { oldStatus: 'NEW', newStatus: 'ACTIVE' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3550 * 1000).toISOString(), eventType: 'OWNER_ASSIGNED', description: 'Assigned to Alice Smith', details: { oldOwner: null, newOwner: 'usr-1' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3500 * 1000).toISOString(), eventType: 'COMMENT_ADDED', description: 'Initial investigation ongoing checking recent deployments', userId: 'usr-1' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3000 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to INVESTIGATING', details: { oldStatus: 'ACTIVE', newStatus: 'INVESTIGATING' }, userId: 'usr-1' },
        ],
        actionItems: [
            { id: uuidv4(), description: 'Review recent deployments in Payment Gateway service', assignedTo: 'usr-1', status: 'IN_PROGRESS', dueDate: new Date(Date.now() + 2 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Check database connection pool for Payment Gateway', assignedTo: 'usr-3', status: 'OPEN', dueDate: new Date(Date.now() + 3 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: null, linkedPlaybookId: 'pb-1', tags: ['payments', 'latency', 'production'], comments: [],
        createdAt: new Date(Date.now() - 3700 * 1000).toISOString(), updatedAt: new Date(Date.now() - 3000 * 1000).toISOString(),
    },
    {
        id: 'inc-2', title: 'Data Analytics Service Outage', severity: 'SEV1', status: 'ACTIVE',
        source: 'MONITORING_ALERT', description: 'The Data Analytics service is completely down leading to reporting failures',
        impactDescription: 'Critical business reporting unavailable impacting decision-making',
        rootCauseDescription: '', affectedServices: ['DataAnalytics'], affectedComponents: ['analytics-backend', 'data-pipeline'],
        detectionTime: new Date(Date.now() - 1200 * 1000).toISOString(), startTime: new Date(Date.now() - 1300 * 1000).toISOString(),
        mitigationTime: null, resolutionTime: null, ownerId: 'usr-3', currentTeam: 'SRE-Data', relatedAlertIds: ['alert-da-down'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 1300 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Paging triggered for Data Analytics team', userId: 'system' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1250 * 1000).toISOString(), eventType: 'OWNER_ASSIGNED', description: 'Assigned to Charlie Brown', details: { oldOwner: null, newOwner: 'usr-3' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1200 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to ACTIVE', details: { oldStatus: 'NEW', newStatus: 'ACTIVE' }, userId: 'usr-3' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1100 * 1000).toISOString(), eventType: 'COMMENT_ADDED', description: 'Restarted analytics-backend pods observing logs', userId: 'usr-3' },
        ],
        actionItems: [
             { id: uuidv4(), description: 'Escalate to Tier 2 support for database investigation', assignedTo: 'usr-8', status: 'OPEN', dueDate: new Date(Date.now() + 1 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: null, linkedPlaybookId: 'pb-2', tags: ['data', 'outage', 'critical'], comments: [],
        createdAt: new Date(Date.now() - 1300 * 1000).toISOString(), updatedAt: new Date(Date.now() - 1100 * 1000).toISOString(),
    },
    {
        id: 'inc-3', title: 'Authentication Service Login Failures', severity: 'SEV3', status: 'MITIGATED',
        source: 'USER_REPORT', description: 'Users reporting intermittent login failures on authentication service',
        impactDescription: 'Some users unable to log in affecting user experience',
        rootCauseDescription: 'Database connection pool exhaustion due to misconfigured max connections',
        affectedServices: ['AuthService'], affectedComponents: ['auth-api', 'user-db'],
        detectionTime: new Date(Date.now() - 10 * 24 * 3600 * 1000).toISOString(), startTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(),
        mitigationTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 30 * 60 * 1000).toISOString(),
        resolutionTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 2 * 3600 * 1000).toISOString(),
        ownerId: 'usr-1', currentTeam: 'SRE-Auth', relatedAlertIds: ['alert-auth-login-fail'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Users report login failures' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Incident set to ACTIVE' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 30 * 60 * 1000).toISOString(), eventType: 'MITIGATION_STEP', description: 'Increased DB connection pool size' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 2 * 3600 * 1000).toISOString(), eventType: 'RESOLUTION_STEP', description: 'Root cause identified and remediated' },
        ],
        actionItems: [
            { id: uuidv4(), description: 'Update DB connection pool configuration in production', assignedTo: 'usr-4', status: 'DONE', dueDate: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Add monitoring for DB connection pool utilization', assignedTo: 'usr-2', status: 'DONE', dueDate: new Date(Date.now() - 8 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Review all service configurations for similar pitfalls', assignedTo: 'usr-2', status: 'OPEN', dueDate: new Date(Date.now() + 7 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: {
            id: 'pm-3', incidentId: 'inc-3', title: 'Postmortem for Auth Service Login Failures', status: 'PUBLISHED',
            createdAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(), updatedAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(),
            sections: [
                { id: uuidv4(), type: 'SUMMARY', title: 'Summary', content: JSON.stringify(convertToRaw(ContentState.createFromText('On YYYY-MM-DD the Authentication Service experienced intermittent login failures for a duration of ~2 hours due to database connection pool exhaustion'))), generatedByAI: false },
                { id: uuidv4(), type: 'IMPACT', title: 'Impact', content: JSON.stringify(convertToRaw(ContentState.createFromText('Approximately 15% of login attempts failed resulting in degraded user experience and potential loss of active users during the incident window'))), generatedByAI: false },
                { id: uuidv4(), type: 'ROOT_CAUSE', title: 'Root Cause', content: JSON.stringify(convertToRaw(ContentState.createFromText('The primary root cause was an incorrectly configured max_connections parameter in the database connection pool which was exhausted under peak load A recent deployment increased traffic without adjusting this setting'))), generatedByAI: false },
                { id: uuidv4(), type: 'RESOLUTION', title: 'Resolution', content: JSON.stringify(convertToRaw(ContentState.createFromText('The incident was mitigated by increasing the max_connections parameter and restarting the AuthService instances Full resolution involved a configuration update'))), generatedByAI: false },
                { id: uuidv4(), type: 'ACTION_ITEMS', title: 'Action Items', content: JSON.stringify(convertToRaw(ContentState.createFromText('1 Update DB connection pool configuration DONE 2 Add monitoring for DB connection pool utilization DONE 3 Review all service configurations for similar pitfalls OPEN'))), generatedByAI: false },
            ],
            approvedBy: 'usr-2',
        },
        linkedPlaybookId: null, tags: ['auth', 'database', 'resolved'], comments: [],
        createdAt: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(), updatedAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(),
    },
    ...Array.from({ length: 20 }).map((_ i) => {
        const id = `inc-${i + 4}`;
        const severity: IncidentSeverity = ['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'][Math.floor(Math.random() * 5)] as IncidentSeverity;
        const status: IncidentStatus = ['ACTIVE', 'INVESTIGATING', 'MITIGATED', 'RESOLVED', 'CLOSED'][Math.floor(Math.random() * 5)] as IncidentStatus;
        const services = ['AuthService', 'PaymentGateway', 'NotificationService', 'DataAnalytics', 'UserManagement', 'ImageProcessing'];
        const affectedService = services[Math.floor(Math.random() * services.length)];
        const title = `${affectedService} Random Issue ${i + 1}`;
        const startTime = new Date(Date.now() - Math.random() * 30 * 24 * 3600 * 1000).toISOString();
        const detectionTime = new Date(new Date(startTime).getTime() + Math.random() * 60 * 1000).toISOString();
        const ownerId = mockUsers[Math.floor(Math.random() * mockUsers.length)].id;
        const hasPostmortem = Math.random() > 0.5;

        return {
            id, title, severity, status,
            source: 'MONITORING_ALERT', description: `Simulated incident for ${affectedService} Details about performance degradation`,
            impactDescription: `Minor impact on ${affectedService} users`,
            rootCauseDescription: hasPostmortem ? 'Simulated root cause for testing purposes' : '',
            affectedServices: [affectedService], affectedComponents: [],
            detectionTime, startTime,
            mitigationTime: status === 'MITIGATED' || status === 'RESOLVED' || status === 'CLOSED' ? new Date(new Date(detectionTime).getTime() + Math.random() * 30 * 60 * 1000).toISOString() : null,
            resolutionTime: status === 'RESOLVED' || status === 'CLOSED' ? new Date(new Date(detectionTime).getTime() + Math.random() * 120 * 60 * 1000).toISOString() : null,
            ownerId, currentTeam: 'SRE-General', relatedAlertIds: [], timelineEvents: [], actionItems: [],
            postmortemDoc: hasPostmortem ? {
                id: `pm-${id}`, incidentId: id, title: `Postmortem for ${id}`, status: Math.random() > 0.5 ? 'PUBLISHED' : 'DRAFT',
                createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), sections: [],
            } : null,
            linkedPlaybookId: Math.random() > 0.7 ? (Math.random() > 0.5 ? 'pb-1' : 'pb-2') : null, tags: [affectedService.toLowerCase(), 'simulated'], comments: [],
            createdAt: startTime, updatedAt: new Date().toISOString(),
        };
    })
];


const mockPlaybooks: Playbook[] = [
    {
        id: 'pb-1', name: 'Payment Gateway Latency Debug', description: 'Steps to debug and resolve payment gateway latency issues',
        steps: [
            { id: uuidv4(), description: 'Check Payment Gateway service metrics for high response times', type: 'CHECK_METRIC', metricToCheck: { service: 'PaymentGateway', metricName: 'responseTime', operator: 'gt', value: 200 }, status: 'PENDING', assignedTo: 'usr-1' },
            { id: uuidv4(), description: 'Review recent deployments to Payment Gateway service', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-1' },
            { id: uuidv4(), description: 'Scale up Payment Gateway application instances', type: 'COMMAND', command: 'kubectl scale deployment payment-gateway --replicas=5', target: 'Kubernetes', status: 'PENDING' },
            { id: uuidv4(), description: 'Notify #payment-alerts Slack channel of ongoing issue', type: 'NOTIFICATION', target: 'Slack', status: 'PENDING' },
            { id: uuidv4(), description: 'Verify latency reduction via monitoring dashboards', type: 'CHECK_METRIC', metricToCheck: { service: 'PaymentGateway', metricName: 'responseTime', operator: 'lt', value: 100 }, status: 'PENDING', assignedTo: 'usr-1' },
        ],
        tags: ['payments', 'playbook'], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
    },
    {
        id: 'pb-2', name: 'Data Analytics Service Restart', description: 'Procedure to restart and verify the Data Analytics service',
        steps: [
            { id: uuidv4(), description: 'Confirm Data Analytics service is down via monitoring', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-3', manualConfirmationRequired: true },
            { id: uuidv4(), description: 'Restart analytics-backend pods', type: 'COMMAND', command: 'kubectl rollout restart deployment analytics-backend', target: 'Kubernetes', status: 'PENDING' },
            { id: uuidv4(), description: 'Verify service status and data processing via dashboards', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-3' },
            { id: uuidv4(), description: 'Post update in #data-analytics Slack channel', type: 'NOTIFICATION', target: 'Slack', status: 'PENDING' },
        ],
        tags: ['data', 'playbook'], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
    },
];

let incidentDataStore: DetailedIncident[] = [...mockIncidentDetails];

export const IncidentApiService = {
    fetchIncidents: async (filters?: { status?: IncidentStatus[], severity?: IncidentSeverity[], service?: string, search?: string }): Promise<DetailedIncident[]> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        let filtered = incidentDataStore;

        if (filters?.status && filters.status.length > 0) {
            filtered = filtered.filter(inc => filters.status!.includes(inc.status));
        }
        if (filters?.severity && filters.severity.length > 0) {
            filtered = filtered.filter(inc => filters.severity!.includes(inc.severity));
        }
        if (filters?.service) {
            filtered = filtered.filter(inc => inc.affectedServices.includes(filters.service!));
        }
        if (filters?.search) {
            const searchTerm = filters.search.toLowerCase();
            filtered = filtered.filter(inc =>
                inc.title.toLowerCase().includes(searchTerm) ||
                inc.description.toLowerCase().includes(searchTerm) ||
                inc.id.toLowerCase().includes(searchTerm) ||
                inc.affectedServices.some(s => s.toLowerCase().includes(searchTerm)) ||
                inc.tags.some(t => t.toLowerCase().includes(searchTerm))
            );
        }

        return JSON.parse(JSON.stringify(filtered));
    },

    fetchIncidentById: async (id: string): Promise<DetailedIncident | null> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        return JSON.parse(JSON.stringify(incidentDataStore.find(inc => inc.id === id) || null));
    },

    updateIncident: async (incident: DetailedIncident, userId: string = 'system'): Promise<DetailedIncident> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const index = incidentDataStore.findIndex(inc => inc.id === incident.id);
        if (index > -1) {
            const oldIncident = incidentDataStore[index];
            const updatedIncident = { ...oldIncident, ...incident, updatedAt: new Date().toISOString() };

            const newTimelineEvents: IncidentTimelineEvent[] = [];
            if (oldIncident.status !== updatedIncident.status) {
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'STATUS_CHANGE',
                    description: `Status changed from ${oldIncident.status} to ${updatedIncident.status}`,
                    details: { oldStatus: oldIncident.status, newStatus: updatedIncident.status }, userId
                });
            }
            if (oldIncident.severity !== updatedIncident.severity) {
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'SEVERITY_CHANGED',
                    description: `Severity changed from ${oldIncident.severity} to ${updatedIncident.severity}`,
                    details: { oldSeverity: oldIncident.severity, newSeverity: updatedIncident.severity }, userId
                });
            }
            if (oldIncident.ownerId !== updatedIncident.ownerId) {
                const oldOwnerName = mockUsers.find(u => u.id === oldIncident.ownerId)?.name || 'Unassigned';
                const newOwnerName = mockUsers.find(u => u.id === updatedIncident.ownerId)?.name || 'Unassigned';
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'OWNER_ASSIGNED',
                    description: `Owner changed from ${oldOwnerName} to ${newOwnerName}`,
                    details: { oldOwner: oldIncident.ownerId, newOwner: updatedIncident.ownerId }, userId
                });
            }
            // Add other field change tracking as needed

            updatedIncident.timelineEvents = [...updatedIncident.timelineEvents, ...newTimelineEvents];
            incidentDataStore[index] = updatedIncident;
            return JSON.parse(JSON.stringify(incidentDataStore[index]));
        }
        throw new Error('Incident not found');
    },

    createIncident: async (newIncidentData: Partial<DetailedIncident>, userId: string = 'system'): Promise<DetailedIncident> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const now = new Date().toISOString();
        const newIncident: DetailedIncident = {
            id: `inc-${uuidv4().substring(0, 8)}`,
            title: newIncidentData.title || 'New Incident',
            severity: newIncidentData.severity || 'SEV3',
            status: newIncidentData.status || 'ACTIVE',
            source: newIncidentData.source || 'MANUAL',
            description: newIncidentData.description || 'No description provided',
            impactDescription: newIncidentData.impactDescription || '',
            rootCauseDescription: '',
            affectedServices: newIncidentData.affectedServices || [],
            affectedComponents: newIncidentData.affectedComponents || [],
            detectionTime: newIncidentData.detectionTime || now,
            startTime: newIncidentData.startTime || now,
            mitigationTime: null,
            resolutionTime: null,
            ownerId: newIncidentData.ownerId || null,
            currentTeam: newIncidentData.currentTeam || null,
            relatedAlertIds: newIncidentData.relatedAlertIds || [],
            timelineEvents: [
                { id: uuidv4(), timestamp: now, eventType: 'CUSTOM_EVENT', description: 'Incident created', userId }
            ],
            actionItems: [],
            postmortemDoc: null,
            linkedPlaybookId: newIncidentData.linkedPlaybookId || null,
            tags: newIncidentData.tags || [],
            comments: [],
            createdAt: now,
            updatedAt: now,
        };
        incidentDataStore.push(newIncident);
        return JSON.parse(JSON.stringify(newIncident));
    },

    fetchUsers: async (): Promise<UserProfile[]> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockUsers));
    },

    fetchServiceHealth: async (): Promise<ServiceHealthMetric[]> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        return JSON.parse(JSON.stringify(mockServices));
    },

    fetchMetricData: async (metricName: string, serviceName?: string, durationMinutes: number = 60): Promise<TimeSeriesMetric> => {
        await new Promise(resolve => setTimeout(resolve, 150));
        let baseValue = 0;
        let fluctuation = 0;
        let unit = '';

        if (metricName === 'responseTime') {
            baseValue = serviceName === 'PaymentGateway' ? 300 : (serviceName === 'DataAnalytics' ? 0 : 80);
            fluctuation = serviceName === 'PaymentGateway' ? 100 : 20;
            unit = 'ms';
        } else if (metricName === 'errorRate') {
            baseValue = serviceName === 'PaymentGateway' ? 0.5 : (serviceName === 'DataAnalytics' ? 100 : 0.05);
            fluctuation = serviceName === 'PaymentGateway' ? 0.3 : 0.03;
            unit = '%';
        } else if (metricName === 'incidentCount') {
            baseValue = 1;
            fluctuation = 0.5;
            unit = 'incidents';
        } else {
            baseValue = 100;
            fluctuation = 10;
            unit = 'units';
        }
        return generateMockMetrics(metricName, unit, baseValue, fluctuation, durationMinutes);
    },

    addIncidentComment: async (incidentId: string, userId: string, userName: string, content: string): Promise<IncidentComment> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const now = new Date().toISOString();
        const newComment: IncidentComment = {
            id: uuidv4(),
            incidentId,
            userId,
            userName,
            timestamp: now,
            content,
        };
        incident.comments.push(newComment);
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'COMMENT_ADDED', description: `Comment added by ${userName}`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(newComment));
    },

    addActionItem: async (incidentId: string, description: string, assignedTo: string, dueDate: string | null, userId: string = 'system'): Promise<IncidentActionItem> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const now = new Date().toISOString();
        const newActionItem: IncidentActionItem = {
            id: uuidv4(),
            description,
            assignedTo,
            status: 'OPEN',
            dueDate,
            createdAt: now,
            updatedAt: now,
        };
        incident.actionItems.push(newActionItem);
        const assigneeName = mockUsers.find(u => u.id === assignedTo)?.name || 'Unknown User';
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'ACTION_ITEM_ADDED', description: `Action item created: "${description}" assigned to ${assigneeName}`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(newActionItem));
    },

    updateActionItem: async (incidentId: string, actionItem: IncidentActionItem, userId: string = 'system'): Promise<IncidentActionItem> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const index = incident.actionItems.findIndex(ai => ai.id === actionItem.id);
        if (index > -1) {
            const oldStatus = incident.actionItems[index].status;
            incident.actionItems[index] = { ...incident.actionItems[index], ...actionItem, updatedAt: new Date().toISOString() };
            if (oldStatus !== actionItem.status) {
                incident.timelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: `Action item "${actionItem.description}" status updated from ${oldStatus} to ${actionItem.status}`, userId
                });
            }
            incident.updatedAt = new Date().toISOString();
            return JSON.parse(JSON.stringify(incident.actionItems[index]));
        }
        throw new Error('Action item not found');
    },

    fetchPlaybooks: async (): Promise<Playbook[]> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockPlaybooks));
    },

    fetchPlaybookById: async (id: string): Promise<Playbook | null> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockPlaybooks.find(pb => pb.id === id) || null));
    },

    updatePlaybookStepStatus: async (incidentId: string, playbookId: string, stepId: string, status: PlaybookStepStatus, userId: string = 'system'): Promise<Playbook> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        const playbook = mockPlaybooks.find(pb => pb.id === playbookId);
        if (!playbook) throw new Error('Playbook not found');

        const step = playbook.steps.find(s => s.id === stepId);
        if (!step) throw new Error('Playbook step not found');

        const oldStatus = step.status;
        step.status = status;
        step.executionLog = (step.executionLog || '') + `\n[${formatTimestamp(new Date().toISOString())}] Step status changed to ${status} by ${mockUsers.find(u => u.id === userId)?.name || 'System'}`;

        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (incident && oldStatus !== status) {
            incident.timelineEvents.push({
                id: uuidv4(),
                timestamp: new Date().toISOString(),
                eventType: 'PLAYBOOK_STEP_EXECUTION',
                description: `Playbook step "${step.description}" status changed to ${status}`,
                details: { playbookId, stepId, oldStatus, newStatus: status },
                userId
            });
            incident.updatedAt = new Date().toISOString();
        }
        return JSON.parse(JSON.stringify(playbook));
    },

    savePostmortem: async (postmortem: PostmortemDocument, userId: string = 'system'): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const incident = incidentDataStore.find(inc => inc.id === postmortem.incidentId);
        if (!incident) throw new Error('Incident not found for postmortem');

        const now = new Date().toISOString();
        if (!incident.postmortemDoc) {
            incident.postmortemDoc = { ...postmortem, id: `pm-${incident.id}`, createdAt: now, updatedAt: now };
        } else {
            incident.postmortemDoc = { ...incident.postmortemDoc, ...postmortem, updatedAt: now };
        }
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'CUSTOM_EVENT', description: `Postmortem document saved Status ${postmortem.status}`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },

    submitPostmortemForReview: async (pmId: string, incidentId: string, userId: string = 'system'): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident?.postmortemDoc || incident.postmortemDoc.id !== pmId) throw new Error('Postmortem not found');

        incident.postmortemDoc.status = 'REVIEW';
        incident.postmortemDoc.updatedAt = new Date().toISOString();
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: 'Postmortem submitted for review', userId
        });
        incident.updatedAt = new Date().toISOString();
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },

    approvePostmortem: async (pmId: string, incidentId: string, approverId: string): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident?.postmortemDoc || incident.postmortemDoc.id !== pmId) throw new Error('Postmortem not found');

        incident.postmortemDoc.status = 'PUBLISHED';
        incident.postmortemDoc.approvedBy = approverId;
        incident.postmortemDoc.updatedAt = new Date().toISOString();
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: `Postmortem approved and published by ${mockUsers.find(u => u.id === approverId)?.name || 'Unknown'}`, userId: approverId
        });
        incident.updatedAt = new Date().toISOString();
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },
};

export const formatTimestamp = (isoString: string | null, includeTime: boolean = true): string => {
    if (!isoString) return 'N/A';
    const date = new Date(isoString);
    if (isNaN(date.getTime())) return 'Invalid Date';
    return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: includeTime ? '2-digit' : undefined,
        minute: includeTime ? '2-digit' : undefined,
        second: includeTime ? '2-digit' : undefined,
        hour12: false
    });
};

export const getSeverityColorClass = (severity: IncidentSeverity): string => {
    switch (severity) {
        case 'SEV1': return 'bg-red-700 text-white';
        case 'SEV2': return 'bg-orange-600 text-white';
        case 'SEV3': return 'bg-yellow-500 text-black';
        case 'SEV4': return 'bg-blue-500 text-white';
        case 'SEV5': return 'bg-green-500 text-white';
        default: return 'bg-gray-500 text-white';
    }
};

export const getStatusColorClass = (status: IncidentStatus): string => {
    switch (status) {
        case 'ACTIVE': return 'text-red-400';
        case 'INVESTIGATING': return 'text-orange-400';
        case 'MITIGATED': return 'text-yellow-400';
        case 'RESOLVED': return 'text-green-400';
        case 'CLOSED': return 'text-gray-500';
        case 'CANCELLED': return 'text-gray-600';
        default: return 'text-gray-400';
    }
};

export const IncidentDetailsModal: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onClose: () => void;
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident users onClose onUpdateIncident }) => {
    const [currentIncident, setCurrentIncident] = useState<DetailedIncident>(incident);
    const [activeTab, setActiveTab] = useState<'overview' | 'timeline' | 'action-items' | 'comments' | 'postmortem' | 'playbook' | 'metrics'>('overview');
    const [isSaving, setIsSaving] = useState(false);
    const { currentUser } = useContext(DataContext);

    useEffect(() => {
        setCurrentIncident(incident);
        if (incident.linkedPlaybookId && activeTab !== 'playbook' && activeTab !== 'overview' && activeTab !== 'metrics') {
            setActiveTab('playbook'); // Automatically switch to playbook if linked and not already on a primary tab
        } else if (!incident.linkedPlaybookId && activeTab === 'playbook') {
            setActiveTab('overview'); // Switch back if playbook unlinked
        }
    }, [incident]);

    const handleFieldChange = useCallback((field: keyof DetailedIncident, value: any) => {
        setCurrentIncident(prev => ({ ...prev, [field]: value }));
    }, []);

    const handleSaveIncident = async () => {
        setIsSaving(true);
        try {
            const updated = await IncidentApiService.updateIncident(currentIncident, currentUser?.id || 'system');
            onUpdateIncident(updated);
            alert('Incident updated successfully');
        } catch (error) {
            console.error('Failed to update incident', error);
            alert('Failed to update incident');
        } finally {
            setIsSaving(false);
        }
    };

    const getOwnerName = (ownerId: string | null) => users.find(u => u.id === ownerId)?.name || 'Unassigned';
    const getAssigneeName = (assigneeId: string) => users.find(u => u.id === assigneeId)?.name || 'Unknown User';

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-5xl w-full h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">{currentIncident.title} <span className={`ml-2 text-sm px-2 py-1 rounded-full ${getSeverityColorClass(currentIncident.severity)}`}>{currentIncident.severity}</span></h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl font-bold leading-none">&times;</button>
                </div>
                <div className="flex-grow flex flex-col">
                    <div className="flex border-b border-gray-700 overflow-x-auto">
                        {['overview', 'timeline', 'action-items', 'comments', 'postmortem', (currentIncident.linkedPlaybookId ? 'playbook' : null), 'metrics'].filter(Boolean).map(tab => (
                            <button
                                key={tab}
                                className={`flex-shrink-0 py-3 px-6 text-sm font-medium ${activeTab === tab ? 'text-cyan-400 border-b-2 border-cyan-400' : 'text-gray-400 hover:text-white'}`}
                                onClick={() => setActiveTab(tab as any)}
                            >
                                {tab?.replace('-', ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}
                            </button>
                        ))}
                    </div>

                    <div className="flex-grow p-6 space-y-4 overflow-y-auto">
                        {activeTab === 'overview' && (
                            <IncidentOverviewTab incident={currentIncident} users={users} onFieldChange={handleFieldChange} onSave={handleSaveIncident} isSaving={isSaving} getOwnerName={getOwnerName} />
                        )}
                        {activeTab === 'timeline' && (
                            <IncidentTimelineTab incident={currentIncident} users={users} />
                        )}
                        {activeTab === 'action-items' && (
                            <IncidentActionItemsTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} getAssigneeName={getAssigneeName} />
                        )}
                        {activeTab === 'comments' && (
                            <IncidentCommentsTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'postmortem' && (
                            <IncidentPostmortemTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'playbook' && currentIncident.linkedPlaybookId && (
                            <IncidentPlaybookTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'metrics' && (
                            <IncidentMetricsTab incident={currentIncident} />
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export const IncidentOverviewTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onFieldChange: (field: keyof DetailedIncident, value: any) => void;
    onSave: () => void;
    isSaving: boolean;
    getOwnerName: (ownerId: string | null) => string;
}> = ({ incident users onFieldChange onSave isSaving getOwnerName }) => {
    const { currentUser } = useContext(DataContext);
    const [selectedUserForAssignment, setSelectedUserForAssignment] = useState(incident.ownerId || '');

    useEffect(() => {
        if (selectedUserForAssignment !== incident.ownerId) {
            onFieldChange('ownerId', selectedUserForAssignment || null);
        }
    }, [selectedUserForAssignment incident.ownerId onFieldChange]);

    const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const tags = e.target.value.split(',').map(tag => tag.trim()).filter(Boolean);
        onFieldChange('tags', tags);
    };

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="col-span-1 md:col-span-2 space-y-4">
                <label className="block text-gray-300 text-sm font-bold mb-1">Title</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.title}
                    onChange={(e) => onFieldChange('title', e.target.value)}
                />

                <label className="block text-gray-300 text-sm font-bold mb-1">Description</label>
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-24"
                    value={incident.description}
                    onChange={(e) => onFieldChange('description', e.target.value)}
                />

                <label className="block text-gray-300 text-sm font-bold mb-1">Impact Description</label>
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-20"
                    value={incident.impactDescription}
                    onChange={(e) => onFieldChange('impactDescription', e.target.value)}
                />
            </div>

            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Severity</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.severity}
                    onChange={(e) => onFieldChange('severity', e.target.value as IncidentSeverity)}
                >
                    {['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'].map(sev => <option key={sev} value={sev}>{sev}</option>)}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Status</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.status}
                    onChange={(e) => onFieldChange('status', e.target.value as IncidentStatus)}
                >
                    {['ACTIVE', 'INVESTIGATING', 'MITIGATED', 'RESOLVED', 'CLOSED', 'CANCELLED'].map(s => <option key={s} value={s}>{s}</option>)}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Owner</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={selectedUserForAssignment}
                    onChange={(e) => setSelectedUserForAssignment(e.target.value)}
                >
                    <option value="">Unassigned</option>
                    {users.filter(u => u.role === 'ENGINEER' || u.role === 'MANAGER' || u.onCall).map(user => (
                        <option key={user.id} value={user.id}>{user.name} {user.onCall && '(On-Call)'}</option>
                    ))}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Current Team</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.currentTeam || ''}
                    onChange={(e) => onFieldChange('currentTeam', e.target.value)}
                />
            </div>
            <div className="col-span-1 md:col-span-2">
                <label className="block text-gray-300 text-sm font-bold mb-1">Affected Services comma separated</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.affectedServices.join(', ')}
                    onChange={(e) => onFieldChange('affectedServices', e.target.value.split(',').map(s => s.trim()).filter(Boolean))}
                />
            </div>
            <div className="col-span-1 md:col-span-2">
                <label className="block text-gray-300 text-sm font-bold mb-1">Tags comma separated</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.tags.join(', ')}
                    onChange={handleTagsChange}
                />
            </div>
            <div className="col-span-1 md:col-span-2 flex justify-end mt-4">
                <button
                    onClick={onSave}
                    className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isSaving}
                >
                    {isSaving ? 'Saving' : 'Save Changes'}
                </button>
            </div>
            <div className="col-span-1 md:col-span-2 mt-4 text-sm text-gray-400 border-t border-gray-700 pt-4">
                <p><strong>Incident ID</strong> {incident.id}</p>
                <p><strong>Source</strong> {incident.source}</p>
                <p><strong>Created At</strong> {formatTimestamp(incident.createdAt)}</p>
                <p><strong>Last Updated</strong> {formatTimestamp(incident.updatedAt)}</p>
                <p><strong>Detected</strong> {formatTimestamp(incident.detectionTime)}</p>
                <p><strong>Started</strong> {formatTimestamp(incident.startTime)}</p>
                <p><strong>Mitigated</strong> {formatTimestamp(incident.mitigationTime)}</p>
                <p><strong>Resolved</strong> {formatTimestamp(incident.resolutionTime)}</p>
                <p><strong>Assigned Owner</strong> {getOwnerName(incident.ownerId)}</p>
                {incident.linkedPlaybookId && <p><strong>Linked Playbook</strong> {incident.linkedPlaybookId}</p>}
                {incident.relatedAlertIds.length > 0 && <p><strong>Related Alerts</strong> {incident.relatedAlertIds.join(', ')}</p>}
            </div>
        </div>
    );
};

export const IncidentTimelineTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
}> = ({ incident users }) => {
    const getUserName = (userId: string | undefined) => users.find(u => u.id === userId)?.name || 'System';

    const sortedEvents = [...incident.timelineEvents].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white mb-4">Incident Timeline</h4>
            {sortedEvents.length === 0 ? (
                <p className="text-gray-400">No timeline events recorded</p>
            ) : (
                <div className="relative pl-8">
                    <div className="absolute left-0 top-0 bottom-0 w-0.5 bg-gray-700"></div>
                    {sortedEvents.map((event index) => (
                        <div key={event.id} className="mb-8 flex items-start relative">
                            <div className="absolute left-0 -ml-2 w-4 h-4 rounded-full bg-cyan-500 border-2 border-gray-800"></div>
                            <div className="ml-8 w-full">
                                <p className="text-gray-400 text-xs mb-1">{formatTimestamp(event.timestamp)}</p>
                                <p className="font-semibold text-white">{event.description}</p>
                                <p className="text-gray-500 text-sm">by {getUserName(event.userId)}</p>
                                {event.details && (
                                    <div className="mt-2 text-xs text-gray-500 bg-gray-700/50 p-2 rounded-md">
                                        <p className="font-semibold">Details</p>
                                        <pre className="whitespace-pre-wrap">{JSON.stringify(event.details, null, 2)}</pre>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

export const IncidentActionItemsTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
    getAssigneeName: (assigneeId: string) => string;
}> = ({ incident users onUpdateIncident getAssigneeName }) => {
    const [actionItems, setActionItems] = useState<IncidentActionItem[]>(incident.actionItems);
    const [newActionItemDescription, setNewActionItemDescription] = useState('');
    const [newActionItemAssignee, setNewActionItemAssignee] = useState('');
    const [newActionItemDueDate, setNewActionItemDueDate] = useState('');
    const [isAdding, setIsAdding] = useState(false);
    const { currentUser } = useContext(DataContext);

    useEffect(() => {
        setActionItems(incident.actionItems);
    }, [incident.actionItems]);

    const handleAddActionItem = async () => {
        if (!newActionItemDescription || !newActionItemAssignee) {
            alert('Description and Assignee are required');
            return;
        }
        setIsAdding(true);
        try {
            const addedItem = await IncidentApiService.addActionItem(
                incident.id,
                newActionItemDescription,
                newActionItemAssignee,
                newActionItemDueDate || null,
                currentUser?.id || 'system'
            );
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id); // Re-fetch for full timeline updates
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            setNewActionItemDescription('');
            setNewActionItemAssignee('');
            setNewActionItemDueDate('');
        } catch (error) {
            console.error('Failed to add action item', error);
            alert('Failed to add action item');
        } finally {
            setIsAdding(false);
        }
    };

    const handleUpdateActionItemStatus = async (item: IncidentActionItem, newStatus: ActionItemStatus) => {
        const updatedItem = { ...item, status: newStatus };
        try {
            await IncidentApiService.updateActionItem(incident.id, updatedItem, currentUser?.id || 'system');
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id); // Re-fetch for full timeline updates
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
        } catch (error) {
            console.error('Failed to update action item status', error);
            alert('Failed to update action item status');
        }
    };

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Action Items</h4>

            <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                <h5 className="text-lg font-semibold text-white">Add New Action Item</h5>
                <input
                    type="text"
                    placeholder="Description"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemDescription}
                    onChange={(e) => setNewActionItemDescription(e.target.value)}
                />
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemAssignee}
                    onChange={(e) => setNewActionItemAssignee(e.target.value)}
                >
                    <option value="">Select Assignee</option>
                    {users.filter(u => u.role === 'ENGINEER' || u.role === 'MANAGER' || u.onCall).map(user => (
                        <option key={user.id} value={user.id}>{user.name} {user.onCall && '(On-Call)'}</option>
                    ))}
                </select>
                <input
                    type="date"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemDueDate}
                    onChange={(e) => setNewActionItemDueDate(e.target.value)}
                />
                <button
                    onClick={handleAddActionItem}
                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isAdding}
                >
                    {isAdding ? 'Adding' : 'Add Action Item'}
                </button>
            </div>

            <div className="space-y-4">
                {actionItems.length === 0 && <p className="text-gray-400">No action items for this incident</p>}
                {actionItems.map(item => (
                    <Card key={item.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-2">
                            <p className="font-semibold text-white">{item.description}</p>
                            <span className={`text-xs px-2 py-1 rounded-full ${item.status === 'DONE' ? 'bg-green-600' : item.status === 'IN_PROGRESS' ? 'bg-blue-600' : item.status === 'BLOCKED' ? 'bg-red-600' : 'bg-gray-600'} text-white`}>
                                {item.status.replace('_', ' ')}
                            </span>
                        </div>
                        <p className="text-sm text-gray-400">Assigned To: {getAssigneeName(item.assignedTo)}</p>
                        {item.dueDate && <p className="text-sm text-gray-400">Due: {formatTimestamp(item.dueDate, false)}</p>}
                        <div className="mt-3 flex space-x-2">
                            {item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'DONE')}
                                    className="bg-green-700 hover:bg-green-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Mark Done
                                </button>
                            )}
                            {item.status !== 'IN_PROGRESS' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'IN_PROGRESS')}
                                    className="bg-blue-700 hover:bg-blue-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    In Progress
                                </button>
                            )}
                            {item.status !== 'OPEN' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'OPEN')}
                                    className="bg-gray-700 hover:bg-gray-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Re-open
                                </button>
                            )}
                             {item.status !== 'BLOCKED' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'BLOCKED')}
                                    className="bg-red-700 hover:bg-red-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Blocked
                                </button>
                            )}
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

export const IncidentCommentsTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident users onUpdateIncident }) => {
    const [newComment, setNewComment] = useState('');
    const [isPosting, setIsPosting] = useState(false);
    const { currentUser } = useContext(DataContext);

    const handlePostComment = async () => {
        if (!newComment.trim()) return;
        if (!currentUser) {
            alert('Current user context missing Cannot post comment');
            return;
        }

        setIsPosting(true);
        try {
            await IncidentApiService.addIncidentComment(
                incident.id,
                currentUser.id,
                currentUser.name,
                newComment
            );
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id);
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            setNewComment('');
        } catch (error) {
            console.error('Failed to add comment', error);
            alert('Failed to add comment');
        } finally {
            setIsPosting(false);
        }
    };

    const getCommenterName = (userId: string) => users.find(u => u.id === userId)?.name || 'Unknown User';

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Comments</h4>

            <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600 h-24"
                    placeholder="Add a comment"
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                />
                <button
                    onClick={handlePostComment}
                    className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isPosting || !newComment.trim()}
                >
                    {isPosting ? 'Posting' : 'Post Comment'}
                </button>
            </div>

            <div className="space-y-4 max-h-96 overflow-y-auto custom-scrollbar">
                {incident.comments.length === 0 && <p className="text-gray-400">No comments yet</p>}
                {incident.comments.sort((a b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).map(comment => (
                    <Card key={comment.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-1">
                            <p className="font-semibold text-white">{getCommenterName(comment.userId)}</p>
                            <p className="text-xs text-gray-400">{formatTimestamp(comment.timestamp)}</p>
                        </div>
                        <p className="text-sm text-gray-300 whitespace-pre-line">{comment.content}</p>
                    </Card>
                ))}
            </div>
        </div>
    );
};

export const IncidentPostmortemTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident users onUpdateIncident }) => {
    const [postmortemDoc, setPostmortemDoc] = useState<PostmortemDocument | null>(incident.postmortemDoc);
    const [isLoadingAI, setIsLoadingAI] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [editorStates, setEditorStates] = useState<Record<string, EditorState>>({});
    const { currentUser } = useContext(DataContext);
    const [aiGeneratingSection, setAiGeneratingSection] = useState<PostmortemSectionType | null>(null);

    const initializeEditorStates = useCallback((pmDoc: PostmortemDocument) => {
        const initialEditorStates: Record<string, EditorState> = {};
        pmDoc.sections.forEach(section => {
            try {
                const contentState = section.content ? convertFromRaw(JSON.parse(section.content)) : ContentState.createFromText('');
                initialEditorStates[section.id] = EditorState.createWithContent(contentState);
            } catch (e) {
                initialEditorStates[section.id] = EditorState.createWithContent(ContentState.createFromText(section.content || ''));
            }
        });
        setEditorStates(initialEditorStates);
    }, []);

    useEffect(() => {
        setPostmortemDoc(incident.postmortemDoc);
        if (incident.postmortemDoc) {
            initializeEditorStates(incident.postmortemDoc);
        } else {
            setEditorStates({});
        }
    }, [incident.postmortemDoc initializeEditorStates]);

    const handleGenerateAISection = async (sectionType: PostmortemSectionType) => {
        setIsLoadingAI(true);
        setAiGeneratingSection(sectionType);
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            let prompt = `For the incident titled "${incident.title}" Incident ID ${incident.id} Severity ${incident.severity} Status ${incident.status} Description "${incident.description}" generate a detailed "${sectionType.replace(/_/g, ' ')}" section for a postmortem report Focus on factual and concise information`;

            if (sectionType === 'ROOT_CAUSE' && incident.timelineEvents.length > 0) {
                prompt += ` Consider the following incident details and timeline events\n`;
                prompt += `Affected Services ${incident.affectedServices.join(', ')}\n`;
                prompt += `Timeline ${incident.timelineEvents.map(e => `${formatTimestamp(e.timestamp)} ${e.description}`).join(' ')}\n`;
                prompt += `Impact Description ${incident.impactDescription}\n`;
                prompt += `Based on this what are the most likely root causes`;
            } else if (sectionType === 'ACTION_ITEMS') {
                prompt += ` Current status ${incident.status} Previous action items ${incident.actionItems.map(ai => `- ${ai.description} ${ai.status}`).join('\n') || 'None'} Suggest specific actionable and measurable items to prevent recurrence or improve response time Categorize them by short-term and long-term`;
            } else if (sectionType === 'IMPACT') {
                prompt += ` The incident had impact "${incident.impactDescription}" Elaborate on the quantitative and qualitative impact on users business and reputation`;
            } else if (sectionType === 'RESOLUTION') {
                prompt += ` The incident is currently ${incident.status} If it's mitigated or resolved describe the steps taken tools used and the personnel involved in resolving the incident`;
            } else if (sectionType === 'SUMMARY') {
                prompt += ` Summarize the incident including when it started when it was detected key impacts and its current status`;
            } else if (sectionType === 'LESSONS_LEARNED') {
                prompt += ` Based on the incident what are the key lessons learned regarding detection response communication and prevention`;
            } else if (sectionType === 'PREVENTION') {
                prompt += ` What concrete steps can be taken to prevent a similar incident from happening again or to minimize its impact if it does`;
            } else if (sectionType === 'TIMELINE') {
                 prompt += ` Reconstruct a detailed timeline from these events focusing on key milestones and actions
                Events ${incident.timelineEvents.map(e => `${formatTimestamp(e.timestamp)} ${e.eventType} ${e.description} by ${users.find(u => u.id === e.userId)?.name || 'System'}`).join('\n')}`;
            }

            prompt += ` Provide the response in a structured text format suitable for a report no more than 500 words`;

            const response = await ai.models.generateContent({ model: 'gemini-1.5-flash', contents: [{ text: prompt }] });
            const generatedContent = response.text;

            const newSection: PostmortemSection = {
                id: uuidv4(),
                type: sectionType,
                title: sectionType.replace(/_/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
                content: JSON.stringify(convertToRaw(ContentState.createFromText(generatedContent))),
                generatedByAI: true,
            };

            let updatedSections: PostmortemSection[] = [];
            let currentPostmortem = postmortemDoc;
            if (currentPostmortem) {
                const existingIndex = currentPostmortem.sections.findIndex(s => s.type === sectionType);
                if (existingIndex > -1) {
                    updatedSections = currentPostmortem.sections.map((s idx) => idx === existingIndex ? newSection : s);
                } else {
                    updatedSections = [...currentPostmortem.sections, newSection];
                }
            } else {
                updatedSections = [newSection];
            }

            const newPostmortemDoc: PostmortemDocument = currentPostmortem ?
                { ...currentPostmortem, sections: updatedSections } :
                {
                    id: `pm-${incident.id}`,
                    incidentId: incident.id,
                    title: `Postmortem for ${incident.title}`,
                    sections: updatedSections,
                    status: 'DRAFT',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                };

            const savedPm = await IncidentApiService.savePostmortem(newPostmortemDoc, currentUser?.id || 'system');
            onUpdateIncident({ ...incident, postmortemDoc: savedPm });
            setPostmortemDoc(savedPm); // Update local state for immediate re-render
            initializeEditorStates(savedPm); // Re-initialize editors with new content
            alert(`${sectionType} section generated by AI and saved`);

        } catch (err) {
            console.error(`Error generating AI ${sectionType} section`, err);
            alert(`Failed to generate AI ${sectionType} section Check console for details`);
        } finally {
            setIsLoadingAI(false);
            setAiGeneratingSection(null);
        }
    };

    const handleSavePostmortem = async () => {
        if (!postmortemDoc) return;
        setIsSaving(true);
        try {
            const updatedSections = postmortemDoc.sections.map(section => ({
                ...section,
                content: JSON.stringify(convertToRaw(editorStates[section.id]?.getCurrentContent() || ContentState.createFromText('')))
            }));
            const updatedPostmortemDoc = { ...postmortemDoc, sections: updatedSections };
            const savedPm = await IncidentApiService.savePostmortem(updatedPostmortemDoc, currentUser?.id || 'system');
            onUpdateIncident({ ...incident, postmortemDoc: savedPm });
            setPostmortemDoc(savedPm);
            alert('Postmortem saved successfully');
        } catch (error) {
            console.error('Failed to save postmortem', error);
            alert('Failed to save postmortem');
        } finally {
            setIsSaving(false);
        }
    };

    const handleEditorStateChange = (sectionId: string, newEditorState: EditorState) => {
        setEditorStates(prev => ({ ...prev, [sectionId]: newEditorState }));
    };

    const handleAddSection = (type: PostmortemSectionType) => {
        const newSection: PostmortemSection = {
            id: uuidv4(),
            type,
            title: type.replace(/_/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
            content: '',
            generatedByAI: false,
        };
        const updatedDoc = postmortemDoc ? { ...postmortemDoc, sections: [...postmortemDoc.sections, newSection] } : {
            id: `pm-${incident.id}`, incidentId: incident.id, title: `Postmortem for ${incident.title}`, sections: [newSection], status: 'DRAFT',
            createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
        };
        setPostmortemDoc(updatedDoc);
        setEditorStates(prev => ({ ...prev, [newSection.id]: EditorState.createEmpty() }));
    };

    const handleRemoveSection = (sectionId: string) => {
        if (!postmortemDoc) return;
        const updatedSections = postmortemDoc.sections.filter(s => s.id !== sectionId);
        setPostmortemDoc({ ...postmortemDoc, sections: updatedSections });
        setEditorStates(prev => {
            const newStates = { ...prev };
            delete newStates[sectionId];
            return newStates;
        });
    };

    const handleStatusUpdate = async (newStatus: 'REVIEW' | 'PUBLISHED') => {
        if (!postmortemDoc) return;
        setIsSaving(true);
        try {
            let updatedPm: PostmortemDocument;
            if (newStatus === 'REVIEW') {
                updatedPm = await IncidentApiService.submitPostmortemForReview(postmortemDoc.id, incident.id, currentUser?.id || 'system');
            } else { // PUBLISHED
                if (!currentUser) { alert('Current user context missing for approval'); return; }
                updatedPm = await IncidentApiService.approvePostmortem(postmortemDoc.id, incident.id, currentUser.id);
            }
            onUpdateIncident({ ...incident, postmortemDoc: updatedPm });
            setPostmortemDoc(updatedPm);
            alert(`Postmortem status updated to ${newStatus}`);
        } catch (error) {
            console.error('Failed to update postmortem status', error);
            alert('Failed to update postmortem status');
        } finally {
            setIsSaving(false);
        }
    };

    const renderPostmortemContent = (section: PostmortemSection) => {
        if (section.content) {
            try {
                const contentState = convertFromRaw(JSON.parse(section.content));
                return <div className="text-sm text-gray-300 read-only-editor" dangerouslySetInnerHTML={{ __html: editorStates[section.id] ? (EditorState.createWithContent(contentState) as any).toHTML() : '' }}></div>;
            } catch (e) {
                return <div className="prose prose-invert text-sm text-gray-300 whitespace-pre-line">{section.content}</div>;
            }
        }
        return <p className="text-gray-500 text-sm">No content yet</p>;
    };

    const canEdit = postmortemDoc?.status === 'DRAFT';
    const canSubmitForReview = postmortemDoc?.status === 'DRAFT' && postmortemDoc.sections.length > 0;
    const canApprove = postmortemDoc?.status === 'REVIEW' && (currentUser?.role === 'ADMIN' || currentUser?.role === 'MANAGER');
    const canGenerateAI = true; // AI generation is always possible but content can be overwritten

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Postmortem Document</h4>

            {!postmortemDoc ? (
                <div className="text-center p-8 bg-gray-700/50 rounded-md">
                    <p className="text-gray-300 mb-4">No postmortem document exists yet for this incident</p>
                    <button
                        onClick={() => {
                            const newPm = {
                                id: `pm-${incident.id}`, incidentId: incident.id, title: `Postmortem for ${incident.title}`, sections: [], status: 'DRAFT' as 'DRAFT',
                                createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
                            };
                            setPostmortemDoc(newPm);
                            IncidentApiService.savePostmortem(newPm, currentUser?.id || 'system');
                        }}
                        className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded"
                    >
                        Create New Postmortem
                    </button>
                </div>
            ) : (
                <div className="space-y-6">
                    <div className="flex flex-col md:flex-row justify-between items-center bg-gray-700/50 p-4 rounded-md">
                        <p className="text-gray-300 mb-2 md:mb-0">Status: <span className={`font-semibold ${postmortemDoc.status === 'PUBLISHED' ? 'text-green-400' : postmortemDoc.status === 'REVIEW' ? 'text-orange-400' : 'text-gray-400'}`}>{postmortemDoc.status}</span></p>
                        <div className="flex space-x-2 flex-wrap justify-end">
                            {canEdit && (
                                <button
                                    onClick={handleSavePostmortem}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    {isSaving ? 'Saving' : 'Save Postmortem'}
                                </button>
                            )}
                            {canSubmitForReview && (
                                <button
                                    onClick={() => handleStatusUpdate('REVIEW')}
                                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    Submit for Review
                                </button>
                            )}
                            {canApprove && (
                                <button
                                    onClick={() => handleStatusUpdate('PUBLISHED')}
                                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    Approve Publish
                                </button>
                            )}
                             {(postmortemDoc.status === 'REVIEW' || postmortemDoc.status === 'PUBLISHED') && !canEdit && (
                                <button
                                    onClick={() => alert('Feature to revert to draft or make a new version is not implemented')}
                                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px]"
                                    disabled={true} // Placeholder to indicate this is a future feature
                                >
                                    Revert/New Version
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                        <h5 className="text-lg font-semibold text-white">AI Generation Section Management</h5>
                        <div className="grid grid-cols-2 lg:grid-cols-4 gap-2">
                            {['SUMMARY', 'IMPACT', 'ROOT_CAUSE', 'RESOLUTION', 'ACTION_ITEMS', 'LESSONS_LEARNED', 'PREVENTION', 'TIMELINE'].map(type => (
                                <div key={type} className="flex items-center space-x-2">
                                    <button
                                        onClick={() => handleGenerateAISection(type as PostmortemSectionType)}
                                        className="flex-grow bg-indigo-600 hover:bg-indigo-700 text-white text-xs px-3 py-2 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                        disabled={isLoadingAI && aiGeneratingSection === type}
                                    >
                                        {isLoadingAI && aiGeneratingSection === type ? `Generating ${type.replace(/_/g, ' ')}` : `Generate AI ${type.replace(/_/g, ' ')}`}
                                    </button>
                                    {canEdit && (
                                        <button
                                            onClick={() => handleAddSection(type as PostmortemSectionType)}
                                            className="bg-gray-600 hover:bg-gray-700 text-white text-xs px-2 py-2 rounded disabled:opacity-50 transition-colors"
                                            title="Add empty section"
                                        >
                                            +
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="space-y-8">
                        {postmortemDoc.sections.length === 0 && <p className="text-gray-400">No sections added to postmortem yet</p>}
                        {postmortemDoc.sections.map(section => (
                            <Card key={section.id} className="p-6 bg-gray-800 border border-gray-700">
                                <div className="flex justify-between items-center mb-4">
                                    <h5 className="text-xl font-semibold text-white">{section.title}</h5>
                                    <div className="flex items-center space-x-2">
                                        {section.generatedByAI && <span className="text-xs text-indigo-400">AI Generated</span>}
                                        {canEdit && (
                                            <button
                                                onClick={() => handleRemoveSection(section.id)}
                                                className="text-red-500 hover:text-red-700 text-sm"
                                                title="Remove section"
                                            >
                                                &times;
                                            </button>
                                        )}
                                    </div>
                                </div>
                                {canEdit ? (
                                    <div className="bg-gray-900 border border-gray-600 rounded p-2 min-h-[10rem]">
                                        <Editor
                                            editorState={editorStates[section.id] || EditorState.createEmpty()}
                                            onEditorStateChange={(newState) => handleEditorStateChange(section.id, newState)}
                                            wrapperClassName="draft-editor-wrapper"
                                            editorClassName="draft-editor-content text-white"
                                            toolbarClassName="draft-editor-toolbar bg-gray-700 border-gray-600 rounded-t"
                                            toolbar={{
                                                options: ['inline', 'blockType', 'list', 'textAlign', 'link', 'emoji', 'remove', 'history'],
                                                inline: { inDropdown: false, options: ['bold', 'italic', 'underline', 'strikethrough'] },
                                                list: { inDropdown: false, options: ['unordered', 'ordered'] },
                                                textAlign: { inDropdown: true },
                                            }}
                                        />
                                    </div>
                                ) : (
                                    renderPostmortemContent(section)
                                )}
                            </Card>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
};

export const IncidentPlaybookTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident users onUpdateIncident }) => {
    const [playbook, setPlaybook] = useState<Playbook | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [executingStepId, setExecutingStepId] = useState<string | null>(null);
    const { currentUser } = useContext(DataContext);
    const [metricCheckResults, setMetricCheckResults] = useState<Record<string, boolean | null>>({});

    const fetchPlaybookData = useCallback(async () => {
        if (incident.linkedPlaybookId) {
            setIsLoading(true);
            try {
                const pb = await IncidentApiService.fetchPlaybookById(incident.linkedPlaybookId);
                setPlaybook(pb);
            } catch (error) {
                console.error('Failed to fetch playbook', error);
                setPlaybook(null);
            } finally {
                setIsLoading(false);
            }
        } else {
            setPlaybook(null);
            setIsLoading(false);
        }
    }, [incident.linkedPlaybookId]);

    useEffect(() => {
        fetchPlaybookData();
    }, [fetchPlaybookData]);

    const handleStepStatusChange = async (stepId: string, newStatus: PlaybookStepStatus) => {
        if (!playbook) return;
        setExecutingStepId(stepId);
        try {
            await IncidentApiService.updatePlaybookStepStatus(incident.id, playbook.id, stepId, newStatus, currentUser?.id || 'system');
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id);
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            fetchPlaybookData(); // Re-fetch playbook to get updated status
        } catch (error) {
            console.error('Failed to update playbook step status', error);
            alert('Failed to update playbook step status');
        } finally {
            setExecutingStepId(null);
        }
    };

    const handleExecuteCommand = async (step: PlaybookStep) => {
        if (!step.command) return;
        setExecutingStepId(step.id);
        alert(`Simulating execution of command ${step.command} on ${step.target || 'N/A'}`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate command execution time
        await handleStepStatusChange(step.id, 'COMPLETED'); // Mark as completed after simulation
        setExecutingStepId(null);
    };

    const handleMetricCheck = async (step: PlaybookStep) => {
        if (!step.metricToCheck) return;
        setExecutingStepId(step.id);
        const { service, metricName, operator, value } = step.metricToCheck;
        try {
            const metric = await IncidentApiService.fetchMetricData(metricName, service, 5); // Fetch last 5 mins
            const latestValue = metric.data[metric.data.length - 1]?.value;

            if (latestValue === undefined) {
                setMetricCheckResults(prev => ({ ...prev, [step.id]: null })); // Indicate no data
                alert(`No data for ${metricName} on ${service}`);
                await handleStepStatusChange(step.id, 'FAILED');
                return;
            }

            let checkPassed = false;
            switch (operator) {
                case 'gt': checkPassed = latestValue > value; break;
                case 'lt': checkPassed = latestValue < value; break;
                case 'eq': checkPassed = latestValue === value; break;
            }

            setMetricCheckResults(prev => ({ ...prev, [step.id]: checkPassed }));
            if (checkPassed) {
                alert(`Metric check passed ${metricName} ${latestValue} is ${operator} ${value}`);
                await handleStepStatusChange(step.id, 'COMPLETED');
            } else {
                alert(`Metric check failed ${metricName} ${latestValue} is NOT ${operator} ${value}`);
                await handleStepStatusChange(step.id, 'FAILED');
            }
        } catch (error) {
            console.error('Error during metric check', error);
            alert('Failed to perform metric check');
            setMetricCheckResults(prev => ({ ...prev, [step.id]: null }));
            await handleStepStatusChange(step.id, 'FAILED');
        } finally {
            setExecutingStepId(null);
        }
    };


    if (isLoading) {
        return <p className="text-gray-400">Loading playbook</p>;
    }

    if (!playbook) {
        return <p className="text-gray-400">No linked playbook for this incident</p>;
    }

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Linked Playbook: {playbook.name}</h4>
            <p className="text-gray-400">{playbook.description}</p>

            <div className="space-y-4">
                {playbook.steps.map((step index) => (
                    <Card key={step.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-2">
                            <p className="font-semibold text-white">Step {index + 1}: {step.description}</p>
                            <span className={`text-xs px-2 py-1 rounded-full ${step.status === 'COMPLETED' ? 'bg-green-600' : step.status === 'IN_PROGRESS' ? 'bg-blue-600' : step.status === 'FAILED' ? 'bg-red-600' : 'bg-gray-600'} text-white`}>
                                {step.status.replace('_', ' ')}
                            </span>
                        </div>
                        <p className="text-sm text-gray-400">Type: {step.type.replace('_', ' ')}</p>
                        {step.assignedTo && <p className="text-sm text-gray-400">Assigned To: {users.find(u => u.id === step.assignedTo)?.name || 'Unassigned'}</p>}
                        {step.command && <p className="text-sm text-gray-400">Command: <code className="bg-gray-700 px-2 py-1 rounded text-cyan-300">{step.command}</code></p>}
                        {step.target && <p className="text-sm text-gray-400">Target: {step.target}</p>}
                        {step.metricToCheck && (
                            <p className="text-sm text-gray-400">Metric Check: {step.metricToCheck.service} {step.metricToCheck.metricName} {step.metricToCheck.operator} {step.metricToCheck.value}</p>
                        )}
                        {step.executionLog && <p className="text-sm text-gray-500 mt-2 italic">Log: {step.executionLog}</p>}
                        {step.manualConfirmationRequired && <p className="text-sm text-orange-400 font-medium mt-1">Manual Confirmation Required</p>}
                        {metricCheckResults[step.id] !== undefined && metricCheckResults[step.id] !== null && (
                            <p className={`text-sm mt-1 ${metricCheckResults[step.id] ? 'text-green-400' : 'text-red-400'}`}>
                                Metric Check Result: {metricCheckResults[step.id] ? 'Passed' : 'Failed'}
                            </p>
                        )}
                        {metricCheckResults[step.id] === null && (
                            <p className="text-sm mt-1 text-gray-500">Metric Check Result: No data</p>
                        )}

                        <div className="mt-3 flex space-x-2 flex-wrap">
                            {step.status !== 'COMPLETED' && step.status !== 'FAILED' && step.type === 'MANUAL_TASK' && (
                                <button
                                    onClick={() => handleStepStatusChange(step.id, 'COMPLETED')}
                                    className="bg-green-700 hover:bg-green-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Completing' : 'Mark Completed'}
                                </button>
                            )}
                            {step.status !== 'COMPLETED' && step.status !== 'FAILED' && step.type === 'COMMAND' && (
                                <button
                                    onClick={()