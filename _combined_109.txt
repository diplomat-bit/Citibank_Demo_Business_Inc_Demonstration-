
--- FILE: ApiThrottlingView.tsx ---

import React, { useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { 
    LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, Legend, 
    BarChart, Bar, AreaChart, Area, PieChart, Pie, Cell, ScatterChart, Scatter, ZAxis, CartesianGrid 
} from 'recharts';
import { 
    ChevronDownIcon, ChevronUpIcon, PencilIcon, TrashIcon, PlusIcon,
    MagnifyingGlassIcon, BellIcon, Cog6ToothIcon, ClockIcon, SparklesIcon,
    ExclamationTriangleIcon, CheckCircleIcon, InformationCircleIcon, RocketLaunchIcon,
    CpuChipIcon, GlobeAltIcon, UserGroupIcon, ServerStackIcon, CodeBracketIcon,
    ScaleIcon, BeakerIcon, ChartBarIcon, DocumentTextIcon, CalendarDaysIcon, TagIcon
} from '@heroicons/react/24/outline'; // Adding more icons for richer UI
import { toast, Toaster } from 'react-hot-toast'; // For notifications

// --- Utility Types and Interfaces ---
interface ApiEndpoint {
    id: string;
    name: string;
    path: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    description: string;
    owner: string;
    category: string;
    avgLatencyMs: number;
    errorRate: number;
    peakTrafficRPS: number;
    status: 'active' | 'deprecated' | 'experimental';
}

interface RateLimitPolicy {
    id: string;
    name: string;
    description: string;
    appliesTo: 'global' | 'endpoint' | 'user' | 'ip' | 'client_id';
    targetId?: string; // e.g., endpointId, userId, ipAddress
    limit: number; // requests per unit
    unit: 'second' | 'minute' | 'hour' | 'day';
    burstLimit?: number; // requests allowed over limit for short period
    windowSizeSeconds?: number; // For sliding window
    priority: number;
    status: 'active' | 'inactive' | 'pending';
    createdAt: string;
    updatedAt: string;
    isAdaptive: boolean;
    adaptiveModelId?: string;
    blockDurationSeconds?: number; // How long to block after hitting limit
    customRules?: string[]; // e.g. ["header:X-API-KEY-TYPE=premium", "body:user.tier=gold"]
}

interface ThrottlingEvent {
    id: string;
    timestamp: string;
    endpointId: string;
    clientIp: string;
    userId?: string;
    policyId: string;
    reason: string; // e.g., 'rate_limit_exceeded', 'burst_limit_exceeded', 'anomaly_detected'
    rateLimitValue: number;
    currentRPS: number;
    blocked: boolean;
    durationMs?: number; // how long the request took (if blocked later)
    tags: string[];
}

interface AnomalyDetectionConfig {
    id: string;
    name: string;
    description: string;
    target: 'global' | 'endpoint' | 'user' | 'ip';
    targetId?: string;
    modelType: 'statistical' | 'machine_learning' | 'heuristic';
    threshold: number; // e.g., standard deviations, confidence score
    alertSeverity: 'low' | 'medium' | 'high' | 'critical';
    alertChannels: string[]; // e.g., ['email', 'slack', 'pagerduty']
    status: 'active' | 'inactive';
    createdAt: string;
    updatedAt: string;
}

interface MlModel {
    id: string;
    name: string;
    version: string;
    type: 'regression' | 'classification' | 'clustering';
    algorithm: string;
    status: 'training' | 'deployed' | 'failed' | 'archived';
    performanceMetrics: {
        accuracy?: number;
        precision?: number;
        recall?: number;
        f1Score?: number;
        mse?: number;
        rSquared?: number;
    };
    trainingDataSize: number;
    lastTrained: string;
    deployedAt?: string;
    description: string;
    featuresUsed: string[];
    outputInterpretation: string; // How to interpret model's output (e.g., probability of abuse)
}

interface SimulationResult {
    id: string;
    name: string;
    timestamp: string;
    scenarioDescription: string;
    inputTrafficIncreasePercentage: number;
    predictedThrottledRequests: number;
    predictedLatencyIncreaseMs: number;
    impactedEndpoints: { endpointId: string; throttledIncrease: number; latencyIncrease: number }[];
    recommendations: string[];
    successRateAfterSimulation: number;
}

interface AuditLogEntry {
    id: string;
    timestamp: string;
    userId: string;
    action: string; // e.g., 'CREATE_POLICY', 'UPDATE_MODEL', 'DEACTIVATE_RULE'
    entityType: string; // e.g., 'RateLimitPolicy', 'MlModel', 'AnomalyDetectionConfig'
    entityId: string;
    oldValue: any;
    newValue: any;
    ipAddress: string;
}

interface CustomRuleSchema {
    id: string;
    name: string;
    description: string;
    language: 'javascript' | 'python' | 'lua' | 'cel'; // Common scripting languages for rule engines
    code: string;
    status: 'active' | 'inactive' | 'draft';
    createdAt: string;
    updatedAt: string;
    tags: string[];
    testCases: { input: any; expectedOutput: boolean; description: string }[];
}

// --- Mock Data Generators ---
const mockEndpoints: ApiEndpoint[] = Array.from({ length: 15 }).map((_, i) => ({
    id: `ep-${i + 1}`,
    name: `/${['users', 'products', 'orders', 'payments', 'analytics', 'auth', 'notifications', 'search', 'config', 'status', 'inventory', 'shipping', 'reviews', 'profile', 'billing'][i % 15]}${i % 3 === 0 ? '/:id' : ''}`,
    path: `/${['users', 'products', 'orders', 'payments', 'analytics', 'auth', 'notifications', 'search', 'config', 'status', 'inventory', 'shipping', 'reviews', 'profile', 'billing'][i % 15]}`,
    method: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'][i % 5] as any,
    description: `API for managing ${['user', 'product', 'order', 'payment', 'analytic', 'authentication', 'notification', 'search', 'configuration', 'system status', 'inventory item', 'shipping detail', 'customer review', 'user profile', 'billing info'][i % 15]} data.`,
    owner: `team-${i % 3 + 1}`,
    category: ['core', 'data', 'utility', 'security'][i % 4],
    avgLatencyMs: Math.floor(Math.random() * 200) + 20,
    errorRate: parseFloat((Math.random() * 5).toFixed(2)),
    peakTrafficRPS: Math.floor(Math.random() * 2000) + 100,
    status: ['active', 'deprecated', 'experimental'][i % 3] as any,
}));

const mockRateLimitPolicies: RateLimitPolicy[] = Array.from({ length: 10 }).map((_, i) => ({
    id: `rlp-${i + 1}`,
    name: `Policy ${i + 1} - ${i % 3 === 0 ? 'Global' : mockEndpoints[i % mockEndpoints.length].name}`,
    description: `Rate limit policy for ${i % 3 === 0 ? 'all APIs' : mockEndpoints[i % mockEndpoints.length].name}.`,
    appliesTo: i % 3 === 0 ? 'global' : 'endpoint',
    targetId: i % 3 === 0 ? undefined : mockEndpoints[i % mockEndpoints.length].id,
    limit: (i + 1) * 100 + 50,
    unit: ['second', 'minute', 'hour'][i % 3] as any,
    burstLimit: i % 2 === 0 ? (i + 1) * 20 : undefined,
    windowSizeSeconds: i % 4 === 0 ? 60 : undefined,
    priority: i,
    status: ['active', 'inactive', 'pending'][i % 3] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    isAdaptive: i % 2 === 0,
    adaptiveModelId: i % 2 === 0 ? `mlm-${i % 3 + 1}` : undefined,
    blockDurationSeconds: i % 3 === 0 ? 300 : undefined,
    customRules: i % 4 === 0 ? [`header:X-User-Tier=${['premium', 'enterprise'][i % 2]}`, `ip_range:192.168.1.${i}.0/24`] : [],
}));

const mockThrottlingEvents: ThrottlingEvent[] = Array.from({ length: 50 }).map((_, i) => ({
    id: `evt-${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
    endpointId: mockEndpoints[i % mockEndpoints.length].id,
    clientIp: `192.168.${i % 255}.${i % 255}`,
    userId: i % 5 === 0 ? `user-${i % 10 + 1}` : undefined,
    policyId: mockRateLimitPolicies[i % mockRateLimitPolicies.length].id,
    reason: ['rate_limit_exceeded', 'burst_limit_exceeded', 'anomaly_detected', 'ip_blacklist'][i % 4],
    rateLimitValue: mockRateLimitPolicies[i % mockRateLimitPolicies.length].limit,
    currentRPS: mockRateLimitPolicies[i % mockRateLimitPolicies.length].limit + Math.floor(Math.random() * 50) + 1,
    blocked: true,
    durationMs: Math.floor(Math.random() * 500) + 10,
    tags: i % 3 === 0 ? ['critical', 'autoblock'] : [],
}));

const mockAnomalyConfigs: AnomalyDetectionConfig[] = Array.from({ length: 5 }).map((_, i) => ({
    id: `adcfg-${i + 1}`,
    name: `Anomaly Config ${i + 1} - ${i % 2 === 0 ? 'Global' : mockEndpoints[i % mockEndpoints.length].name}`,
    description: `Configuration for detecting anomalies.`,
    target: i % 2 === 0 ? 'global' : 'endpoint',
    targetId: i % 2 === 0 ? undefined : mockEndpoints[i % mockEndpoints.length].id,
    modelType: ['statistical', 'machine_learning', 'heuristic'][i % 3] as any,
    threshold: parseFloat((Math.random() * 3 + 1).toFixed(2)),
    alertSeverity: ['low', 'medium', 'high', 'critical'][i % 4] as any,
    alertChannels: ['email', 'slack', 'pagerduty'].slice(0, i % 3 + 1),
    status: ['active', 'inactive'][i % 2] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
}));

const mockMlModels: MlModel[] = Array.from({ length: 7 }).map((_, i) => ({
    id: `mlm-${i + 1}`,
    name: `TrafficPredictor-${i % 3 + 1}`,
    version: `v1.${i}`,
    type: ['regression', 'classification'][i % 2] as any,
    algorithm: ['XGBoost', 'RandomForest', 'NeuralNetwork', 'IsolationForest'][i % 4],
    status: ['deployed', 'training', 'failed', 'archived'][i % 4] as any,
    performanceMetrics: {
        accuracy: i % 2 === 0 ? parseFloat((0.85 + Math.random() * 0.1).toFixed(2)) : undefined,
        mse: i % 2 !== 0 ? parseFloat((0.01 + Math.random() * 0.05).toFixed(3)) : undefined,
    },
    trainingDataSize: Math.floor(Math.random() * 1000000) + 50000,
    lastTrained: new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000).toISOString(),
    deployedAt: i % 2 === 0 ? new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString() : undefined,
    description: `ML model for predicting API traffic patterns and identifying abusive behavior.`,
    featuresUsed: ['RPS', 'latency', 'error_rate', 'user_agent', 'geo_location', 'time_of_day'].slice(0, i % 6 + 1),
    outputInterpretation: i % 2 === 0 ? 'Probability of a request being abusive (0-1)' : 'Predicted optimal RPS limit',
}));

const mockSimulationResults: SimulationResult[] = Array.from({ length: 8 }).map((_, i) => ({
    id: `sim-${i + 1}`,
    name: `Scenario ${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000).toISOString(),
    scenarioDescription: `Simulated a ${i * 10 + 10}% traffic increase for 1 hour.`,
    inputTrafficIncreasePercentage: i * 10 + 10,
    predictedThrottledRequests: Math.floor(Math.random() * 10000) + 500,
    predictedLatencyIncreaseMs: Math.floor(Math.random() * 50) + 5,
    impactedEndpoints: mockEndpoints.slice(0, i % 5 + 1).map(ep => ({
        endpointId: ep.id,
        throttledIncrease: Math.floor(Math.random() * 1000) + 50,
        latencyIncrease: Math.floor(Math.random() * 20) + 2,
    })),
    recommendations: [`Adjust rate limit for ${mockEndpoints[i % mockEndpoints.length].name}`, `Scale up service capacity`, `Investigate traffic source`],
    successRateAfterSimulation: parseFloat((0.9 - Math.random() * 0.1).toFixed(2)),
}));

const mockAuditLogs: AuditLogEntry[] = Array.from({ length: 30 }).map((_, i) => ({
    id: `aud-${i + 1}`,
    timestamp: new Date(Date.now() - Math.random() * 14 * 24 * 60 * 60 * 1000).toISOString(),
    userId: `admin_user_${i % 3 + 1}`,
    action: ['CREATE_POLICY', 'UPDATE_POLICY', 'DELETE_POLICY', 'DEPLOY_MODEL', 'DEACTIVATE_ANOMALY_RULE'][i % 5],
    entityType: ['RateLimitPolicy', 'MlModel', 'AnomalyDetectionConfig'][i % 3],
    entityId: `rlp-${i % mockRateLimitPolicies.length + 1}`,
    oldValue: i % 2 === 0 ? { status: 'inactive' } : null,
    newValue: i % 2 === 0 ? { status: 'active' } : { limit: (i + 1) * 100 },
    ipAddress: `192.168.1.${i % 255}`,
}));

const mockCustomRules: CustomRuleSchema[] = Array.from({ length: 5 }).map((_, i) => ({
    id: `crule-${i + 1}`,
    name: `Custom Rule ${i + 1} - ${['PremiumUserCheck', 'HighTrafficAlert', 'BotDetection', 'GeoBlocking'][i % 4]}`,
    description: `Custom rule for advanced traffic filtering or anomaly detection.`,
    language: ['javascript', 'lua', 'cel'][i % 3] as any,
    code: `
function evaluate(request) {
    if (request.headers['X-User-Tier'] === 'premium' && request.path.startsWith('/api/v1/data')) {
        return true; // Allow more requests for premium users on data endpoints
    }
    if (request.ip === '1.2.3.4') {
        return false; // Block specific IP
    }
    return true;
}
    `, // Example pseudo-code
    status: ['active', 'inactive', 'draft'][i % 3] as any,
    createdAt: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    updatedAt: new Date().toISOString(),
    tags: ['security', 'performance', 'custom'][i % 3],
    testCases: [
        { input: { headers: { 'X-User-Tier': 'premium' }, path: '/api/v1/data' }, expectedOutput: true, description: 'Premium user on data endpoint' },
        { input: { headers: { 'X-User-Tier': 'basic' }, path: '/api/v1/data' }, expectedOutput: false, description: 'Basic user on data endpoint' },
    ],
}));

// Mock data for live throttling events (for a real-time feed)
let liveEventCounter = 0;
const generateLiveThrottlingEvent = (): ThrottlingEvent => {
    liveEventCounter++;
    const endpoint = mockEndpoints[liveEventCounter % mockEndpoints.length];
    const policy = mockRateLimitPolicies[liveEventCounter % mockRateLimitPolicies.length];
    return {
        id: `live-evt-${Date.now()}-${liveEventCounter}`,
        timestamp: new Date().toISOString(),
        endpointId: endpoint.id,
        clientIp: `203.0.113.${liveEventCounter % 255}`,
        userId: liveEventCounter % 7 === 0 ? `live-user-${liveEventCounter % 20 + 1}` : undefined,
        policyId: policy.id,
        reason: ['rate_limit_exceeded', 'burst_limit_exceeded', 'anomaly_detected', 'ip_blacklist'][liveEventCounter % 4],
        rateLimitValue: policy.limit,
        currentRPS: policy.limit + Math.floor(Math.random() * 100) + 1,
        blocked: true,
        durationMs: Math.floor(Math.random() * 80) + 5,
        tags: liveEventCounter % 5 === 0 ? ['alert', 'high_impact'] : [],
    };
};

// --- Helper Components & Utilities (exported for modularity, but kept in one file for directive) ---

export const StatusIndicator: React.FC<{ status: string }> = ({ status }) => {
    let colorClass = '';
    let icon;
    switch (status.toLowerCase()) {
        case 'active':
        case 'deployed':
            colorClass = 'text-green-500';
            icon = <CheckCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'inactive':
        case 'archived':
            colorClass = 'text-gray-500';
            icon = <InformationCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'pending':
        case 'training':
        case 'experimental':
            colorClass = 'text-yellow-500';
            icon = <ExclamationTriangleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        case 'failed':
        case 'deprecated':
            colorClass = 'text-red-500';
            icon = <ExclamationTriangleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
        default:
            colorClass = 'text-blue-500';
            icon = <InformationCircleIcon className="h-4 w-4 inline-block mr-1" />;
            break;
    }
    return (
        <span className={`flex items-center text-sm ${colorClass}`}>
            {icon} {status}
        </span>
    );
};

export const FilterSortPanel: React.FC<{
    filters: any;
    onFilterChange: (key: string, value: any) => void;
    sortBy: string;
    sortOrder: 'asc' | 'desc';
    onSortChange: (key: string) => void;
    availableFilters: { key: string; label: string; type: 'text' | 'select' | 'date-range'; options?: { value: string; label: string }[] }[];
    availableSorts: { key: string; label: string }[];
}> = ({ filters, onFilterChange, sortBy, sortOrder, onSortChange, availableFilters, availableSorts }) => {
    return (
        <div className="bg-gray-800 p-4 rounded-lg shadow-inner mb-6">
            <h3 className="text-lg font-semibold text-white mb-3">Filter & Sort</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {availableFilters.map(filter => (
                    <div key={filter.key}>
                        <label htmlFor={filter.key} className="block text-sm font-medium text-gray-300 mb-1">
                            {filter.label}
                        </label>
                        {filter.type === 'text' && (
                            <input
                                type="text"
                                id={filter.key}
                                value={filters[filter.key] || ''}
                                onChange={e => onFilterChange(filter.key, e.target.value)}
                                className="block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                                placeholder={`Search by ${filter.label.toLowerCase()}`}
                            />
                        )}
                        {filter.type === 'select' && (
                            <select
                                id={filter.key}
                                value={filters[filter.key] || ''}
                                onChange={e => onFilterChange(filter.key, e.target.value)}
                                className="block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                            >
                                <option value="">All {filter.label}</option>
                                {filter.options?.map(option => (
                                    <option key={option.value} value={option.value}>
                                        {option.label}
                                    </option>
                                ))}
                            </select>
                        )}
                        {/* Add more filter types like date-range if needed for real application */}
                    </div>
                ))}
            </div>
            <div className="mt-4 pt-4 border-t border-gray-700">
                <h4 className="text-md font-medium text-gray-300 mb-2">Sort By</h4>
                <div className="flex flex-wrap gap-2">
                    {availableSorts.map(sort => (
                        <button
                            key={sort.key}
                            onClick={() => onSortChange(sort.key)}
                            className={`px-3 py-1 text-sm rounded-full ${sortBy === sort.key ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} transition-colors duration-200 flex items-center`}
                        >
                            {sort.label}
                            {sortBy === sort.key && (
                                sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-4 w-4" /> : <ChevronDownIcon className="ml-1 h-4 w-4" />
                            )}
                        </button>
                    ))}
                </div>
            </div>
        </div>
    );
};

export const PaginationControls: React.FC<{
    currentPage: number;
    totalPages: number;
    onPageChange: (page: number) => void;
    totalItems: number;
    itemsPerPage: number;
}> = ({ currentPage, totalPages, onPageChange, totalItems, itemsPerPage }) => {
    if (totalPages <= 1) return null;

    const pageNumbers = useMemo(() => {
        const pages = [];
        const maxPagesToShow = 5; // e.g., 1 ... 4 5 [6] 7 8 ... 10
        let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
        let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

        if (endPage - startPage + 1 < maxPagesToShow) {
            startPage = Math.max(1, endPage - maxPagesToShow + 1);
        }

        if (startPage > 1) {
            pages.push(1);
            if (startPage > 2) pages.push('...');
        }

        for (let i = startPage; i <= endPage; i++) {
            pages.push(i);
        }

        if (endPage < totalPages) {
            if (endPage < totalPages - 1) pages.push('...');
            pages.push(totalPages);
        }

        return pages;
    }, [currentPage, totalPages]);

    return (
        <div className="flex justify-between items-center mt-6">
            <span className="text-sm text-gray-400">
                Showing {Math.min(totalItems, (currentPage - 1) * itemsPerPage + 1)} - {Math.min(totalItems, currentPage * itemsPerPage)} of {totalItems} items
            </span>
            <nav className="relative z-0 inline-flex rounded-md shadow-sm -space-x-px" aria-label="Pagination">
                <button
                    onClick={() => onPageChange(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Previous
                </button>
                {pageNumbers.map((page, index) =>
                    typeof page === 'string' ? (
                        <span key={index} className="relative inline-flex items-center px-4 py-2 border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400">
                            {page}
                        </span>
                    ) : (
                        <button
                            key={page}
                            onClick={() => onPageChange(page)}
                            aria-current={page === currentPage ? 'page' : undefined}
                            className={`relative inline-flex items-center px-4 py-2 border border-gray-700 text-sm font-medium ${
                                page === currentPage
                                    ? 'z-10 bg-indigo-600 text-white'
                                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                            }`}
                        >
                            {page}
                        </button>
                    )
                )}
                <button
                    onClick={() => onPageChange(currentPage + 1)}
                    disabled={currentPage === totalPages}
                    className="relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-700 bg-gray-800 text-sm font-medium text-gray-400 hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Next
                </button>
            </nav>
        </div>
    );
};

export const Modal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    size?: 'sm' | 'md' | 'lg' | 'xl';
}> = ({ isOpen, onClose, title, children, size = 'md' }) => {
    if (!isOpen) return null;

    const sizeClasses = {
        sm: 'max-w-md',
        md: 'max-w-lg',
        lg: 'max-w-2xl',
        xl: 'max-w-4xl',
    };

    return (
        <div className="fixed inset-0 z-50 overflow-y-auto bg-gray-900 bg-opacity-75 flex items-center justify-center p-4" onClick={onClose}>
            <div
                className={`relative bg-gray-800 rounded-lg shadow-xl ${sizeClasses[size]} w-full mx-auto my-8`}
                onClick={e => e.stopPropagation()}
            >
                <div className="flex items-center justify-between p-4 border-b border-gray-700">
                    <h3 className="text-xl font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-gray-200">
                        <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div className="p-6">{children}</div>
            </div>
        </div>
    );
};

// --- Form Components for Editing/Creating ---
export const RateLimitPolicyForm: React.FC<{
    initialData?: RateLimitPolicy;
    onSave: (policy: RateLimitPolicy) => void;
    onCancel: () => void;
    endpoints: ApiEndpoint[];
    mlModels: MlModel[];
}> = ({ initialData, onSave, onCancel, endpoints, mlModels }) => {
    const [policy, setPolicy] = useState<RateLimitPolicy>(
        initialData || {
            id: `new-rlp-${Date.now()}`,
            name: '',
            description: '',
            appliesTo: 'global',
            limit: 0,
            unit: 'minute',
            priority: 0,
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            isAdaptive: false,
            blockDurationSeconds: 300,
            customRules: [],
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setPolicy(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value,
        }));
    };

    const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target;
        setPolicy(prev => ({
            ...prev,
            [name]: value === '' ? 0 : parseInt(value, 10),
        }));
    };

    const handleCustomRulesChange = (index: number, value: string) => {
        const newRules = [...(policy.customRules || [])];
        newRules[index] = value;
        setPolicy(prev => ({ ...prev, customRules: newRules }));
    };

    const addCustomRule = () => {
        setPolicy(prev => ({ ...prev, customRules: [...(prev.customRules || []), ''] }));
    };

    const removeCustomRule = (index: number) => {
        const newRules = [...(policy.customRules || [])];
        newRules.splice(index, 1);
        setPolicy(prev => ({ ...prev, customRules: newRules }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...policy, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Policy Name</label>
                <input type="text" name="name" id="name" value={policy.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={policy.description} onChange={handleChange} rows={3}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="appliesTo" className="block text-sm font-medium">Applies To</label>
                    <select name="appliesTo" id="appliesTo" value={policy.appliesTo} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="global">Global</option>
                        <option value="endpoint">Endpoint</option>
                        <option value="user">User</option>
                        <option value="ip">IP Address</option>
                        <option value="client_id">Client ID</option>
                    </select>
                </div>
                {policy.appliesTo === 'endpoint' && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target Endpoint</label>
                        <select name="targetId" id="targetId" value={policy.targetId || ''} onChange={handleChange} required
                                className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            <option value="">Select an endpoint</option>
                            {endpoints.map(ep => (
                                <option key={ep.id} value={ep.id}>{ep.name} ({ep.method})</option>
                            ))}
                        </select>
                    </div>
                )}
                {(policy.appliesTo === 'user' || policy.appliesTo === 'ip' || policy.appliesTo === 'client_id') && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target ID ({policy.appliesTo})</label>
                        <input type="text" name="targetId" id="targetId" value={policy.targetId || ''} onChange={handleChange}
                               className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder={`Enter ${policy.appliesTo} ID/Address`} />
                    </div>
                )}
            </div>

            <div className="grid grid-cols-3 gap-4">
                <div>
                    <label htmlFor="limit" className="block text-sm font-medium">Limit (requests)</label>
                    <input type="number" name="limit" id="limit" value={policy.limit} onChange={handleNumberChange} required min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
                <div>
                    <label htmlFor="unit" className="block text-sm font-medium">Unit</label>
                    <select name="unit" id="unit" value={policy.unit} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="second">Second</option>
                        <option value="minute">Minute</option>
                        <option value="hour">Hour</option>
                        <option value="day">Day</option>
                    </select>
                </div>
                <div>
                    <label htmlFor="priority" className="block text-sm font-medium">Priority (lower = higher)</label>
                    <input type="number" name="priority" id="priority" value={policy.priority} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="burstLimit" className="block text-sm font-medium">Burst Limit (optional)</label>
                    <input type="number" name="burstLimit" id="burstLimit" value={policy.burstLimit || ''} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
                <div>
                    <label htmlFor="blockDurationSeconds" className="block text-sm font-medium">Block Duration (seconds)</label>
                    <input type="number" name="blockDurationSeconds" id="blockDurationSeconds" value={policy.blockDurationSeconds || ''} onChange={handleNumberChange} min="0"
                           className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                </div>
            </div>

            <div className="flex items-center space-x-2">
                <input type="checkbox" name="isAdaptive" id="isAdaptive" checked={policy.isAdaptive} onChange={handleChange}
                       className="rounded border-gray-600 text-indigo-600 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" />
                <label htmlFor="isAdaptive" className="text-sm font-medium">Use Adaptive Throttling</label>
            </div>
            {policy.isAdaptive && (
                <div>
                    <label htmlFor="adaptiveModelId" className="block text-sm font-medium">Adaptive ML Model</label>
                    <select name="adaptiveModelId" id="adaptiveModelId" value={policy.adaptiveModelId || ''} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="">Select an ML Model</option>
                        {mlModels.filter(m => m.status === 'deployed').map(model => (
                            <option key={model.id} value={model.id}>{model.name} ({model.version})</option>
                        ))}
                    </select>
                </div>
            )}

            <div>
                <label className="block text-sm font-medium mb-1">Custom Rules (optional)</label>
                {policy.customRules?.map((rule, index) => (
                    <div key={index} className="flex space-x-2 mb-2">
                        <input type="text" value={rule} onChange={e => handleCustomRulesChange(index, e.target.value)}
                               className="flex-grow rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder="e.g., header:X-User-Tier=premium" />
                        <button type="button" onClick={() => removeCustomRule(index)}
                                className="p-2 text-red-400 hover:text-red-300 rounded-md hover:bg-gray-700">
                            <TrashIcon className="h-5 w-5" />
                        </button>
                    </div>
                ))}
                <button type="button" onClick={addCustomRule}
                        className="mt-2 inline-flex items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> Add Custom Rule
                </button>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Policy
                </button>
            </div>
        </form>
    );
};


export const AnomalyDetectionConfigForm: React.FC<{
    initialData?: AnomalyDetectionConfig;
    onSave: (config: AnomalyDetectionConfig) => void;
    onCancel: () => void;
    endpoints: ApiEndpoint[];
}> = ({ initialData, onSave, onCancel, endpoints }) => {
    const [config, setConfig] = useState<AnomalyDetectionConfig>(
        initialData || {
            id: `new-adcfg-${Date.now()}`,
            name: '',
            description: '',
            target: 'global',
            modelType: 'machine_learning',
            threshold: 3,
            alertSeverity: 'medium',
            alertChannels: ['email'],
            status: 'active',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setConfig(prev => ({ ...prev, [name]: value }));
    };

    const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { name, value } = e.target;
        setConfig(prev => ({ ...prev, [name]: parseFloat(value) }));
    };

    const handleAlertChannelsChange = (channel: string, checked: boolean) => {
        setConfig(prev => {
            const newChannels = checked
                ? [...new Set([...prev.alertChannels, channel])]
                : prev.alertChannels.filter(c => c !== channel);
            return { ...prev, alertChannels: newChannels };
        });
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...config, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Config Name</label>
                <input type="text" name="name" id="name" value={config.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={config.description} onChange={handleChange} rows={2}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="target" className="block text-sm font-medium">Target Scope</label>
                    <select name="target" id="target" value={config.target} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="global">Global</option>
                        <option value="endpoint">Endpoint</option>
                        <option value="user">User</option>
                        <option value="ip">IP Address</option>
                    </select>
                </div>
                {config.target === 'endpoint' && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target Endpoint</label>
                        <select name="targetId" id="targetId" value={config.targetId || ''} onChange={handleChange} required
                                className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            <option value="">Select an endpoint</option>
                            {endpoints.map(ep => (
                                <option key={ep.id} value={ep.id}>{ep.name} ({ep.method})</option>
                            ))}
                        </select>
                    </div>
                )}
                {(config.target === 'user' || config.target === 'ip') && (
                    <div>
                        <label htmlFor="targetId" className="block text-sm font-medium">Target ID ({config.target})</label>
                        <input type="text" name="targetId" id="targetId" value={config.targetId || ''} onChange={handleChange}
                               className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                               placeholder={`Enter ${config.target} ID/Address`} />
                    </div>
                )}
            </div>
            <div>
                <label htmlFor="modelType" className="block text-sm font-medium">Model Type</label>
                <select name="modelType" id="modelType" value={config.modelType} onChange={handleChange}
                        className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    <option value="statistical">Statistical Thresholds</option>
                    <option value="machine_learning">Machine Learning</option>
                    <option value="heuristic">Heuristic Rules</option>
                </select>
            </div>
            <div>
                <label htmlFor="threshold" className="block text-sm font-medium">Threshold</label>
                <input type="number" name="threshold" id="threshold" value={config.threshold} onChange={handleNumberChange} step="0.1"
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                <p className="mt-1 text-xs text-gray-400">Interpretation depends on model type (e.g., standard deviations, confidence score).</p>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="alertSeverity" className="block text-sm font-medium">Alert Severity</label>
                    <select name="alertSeverity" id="alertSeverity" value={config.alertSeverity} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                        <option value="critical">Critical</option>
                    </select>
                </div>
                <div>
                    <label className="block text-sm font-medium">Alert Channels</label>
                    <div className="mt-1 space-y-1">
                        {['email', 'slack', 'pagerduty', 'webhook'].map(channel => (
                            <div key={channel} className="flex items-center">
                                <input
                                    id={`channel-${channel}`}
                                    name="alertChannels"
                                    type="checkbox"
                                    checked={config.alertChannels.includes(channel)}
                                    onChange={e => handleAlertChannelsChange(channel, e.target.checked)}
                                    className="h-4 w-4 rounded border-gray-600 text-indigo-600 focus:ring-indigo-500"
                                />
                                <label htmlFor={`channel-${channel}`} className="ml-2 text-sm text-gray-300 capitalize">{channel}</label>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            <div className="flex justify-end space-x-3 pt-4 border-t border-gray-700">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Configuration
                </button>
            </div>
        </form>
    );
};

export const CustomRuleForm: React.FC<{
    initialData?: CustomRuleSchema;
    onSave: (rule: CustomRuleSchema) => void;
    onCancel: () => void;
}> = ({ initialData, onSave, onCancel }) => {
    const [rule, setRule] = useState<CustomRuleSchema>(
        initialData || {
            id: `new-crule-${Date.now()}`,
            name: '',
            description: '',
            language: 'javascript',
            code: `// Your custom rule logic here.
// 'request' object contains headers, body, ip, path, method.
// Return true to allow, false to block, or an object { allowed: boolean, reason: string }.
function evaluate(request) {
    if (request.headers['X-Api-Key'] === 'blocked-key') {
        return { allowed: false, reason: 'Blocked API Key' };
    }
    return true;
}`,
            status: 'draft',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            tags: [],
            testCases: [],
        }
    );

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setRule(prev => ({ ...prev, [name]: value }));
    };

    const handleCodeChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setRule(prev => ({ ...prev, code: e.target.value }));
    };

    const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const tags = e.target.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
        setRule(prev => ({ ...prev, tags }));
    };

    const handleTestCaseChange = (index: number, field: keyof typeof rule.testCases[0], value: any) => {
        const newTestCases = [...rule.testCases];
        newTestCases[index] = { ...newTestCases[index], [field]: value };
        setRule(prev => ({ ...prev, testCases: newTestCases }));
    };

    const addTestCase = () => {
        setRule(prev => ({ ...prev, testCases: [...prev.testCases, { input: {}, expectedOutput: true, description: '' }] }));
    };

    const removeTestCase = (index: number) => {
        const newTestCases = [...rule.testCases];
        newTestCases.splice(index, 1);
        setRule(prev => ({ ...prev, testCases: newTestCases }));
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ ...rule, updatedAt: new Date().toISOString() });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium">Rule Name</label>
                <input type="text" name="name" id="name" value={rule.name} onChange={handleChange} required
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium">Description</label>
                <textarea name="description" id="description" value={rule.description} onChange={handleChange} rows={2}
                          className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="language" className="block text-sm font-medium">Language</label>
                    <select name="language" id="language" value={rule.language} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="javascript">JavaScript</option>
                        <option value="python">Python</option>
                        <option value="lua">Lua</option>
                        <option value="cel">CEL (Common Expression Language)</option>
                    </select>
                </div>
                <div>
                    <label htmlFor="status" className="block text-sm font-medium">Status</label>
                    <select name="status" id="status" value={rule.status} onChange={handleChange}
                            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                        <option value="draft">Draft</option>
                    </select>
                </div>
            </div>
            <div>
                <label htmlFor="code" className="block text-sm font-medium">Rule Code</label>
                <textarea name="code" id="code" value={rule.code} onChange={handleCodeChange} rows={10}
                          className="mt-1 block w-full font-mono text-sm rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
            </div>
            <div>
                <label htmlFor="tags" className="block text-sm font-medium">Tags (comma-separated)</label>
                <input type="text" name="tags" id="tags" value={rule.tags.join(', ')} onChange={handleTagsChange}
                       className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                       placeholder="e.g., security, performance, critical" />
            </div>

            <div className="pt-4 border-t border-gray-700">
                <h4 className="text-md font-medium text-gray-300 mb-2">Test Cases</h4>
                {rule.testCases.map((testCase, index) => (
                    <div key={index} className="border border-gray-700 p-3 rounded-md mb-3 space-y-2">
                        <div className="flex justify-between items-center">
                            <label className="block text-sm font-medium">Test Case #{index + 1}</label>
                            <button type="button" onClick={() => removeTestCase(index)}
                                    className="p-1 text-red-400 hover:text-red-300 rounded-md hover:bg-gray-700">
                                <TrashIcon className="h-4 w-4" />
                            </button>
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Description</label>
                            <input type="text" value={testCase.description} onChange={e => handleTestCaseChange(index, 'description', e.target.value)}
                                   className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Input (JSON)</label>
                            <textarea value={JSON.stringify(testCase.input, null, 2)}
                                      onChange={e => {
                                          try {
                                              handleTestCaseChange(index, 'input', JSON.parse(e.target.value));
                                          } catch (err) {
                                              // console.error("Invalid JSON input", err);
                                          }
                                      }}
                                      rows={4}
                                      className="mt-1 block w-full font-mono text-sm rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Expected Output</label>
                            <select value={String(testCase.expectedOutput)} onChange={e => handleTestCaseChange(index, 'expectedOutput', e.target.value === 'true')}
                                    className="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                                <option value="true">True (Allowed)</option>
                                <option value="false">False (Blocked)</option>
                            </select>
                        </div>
                    </div>
                ))}
                <button type="button" onClick={addTestCase}
                        className="mt-2 inline-flex items-center px-3 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    <PlusIcon className="-ml-1 mr-2 h-5 w-5" /> Add Test Case
                </button>
            </div>

            <div className="pt-4 border-t border-gray-700 flex justify-end space-x-3">
                <button type="button" onClick={onCancel}
                        className="px-4 py-2 text-sm font-medium text-gray-300 rounded-md border border-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                    Cancel
                </button>
                <button type="submit"
                        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Save Custom Rule
                </button>
            </div>
        </form>
    );
};


// --- Data Display Components ---

export const EndpointDetailsTable: React.FC<{ endpoints: ApiEndpoint[] }> = ({ endpoints }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState<keyof ApiEndpoint>('name');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const filteredAndSortedEndpoints = useMemo(() => {
        let filtered = endpoints.filter(ep =>
            ep.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.path.toLowerCase().includes(searchTerm.toLowerCase()) ||
            ep.owner.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [endpoints, searchTerm, sortBy, sortOrder]);

    const handleSort = (key: keyof ApiEndpoint) => {
        if (sortBy === key) {
            setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    };

    const renderSortIcon = (key: keyof ApiEndpoint) => {
        if (sortBy === key) {
            return sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />;
        }
        return null;
    };

    return (
        <Card title="API Endpoint Directory" className="h-full">
            <input
                type="text"
                placeholder="Search endpoints..."
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                className="mb-4 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('name')}>
                                <div className="flex items-center">Endpoint {renderSortIcon('name')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('method')}>
                                <div className="flex items-center">Method {renderSortIcon('method')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('owner')}>
                                <div className="flex items-center">Owner {renderSortIcon('owner')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('avgLatencyMs')}>
                                <div className="flex items-center">Avg Latency (ms) {renderSortIcon('avgLatencyMs')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('errorRate')}>
                                <div className="flex items-center">Error Rate (%) {renderSortIcon('errorRate')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('peakTrafficRPS')}>
                                <div className="flex items-center">Peak RPS {renderSortIcon('peakTrafficRPS')}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">
                                Status
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {filteredAndSortedEndpoints.map(ep => (
                            <tr key={ep.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{ep.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.method}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.owner}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.avgLatencyMs.toFixed(1)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.errorRate.toFixed(2)}%</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{ep.peakTrafficRPS}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={ep.status} />
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </Card>
    );
};

export const RateLimitPolicyList: React.FC<{
    policies: RateLimitPolicy[];
    endpoints: ApiEndpoint[];
    onEdit: (policy: RateLimitPolicy) => void;
    onDelete: (policyId: string) => void;
    onToggleStatus: (policy: RateLimitPolicy) => void;
}> = ({ policies, endpoints, onEdit, onDelete, onToggleStatus }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 10;

    const [filters, setFilters] = useState({
        name: '',
        appliesTo: '',
        status: '',
    });
    const [sortBy, setSortBy] = useState<keyof RateLimitPolicy>('priority');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1); // Reset to first page on filter change
    }, []);

    const handleSortChange = useCallback((key: keyof RateLimitPolicy) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    }, [sortBy]);

    const filteredAndSortedPolicies = useMemo(() => {
        let filtered = policies.filter(policy => {
            const matchesName = filters.name ? policy.name.toLowerCase().includes(filters.name.toLowerCase()) : true;
            const matchesAppliesTo = filters.appliesTo ? policy.appliesTo === filters.appliesTo : true;
            const matchesStatus = filters.status ? policy.status === filters.status : true;
            return matchesName && matchesAppliesTo && matchesStatus;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [policies, filters, sortBy, sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedPolicies.length / itemsPerPage);
    const paginatedPolicies = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedPolicies.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedPolicies, currentPage, itemsPerPage]);

    const getEndpointName = (id?: string) => {
        return id ? endpoints.find(ep => ep.id === id)?.name || id : 'N/A';
    };

    const availableFilters = [
        { key: 'name', label: 'Policy Name', type: 'text' as const },
        { key: 'appliesTo', label: 'Applies To', type: 'select' as const, options: [{ value: 'global', label: 'Global' }, { value: 'endpoint', label: 'Endpoint' }, { value: 'user', label: 'User' }, { value: 'ip', label: 'IP' }, { value: 'client_id', label: 'Client ID' }] },
        { key: 'status', label: 'Status', type: 'select' as const, options: [{ value: 'active', label: 'Active' }, { value: 'inactive', label: 'Inactive' }, { value: 'pending', label: 'Pending' }] },
    ];

    const availableSorts = [
        { key: 'name', label: 'Name' },
        { key: 'priority', label: 'Priority' },
        { key: 'updatedAt', label: 'Last Updated' },
    ];

    return (
        <Card title="Rate Limit Policies">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Applies To</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Target</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Limit</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Priority</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Adaptive</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" className="relative px-6 py-3">
                                <span className="sr-only">Actions</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedPolicies.map(policy => (
                            <tr key={policy.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{policy.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{policy.appliesTo.replace('_', ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    {policy.appliesTo === 'endpoint' ? getEndpointName(policy.targetId) : policy.targetId || 'N/A'}
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.limit} req/{policy.unit}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{policy.priority}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    {policy.isAdaptive ? <CheckCircleIcon className="h-5 w-5 text-green-500" /> : 'No'}
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={policy.status} />
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => onEdit(policy)} className="text-indigo-400 hover:text-indigo-300 mr-3">
                                        <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button onClick={() => onToggleStatus(policy)} className={`mr-3 ${policy.status === 'active' ? 'text-yellow-400 hover:text-yellow-300' : 'text-green-400 hover:text-green-300'}`}>
                                        {policy.status === 'active' ? <ExclamationTriangleIcon className="h-5 w-5" /> : <RocketLaunchIcon className="h-5 w-5" />}
                                    </button>
                                    <button onClick={() => onDelete(policy.id)} className="text-red-400 hover:text-red-300">
                                        <TrashIcon className="h-5 w-5" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedPolicies.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const ThrottlingEventLog: React.FC<{ events: ThrottlingEvent[]; endpoints: ApiEndpoint[]; policies: RateLimitPolicy[] }> = ({ events, endpoints, policies }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 15;

    const [filters, setFilters] = useState({
        endpointId: '',
        reason: '',
        clientIp: '',
        blocked: '',
    });
    const [sortBy, setSortBy] = useState<keyof ThrottlingEvent>('timestamp');
    const [sortOrder, setSortOrder] = useState<'desc' | 'asc'>('desc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1);
    }, []);

    const handleSortChange = useCallback((key: keyof ThrottlingEvent) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('desc'); // Default to desc for timestamp, asc for others
        }
    }, [sortBy]);

    const filteredAndSortedEvents = useMemo(() => {
        let filtered = events.filter(event => {
            const matchesEndpoint = filters.endpointId ? event.endpointId === filters.endpointId : true;
            const matchesReason = filters.reason ? event.reason === filters.reason : true;
            const matchesIp = filters.clientIp ? event.clientIp.includes(filters.clientIp) : true;
            const matchesBlocked = filters.blocked ? (filters.blocked === 'true' ? event.blocked : !event.blocked) : true;
            return matchesEndpoint && matchesReason && matchesIp && matchesBlocked;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (sortBy === 'timestamp') {
                    return sortOrder === 'asc' ? new Date(aValue).getTime() - new Date(bValue).getTime() : new Date(bValue).getTime() - new Date(aValue).getTime();
                }
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [events, filters, sortBy, sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedEvents.length / itemsPerPage);
    const paginatedEvents = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedEvents.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedEvents, currentPage, itemsPerPage]);

    const getEndpointName = (id: string) => endpoints.find(ep => ep.id === id)?.name || id;
    const getPolicyName = (id: string) => policies.find(p => p.id === id)?.name || id;

    const availableFilters = [
        { key: 'endpointId', label: 'Endpoint', type: 'select' as const, options: mockEndpoints.map(ep => ({ value: ep.id, label: ep.name })) },
        { key: 'reason', label: 'Reason', type: 'select' as const, options: [{ value: 'rate_limit_exceeded', label: 'Rate Limit Exceeded' }, { value: 'burst_limit_exceeded', label: 'Burst Limit Exceeded' }, { value: 'anomaly_detected', label: 'Anomaly Detected' }, { value: 'ip_blacklist', label: 'IP Blacklist' }] },
        { key: 'clientIp', label: 'Client IP', type: 'text' as const },
        { key: 'blocked', label: 'Blocked', type: 'select' as const, options: [{ value: 'true', label: 'Yes' }, { value: 'false', label: 'No' }] },
    ];

    const availableSorts = [
        { key: 'timestamp', label: 'Timestamp' },
        { key: 'currentRPS', label: 'Current RPS' },
        { key: 'reason', label: 'Reason' },
    ];

    return (
        <Card title="Throttling Event Log">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('timestamp')}>
                                <div className="flex items-center">Timestamp {sortBy === 'timestamp' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Endpoint</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Client IP</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('reason')}>
                                <div className="flex items-center">Reason {sortBy === 'reason' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider cursor-pointer" onClick={() => handleSortChange('currentRPS')}>
                                <div className="flex items-center">RPS @ Event {sortBy === 'currentRPS' && (sortOrder === 'asc' ? <ChevronUpIcon className="ml-1 h-3 w-3" /> : <ChevronDownIcon className="ml-1 h-3 w-3" />)}</div>
                            </th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Policy</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Blocked</th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedEvents.map(event => (
                            <tr key={event.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{new Date(event.timestamp).toLocaleString()}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-white">{getEndpointName(event.endpointId)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{event.clientIp} {event.userId && `(User: ${event.userId})`}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-red-400 font-semibold">{event.reason.replace(/_/g, ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{event.currentRPS} / {event.rateLimitValue}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{getPolicyName(event.policyId)}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                    {event.blocked ? <CheckCircleIcon className="h-5 w-5 text-red-500" /> : <CheckCircleIcon className="h-5 w-5 text-green-500" />}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedEvents.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const MlModelManagement: React.FC<{ mlModels: MlModel[]; onDeploy: (id: string) => void; onRetrain: (id: string) => void }> = ({ mlModels, onDeploy, onRetrain }) => {
    const [searchTerm, setSearchTerm] = useState('');

    const filteredModels = useMemo(() => {
        return mlModels.filter(model =>
            model.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            model.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
            model.algorithm.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [mlModels, searchTerm]);

    return (
        <Card title="AI/ML Throttling Model Management">
            <input
                type="text"
                placeholder="Search models..."
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                className="mb-4 block w-full rounded-md border-gray-600 bg-gray-700 text-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            />
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {filteredModels.map(model => (
                    <div key={model.id} className="bg-gray-700 p-4 rounded-lg shadow-md flex flex-col justify-between">
                        <div>
                            <h4 className="text-xl font-semibold text-white mb-2">{model.name} <span className="text-gray-400 text-sm">({model.version})</span></h4>
                            <p className="text-gray-300 text-sm mb-2">{model.description}</p>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <CpuChipIcon className="h-4 w-4 mr-1" /> Algorithm: {model.algorithm}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <TagIcon className="h-4 w-4 mr-1" /> Type: {model.type}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-1">
                                <CalendarDaysIcon className="h-4 w-4 mr-1" /> Last Trained: {new Date(model.lastTrained).toLocaleDateString()}
                            </div>
                            <div className="flex items-center text-gray-400 text-sm mb-2">
                                <ServerStackIcon className="h-4 w-4 mr-1" /> Training Data: {(model.trainingDataSize / 1000000).toFixed(1)}M samples
                            </div>
                            <div className="mb-2">
                                <h5 className="text-sm font-medium text-gray-300">Performance:</h5>
                                {model.performanceMetrics.accuracy && <p className="text-xs text-gray-400 ml-2">Accuracy: {(model.performanceMetrics.accuracy * 100).toFixed(2)}%</p>}
                                {model.performanceMetrics.mse && <p className="text-xs text-gray-400 ml-2">MSE: {model.performanceMetrics.mse.toFixed(4)}</p>}
                                {model.performanceMetrics.precision && <p className="text-xs text-gray-400 ml-2">Precision: {(model.performanceMetrics.precision * 100).toFixed(2)}%</p>}
                            </div>
                            <div className="mb-3">
                                <p className="text-xs font-medium text-gray-300">Features Used: <span className="text-gray-400">{model.featuresUsed.join(', ')}</span></p>
                            </div>
                        </div>
                        <div className="flex items-center justify-between mt-3 pt-3 border-t border-gray-600">
                            <StatusIndicator status={model.status} />
                            <div className="space-x-2">
                                {model.status !== 'deployed' && (
                                    <button onClick={() => onDeploy(model.id)} className="px-3 py-1 text-sm bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Deploy</button>
                                )}
                                {model.status !== 'training' && (
                                    <button onClick={() => onRetrain(model.id)} className="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">Retrain</button>
                                )}
                            </div>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
};

export const AnomalyDetectionConfigsList: React.FC<{
    configs: AnomalyDetectionConfig[];
    endpoints: ApiEndpoint[];
    onEdit: (config: AnomalyDetectionConfig) => void;
    onDelete: (configId: string) => void;
    onToggleStatus: (config: AnomalyDetectionConfig) => void;
}> = ({ configs, endpoints, onEdit, onDelete, onToggleStatus }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 8;

    const [filters, setFilters] = useState({
        name: '',
        target: '',
        status: '',
    });
    const [sortBy, setSortBy] = useState<keyof AnomalyDetectionConfig>('name');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

    const handleFilterChange = useCallback((key: string, value: any) => {
        setFilters(prev => ({ ...prev, [key]: value }));
        setCurrentPage(1);
    }, []);

    const handleSortChange = useCallback((key: keyof AnomalyDetectionConfig) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('asc');
        }
    }, [sortBy]);

    const filteredAndSortedConfigs = useMemo(() => {
        let filtered = configs.filter(config => {
            const matchesName = filters.name ? config.name.toLowerCase().includes(filters.name.toLowerCase()) : true;
            const matchesTarget = filters.target ? config.target === filters.target : true;
            const matchesStatus = filters.status ? config.status === filters.status : true;
            return matchesName && matchesTarget && matchesStatus;
        });

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });
        }
        return filtered;
    }, [configs, filters, sortBy, sortOrder]);

    const totalPages = Math.ceil(filteredAndSortedConfigs.length / itemsPerPage);
    const paginatedConfigs = useMemo(() => {
        const startIndex = (currentPage - 1) * itemsPerPage;
        return filteredAndSortedConfigs.slice(startIndex, startIndex + itemsPerPage);
    }, [filteredAndSortedConfigs, currentPage, itemsPerPage]);

    const getTargetName = (config: AnomalyDetectionConfig) => {
        if (config.target === 'endpoint' && config.targetId) {
            return endpoints.find(ep => ep.id === config.targetId)?.name || config.targetId;
        }
        return config.targetId || 'N/A';
    };

    const availableFilters = [
        { key: 'name', label: 'Config Name', type: 'text' as const },
        { key: 'target', label: 'Target Scope', type: 'select' as const, options: [{ value: 'global', label: 'Global' }, { value: 'endpoint', label: 'Endpoint' }, { value: 'user', label: 'User' }, { value: 'ip', label: 'IP' }] },
        { key: 'status', label: 'Status', type: 'select' as const, options: [{ value: 'active', label: 'Active' }, { value: 'inactive', label: 'Inactive' }] },
    ];

    const availableSorts = [
        { key: 'name', label: 'Name' },
        { key: 'alertSeverity', label: 'Severity' },
        { key: 'updatedAt', label: 'Last Updated' },
    ];

    return (
        <Card title="Anomaly Detection Configurations">
            <FilterSortPanel
                filters={filters}
                onFilterChange={handleFilterChange}
                sortBy={sortBy}
                sortOrder={sortOrder}
                onSortChange={handleSortChange}
                availableFilters={availableFilters}
                availableSorts={availableSorts}
            />
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-700">
                    <thead className="bg-gray-700">
                        <tr>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Name</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Target</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Model Type</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Threshold</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Severity</th>
                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" className="relative px-6 py-3">
                                <span className="sr-only">Actions</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800 divide-y divide-gray-700">
                        {paginatedConfigs.map(config => (
                            <tr key={config.id} className="hover:bg-gray-700">
                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{config.name}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.target} ({getTargetName(config)})</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.modelType.replace('_', ' ')}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{config.threshold}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300 capitalize">{config.alertSeverity}</td>
                                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">
                                    <StatusIndicator status={config.status} />
                                </td>
                                <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                    <button onClick={() => onEdit(config)} className="text-indigo-400 hover:text-indigo-300 mr-3">
                                        <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button onClick={() => onToggleStatus(config)} className={`mr-3 ${config.status === 'active' ? 'text-yellow-400 hover:text-yellow-300' : 'text-green-400 hover:text-green-300'}`}>
                                        {config.status === 'active' ? <ExclamationTriangleIcon className="h-5 w-5" /> : <RocketLaunchIcon className="h-5 w-5" />}
                                    </button>
                                    <button onClick={() => onDelete(config.id)} className="text-red-400 hover:text-red-300">
                                        <TrashIcon className="h-5 w-5" />
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            <PaginationControls
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={setCurrentPage}
                totalItems={filteredAndSortedConfigs.length}
                itemsPerPage={itemsPerPage}
            />
        </Card>
    );
};

export const SimulationResultsList: React.FC<{ results: SimulationResult[] }> = ({ results }) => {
    const [currentPage, setCurrentPage] = useState(1);
    const itemsPerPage = 7;

    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState<keyof SimulationResult>('timestamp');
    const [sortOrder, setSortOrder] = useState<'desc' | 'asc'>('desc');

    const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(e.target.value);
        setCurrentPage(1);
    };

    const handleSortChange = (key: keyof SimulationResult) => {
        if (sortBy === key) {
            setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));
        } else {
            setSortBy(key);
            setSortOrder('desc');
        }
    };

    const filteredAndSortedResults = useMemo(() => {
        let filtered = results.filter(result =>
            result.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            result.scenarioDescription.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (sortBy) {
            filtered = filtered.sort((a, b) => {
                const aValue = a[sortBy];
                const bValue = b[sortBy];

                if (sortBy === 'timestamp') {
                    return sortOrder === 'asc' ? new Date(aValue).getTime() - new Date(bValue).getTime() : new Date(bValue).getTime() - new Date(aValue).getTime();
                }
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
                }
                return 0;
            });

--- FILE: BackupRecoveryView.tsx ---

import React, { useContext, useState, useEffect, useCallback, useMemo } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";

/**
 * @file BackupRecoveryView.tsx
 * @description This file implements a comprehensive Backup & Recovery management dashboard.
 * It integrates features for managing backup jobs, defining recovery policies, simulating disaster recovery,
 * configuring storage targets, monitoring backup health, and advanced reporting.
 * The aim is to provide a "real-world" enterprise-grade interface for infrastructure resilience.
 */

// --- GLOBAL UTILITIES AND CONSTANTS ---
/**
 * Generates a unique ID string.
 * @returns {string} A unique ID.
 */
export const generateUniqueId = (): string => Math.random().toString(36).substr(2, 9);

/**
 * Formats a timestamp into a human-readable date and time string.
 * @param {string | Date} timestamp - The timestamp to format.
 * @returns {string} Formatted date and time.
 */
export const formatTimestamp = (timestamp: string | Date): string => {
    const date = new Date(timestamp);
    return date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
};

/**
 * Converts bytes to a human-readable size string (e.g., KB, MB, GB).
 * @param {number} bytes - The number of bytes.
 * @returns {string} Formatted size string.
 */
export const formatBytes = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

/**
 * Enum for Backup Job Status.
 * @enum {string}
 */
export enum BackupStatus {
    SUCCESS = 'SUCCESS',
    FAILED = 'FAILED',
    IN_PROGRESS = 'IN_PROGRESS',
    SCHEDULED = 'SCHEDULED',
    CANCELLED = 'CANCELLED',
    PARTIAL = 'PARTIAL'
}

/**
 * Enum for Recovery Point Objective (RPO) units.
 * @enum {string}
 */
export enum RPOUnit {
    MINUTES = 'MINUTES',
    HOURS = 'HOURS',
    DAYS = 'DAYS'
}

/**
 * Enum for Recovery Time Objective (RTO) units.
 * @enum {string}
 */
export enum RTOUnit {
    MINUTES = 'MINUTES',
    HOURS = 'HOURS',
    DAYS = 'DAYS'
}

/**
 * Enum for Backup Frequency.
 * @enum {string}
 */
export enum BackupFrequency {
    HOURLY = 'HOURLY',
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    MONTHLY = 'MONTHLY',
    CUSTOM = 'CUSTOM'
}

/**
 * Enum for Backup Type.
 * @enum {string}
 */
export enum BackupType {
    FULL = 'FULL',
    INCREMENTAL = 'INCREMENTAL',
    DIFFERENTIAL = 'DIFFERENTIAL'
}

/**
 * Enum for Storage Target Type.
 * @enum {string}
 */
export enum StorageTargetType {
    S3 = 'AWS S3',
    AZURE_BLOB = 'Azure Blob Storage',
    GCS = 'Google Cloud Storage',
    NFS = 'NFS Share',
    LOCAL = 'Local Disk'
}

/**
 * Enum for Alert Severity.
 * @enum {string}
 */
export enum AlertSeverity {
    INFO = 'INFO',
    WARNING = 'WARNING',
    CRITICAL = 'CRITICAL',
    HIGH = 'HIGH',
    MEDIUM = 'MEDIUM',
    LOW = 'LOW'
}

/**
 * Enum for Compliance Standard.
 * @enum {string}
 */
export enum ComplianceStandard {
    GDPR = 'GDPR',
    HIPAA = 'HIPAA',
    PCI_DSS = 'PCI DSS',
    ISO_27001 = 'ISO 27001'
}

/**
 * Enum for DR Drill Status.
 * @enum {string}
 */
export enum DRDrillStatus {
    PENDING = 'PENDING',
    IN_PROGRESS = 'IN_PROGRESS',
    COMPLETED_SUCCESS = 'COMPLETED_SUCCESS',
    COMPLETED_FAILED = 'COMPLETED_FAILED',
    SCHEDULED = 'SCHEDULED'
}

/**
 * Enum for Playbook Status.
 * @enum {string}
 */
export enum PlaybookStatus {
    DRAFT = 'DRAFT',
    ACTIVE = 'ACTIVE',
    DEPRECATED = 'DEPRECATED'
}

// --- INTERFACES FOR NEW DATA STRUCTURES ---

/**
 * Interface for a detailed Backup Job.
 * Extends the existing `BackupJob` type from `DataContext`.
 */
export interface DetailedBackupJob {
    id: string;
    service: string;
    type: BackupType;
    status: BackupStatus;
    timestamp: string;
    duration: string; // e.g., "1h 30m"
    size: number; // in bytes
    policyId?: string;
    storageTargetId?: string;
    recoveryPoint?: string; // Timestamp of the recovery point
    logs: string[];
    progress: number; // 0-100
}

/**
 * Interface for a Backup Policy.
 */
export interface BackupPolicy {
    id: string;
    name: string;
    description: string;
    services: string[]; // Services covered by this policy
    frequency: BackupFrequency;
    schedule: string; // e.g., "Every 4 hours", "Daily at 2 AM", "Every Mon, Wed, Fri"
    retentionDays: number; // How long backups are kept
    backupType: BackupType;
    rpoUnit: RPOUnit;
    rpoValue: number;
    enabled: boolean;
    storageTargetId: string;
    lastUpdated: string;
}

/**
 * Interface for a Storage Target.
 */
export interface StorageTarget {
    id: string;
    name: string;
    type: StorageTargetType;
    location: string; // e.g., "us-east-1", "Azure East US"
    endpoint?: string; // For S3, GCS, Azure Blob
    accessKeyId?: string; // Masked in UI
    secretAccessKey?: string; // Masked in UI
    mountPath?: string; // For NFS, Local
    capacityBytes: number;
    usedBytes: number;
    enabled: boolean;
    createdAt: string;
}

/**
 * Interface for a Recovery Plan.
 */
export interface RecoveryPlan {
    id: string;
    name: string;
    description: string;
    targetServices: string[];
    rtoUnit: RTOUnit;
    rtoValue: number;
    recoverySteps: string[]; // Detailed steps for recovery
    validationSteps: string[]; // Steps to validate recovery
    associatedPolicies: string[]; // IDs of backup policies supporting this plan
    lastTested: string | null;
    status: PlaybookStatus; // Draft, Active, Deprecated
    createdBy: string;
    lastModifiedBy: string;
    version: string;
    // AI generated fields
    aiGeneratedSummary?: string;
    aiOptimizedSteps?: string[];
}

/**
 * Interface for a DR Drill (test of a Recovery Plan).
 */
export interface DRDrill {
    id: string;
    planId: string;
    planName: string;
    startTime: string;
    endTime: string | null;
    status: DRDrillStatus;
    triggeredBy: string;
    outcome: string; // Detailed outcome or summary
    logs: string[];
    durationMinutes: number | null;
    testRecoveryPoint?: string; // Specific backup used for the drill
}

/**
 * Interface for an Alert Rule.
 */
export interface AlertRule {
    id: string;
    name: string;
    description: string;
    condition: string; // e.g., "Backup Failure Rate > 10%", "RPO Breach"
    severity: AlertSeverity;
    notificationChannels: string[]; // e.g., "email:admin@example.com", "slack:#dr-alerts"
    enabled: boolean;
    lastTriggered: string | null;
}

/**
 * Interface for an Audit Log entry.
 */
export interface AuditLog {
    id: string;
    timestamp: string;
    actor: string;
    action: string; // e.g., "Created Backup Policy 'DailyDB'", "Triggered DR Drill for 'WebAppFailover'"
    target: string; // The resource acted upon
    details: string; // JSON string or detailed message
    ipAddress: string;
}

/**
 * Interface for a Compliance Report.
 */
export interface ComplianceReport {
    id: string;
    standard: ComplianceStandard;
    generationDate: string;
    periodStart: string;
    periodEnd: string;
    complianceStatus: string; // e.g., "Compliant", "Non-Compliant (Minor)", "Non-Compliant (Critical)"
    findings: string[]; // List of non-compliance findings
    recommendations: string[]; // Recommendations for improvement
    generatedBy: string;
    reportFileUrl?: string; // URL to a PDF report
}

// --- MOCK DATA GENERATORS ---
const MOCK_SERVICES = ['Database A', 'Microservice X', 'Payment Gateway', 'User Auth', 'Analytics Engine', 'CMS Backend'];

const generateMockDetailedBackupJob = (count: number): DetailedBackupJob[] => {
    const jobs: DetailedBackupJob[] = [];
    for (let i = 0; i < count; i++) {
        const status = Object.values(BackupStatus)[Math.floor(Math.random() * Object.values(BackupStatus).length)];
        const service = MOCK_SERVICES[Math.floor(Math.random() * MOCK_SERVICES.length)];
        const timestamp = new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString();
        const durationSeconds = Math.floor(Math.random() * 3600) + 60; // 1 min to 1 hour
        const duration = `${Math.floor(durationSeconds / 60)}m ${durationSeconds % 60}s`;
        const size = Math.floor(Math.random() * (500 * 1024 * 1024)) + (10 * 1024 * 1024); // 10MB to 500MB
        const type = Object.values(BackupType)[Math.floor(Math.random() * Object.values(BackupType).length)];
        const progress = status === BackupStatus.IN_PROGRESS ? Math.floor(Math.random() * 99) + 1 : (status === BackupStatus.SUCCESS ? 100 : 0);

        jobs.push({
            id: generateUniqueId(),
            service,
            type,
            status,
            timestamp: formatTimestamp(timestamp),
            duration,
            size,
            logs: [`Backup started for ${service}`, `Phase 1 complete`, `Transferring data...`, `Backup finished. Status: ${status}`],
            progress,
            recoveryPoint: formatTimestamp(new Date(new Date(timestamp).getTime() - Math.random() * 60 * 60 * 1000)), // Point before backup
        });
    }
    return jobs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
};

const generateMockBackupPolicies = (count: number): BackupPolicy[] => {
    const policies: BackupPolicy[] = [];
    const storageTargets = generateMockStorageTargets(2); // Ensure we have some targets
    for (let i = 0; i < count; i++) {
        const frequency = Object.values(BackupFrequency)[Math.floor(Math.random() * Object.values(BackupFrequency).length)];
        const services = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => MOCK_SERVICES[Math.floor(Math.random() * MOCK_SERVICES.length)]);
        policies.push({
            id: `policy-${generateUniqueId()}`,
            name: `Policy ${String.fromCharCode(65 + i)} - ${frequency}`,
            description: `Automated backup policy for ${services.join(', ')} with ${frequency} frequency.`,
            services: Array.from(new Set(services)), // Unique services
            frequency,
            schedule: frequency === BackupFrequency.HOURLY ? 'Every 4 hours' : 'Daily at 2 AM',
            retentionDays: Math.floor(Math.random() * 365) + 7,
            backupType: Object.values(BackupType)[Math.floor(Math.random() * Object.values(BackupType).length)],
            rpoUnit: Object.values(RPOUnit)[Math.floor(Math.random() * Object.values(RPOUnit).length)],
            rpoValue: Math.floor(Math.random() * 12) + 1,
            enabled: Math.random() > 0.1,
            storageTargetId: storageTargets[Math.floor(Math.random() * storageTargets.length)].id,
            lastUpdated: formatTimestamp(new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000))
        });
    }
    return policies;
};

const generateMockStorageTargets = (count: number): StorageTarget[] => {
    const targets: StorageTarget[] = [];
    for (let i = 0; i < count; i++) {
        const type = Object.values(StorageTargetType)[Math.floor(Math.random() * Object.values(StorageTargetType).length)];
        const totalCapacity = Math.random() * (10 * 1024 * 1024 * 1024 * 1024) + (1 * 1024 * 1024 * 1024 * 1024); // 1TB to 10TB
        const usedCapacity = Math.random() * totalCapacity * 0.8; // Up to 80% used
        targets.push({
            id: `storage-${generateUniqueId()}`,
            name: `${type} Target ${i + 1}`,
            type,
            location: type.includes('AWS') ? 'us-east-1' : (type.includes('Azure') ? 'East US' : (type.includes('Google') ? 'asia-southeast1' : 'datacenter-01')),
            capacityBytes: totalCapacity,
            usedBytes: usedCapacity,
            enabled: Math.random() > 0.05,
            createdAt: formatTimestamp(new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000))
        });
    }
    return targets;
};

const generateMockRecoveryPlans = (count: number, policies: BackupPolicy[]): RecoveryPlan[] => {
    const plans: RecoveryPlan[] = [];
    for (let i = 0; i < count; i++) {
        const targetServices = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => MOCK_SERVICES[Math.floor(Math.random() * MOCK_SERVICES.length)]);
        const associatedPolicies = policies
            .filter(p => targetServices.some(ts => p.services.includes(ts)))
            .map(p => p.id)
            .slice(0, Math.floor(Math.random() * 2) + 1);

        plans.push({
            id: `plan-${generateUniqueId()}`,
            name: `DR Plan for ${targetServices[0]}`,
            description: `Detailed recovery playbook for ${targetServices.join(', ')} to ensure business continuity.`,
            targetServices: Array.from(new Set(targetServices)),
            rtoUnit: Object.values(RTOUnit)[Math.floor(Math.random() * Object.values(RTOUnit).length)],
            rtoValue: Math.floor(Math.random() * 8) + 1,
            recoverySteps: [
                "1. Declare disaster and activate plan.",
                "2. Failover to DR region/site.",
                "3. Restore data from latest available backup.",
                "4. Verify application functionality.",
                "5. Cutover to restored services."
            ],
            validationSteps: [
                "1. Check service endpoints.",
                "2. Perform data integrity checks.",
                "3. Conduct user acceptance testing."
            ],
            associatedPolicies,
            lastTested: Math.random() > 0.5 ? formatTimestamp(new Date(Date.now() - Math.random() * 180 * 24 * 60 * 60 * 1000)) : null,
            status: Object.values(PlaybookStatus)[Math.floor(Math.random() * Object.values(PlaybookStatus).length)],
            createdBy: 'admin@example.com',
            lastModifiedBy: 'admin@example.com',
            version: `1.${Math.floor(Math.random() * 10)}`,
            aiGeneratedSummary: `AI-powered summary: This plan focuses on rapid failover for ${targetServices[0]} using a multi-region strategy.`,
            aiOptimizedSteps: ["AI-optimized step 1", "AI-optimized step 2"]
        });
    }
    return plans;
};

const generateMockDRDrills = (count: number, plans: RecoveryPlan[]): DRDrill[] => {
    const drills: DRDrill[] = [];
    for (let i = 0; i < count; i++) {
        const plan = plans[Math.floor(Math.random() * plans.length)];
        const status = Object.values(DRDrillStatus)[Math.floor(Math.random() * Object.values(DRDrillStatus).length)];
        const startTime = new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000);
        const durationMinutes = status === DRDrillStatus.IN_PROGRESS ? null : Math.floor(Math.random() * 240) + 30; // 30 mins to 4 hours
        const endTime = durationMinutes ? new Date(startTime.getTime() + durationMinutes * 60 * 1000) : null;
        drills.push({
            id: `drill-${generateUniqueId()}`,
            planId: plan.id,
            planName: plan.name,
            startTime: formatTimestamp(startTime),
            endTime: endTime ? formatTimestamp(endTime) : null,
            status,
            triggeredBy: Math.random() > 0.7 ? 'system' : 'ops_user@example.com',
            outcome: status === DRDrillStatus.COMPLETED_SUCCESS ? 'Successfully validated RTO/RPO targets.' : (status === DRDrillStatus.COMPLETED_FAILED ? 'Identified issues in step 3, requiring plan revision.' : 'N/A'),
            logs: ["Drill initiated.", "Service failover started.", "Data restoration validation passed."],
            durationMinutes,
            testRecoveryPoint: formatTimestamp(new Date(startTime.getTime() - Math.random() * 24 * 60 * 60 * 1000))
        });
    }
    return drills.sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());
};

const generateMockAlertRules = (count: number): AlertRule[] => {
    const rules: AlertRule[] = [];
    const conditions = ["Backup Failure Rate > 10%", "RPO Breach for Database A", "Storage Target Capacity > 90%", "No successful backup in 24h"];
    for (let i = 0; i < count; i++) {
        rules.push({
            id: `alert-${generateUniqueId()}`,
            name: `Alert Rule ${i + 1}`,
            description: `Alert when ${conditions[Math.floor(Math.random() * conditions.length)]}.`,
            condition: conditions[Math.floor(Math.random() * conditions.length)],
            severity: Object.values(AlertSeverity)[Math.floor(Math.random() * Object.values(AlertSeverity).length)],
            notificationChannels: ['email:ops@example.com', 'slack:#alerts'],
            enabled: Math.random() > 0.1,
            lastTriggered: Math.random() > 0.5 ? formatTimestamp(new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000)) : null
        });
    }
    return rules;
};

const generateMockAuditLogs = (count: number): AuditLog[] => {
    const logs: AuditLog[] = [];
    const actions = ["Created Backup Policy", "Modified Storage Target", "Triggered DR Drill", "Deleted Backup Job", "Viewed Recovery Plan"];
    const actors = ["admin@example.com", "ops_user@example.com", "system"];
    const targets = ["Policy-001", "Storage-AWS-S3", "Plan-WebApp", "Job-DBA-20231026", "ComplianceReport-GDPR"];
    for (let i = 0; i < count; i++) {
        const action = actions[Math.floor(Math.random() * actions.length)];
        logs.push({
            id: `audit-${generateUniqueId()}`,
            timestamp: formatTimestamp(new Date(Date.now() - Math.random() * 90 * 24 * 60 * 60 * 1000)),
            actor: actors[Math.floor(Math.random() * actors.length)],
            action,
            target: targets[Math.floor(Math.random() * targets.length)],
            details: `Details for action: ${action} on ${targets[Math.floor(Math.random() * targets.length)]}.`,
            ipAddress: `192.168.1.${Math.floor(Math.random() * 255)}`
        });
    }
    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
};

const generateMockComplianceReports = (count: number): ComplianceReport[] => {
    const reports: ComplianceReport[] = [];
    for (let i = 0; i < count; i++) {
        const standard = Object.values(ComplianceStandard)[Math.floor(Math.random() * Object.values(ComplianceStandard).length)];
        const generationDate = new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000);
        const periodStart = new Date(generationDate.getTime() - 90 * 24 * 60 * 60 * 1000);
        const complianceStatus = Math.random() > 0.8 ? 'Non-Compliant (Minor)' : 'Compliant';
        reports.push({
            id: `report-${generateUniqueId()}`,
            standard,
            generationDate: formatTimestamp(generationDate),
            periodStart: formatTimestamp(periodStart),
            periodEnd: formatTimestamp(generationDate),
            complianceStatus,
            findings: complianceStatus !== 'Compliant' ? [`Finding: Minor RPO breach for service X`, `Recommendation: Adjust policy 'HourlyDB' to lower RPO.`] : [],
            recommendations: complianceStatus !== 'Compliant' ? [`Review policy settings for ${standard}.`] : [],
            generatedBy: 'compliance_officer@example.com',
            reportFileUrl: `https://example.com/reports/${standard.toLowerCase()}-${generateUniqueId()}.pdf`
        });
    }
    return reports.sort((a, b) => new Date(b.generationDate).getTime() - new Date(a.generationDate).getTime());
};

// --- REACT COMPONENTS (EXPORTED WHERE APPLICABLE FOR REUSABILITY/STRUCTURE) ---

/**
 * Props for the ActionButton component.
 */
export interface ActionButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    label: string;
    onClick: () => void;
    isLoading?: boolean;
    loadingText?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'success';
}

/**
 * A generic action button component.
 * @param {ActionButtonProps} props - The props for the button.
 * @returns {JSX.Element} The rendered button.
 */
export const ActionButton: React.FC<ActionButtonProps> = ({
    label,
    onClick,
    isLoading = false,
    loadingText = 'Processing...',
    variant = 'primary',
    className,
    disabled,
    ...rest
}) => {
    const baseStyle = "px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200";
    let variantStyle = "";
    switch (variant) {
        case 'primary':
            variantStyle = "bg-cyan-600 hover:bg-cyan-700 text-white";
            break;
        case 'secondary':
            variantStyle = "bg-gray-600 hover:bg-gray-700 text-white";
            break;
        case 'danger':
            variantStyle = "bg-red-600 hover:bg-red-700 text-white";
            break;
        case 'success':
            variantStyle = "bg-green-600 hover:bg-green-700 text-white";
            break;
    }

    return (
        <button
            onClick={onClick}
            disabled={isLoading || disabled}
            className={`${baseStyle} ${variantStyle} ${isLoading ? 'opacity-50 cursor-not-allowed' : ''} ${className || ''}`}
            {...rest}
        >
            {isLoading ? loadingText : label}
        </button>
    );
};

/**
 * Props for the Modal component.
 */
export interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
    className?: string;
    widthClass?: string; // e.g., 'max-w-2xl'
}

/**
 * A generic modal component.
 * @param {ModalProps} props - The props for the modal.
 * @returns {JSX.Element | null} The rendered modal or null if not open.
 */
export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, className, widthClass = 'max-w-2xl' }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={onClose}>
            <div
                className={`bg-gray-800 rounded-lg shadow-2xl w-full ${widthClass} ${className || ''}`}
                onClick={e => e.stopPropagation()}
            >
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white">
                        <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div className="p-6">{children}</div>
            </div>
        </div>
    );
};

/**
 * Props for the StatusBadge component.
 */
export interface StatusBadgeProps {
    status: string;
    type?: 'success' | 'warning' | 'error' | 'info' | 'default';
}

/**
 * A reusable status badge component.
 * @param {StatusBadgeProps} props - The props for the badge.
 * @returns {JSX.Element} The rendered badge.
 */
export const StatusBadge: React.FC<StatusBadgeProps> = ({ status, type }) => {
    let colorClass = 'bg-gray-700 text-gray-300';
    switch (type || status.toLowerCase()) {
        case 'success':
        case 'completed_success':
        case 'compliant':
            colorClass = 'bg-green-700 text-green-300';
            break;
        case 'warning':
        case 'partial':
        case 'in_progress':
            colorClass = 'bg-yellow-700 text-yellow-300';
            break;
        case 'error':
        case 'failed':
        case 'non-compliant (critical)':
            colorClass = 'bg-red-700 text-red-300';
            break;
        case 'info':
        case 'scheduled':
        case 'pending':
            colorClass = 'bg-blue-700 text-blue-300';
            break;
        case 'active':
            colorClass = 'bg-purple-700 text-purple-300';
            break;
        case 'draft':
            colorClass = 'bg-indigo-700 text-indigo-300';
            break;
        default:
            colorClass = 'bg-gray-700 text-gray-300';
            break;
    }
    return (
        <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${colorClass}`}>
            {status.replace(/_/g, ' ')}
        </span>
    );
};

/**
 * Props for the ProgressBar component.
 */
export interface ProgressBarProps {
    progress: number; // 0-100
    label?: string;
    color?: string; // Tailwind color class, e.g., 'bg-green-500'
}

/**
 * A simple progress bar component.
 * @param {ProgressBarProps} props - The props for the progress bar.
 * @returns {JSX.Element} The rendered progress bar.
 */
export const ProgressBar: React.FC<ProgressBarProps> = ({ progress, label, color = 'bg-cyan-500' }) => {
    const clampedProgress = Math.max(0, Math.min(100, progress));
    return (
        <div className="w-full bg-gray-700 rounded-full h-2.5">
            <div
                className={`h-2.5 rounded-full ${color}`}
                style={{ width: `${clampedProgress}%` }}
                role="progressbar"
                aria-valuenow={clampedProgress}
                aria-valuemin={0}
                aria-valuemax={100}
            ></div>
            {label && <p className="text-xs text-gray-400 mt-1">{label}: {clampedProgress}%</p>}
        </div>
    );
};

/**
 * Props for the CollapsibleSection component.
 */
export interface CollapsibleSectionProps {
    title: string;
    children: React.ReactNode;
    defaultOpen?: boolean;
}

/**
 * A collapsible section component for better UI organization.
 * @param {CollapsibleSectionProps} props - The props for the section.
 * @returns {JSX.Element} The rendered collapsible section.
 */
export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({ title, children, defaultOpen = false }) => {
    const [isOpen, setIsOpen] = useState(defaultOpen);

    return (
        <Card className="p-0">
            <div
                className="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-700/50 transition-colors duration-150"
                onClick={() => setIsOpen(!isOpen)}
            >
                <h4 className="text-lg font-semibold text-white">{title}</h4>
                <svg
                    className={`h-5 w-5 text-gray-400 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}
                    fill="none" viewBox="0 0 24 24" stroke="currentColor"
                >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            {isOpen && (
                <div className="p-4 border-t border-gray-700">
                    {children}
                </div>
            )}
        </Card>
    );
};

/**
 * Form for creating/editing a backup policy.
 */
export interface BackupPolicyFormProps {
    policy?: BackupPolicy;
    onSave: (policy: BackupPolicy) => Promise<void>;
    onCancel: () => void;
    isLoading: boolean;
    storageTargets: StorageTarget[];
    services: string[];
}

export const BackupPolicyForm: React.FC<BackupPolicyFormProps> = ({
    policy: initialPolicy, onSave, onCancel, isLoading, storageTargets, services
}) => {
    const [policy, setPolicy] = useState<BackupPolicy>(
        initialPolicy || {
            id: generateUniqueId(),
            name: '',
            description: '',
            services: [],
            frequency: BackupFrequency.DAILY,
            schedule: 'Daily at 2 AM',
            retentionDays: 30,
            backupType: BackupType.FULL,
            rpoUnit: RPOUnit.HOURS,
            rpoValue: 4,
            enabled: true,
            storageTargetId: storageTargets[0]?.id || '',
            lastUpdated: formatTimestamp(new Date())
        }
    );
    const [selectedServices, setSelectedServices] = useState<string[]>(initialPolicy?.services || []);

    useEffect(() => {
        setPolicy(initialPolicy || {
            id: generateUniqueId(),
            name: '',
            description: '',
            services: [],
            frequency: BackupFrequency.DAILY,
            schedule: 'Daily at 2 AM',
            retentionDays: 30,
            backupType: BackupType.FULL,
            rpoUnit: RPOUnit.HOURS,
            rpoValue: 4,
            enabled: true,
            storageTargetId: storageTargets[0]?.id || '',
            lastUpdated: formatTimestamp(new Date())
        });
        setSelectedServices(initialPolicy?.services || []);
    }, [initialPolicy, storageTargets]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setPolicy(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    const handleServiceChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = Array.from(e.target.selectedOptions, option => option.value);
        setSelectedServices(value);
        setPolicy(prev => ({ ...prev, services: value }));
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        await onSave(policy);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-400">Policy Name</label>
                <input type="text" id="name" name="name" value={policy.name} onChange={handleChange} required
                       className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-400">Description</label>
                <textarea id="description" name="description" value={policy.description} onChange={handleChange}
                          className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"></textarea>
            </div>
            <div>
                <label htmlFor="services" className="block text-sm font-medium text-gray-400">Covered Services</label>
                <select multiple id="services" name="services" value={selectedServices} onChange={handleServiceChange} required
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none min-h-[80px]">
                    {services.map(s => <option key={s} value={s}>{s}</option>)}
                </select>
                <p className="text-xs text-gray-500 mt-1">Hold Ctrl/Cmd to select multiple services.</p>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="frequency" className="block text-sm font-medium text-gray-400">Frequency</label>
                    <select id="frequency" name="frequency" value={policy.frequency} onChange={handleChange} required
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                        {Object.values(BackupFrequency).map(f => <option key={f} value={f}>{f.replace(/_/g, ' ')}</option>)}
                    </select>
                </div>
                <div>
                    <label htmlFor="schedule" className="block text-sm font-medium text-gray-400">Schedule Details</label>
                    <input type="text" id="schedule" name="schedule" value={policy.schedule} onChange={handleChange} required
                           className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                </div>
            </div>
            <div className="grid grid-cols-3 gap-4">
                <div>
                    <label htmlFor="retentionDays" className="block text-sm font-medium text-gray-400">Retention (Days)</label>
                    <input type="number" id="retentionDays" name="retentionDays" value={policy.retentionDays} onChange={handleChange} required
                           min="1" className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                </div>
                <div>
                    <label htmlFor="backupType" className="block text-sm font-medium text-gray-400">Backup Type</label>
                    <select id="backupType" name="backupType" value={policy.backupType} onChange={handleChange} required
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                        {Object.values(BackupType).map(t => <option key={t} value={t}>{t}</option>)}
                    </select>
                </div>
                <div>
                    <label htmlFor="storageTargetId" className="block text-sm font-medium text-gray-400">Storage Target</label>
                    <select id="storageTargetId" name="storageTargetId" value={policy.storageTargetId} onChange={handleChange} required
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                        {storageTargets.map(target => (
                            <option key={target.id} value={target.id}>{target.name} ({target.type})</option>
                        ))}
                    </select>
                </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="rpoValue" className="block text-sm font-medium text-gray-400">RPO Value</label>
                    <input type="number" id="rpoValue" name="rpoValue" value={policy.rpoValue} onChange={handleChange} required
                           min="1" className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                </div>
                <div>
                    <label htmlFor="rpoUnit" className="block text-sm font-medium text-gray-400">RPO Unit</label>
                    <select id="rpoUnit" name="rpoUnit" value={policy.rpoUnit} onChange={handleChange} required
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                        {Object.values(RPOUnit).map(u => <option key={u} value={u}>{u}</option>)}
                    </select>
                </div>
            </div>
            <div className="flex items-center">
                <input type="checkbox" id="enabled" name="enabled" checked={policy.enabled} onChange={handleChange}
                       className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500" />
                <label htmlFor="enabled" className="ml-2 block text-sm text-gray-400">Enabled</label>
            </div>
            <div className="flex justify-end space-x-2 mt-6">
                <ActionButton label="Cancel" onClick={onCancel} variant="secondary" disabled={isLoading} />
                <ActionButton label={initialPolicy ? "Update Policy" : "Create Policy"} onClick={handleSubmit} isLoading={isLoading} loadingText="Saving..." />
            </div>
        </form>
    );
};

/**
 * Form for creating/editing a recovery plan.
 */
export interface RecoveryPlanFormProps {
    plan?: RecoveryPlan;
    onSave: (plan: RecoveryPlan) => Promise<void>;
    onCancel: () => void;
    isLoading: boolean;
    policies: BackupPolicy[];
    services: string[];
}

export const RecoveryPlanForm: React.FC<RecoveryPlanFormProps> = ({
    plan: initialPlan, onSave, onCancel, isLoading, policies, services
}) => {
    const [plan, setPlan] = useState<RecoveryPlan>(
        initialPlan || {
            id: generateUniqueId(),
            name: '',
            description: '',
            targetServices: [],
            rtoUnit: RTOUnit.HOURS,
            rtoValue: 1,
            recoverySteps: [''],
            validationSteps: [''],
            associatedPolicies: [],
            lastTested: null,
            status: PlaybookStatus.DRAFT,
            createdBy: 'current_user@example.com',
            lastModifiedBy: 'current_user@example.com',
            version: '1.0'
        }
    );
    const [selectedTargetServices, setSelectedTargetServices] = useState<string[]>(initialPlan?.targetServices || []);
    const [selectedAssociatedPolicies, setSelectedAssociatedPolicies] = useState<string[]>(initialPlan?.associatedPolicies || []);

    useEffect(() => {
        setPlan(initialPlan || {
            id: generateUniqueId(),
            name: '',
            description: '',
            targetServices: [],
            rtoUnit: RTOUnit.HOURS,
            rtoValue: 1,
            recoverySteps: [''],
            validationSteps: [''],
            associatedPolicies: [],
            lastTested: null,
            status: PlaybookStatus.DRAFT,
            createdBy: 'current_user@example.com',
            lastModifiedBy: 'current_user@example.com',
            version: '1.0'
        });
        setSelectedTargetServices(initialPlan?.targetServices || []);
        setSelectedAssociatedPolicies(initialPlan?.associatedPolicies || []);
    }, [initialPlan]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setPlan(prev => ({ ...prev, [name]: value }));
    };

    const handleServiceChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = Array.from(e.target.selectedOptions, option => option.value);
        setSelectedTargetServices(value);
        setPlan(prev => ({ ...prev, targetServices: value }));
    };

    const handlePolicyChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = Array.from(e.target.selectedOptions, option => option.value);
        setSelectedAssociatedPolicies(value);
        setPlan(prev => ({ ...prev, associatedPolicies: value }));
    };

    const handleStepChange = (index: number, value: string, type: 'recovery' | 'validation') => {
        if (type === 'recovery') {
            const newSteps = [...plan.recoverySteps];
            newSteps[index] = value;
            setPlan(prev => ({ ...prev, recoverySteps: newSteps }));
        } else {
            const newSteps = [...plan.validationSteps];
            newSteps[index] = value;
            setPlan(prev => ({ ...prev, validationSteps: newSteps }));
        }
    };

    const addStep = (type: 'recovery' | 'validation') => {
        if (type === 'recovery') {
            setPlan(prev => ({ ...prev, recoverySteps: [...prev.recoverySteps, ''] }));
        } else {
            setPlan(prev => ({ ...prev, validationSteps: [...prev.validationSteps, ''] }));
        }
    };

    const removeStep = (index: number, type: 'recovery' | 'validation') => {
        if (type === 'recovery') {
            setPlan(prev => ({ ...prev, recoverySteps: prev.recoverySteps.filter((_, i) => i !== index) }));
        } else {
            setPlan(prev => ({ ...prev, validationSteps: prev.validationSteps.filter((_, i) => i !== index) }));
        }
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        await onSave(plan);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-400">Plan Name</label>
                <input type="text" id="name" name="name" value={plan.name} onChange={handleChange} required
                       className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
            </div>
            <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-400">Description</label>
                <textarea id="description" name="description" value={plan.description} onChange={handleChange}
                          className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"></textarea>
            </div>
            <div>
                <label htmlFor="targetServices" className="block text-sm font-medium text-gray-400">Target Services</label>
                <select multiple id="targetServices" name="targetServices" value={selectedTargetServices} onChange={handleServiceChange} required
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none min-h-[80px]">
                    {services.map(s => <option key={s} value={s}>{s}</option>)}
                </select>
                <p className="text-xs text-gray-500 mt-1">Hold Ctrl/Cmd to select multiple services.</p>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <label htmlFor="rtoValue" className="block text-sm font-medium text-gray-400">RTO Value</label>
                    <input type="number" id="rtoValue" name="rtoValue" value={plan.rtoValue} onChange={handleChange} required
                           min="1" className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                </div>
                <div>
                    <label htmlFor="rtoUnit" className="block text-sm font-medium text-gray-400">RTO Unit</label>
                    <select id="rtoUnit" name="rtoUnit" value={plan.rtoUnit} onChange={handleChange} required
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                        {Object.values(RTOUnit).map(u => <option key={u} value={u}>{u}</option>)}
                    </select>
                </div>
            </div>

            {/* Recovery Steps */}
            <div>
                <label className="block text-sm font-medium text-gray-400">Recovery Steps</label>
                {plan.recoverySteps.map((step, index) => (
                    <div key={`rec-step-${index}`} className="flex items-center space-x-2 mb-2">
                        <textarea
                            value={step}
                            onChange={(e) => handleStepChange(index, e.target.value, 'recovery')}
                            rows={2}
                            className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            placeholder={`Step ${index + 1}`}
                        />
                        <ActionButton label="-" onClick={() => removeStep(index, 'recovery')} variant="danger" className="h-fit" />
                    </div>
                ))}
                <ActionButton label="Add Recovery Step" onClick={() => addStep('recovery')} variant="secondary" className="mt-2" />
            </div>

            {/* Validation Steps */}
            <div>
                <label className="block text-sm font-medium text-gray-400">Validation Steps</label>
                {plan.validationSteps.map((step, index) => (
                    <div key={`val-step-${index}`} className="flex items-center space-x-2 mb-2">
                        <textarea
                            value={step}
                            onChange={(e) => handleStepChange(index, e.target.value, 'validation')}
                            rows={2}
                            className="flex-grow bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            placeholder={`Step ${index + 1}`}
                        />
                        <ActionButton label="-" onClick={() => removeStep(index, 'validation')} variant="danger" className="h-fit" />
                    </div>
                ))}
                <ActionButton label="Add Validation Step" onClick={() => addStep('validation')} variant="secondary" className="mt-2" />
            </div>

            <div>
                <label htmlFor="associatedPolicies" className="block text-sm font-medium text-gray-400">Associated Backup Policies</label>
                <select multiple id="associatedPolicies" name="associatedPolicies" value={selectedAssociatedPolicies} onChange={handlePolicyChange}
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none min-h-[80px]">
                    {policies.map(p => <option key={p.id} value={p.id}>{p.name} ({p.frequency})</option>)}
                </select>
                <p className="text-xs text-gray-500 mt-1">Select policies that feed backups for this plan.</p>
            </div>

            <div>
                <label htmlFor="status" className="block text-sm font-medium text-gray-400">Plan Status</label>
                <select id="status" name="status" value={plan.status} onChange={handleChange} required
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                    {Object.values(PlaybookStatus).map(s => <option key={s} value={s}>{s}</option>)}
                </select>
            </div>

            <div className="flex justify-end space-x-2 mt-6">
                <ActionButton label="Cancel" onClick={onCancel} variant="secondary" disabled={isLoading} />
                <ActionButton label={initialPlan ? "Update Plan" : "Create Plan"} onClick={handleSubmit} isLoading={isLoading} loadingText="Saving..." />
            </div>
        </form>
    );
};

/**
 * Form for creating/editing a storage target.
 */
export interface StorageTargetFormProps {
    target?: StorageTarget;
    onSave: (target: StorageTarget) => Promise<void>;
    onCancel: () => void;
    isLoading: boolean;
}

export const StorageTargetForm: React.FC<StorageTargetFormProps> = ({ target: initialTarget, onSave, onCancel, isLoading }) => {
    const [target, setTarget] = useState<StorageTarget>(
        initialTarget || {
            id: generateUniqueId(),
            name: '',
            type: StorageTargetType.S3,
            location: '',
            capacityBytes: 1024 * 1024 * 1024 * 1024, // 1TB default
            usedBytes: 0,
            enabled: true,
            createdAt: formatTimestamp(new Date())
        }
    );

    useEffect(() => {
        setTarget(initialTarget || {
            id: generateUniqueId(),
            name: '',
            type: StorageTargetType.S3,
            location: '',
            capacityBytes: 1024 * 1024 * 1024 * 1024,
            usedBytes: 0,
            enabled: true,
            createdAt: formatTimestamp(new Date())
        });
    }, [initialTarget]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
        const { name, value, type, checked } = e.target as HTMLInputElement;
        setTarget(prev => ({
            ...prev,
            [name]: type === 'checkbox' ? checked : (name === 'capacityBytes' || name === 'usedBytes' ? parseInt(value) || 0 : value)
        }));
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        await onSave(target);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4 text-gray-300">
            <div>
                <label htmlFor="name" className="block text-sm font-medium text-gray-400">Target Name</label>
                <input type="text" id="name" name="name" value={target.name} onChange={handleChange} required
                       className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
            </div>
            <div>
                <label htmlFor="type" className="block text-sm font-medium text-gray-400">Storage Type</label>
                <select id="type" name="type" value={target.type} onChange={handleChange} required
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none">
                    {Object.values(StorageTargetType).map(t => <option key={t} value={t}>{t}</option>)}
                </select>
            </div>
            <div>
                <label htmlFor="location" className="block text-sm font-medium text-gray-400">Location/Region</label>
                <input type="text" id="location" name="location" value={target.location} onChange={handleChange} required
                       className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
            </div>
            {(target.type === StorageTargetType.S3 || target.type === StorageTargetType.GCS || target.type === StorageTargetType.AZURE_BLOB) && (
                <>
                    <div>
                        <label htmlFor="endpoint" className="block text-sm font-medium text-gray-400">Endpoint URL (Optional)</label>
                        <input type="text" id="endpoint" name="endpoint" value={target.endpoint || ''} onChange={handleChange}
                               className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                    </div>
                    <div>
                        <label htmlFor="accessKeyId" className="block text-sm font-medium text-gray-400">Access Key ID</label>
                        <input type="password" id="accessKeyId" name="accessKeyId" value={target.accessKeyId || ''} onChange={handleChange}
                               className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                    </div>
                    <div>
                        <label htmlFor="secretAccessKey" className="block text-sm font-medium text-gray-400">Secret Access Key</label>
                        <input type="password" id="secretAccessKey" name="secretAccessKey" value={target.secretAccessKey || ''} onChange={handleChange}
                               className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                    </div>
                </>
            )}
            {(target.type === StorageTargetType.NFS || target.type === StorageTargetType.LOCAL) && (
                <div>
                    <label htmlFor="mountPath" className="block text-sm font-medium text-gray-400">Mount Path</label>
                    <input type="text" id="mountPath" name="mountPath" value={target.mountPath || ''} onChange={handleChange} required
                           className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                </div>
            )}
            <div>
                <label htmlFor="capacityBytes" className="block text-sm font-medium text-gray-400">Total Capacity (Bytes)</label>
                <input type="number" id="capacityBytes" name="capacityBytes" value={target.capacityBytes} onChange={handleChange} required
                       min="0" className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                <p className="text-xs text-gray-500 mt-1">Current: {formatBytes(target.capacityBytes)}</p>
            </div>
            <div>
                <label htmlFor="usedBytes" className="block text-sm font-medium text-gray-400">Used Capacity (Bytes)</label>
                <input type="number" id="usedBytes" name="usedBytes" value={target.usedBytes} onChange={handleChange} required
                       min="0" max={target.capacityBytes} className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none" />
                <p className="text-xs text-gray-500 mt-1">Current: {formatBytes(target.usedBytes)}</p>
            </div>
            <div className="flex items-center">
                <input type="checkbox" id="enabled" name="enabled" checked={target.enabled} onChange={handleChange}
                       className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500" />
                <label htmlFor="enabled" className="ml-2 block text-sm text-gray-400">Enabled</label>
            </div>
            <div className="flex justify-end space-x-2 mt-6">
                <ActionButton label="Cancel" onClick={onCancel} variant="secondary" disabled={isLoading} />
                <ActionButton label={initialTarget ? "Update Target" : "Add Target"} onClick={handleSubmit} isLoading={isLoading} loadingText="Saving..." />
            </div>
        </form>
    );
};

// --- MAIN BACKUPRECOVERYVIEW COMPONENT ---

const BackupRecoveryView: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("BackupRecoveryView must be within DataProvider");

    const { backupJobs: initialBackupJobs, services: availableServices } = context;

    // --- Core State Management ---
    const [detailedBackupJobs, setDetailedBackupJobs] = useState<DetailedBackupJob[]>(() => generateMockDetailedBackupJob(20));
    const [backupPolicies, setBackupPolicies] = useState<BackupPolicy[]>(() => generateMockBackupPolicies(5));
    const [storageTargets, setStorageTargets] = useState<StorageTarget[]>(() => generateMockStorageTargets(3));
    const [recoveryPlans, setRecoveryPlans] = useState<RecoveryPlan[]>(() => generateMockRecoveryPlans(5, backupPolicies));
    const [drDrills, setDrDrills] = useState<DRDrill[]>(() => generateMockDRDrills(10, recoveryPlans));
    const [alertRules, setAlertRules] = useState<AlertRule[]>(() => generateMockAlertRules(4));
    const [auditLogs, setAuditLogs] = useState<AuditLog[]>(() => generateMockAuditLogs(30));
    const [complianceReports, setComplianceReports] = useState<ComplianceReport[]>(() => generateMockComplianceReports(3));

    // --- UI State Management for Modals & Forms ---
    const [isSimulatorOpen, setSimulatorOpen] = useState(false);
    const [scenario, setScenario] = useState("Primary database corruption");
    const [aiPlan, setAiPlan] = useState(''); // Renamed to aiPlan to avoid conflict with `plan` variable within component
    const [isAiLoading, setIsAiLoading] = useState(false);
    const [isPolicyFormOpen, setPolicyFormOpen] = useState(false);
    const [editingPolicy, setEditingPolicy] = useState<BackupPolicy | undefined>(undefined);
    const [isRecoveryPlanFormOpen, setRecoveryPlanFormOpen] = useState(false);
    const [editingRecoveryPlan, setEditingRecoveryPlan] = useState<RecoveryPlan | undefined>(undefined);
    const [isStorageTargetFormOpen, setStorageTargetFormOpen] = useState(false);
    const [editingStorageTarget, setEditingStorageTarget] = useState<StorageTarget | undefined>(undefined);
    const [selectedDrillPlanId, setSelectedDrillPlanId] = useState<string | null>(null);
    const [isTriggerDrillModalOpen, setTriggerDrillModalOpen] = useState(false);
    const [isAlertRuleFormOpen, setAlertRuleFormOpen] = useState(false);
    const [editingAlertRule, setEditingAlertRule] = useState<AlertRule | undefined>(undefined);
    const [selectedJobForDetails, setSelectedJobForDetails] = useState<DetailedBackupJob | null>(null);
    const [isJobDetailsModalOpen, setJobDetailsModalOpen] = useState(false);
    const [isManualBackupModalOpen, setManualBackupModalOpen] = useState(false);
    const [manualBackupService, setManualBackupService] = useState<string>('');
    const [manualBackupType, setManualBackupType] = useState<BackupType>(BackupType.FULL);
    const [isManualBackupLoading, setIsManualBackupLoading] = useState(false);

    // --- Derived State & Memorized Values ---
    const successfulBackups24h = useMemo(() => {
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return detailedBackupJobs.filter(job =>
            job.status === BackupStatus.SUCCESS &&
            new Date(job.timestamp).getTime() > twentyFourHoursAgo.getTime()
        ).length;
    }, [detailedBackupJobs]);

    const totalBackups24h = useMemo(() => {
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return detailedBackupJobs.filter(job =>
            new Date(job.timestamp).getTime() > twentyFourHoursAgo.getTime()
        ).length;
    }, [detailedBackupJobs]);

    const backupSuccessRate = useMemo(() => {
        return totalBackups24h > 0 ? (successfulBackups24h / totalBackups24h * 100).toFixed(2) : 'N/A';
    }, [successfulBackups24h, totalBackups24h]);

    const overallRPO = useMemo(() => {
        // Simple average for demonstration; in real-world, this would be more complex
        if (backupPolicies.length === 0) return 'N/A';
        const totalMinutes = backupPolicies.reduce((sum, p) => {
            let minutes = p.rpoValue;
            if (p.rpoUnit === RPOUnit.HOURS) minutes *= 60;
            if (p.rpoUnit === RPOUnit.DAYS) minutes *= 24 * 60;
            return sum + minutes;
        }, 0);
        return `${Math.round(totalMinutes / backupPolicies.length / 60)}h`;
    }, [backupPolicies]);

    const overallRTO = useMemo(() => {
        // Simple average for demonstration
        if (recoveryPlans.length === 0) return 'N/A';
        const totalMinutes = recoveryPlans.reduce((sum, p) => {
            let minutes = p.rtoValue;
            if (p.rtoUnit === RTOUnit.HOURS) minutes *= 60;
            if (p.rtoUnit === RTOUnit.DAYS) minutes *= 24 * 60;
            return sum + minutes;
        }, 0);
        return `${Math.round(totalMinutes / recoveryPlans.length / 60)}h`;
    }, [recoveryPlans]);

    const totalStorageCapacity = useMemo(() => storageTargets.reduce((sum, t) => sum + t.capacityBytes, 0), [storageTargets]);
    const totalStorageUsed = useMemo(() => storageTargets.reduce((sum, t) => sum + t.usedBytes, 0), [storageTargets]);
    const storageUtilization = useMemo(() => totalStorageCapacity > 0 ? (totalStorageUsed / totalStorageCapacity * 100).toFixed(2) : '0', [totalStorageCapacity, totalStorageUsed]);

    // --- API & State Update Handlers ---

    /**
     * Handles the AI DR Plan simulation.
     */
    const handleSimulate = async () => {
        setIsAiLoading(true); setAiPlan('');
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `Generate a high-level disaster recovery plan (DRP) for this scenario: "${scenario}". Include steps for failover, data restoration, and post-recovery validation. Make it detailed, around 500 words, and structured with headings.`;
            const model = ai.getGenerativeModel({ model: 'gemini-pro' }); // Using a more capable model
            const result = await model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            setAiPlan(text);
        } catch (err) {
            console.error("AI Simulation Error:", err);
            setAiPlan("Failed to generate plan. Please check API key and try again. Error: " + (err as Error).message);
        } finally {
            setIsAiLoading(false);
        }
    };

    /**
     * Handles saving a backup policy (create or update).
     * @param {BackupPolicy} policy - The policy to save.
     */
    const handleSavePolicy = useCallback(async (policy: BackupPolicy) => {
        // Simulate API call
        setIsAiLoading(true); // Re-using AI loading state for general form submission simulation
        await new Promise(resolve => setTimeout(resolve, 1500));
        setBackupPolicies(prev => {
            const existingIndex = prev.findIndex(p => p.id === policy.id);
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex] = { ...policy, lastUpdated: formatTimestamp(new Date()) };
                return updated;
            }
            return [...prev, policy];
        });
        setPolicyFormOpen(false);
        setEditingPolicy(undefined);
        setIsAiLoading(false);
        console.log("Saved policy:", policy);
    }, []);

    /**
     * Handles deleting a backup policy.
     * @param {string} policyId - The ID of the policy to delete.
     */
    const handleDeletePolicy = useCallback(async (policyId: string) => {
        if (!window.confirm("Are you sure you want to delete this policy?")) return;
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        setBackupPolicies(prev => prev.filter(p => p.id !== policyId));
        setIsAiLoading(false);
        console.log("Deleted policy:", policyId);
    }, []);

    /**
     * Handles saving a recovery plan.
     * @param {RecoveryPlan} plan - The plan to save.
     */
    const handleSaveRecoveryPlan = useCallback(async (plan: RecoveryPlan) => {
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1500));
        setRecoveryPlans(prev => {
            const existingIndex = prev.findIndex(p => p.id === plan.id);
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex] = { ...plan, lastModifiedBy: 'current_user@example.com', lastTested: plan.lastTested || null };
                return updated;
            }
            return [...prev, plan];
        });
        setRecoveryPlanFormOpen(false);
        setEditingRecoveryPlan(undefined);
        setIsAiLoading(false);
        console.log("Saved recovery plan:", plan);
    }, []);

    /**
     * Handles deleting a recovery plan.
     * @param {string} planId - The ID of the plan to delete.
     */
    const handleDeleteRecoveryPlan = useCallback(async (planId: string) => {
        if (!window.confirm("Are you sure you want to delete this recovery plan?")) return;
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        setRecoveryPlans(prev => prev.filter(p => p.id !== planId));
        setIsAiLoading(false);
        console.log("Deleted recovery plan:", planId);
    }, []);

    /**
     * Handles saving a storage target.
     * @param {StorageTarget} target - The storage target to save.
     */
    const handleSaveStorageTarget = useCallback(async (target: StorageTarget) => {
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1500));
        setStorageTargets(prev => {
            const existingIndex = prev.findIndex(t => t.id === target.id);
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex] = target;
                return updated;
            }
            return [...prev, target];
        });
        setStorageTargetFormOpen(false);
        setEditingStorageTarget(undefined);
        setIsAiLoading(false);
        console.log("Saved storage target:", target);
    }, []);

    /**
     * Handles deleting a storage target.
     * @param {string} targetId - The ID of the target to delete.
     */
    const handleDeleteStorageTarget = useCallback(async (targetId: string) => {
        if (!window.confirm("Are you sure you want to delete this storage target?")) return;
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        setStorageTargets(prev => prev.filter(t => t.id !== targetId));
        setIsAiLoading(false);
        console.log("Deleted storage target:", targetId);
    }, []);

    /**
     * Triggers a DR drill for a selected plan.
     */
    const handleTriggerDrill = useCallback(async () => {
        if (!selectedDrillPlanId) return;
        setIsAiLoading(true); // Re-using for drill
        setTriggerDrillModalOpen(false);
        console.log(`Triggering DR drill for plan: ${selectedDrillPlanId}`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate drill initiation
        const newDrill: DRDrill = {
            id: `drill-${generateUniqueId()}`,
            planId: selectedDrillPlanId,
            planName: recoveryPlans.find(p => p.id === selectedDrillPlanId)?.name || 'Unknown Plan',
            startTime: formatTimestamp(new Date()),
            endTime: null,
            status: DRDrillStatus.IN_PROGRESS,
            triggeredBy: 'current_user@example.com',
            outcome: 'Drill initiated...',
            logs: [`DR Drill for plan ${selectedDrillPlanId} initiated.`],
            durationMinutes: null
        };
        setDrDrills(prev => [newDrill, ...prev]);
        setSelectedDrillPlanId(null);
        setIsAiLoading(false);

        // Simulate drill completion after a delay
        setTimeout(() => {
            setDrDrills(prev => prev.map(drill => {
                if (drill.id === newDrill.id) {
                    const duration = Math.floor(Math.random() * 120) + 30;
                    return {
                        ...drill,
                        endTime: formatTimestamp(new Date(new Date(drill.startTime).getTime() + duration * 60 * 1000)),
                        status: Math.random() > 0.2 ? DRDrillStatus.COMPLETED_SUCCESS : DRDrillStatus.COMPLETED_FAILED,
                        outcome: Math.random() > 0.2 ? 'Drill completed successfully, RTO/RPO validated.' : 'Drill failed, identified issues in restoration phase.',
                        durationMinutes: duration,
                        logs: [...drill.logs, `Drill completed. Status: ${Math.random() > 0.2 ? 'SUCCESS' : 'FAILED'}`]
                    };
                }
                return drill;
            }));
        }, Math.random() * 10000 + 5000); // 5 to 15 seconds for drill to complete
    }, [selectedDrillPlanId, recoveryPlans]);

    /**
     * Handles saving an alert rule.
     * @param {AlertRule} rule - The alert rule to save.
     */
    const handleSaveAlertRule = useCallback(async (rule: AlertRule) => {
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1500));
        setAlertRules(prev => {
            const existingIndex = prev.findIndex(r => r.id === rule.id);
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex] = rule;
                return updated;
            }
            return [...prev, rule];
        });
        setAlertRuleFormOpen(false);
        setEditingAlertRule(undefined);
        setIsAiLoading(false);
        console.log("Saved alert rule:", rule);
    }, []);

    /**
     * Handles deleting an alert rule.
     * @param {string} ruleId - The ID of the rule to delete.
     */
    const handleDeleteAlertRule = useCallback(async (ruleId: string) => {
        if (!window.confirm("Are you sure you want to delete this alert rule?")) return;
        setIsAiLoading(true);
        await new Promise(resolve => setTimeout(resolve, 1000));
        setAlertRules(prev => prev.filter(r => r.id !== ruleId));
        setIsAiLoading(false);
        console.log("Deleted alert rule:", ruleId);
    }, []);

    /**
     * Triggers a manual backup for a specified service and type.
     */
    const handleTriggerManualBackup = useCallback(async () => {
        if (!manualBackupService) {
            alert('Please select a service for manual backup.');
            return;
        }

        setIsManualBackupLoading(true);
        setManualBackupModalOpen(false);
        console.log(`Initiating manual ${manualBackupType} backup for service: ${manualBackupService}`);

        await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate API call to start backup

        const newJob: DetailedBackupJob = {
            id: generateUniqueId(),
            service: manualBackupService,
            type: manualBackupType,
            status: BackupStatus.IN_PROGRESS,
            timestamp: formatTimestamp(new Date()),
            duration: '0m 0s',
            size: 0,
            logs: [`Manual ${manualBackupType} backup initiated for ${manualBackupService}.`],
            progress: 0,
            recoveryPoint: formatTimestamp(new Date())
        };

        setDetailedBackupJobs(prev => [newJob, ...prev]);
        setIsManualBackupLoading(false);

        // Simulate backup completion
        let currentProgress = 0;
        const interval = setInterval(() => {
            currentProgress += 10;
            if (currentProgress > 100) {
                clearInterval(interval);
                setDetailedBackupJobs(prev => prev.map(job => {
                    if (job.id === newJob.id) {
                        const finalStatus = Math.random() > 0.1 ? BackupStatus.SUCCESS : BackupStatus.FAILED; // 10% failure chance
                        const finalSize = Math.floor(Math.random() * (200 * 1024 * 1024)) + (5 * 1024 * 1024); // 5MB to 200MB
                        const finalDurationSeconds = Math.floor(Math.random() * 300) + 30; // 30 sec to 5 min
                        const finalDuration = `${Math.floor(finalDurationSeconds / 60)}m ${finalDurationSeconds % 60}s`;
                        return {
                            ...job,
                            status: finalStatus,
                            duration: finalDuration,
                            size: finalSize,
                            progress: 100,
                            logs: [...job.logs, `Backup completed. Status: ${finalStatus}. Size: ${formatBytes(finalSize)}. Duration: ${finalDuration}.`]
                        };
                    }
                    return job;
                }));
            } else {
                setDetailedBackupJobs(prev => prev.map(job =>
                    job.id === newJob.id ? { ...job, progress: currentProgress } : job
                ));
            }
        }, 500); // Update progress every 0.5 seconds
    }, [manualBackupService, manualBackupType]);

    // --- JSX Rendering Logic ---
    return (
        <>
            <div className="space-y-6">
                <div className="flex justify-between items-center">
                    <h2 className="text-3xl font-bold text-white tracking-wider">Backup & Recovery Operations Center</h2>
                    <div className="flex space-x-3">
                        <ActionButton
                            label="Manual Backup"
                            onClick={() => setManualBackupModalOpen(true)}
                            variant="primary"
                        />
                        <ActionButton
                            label="AI DR Plan Simulator"
                            onClick={() => setSimulatorOpen(true)}
                            variant="secondary"
                        />
                    </div>
                </div>

                {/* Top-level Metrics */}
                <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                    <Card className="text-center">
                        <p className="text-3xl font-bold text-green-400">{backupSuccessRate}%</p>
                        <p className="text-sm text-gray-400 mt-1">Backup Success (24h)</p>
                    </Card>
                    <Card className="text-center">
                        <p className="text-3xl font-bold text-white">{overallRPO}</p>
                        <p className="text-sm text-gray-400 mt-1">Avg. Recovery Point Objective</p>
                    </Card>
                    <Card className="text-center">
                        <p className="text-3xl font-bold text-white">{overallRTO}</p>
                        <p className="text-sm text-gray-400 mt-1">Avg. Recovery Time Objective</p>
                    </Card>
                    <Card className="text-center">
                        <p className="text-3xl font-bold text-cyan-400">{storageUtilization}%</p>
                        <p className="text-sm text-gray-400 mt-1">Storage Utilization</p>
                    </Card>
                </div>

                {/* Recent Backup Jobs - Expanded */}
                <CollapsibleSection title="Recent Backup Jobs" defaultOpen={true}>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Service</th>
                                <th scope="col" className="px-4 py-2 text-left">Type</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Timestamp</th>
                                <th scope="col" className="px-4 py-2 text-left">Duration</th>
                                <th scope="col" className="px-4 py-2 text-left">Size</th>
                                <th scope="col" className="px-4 py-2 text-left">Progress</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {detailedBackupJobs.slice(0, 10).map(job => (
                                <tr key={job.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{job.service}</td>
                                    <td className="px-4 py-2">{job.type}</td>
                                    <td className="px-4 py-2"><StatusBadge status={job.status} /></td>
                                    <td className="px-4 py-2">{job.timestamp}</td>
                                    <td className="px-4 py-2">{job.duration}</td>
                                    <td className="px-4 py-2">{formatBytes(job.size)}</td>
                                    <td className="px-4 py-2">
                                        <ProgressBar progress={job.progress} />
                                    </td>
                                    <td className="px-4 py-2">
                                        <ActionButton
                                            label="Details"
                                            onClick={() => { setSelectedJobForDetails(job); setJobDetailsModalOpen(true); }}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                    <div className="mt-4 text-center">
                        <ActionButton label="View All Backup Jobs" onClick={() => {/* navigate to full jobs list */}} variant="secondary" />
                    </div>
                </CollapsibleSection>

                {/* Backup Policies Management */}
                <CollapsibleSection title="Backup Policies">
                    <div className="mb-4 flex justify-end">
                        <ActionButton label="Create New Policy" onClick={() => { setEditingPolicy(undefined); setPolicyFormOpen(true); }} />
                    </div>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Name</th>
                                <th scope="col" className="px-4 py-2 text-left">Services</th>
                                <th scope="col" className="px-4 py-2 text-left">Frequency</th>
                                <th scope="col" className="px-4 py-2 text-left">Retention</th>
                                <th scope="col" className="px-4 py-2 text-left">RPO</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Last Updated</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {backupPolicies.map(policy => (
                                <tr key={policy.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{policy.name}</td>
                                    <td className="px-4 py-2">{policy.services.join(', ')}</td>
                                    <td className="px-4 py-2">{policy.frequency.replace(/_/g, ' ')}</td>
                                    <td className="px-4 py-2">{policy.retentionDays} days</td>
                                    <td className="px-4 py-2">{policy.rpoValue} {policy.rpoUnit}</td>
                                    <td className="px-4 py-2"><StatusBadge status={policy.enabled ? 'ACTIVE' : 'DISABLED'} type={policy.enabled ? 'success' : 'error'} /></td>
                                    <td className="px-4 py-2">{policy.lastUpdated}</td>
                                    <td className="px-4 py-2 flex space-x-2">
                                        <ActionButton
                                            label="Edit"
                                            onClick={() => { setEditingPolicy(policy); setPolicyFormOpen(true); }}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                        <ActionButton
                                            label="Delete"
                                            onClick={() => handleDeletePolicy(policy.id)}
                                            variant="danger"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </CollapsibleSection>

                {/* Recovery Plans & DR Drills */}
                <CollapsibleSection title="Recovery Plans & DR Drills">
                    <div className="mb-4 flex justify-end space-x-2">
                        <ActionButton label="Create New Plan" onClick={() => { setEditingRecoveryPlan(undefined); setRecoveryPlanFormOpen(true); }} />
                        <ActionButton label="Trigger DR Drill" onClick={() => setTriggerDrillModalOpen(true)} variant="danger" />
                    </div>
                    <h4 className="text-xl font-semibold text-white mb-3">Recovery Plans</h4>
                    <table className="w-full text-sm text-gray-300 mb-8">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Name</th>
                                <th scope="col" className="px-4 py-2 text-left">Target Services</th>
                                <th scope="col" className="px-4 py-2 text-left">RTO</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Last Tested</th>
                                <th scope="col" className="px-4 py-2 text-left">Version</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {recoveryPlans.map(plan => (
                                <tr key={plan.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{plan.name}</td>
                                    <td className="px-4 py-2">{plan.targetServices.join(', ')}</td>
                                    <td className="px-4 py-2">{plan.rtoValue} {plan.rtoUnit}</td>
                                    <td className="px-4 py-2"><StatusBadge status={plan.status} /></td>
                                    <td className="px-4 py-2">{plan.lastTested || 'Never'}</td>
                                    <td className="px-4 py-2">{plan.version}</td>
                                    <td className="px-4 py-2 flex space-x-2">
                                        <ActionButton
                                            label="Edit"
                                            onClick={() => { setEditingRecoveryPlan(plan); setRecoveryPlanFormOpen(true); }}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                        <ActionButton
                                            label="Delete"
                                            onClick={() => handleDeleteRecoveryPlan(plan.id)}
                                            variant="danger"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>

                    <h4 className="text-xl font-semibold text-white mb-3">Recent DR Drills</h4>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Plan</th>
                                <th scope="col" className="px-4 py-2 text-left">Start Time</th>
                                <th scope="col" className="px-4 py-2 text-left">End Time</th>
                                <th scope="col" className="px-4 py-2 text-left">Duration</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Triggered By</th>
                                <th scope="col" className="px-4 py-2 text-left">Outcome</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {drDrills.slice(0, 5).map(drill => (
                                <tr key={drill.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{drill.planName}</td>
                                    <td className="px-4 py-2">{drill.startTime}</td>
                                    <td className="px-4 py-2">{drill.endTime || 'N/A'}</td>
                                    <td className="px-4 py-2">{drill.durationMinutes ? `${drill.durationMinutes} min` : 'N/A'}</td>
                                    <td className="px-4 py-2"><StatusBadge status={drill.status} /></td>
                                    <td className="px-4 py-2">{drill.triggeredBy}</td>
                                    <td className="px-4 py-2 max-w-[150px] overflow-hidden text-ellipsis whitespace-nowrap">{drill.outcome}</td>
                                    <td className="px-4 py-2">
                                        <ActionButton
                                            label="View Logs"
                                            onClick={() => alert(`Drill Logs for ${drill.planName}:\n${drill.logs.join('\n')}`)}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                    <div className="mt-4 text-center">
                        <ActionButton label="View All DR Drills" onClick={() => {/* navigate to full drills list */}} variant="secondary" />
                    </div>
                </CollapsibleSection>

                {/* Storage Targets Management */}
                <CollapsibleSection title="Storage Targets">
                    <div className="mb-4 flex justify-end">
                        <ActionButton label="Add New Target" onClick={() => { setEditingStorageTarget(undefined); setStorageTargetFormOpen(true); }} />
                    </div>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Name</th>
                                <th scope="col" className="px-4 py-2 text-left">Type</th>
                                <th scope="col" className="px-4 py-2 text-left">Location</th>
                                <th scope="col" className="px-4 py-2 text-left">Capacity</th>
                                <th scope="col" className="px-4 py-2 text-left">Used</th>
                                <th scope="col" className="px-4 py-2 text-left">Utilization</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {storageTargets.map(target => (
                                <tr key={target.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{target.name}</td>
                                    <td className="px-4 py-2">{target.type}</td>
                                    <td className="px-4 py-2">{target.location}</td>
                                    <td className="px-4 py-2">{formatBytes(target.capacityBytes)}</td>
                                    <td className="px-4 py-2">{formatBytes(target.usedBytes)}</td>
                                    <td className="px-4 py-2">
                                        <ProgressBar
                                            progress={(target.usedBytes / target.capacityBytes) * 100}
                                            color={(target.usedBytes / target.capacityBytes) > 0.8 ? 'bg-red-500' : 'bg-cyan-500'}
                                        />
                                    </td>
                                    <td className="px-4 py-2"><StatusBadge status={target.enabled ? 'ACTIVE' : 'DISABLED'} type={target.enabled ? 'success' : 'error'} /></td>
                                    <td className="px-4 py-2 flex space-x-2">
                                        <ActionButton
                                            label="Edit"
                                            onClick={() => { setEditingStorageTarget(target); setStorageTargetFormOpen(true); }}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                        <ActionButton
                                            label="Delete"
                                            onClick={() => handleDeleteStorageTarget(target.id)}
                                            variant="danger"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </CollapsibleSection>

                {/* Monitoring & Alerting */}
                <CollapsibleSection title="Alert Rules">
                    <div className="mb-4 flex justify-end">
                        <ActionButton label="Create New Rule" onClick={() => { setEditingAlertRule(undefined); setAlertRuleFormOpen(true); }} />
                    </div>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Name</th>
                                <th scope="col" className="px-4 py-2 text-left">Condition</th>
                                <th scope="col" className="px-4 py-2 text-left">Severity</th>
                                <th scope="col" className="px-4 py-2 text-left">Channels</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Last Triggered</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {alertRules.map(rule => (
                                <tr key={rule.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{rule.name}</td>
                                    <td className="px-4 py-2">{rule.condition}</td>
                                    <td className="px-4 py-2"><StatusBadge status={rule.severity} /></td>
                                    <td className="px-4 py-2">{rule.notificationChannels.join(', ')}</td>
                                    <td className="px-4 py-2"><StatusBadge status={rule.enabled ? 'ENABLED' : 'DISABLED'} type={rule.enabled ? 'success' : 'error'} /></td>
                                    <td className="px-4 py-2">{rule.lastTriggered || 'Never'}</td>
                                    <td className="px-4 py-2 flex space-x-2">
                                        <ActionButton
                                            label="Edit"
                                            onClick={() => { setEditingAlertRule(rule); setAlertRuleFormOpen(true); }}
                                            variant="secondary"
                                            className="px-2 py-1"
                                        />
                                        <ActionButton
                                            label="Delete"
                                            onClick={() => handleDeleteAlertRule(rule.id)}
                                            variant="danger"
                                            className="px-2 py-1"
                                        />
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </CollapsibleSection>

                {/* Compliance & Audit */}
                <CollapsibleSection title="Compliance Reports">
                    <div className="mb-4 flex justify-end">
                        <ActionButton label="Generate New Report" onClick={() => alert('Generating new compliance report...')} />
                    </div>
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Standard</th>
                                <th scope="col" className="px-4 py-2 text-left">Generation Date</th>
                                <th scope="col" className="px-4 py-2 text-left">Period</th>
                                <th scope="col" className="px-4 py-2 text-left">Status</th>
                                <th scope="col" className="px-4 py-2 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {complianceReports.map(report => (
                                <tr key={report.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{report.standard}</td>
                                    <td className="px-4 py-2">{report.generationDate}</td>
                                    <td className="px-4 py-2">{report.periodStart} - {report.periodEnd}</td>
                                    <td className="px-4 py-2"><StatusBadge status={report.complianceStatus} /></td>
                                    <td className="px-4 py-2">
                                        {report.reportFileUrl && (
                                            <a href={report.reportFileUrl} target="_blank" rel="noopener noreferrer">
                                                <ActionButton label="View Report" variant="secondary" className="px-2 py-1" />
                                            </a>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </CollapsibleSection>

                <CollapsibleSection title="Audit Logs">
                    <table className="w-full text-sm text-gray-300">
                        <thead className="text-xs text-gray-300 uppercase bg-gray-900/30">
                            <tr>
                                <th scope="col" className="px-4 py-2 text-left">Timestamp</th>
                                <th scope="col" className="px-4 py-2 text-left">Actor</th>
                                <th scope="col" className="px-4 py-2 text-left">Action</th>
                                <th scope="col" className="px-4 py-2 text-left">Target</th>
                                <th scope="col" className="px-4 py-2 text-left">IP Address</th>
                            </tr>
                        </thead>
                        <tbody>
                            {auditLogs.slice(0, 15).map(log => (
                                <tr key={log.id} className="border-b border-gray-700 hover:bg-gray-800/50">
                                    <td className="px-4 py-2">{log.timestamp}</td>
                                    <td className="px-4 py-2">{log.actor}</td>
                                    <td className="px-4 py-2">{log.action}</td>
                                    <td className="px-4 py-2">{log.target}</td>
                                    <td className="px-4 py-2">{log.ipAddress}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                    <div className="mt-4 text-center">
                        <ActionButton label="View All Audit Logs" onClick={() => {/* navigate to full audit logs */}} variant="secondary" />
                    </div>
                </CollapsibleSection>
            </div>

            {/* AI DR Plan Simulator Modal */}
            <Modal isOpen={isSimulatorOpen} onClose={() => setSimulatorOpen(false)} title="AI DR Plan Simulator">
                <div className="p-6 space-y-4">
                    <label htmlFor="scenarioInput" className="block text-sm font-medium text-gray-400">Describe your disaster scenario:</label>
                    <textarea
                        id="scenarioInput"
                        value={scenario}
                        onChange={e => setScenario(e.target.value)}
                        className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none min-h-[100px]"
                        placeholder="e.g., 'Primary data center outage affecting all services', 'Ransomware attack encrypting critical databases'"
                    />
                    <ActionButton
                        label="Simulate DR Plan"
                        onClick={handleSimulate}
                        isLoading={isAiLoading}
                        loadingText="Simulating..."
                        className="w-full"
                    />
                    {aiPlan && (
                        <Card title="Simulated Plan">
                            <div className="min-h-[10rem] max-h-60 overflow-y-auto text-sm text-gray-300 whitespace-pre-line p-2 bg-gray-900/30 rounded">
                                {aiPlan}
                            </div>
                        </Card>
                    )}
                </div>
            </Modal>

            {/* Backup Policy Form Modal */}
            <Modal isOpen={isPolicyFormOpen} onClose={() => setPolicyFormOpen(false)} title={editingPolicy ? "Edit Backup Policy" : "Create Backup Policy"} widthClass="max-w-3xl">
                <BackupPolicyForm
                    policy={editingPolicy}
                    onSave={handleSavePolicy}
                    onCancel={() => { setPolicyFormOpen(false); setEditingPolicy(undefined); }}
                    isLoading={isAiLoading}
                    storageTargets={storageTargets}
                    services={availableServices || MOCK_SERVICES}
                />
            </Modal>

            {/* Recovery Plan Form Modal */}
            <Modal isOpen={isRecoveryPlanFormOpen} onClose={() => setRecoveryPlanFormOpen(false)} title={editingRecoveryPlan ? "Edit Recovery Plan" : "Create Recovery Plan"} widthClass="max-w-4xl">
                <RecoveryPlanForm
                    plan={editingRecoveryPlan}
                    onSave={handleSaveRecoveryPlan}
                    onCancel={() => { setRecoveryPlanFormOpen(false); setEditingRecoveryPlan(undefined); }}
                    isLoading={isAiLoading}
                    policies={backupPolicies}
                    services={availableServices || MOCK_SERVICES}
                />
            </Modal>

            {/* Storage Target Form Modal */}
            <Modal isOpen={isStorageTargetFormOpen} onClose={() => setStorageTargetFormOpen(false)} title={editingStorageTarget ? "Edit Storage Target" : "Add Storage Target"} widthClass="max-w-2xl">
                <StorageTargetForm
                    target={editingStorageTarget}
                    onSave={handleSaveStorageTarget}
                    onCancel={() => { setStorageTargetFormOpen(false); setEditingStorageTarget(undefined); }}
                    isLoading={isAiLoading}
                />
            </Modal>

            {/* Trigger DR Drill Modal */}
            <Modal isOpen={isTriggerDrillModalOpen} onClose={() => setTriggerDrillModalOpen(false)} title="Trigger Disaster Recovery Drill">
                <div className="space-y-4 text-gray-300">
                    <p className="text-gray-400">Select a recovery plan to initiate a simulated DR drill. This will test the plan's effectiveness without impacting production.</p>
                    <div>
                        <label htmlFor="drillPlanSelect" className="block text-sm font-medium text-gray-400">Select Recovery Plan</label>
                        <select
                            id="drillPlanSelect"
                            value={selectedDrillPlanId || ''}
                            onChange={(e) => setSelectedDrillPlanId(e.target.value)}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            required
                        >
                            <option value="">-- Select a Plan --</option>
                            {recoveryPlans.filter(p => p.status === PlaybookStatus.ACTIVE).map(plan => (
                                <option key={plan.id} value={plan.id}>{plan.name} (RTO: {plan.rtoValue}{plan.rtoUnit.charAt(0)})</option>
                            ))}
                        </select>
                    </div>
                    <p className="text-yellow-400 text-sm">
                        <span className="font-bold">Warning:</span> Triggering a drill will create an entry in the DR Drills log and simulate the recovery process.
                    </p>
                    <div className="flex justify-end space-x-2">
                        <ActionButton label="Cancel" onClick={() => setTriggerDrillModalOpen(false)} variant="secondary" disabled={isAiLoading} />
                        <ActionButton label="Start Drill" onClick={handleTriggerDrill} isLoading={isAiLoading} loadingText="Initiating..." disabled={!selectedDrillPlanId} />
                    </div>
                </div>
            </Modal>

            {/* Alert Rule Form Modal */}
            <Modal isOpen={isAlertRuleFormOpen} onClose={() => setAlertRuleFormOpen(false)} title={editingAlertRule ? "Edit Alert Rule" : "Create Alert Rule"} widthClass="max-w-2xl">
                <form onSubmit={async (e) => {
                    e.preventDefault();
                    await handleSaveAlertRule(editingAlertRule || {
                        id: generateUniqueId(),
                        name: '',
                        description: '',
                        condition: '',
                        severity: AlertSeverity.MEDIUM,
                        notificationChannels: [],
                        enabled: true,
                        lastTriggered: null
                    });
                }} className="space-y-4 text-gray-300">
                    <div>
                        <label htmlFor="alertName" className="block text-sm font-medium text-gray-400">Rule Name</label>
                        <input
                            type="text" id="alertName" name="name"
                            value={editingAlertRule?.name || ''}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, name: e.target.value }))}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="alertDescription" className="block text-sm font-medium text-gray-400">Description</label>
                        <textarea
                            id="alertDescription" name="description"
                            value={editingAlertRule?.description || ''}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, description: e.target.value }))}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                        />
                    </div>
                    <div>
                        <label htmlFor="alertCondition" className="block text-sm font-medium text-gray-400">Condition</label>
                        <input
                            type="text" id="alertCondition" name="condition"
                            value={editingAlertRule?.condition || ''}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, condition: e.target.value }))}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            placeholder="e.g., 'Backup Failure Rate > 10%'"
                            required
                        />
                    </div>
                    <div>
                        <label htmlFor="alertSeverity" className="block text-sm font-medium text-gray-400">Severity</label>
                        <select
                            id="alertSeverity" name="severity"
                            value={editingAlertRule?.severity || AlertSeverity.MEDIUM}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, severity: e.target.value as AlertSeverity }))}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            required
                        >
                            {Object.values(AlertSeverity).map(s => <option key={s} value={s}>{s}</option>)}
                        </select>
                    </div>
                    <div>
                        <label htmlFor="notificationChannels" className="block text-sm font-medium text-gray-400">Notification Channels (comma-separated)</label>
                        <input
                            type="text" id="notificationChannels" name="notificationChannels"
                            value={editingAlertRule?.notificationChannels.join(', ') || ''}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, notificationChannels: e.target.value.split(',').map(c => c.trim()).filter(Boolean) }))}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            placeholder="e.g., 'email:ops@example.com, slack:#dr-alerts'"
                        />
                    </div>
                    <div className="flex items-center">
                        <input
                            type="checkbox" id="alertEnabled" name="enabled"
                            checked={editingAlertRule?.enabled || false}
                            onChange={(e) => setEditingAlertRule(prev => ({ ...prev!, enabled: e.target.checked }))}
                            className="h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
                        />
                        <label htmlFor="alertEnabled" className="ml-2 block text-sm text-gray-400">Enabled</label>
                    </div>
                    <div className="flex justify-end space-x-2 mt-6">
                        <ActionButton label="Cancel" onClick={() => { setAlertRuleFormOpen(false); setEditingAlertRule(undefined); }} variant="secondary" disabled={isAiLoading} />
                        <ActionButton label={editingAlertRule ? "Update Rule" : "Create Rule"} type="submit" isLoading={isAiLoading} loadingText="Saving..." />
                    </div>
                </form>
            </Modal>

            {/* Backup Job Details Modal */}
            <Modal isOpen={isJobDetailsModalOpen} onClose={() => setJobDetailsModalOpen(false)} title="Backup Job Details" widthClass="max-w-2xl">
                {selectedJobForDetails ? (
                    <div className="space-y-3 text-gray-300">
                        <p><strong>Service:</strong> {selectedJobForDetails.service}</p>
                        <p><strong>Type:</strong> {selectedJobForDetails.type}</p>
                        <p><strong>Status:</strong> <StatusBadge status={selectedJobForDetails.status} /></p>
                        <p><strong>Timestamp:</strong> {selectedJobForDetails.timestamp}</p>
                        <p><strong>Duration:</strong> {selectedJobForDetails.duration}</p>
                        <p><strong>Size:</strong> {formatBytes(selectedJobForDetails.size)}</p>
                        <p><strong>Recovery Point:</strong> {selectedJobForDetails.recoveryPoint}</p>
                        <div>
                            <strong>Logs:</strong>
                            <div className="bg-gray-900/50 p-3 rounded text-xs max-h-40 overflow-y-auto mt-1">
                                {selectedJobForDetails.logs.length > 0 ? (
                                    selectedJobForDetails.logs.map((log, i) => <p key={i}>{log}</p>)
                                ) : (
                                    <p>No logs available.</p>
                                )}
                            </div>
                        </div>
                        <div className="pt-2 border-t border-gray-700 text-right">
                            <ActionButton label="Initiate Recovery" onClick={() => alert(`Initiating recovery for ${selectedJobForDetails.service} from point ${selectedJobForDetails.recoveryPoint}.`)} variant="success" className="mr-2" />
                            <ActionButton label="Close" onClick={() => setJobDetailsModalOpen(false)} variant="secondary" />
                        </div>
                    </div>
                ) : <p>No job selected.</p>}
            </Modal>

            {/* Manual Backup Modal */}
            <Modal isOpen={isManualBackupModalOpen} onClose={() => setManualBackupModalOpen(false)} title="Trigger Manual Backup" widthClass="max-w-xl">
                <div className="space-y-4 text-gray-300">
                    <p className="text-gray-400">Manually trigger a backup for a specific service. This will run outside of scheduled policies.</p>
                    <div>
                        <label htmlFor="manualServiceSelect" className="block text-sm font-medium text-gray-400">Select Service</label>
                        <select
                            id="manualServiceSelect"
                            value={manualBackupService}
                            onChange={(e) => setManualBackupService(e.target.value)}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            required
                        >
                            <option value="">-- Select a Service --</option>
                            {(availableServices || MOCK_SERVICES).map(s => (
                                <option key={s} value={s}>{s}</option>
                            ))}
                        </select>
                    </div>
                    <div>
                        <label htmlFor="manualBackupType" className="block text-sm font-medium text-gray-400">Backup Type</label>
                        <select
                            id="manualBackupType"
                            value={manualBackupType}
                            onChange={(e) => setManualBackupType(e.target.value as BackupType)}
                            className="w-full bg-gray-700/50 p-2 rounded border border-gray-600 focus:border-cyan-500 outline-none"
                            required
                        >
                            {Object.values(BackupType).map(t => <option key={t} value={t}>{t}</option>)}
                        </select>
                    </div>
                    <div className="flex justify-end space-x-2 mt-6">
                        <ActionButton label="Cancel" onClick={() => setManualBackupModalOpen(false)} variant="secondary" disabled={isManualBackupLoading} />
                        <ActionButton label="Start Backup" onClick={handleTriggerManualBackup} isLoading={isManualBackupLoading} loadingText="Starting..." disabled={!manualBackupService} />
                    </div>
                </div>
            </Modal>
        </>
    );
};

export default BackupRecoveryView;

--- FILE: ContainerRegistryView.tsx ---

import React, { useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";

// ====================================================================================================================
// --- Type Definitions (Extensive for all new features) ---
// ====================================================================================================================

/**
 * Represents a single container image entry.
 * @interface ContainerImage
 */
export interface ContainerImage {
    id: string;
    repository: string;
    tag: string;
    size: string; // e.g., "500MB"
    lastPush: string; // ISO date string
    digest: string; // SHA256 digest
    status: 'active' | 'deprecated' | 'archived' | 'pending_scan';
    architecture: 'amd64' | 'arm64' | 'windows/amd64';
    os: 'linux' | 'windows';
    vulnerabilityScore: number; // 0-100, lower is better
    vulnerabilities: ImageVulnerability[];
    layers: ImageLayer[];
    manifest: string; // Base64 encoded manifest or a large JSON string
    labels: { [key: string]: string };
    baseImage: string;
    pullCountLast30Days: number;
    pullCountTotal: number;
    lastPulled: string; // ISO date string
    buildId?: string; // Link to a build process
    deploymentTargets: ImageDeploymentTarget[];
    retentionPolicyApplied?: string; // e.g., "30-day-policy"
    costEstimateUSD?: number; // Estimated cost for storage/pulls
    aiInsights?: ImageAIInsight[];
    metadata: {
        creator: string;
        source: string; // e.g., "CI/CD Pipeline", "Local Build"
        scanStatus: 'NOT_SCANNED' | 'SCANNING' | 'COMPLETED' | 'FAILED';
        scanLastRun?: string; // ISO date string
        scanResultsSummary?: string;
    };
    storageDetails: {
        location: string; // e.g., "us-east-1", "eu-west-2", "on-prem"
        compressionRatio: string; // e.g., "1.5x"
        storageClass: 'standard' | 'cold' | 'archive';
    };
    networkAccess: {
        exposedPorts: number[];
        registryPullAccess: string[]; // e.g., "public", "private", "vpc-only"
        repoExternalAccess?: string; // e.g., "Read-only for org"
    };
    securityContext?: {
        runAsUser: string; // e.g., "root", "1000"
        capabilities: string[]; // e.g., "NET_RAW", "SYS_ADMIN"
        seccompProfile?: string;
    };
    dependencyGraph?: {
        packages: { name: string; version: string; license: string; vulnerabilities: string[]; }[];
        osDependencies: { name: string; version: string; }[];
    };
}

/**
 * Represents a detected vulnerability in a container image.
 * @interface ImageVulnerability
 */
export interface ImageVulnerability {
    id: string;
    cve: string;
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
    packageName: string;
    version: string;
    fixedVersion: string;
    description: string;
    links: string[];
    exploitabilityScore: number; // 0-10, higher means easier to exploit
    cvssScore: string; // e.g., "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:X/RL:X/RC:X"
    attackVector: 'NETWORK' | 'ADJACENT_NETWORK' | 'LOCAL' | 'PHYSICAL';
    references: string[]; // URLs to external resources
    exploitCodeMaturity: 'NOT_DEFINED' | 'UNPROVEN' | 'PROOF_OF_CONCEPT' | 'FUNCTIONAL' | 'HIGH';
    discoveredDate: string; // ISO date string
    status: 'open' | 'fixed' | 'ignored' | 'deferred';
    patchAvailable: boolean;
    remediationGuidance: string;
    identifiedLayerId?: string; // Which layer introduced this vuln
}

/**
 * Represents a layer in a Docker image.
 * @interface ImageLayer
 */
export interface ImageLayer {
    id: string; // Layer digest
    size: string;
    compressedSize: string;
    command: string; // The Dockerfile command that created this layer
    digest: string;
    created: string; // ISO date string
    emptyLayer: boolean;
    packagesInstalled: { name: string; version: string; }[];
    filesAdded: { path: string; size: string; permissions: string; }[];
    envVariables: { [key: string]: string };
    portsExposed: number[];
    diffId: string; // Content addressable ID for the layer filesystem changes
}

/**
 * Represents a target where an image is deployed.
 * @interface ImageDeploymentTarget
 */
export interface ImageDeploymentTarget {
    id: string;
    environment: string; // e.g., "production", "staging"
    cluster: string; // e.g., "k8s-prod-us-east-1"
    namespace: string;
    service: string;
    currentVersion: string; // Tag or digest deployed
    status: 'healthy' | 'unhealthy' | 'deploying' | 'pending' | 'rolled_back';
    lastUpdated: string; // ISO date string
    healthChecks: DeploymentHealthCheck[];
    associatedResources: {
        type: 'Pod' | 'Deployment' | 'ReplicaSet';
        name: string;
        status: string;
    }[];
    rollbackHistory: {
        timestamp: string;
        previousVersion: string;
        reason: string;
        triggeredBy: string;
    }[];
    trafficSplitPercentage: number; // e.g., for canary deployments
}

/**
 * Represents a health check for a deployed image.
 * @interface DeploymentHealthCheck
 */
export interface DeploymentHealthCheck {
    id: string;
    type: 'liveness' | 'readiness' | 'startup';
    status: 'pass' | 'fail' | 'unknown';
    timestamp: string; // ISO date string
    message?: string;
    lastProbeTime: string; // ISO date string
    failureCount: number;
}

/**
 * Represents a build pipeline definition.
 * @interface BuildPipeline
 */
export interface BuildPipeline {
    id: string;
    name: string;
    description: string;
    repository: string; // Git repository URL
    branch: string;
    dockerfilePath: string; // Path to Dockerfile in repo
    contextPath: string; // Build context path
    buildArguments: { [key: string]: string };
    envVariables: { [key: string]: string };
    targetImageName: string;
    tags: string[]; // Tags to apply to built image
    status: 'active' | 'inactive' | 'archived';
    lastRunId?: string;
    lastRunStatus?: 'SUCCESS' | 'FAILED' | 'RUNNING' | 'PENDING' | 'CANCELLED';
    lastRunStartTime?: string;
    lastRunEndTime?: string;
    createdAt: string; // ISO date string
    updatedAt: string; // ISO date string
    webhooksEnabled: boolean;
    cachingStrategy: 'LAYER' | 'NOCACHE' | 'CUSTOM';
    artifactStorageLocation: string; // e.g., "s3://my-bucket/artifacts"
    notificationEmails: string[];
    buildStages: { name: string; commands: string[]; baseImage?: string; }[];
    securityScanningAfterBuild: boolean;
    automaticDeploymentOnSuccess: boolean;
}

/**
 * Represents a single run of a build pipeline.
 * @interface BuildRun
 */
export interface BuildRun {
    id: string;
    pipelineId: string;
    status: 'SUCCESS' | 'FAILED' | 'RUNNING' | 'PENDING' | 'CANCELLED';
    triggeredBy: string; // User ID or "webhook"
    startTime: string; // ISO date string
    endTime?: string; // ISO date string
    durationSeconds?: number;
    logOutput: string; // Large string of build logs
    logUrl?: string; // Link to external log viewer
    commitHash: string;
    commitMessage: string;
    builtImageDigest?: string;
    builtImageTags: string[];
    errorMessage?: string;
    artifacts: { name: string; size: string; url: string; }[];
    buildArgsUsed: { [key: string]: string };
    envVarsUsed: { [key: string]: string };
    cpuUsagePercent: number; // Simulated
    memoryUsageMB: number; // Simulated
    scanResultSummary?: {
        status: 'COMPLETED' | 'FAILED' | 'SKIPPED';
        vulnerabilitiesFound: number;
        criticalCount: number;
    };
}

/**
 * Represents a webhook configuration for the registry.
 * @interface RegistryWebhook
 */
export interface RegistryWebhook {
    id: string;
    name: string;
    url: string;
    events: ('push' | 'pull' | 'scan_completed' | 'build_completed' | 'tag_created' | 'tag_deleted')[];
    secret?: string; // Hashed secret
    headers: { [key: string]: string }; // Custom headers
    retryPolicy: {
        maxAttempts: number;
        intervalSeconds: number;
        backoffFactor: number;
    };
    eventFilters: {
        repositoryRegex?: string;
        tagRegex?: string;
        minSeverity?: ImageVulnerability['severity'];
    };
    status: 'active' | 'inactive' | 'failed';
    createdAt: string;
    lastTriggered?: string;
    lastStatus?: 'SUCCESS' | 'FAILED';
    lastResponseCode?: number;
    errorCount: number;
}

/**
 * Represents a retention policy for images.
 * @interface RetentionPolicy
 */
export interface RetentionPolicy {
    id: string;
    name: string;
    description: string;
    priority: number; // Lower number means higher priority
    repositoryFilter: string; // Regex or exact match
    tagFilters: {
        keepTagsMatching?: string; // Regex
        keepTagsNotMatching?: string; // Regex
    };
    rules: {
        keepLastNImages?: number;
        deleteImagesOlderThanDays?: number;
        keepIfDeployed?: boolean; // Don't delete if still deployed
        keepIfCriticalVulnerabilities?: boolean; // Don't delete if critical vulns exist
    }[];
    schedule: string; // e.g., "daily", "weekly", "CRON_EXPRESSION"
    status: 'active' | 'inactive';
    dryRunMode: boolean; // If true, only simulate deletion
    lastRunResult?: string; // Log of what was deleted
    lastRunTimestamp?: string;
    createdAt: string;
    updatedAt: string;
    createdBy: string;
    exemptRepositories: string[]; // List of repos explicitly excluded
    notifyOnDeletion: string[]; // Email addresses to notify
}

/**
 * Represents an audit log entry.
 * @interface AuditLogEntry
 */
export interface AuditLogEntry {
    id: string;
    timestamp: string; // ISO date string
    user: string;
    action: string; // e.g., "PUSH_IMAGE", "DELETE_TAG", "UPDATE_POLICY"
    resourceType: 'image' | 'repository' | 'policy' | 'webhook' | 'build_pipeline' | 'user' | 'role';
    resourceId: string;
    details: {
        ipAddress: string;
        userAgent?: string;
        repository?: string;
        tag?: string;
        oldValue?: any;
        newValue?: any;
        reason?: string;
        success: boolean;
        errorMessage?: string;
    }; // Arbitrary details
    severity: 'INFO' | 'WARNING' | 'CRITICAL';
    location: string; // e.g., "us-east-1"
}

/**
 * Represents a user or role in the system.
 * @interface UserRole
 */
export interface UserRole {
    id: string;
    name: string;
    type: 'user' | 'role';
    description?: string;
    permissions: {
        scope: 'global' | 'repository' | 'image';
        resource: string; // e.g., "myorg/repo-backend" or "*" for global
        actions: string[]; // e.g., "read", "write", "delete", "pull", "push", "manage_policy"
    }[];
    assignedUsers?: string[]; // For roles, list of user IDs
    email?: string; // For users
    mfaEnabled: boolean;
    lastLogin?: string; // ISO date string
    status: 'active' | 'suspended';
    createdAt: string;
    updatedAt: string;
}

/**
 * Represents an AI insight about an image.
 * @interface ImageAIInsight
 */
export interface ImageAIInsight {
    id: string;
    type: 'OPTIMIZATION_SUGGESTION' | 'SECURITY_RECOMMENDATION' | 'COST_ANALYSIS' | 'COMPLIANCE_CHECK' | 'CONTENT_SUMMARY' | 'PERFORMANCE_TIP';
    summary: string;
    details: string;
    severity: 'INFO' | 'WARNING' | 'CRITICAL';
    timestamp: string;
    actionableItems?: {
        description: string;
        recommendationCode?: string; // e.g., optimized Dockerfile snippet
        jiraLink?: string;
        status: 'OPEN' | 'IN_PROGRESS' | 'COMPLETED' | 'DISMISSED';
    }[];
    confidenceScore?: number; // 0-1
    modelUsed: string; // e.g., "gemini-pro-1.5"
    tags: string[]; // e.g., "Dockerfile", "CVE", "Cost"
    costSavingsEstimate?: number; // USD/month
    relatedVulnerabilityIds?: string[];
}

/**
 * Represents a global notification.
 * @interface SystemNotification
 */
export interface SystemNotification {
    id: string;
    type: 'alert' | 'info' | 'warning' | 'success';
    message: string;
    timestamp: string;
    read: boolean;
    priority: 'HIGH' | 'MEDIUM' | 'LOW';
    source: 'Registry Scanner' | 'Build System' | 'User Activity' | 'AI Insights';
    actions?: { label: string; action: string; payload?: any; }[];
    expiryDate?: string; // ISO date string
}

/**
 * Represents aggregated metrics for the registry.
 * @interface RegistryMetrics
 */
export interface RegistryMetrics {
    totalImages: number;
    totalRepositories: number;
    totalStorageGB: number;
    pullsLast24Hours: number;
    pushesLast24Hours: number;
    criticalVulnerabilitiesCount: number;
    highVulnerabilitiesCount: number;
    averageImageSizeMB: number;
    storageUsageBreakdown: {
        repository: string;
        sizeGB: number;
        imageCount: number;
    }[];
    topRepositoriesByPulls: { repository: string; pulls: number }[];
    storageUsageHistoryGB: { timestamp: string; value: number }[]; // For charts (last 30 days)
    pullRateHistoryHourly: { timestamp: string; value: number }[]; // For charts (last 24 hours)
    vulnerabilitySeverityBreakdown: {
        CRITICAL: number; HIGH: number; MEDIUM: number; LOW: number; INFO: number;
    };
    buildSuccessRate: number; // percentage
    deploymentHealthSummary: {
        healthy: number; unhealthy: number; deploying: number;
    };
    geoDistributionPulls: { region: string; count: number; }[];
}


// ====================================================================================================================
// --- Mock Data Generation (To simulate a real backend) ---
// ====================================================================================================================

const generateId = () => Math.random().toString(36).substring(2, 15);
const getRandomDate = (daysAgoMax: number = 30) => new Date(Date.now() - Math.random() * daysAgoMax * 24 * 60 * 60 * 1000).toISOString();
const getRandomSeverity = (): ImageVulnerability['severity'] => {
    const severities = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];
    return severities[Math.floor(Math.random() * severities.length)];
};
const getRandomImageStatus = (): ContainerImage['status'] => {
    const statuses = ['active', 'deprecated', 'archived', 'pending_scan'];
    return statuses[Math.floor(Math.random() * statuses.length)];
};
const getRandomDeploymentStatus = (): ImageDeploymentTarget['status'] => {
    const statuses = ['healthy', 'unhealthy', 'deploying', 'pending', 'rolled_back'];
    return statuses[Math.floor(Math.random() * statuses.length)];
};
const getRandomBuildStatus = (): BuildRun['status'] => {
    const statuses = ['SUCCESS', 'FAILED', 'RUNNING', 'PENDING', 'CANCELLED'];
    return statuses[Math.floor(Math.random() * statuses.length)];
};
const generateRandomText = (wordCount: number): string => {
    const words = ["lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit", "sed", "do", "eiusmod", "tempor", "incididunt", "ut", "labore", "et", "dolore", "magna", "aliqua"];
    return Array.from({ length: wordCount }, () => words[Math.floor(Math.random() * words.length)]).join(' ');
};

const generateVulnerability = (layerId?: string): ImageVulnerability => ({
    id: generateId(),
    cve: `CVE-2023-${Math.floor(1000 + Math.random() * 9000)}`,
    severity: getRandomSeverity(),
    packageName: `lib-${Math.floor(Math.random() * 100)}`,
    version: `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}`,
    fixedVersion: Math.random() > 0.3 ? `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10) + 1}.${Math.floor(Math.random() * 10)}` : '',
    description: `A ${getRandomSeverity().toLowerCase()} vulnerability found in ${`lib-${Math.floor(Math.random() * 100)}`} affecting versions prior to ${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10) + 1}. ${generateRandomText(20)}`,
    links: ['https://cve.mitre.org/', 'https://nvd.nist.gov/'],
    exploitabilityScore: parseFloat((Math.random() * 10).toFixed(1)),
    cvssScore: `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:${Math.random() > 0.5 ? 'F' : 'P'}/RL:X/RC:X`,
    attackVector: Math.random() > 0.7 ? 'NETWORK' : 'LOCAL',
    references: [`https://example.com/vuln-${generateId().substring(0,5)}`],
    exploitCodeMaturity: Math.random() > 0.6 ? 'FUNCTIONAL' : 'PROOF_OF_CONCEPT',
    discoveredDate: getRandomDate(90),
    status: Math.random() > 0.8 ? 'fixed' : (Math.random() > 0.7 ? 'ignored' : 'open'),
    patchAvailable: Math.random() > 0.5,
    remediationGuidance: `Upgrade ${`lib-${Math.floor(Math.random() * 100)}`} to version ${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10) + 1}.${Math.floor(Math.random() * 10)} or apply official patch.`,
    identifiedLayerId: layerId,
});

const generateLayer = (): ImageLayer => {
    const layerId = `sha256:${generateId()}${generateId()}${generateId()}`;
    return {
        id: layerId,
        size: `${Math.floor(1 + Math.random() * 500)}MB`,
        command: `CMD [\"/bin/sh\", \"-c\", \"${generateRandomText(5)}\"]`,
        digest: `sha256:${generateId()}${generateId()}`,
        created: getRandomDate(60),
        compressedSize: `${Math.floor(1 + Math.random() * 200)}MB`,
        emptyLayer: Math.random() < 0.1,
        packagesInstalled: Array.from({ length: Math.floor(Math.random() * 5) }, (_, i) => ({
            name: `pkg-${i}-${generateId().substring(0,3)}`,
            version: `${Math.floor(Math.random() * 3)}.${Math.floor(Math.random() * 10)}`,
        })),
        filesAdded: Array.from({ length: Math.floor(Math.random() * 3) }, (_, i) => ({
            path: `/app/file_${i}.txt`,
            size: `${Math.floor(Math.random() * 10)}KB`,
            permissions: 'rw-r--r--',
        })),
        envVariables: Math.random() > 0.5 ? { PATH: '/usr/local/sbin:/usr/local/bin', LANG: 'C.UTF-8' } : {},
        portsExposed: Math.random() > 0.7 ? [8080, 8443] : [],
        diffId: `sha256:${generateId()}${generateId()}${generateId()}${generateId()}`,
    };
};

const generateDeploymentTarget = (imageRepo: string, imageTag: string): ImageDeploymentTarget => ({
    id: generateId(),
    environment: Math.random() > 0.7 ? 'production' : 'staging',
    cluster: `k8s-${Math.random() > 0.5 ? 'prod' : 'dev'}-${Math.random() > 0.5 ? 'us-east-1' : 'eu-west-1'}`,
    namespace: Math.random() > 0.5 ? 'default' : `app-ns-${generateId().substring(0,3)}`,
    service: `${imageRepo.split('/').pop()}-service-${generateId().substring(0,4)}`,
    currentVersion: imageTag,
    status: getRandomDeploymentStatus(),
    lastUpdated: getRandomDate(7),
    healthChecks: [
        { id: generateId(), type: 'liveness', status: Math.random() > 0.1 ? 'pass' : 'fail', timestamp: getRandomDate(1), lastProbeTime: getRandomDate(1), failureCount: Math.floor(Math.random() * 3) },
        { id: generateId(), type: 'readiness', status: Math.random() > 0.1 ? 'pass' : 'fail', timestamp: getRandomDate(1), lastProbeTime: getRandomDate(1), failureCount: Math.floor(Math.random() * 2) },
    ],
    associatedResources: [
        { type: 'Deployment', name: `${imageRepo.split('/').pop()}-deployment`, status: 'Running' },
        { type: 'Pod', name: `${imageRepo.split('/').pop()}-pod-${generateId().substring(0,5)}`, status: 'Running' },
    ],
    rollbackHistory: Math.random() > 0.6 ? [{
        timestamp: getRandomDate(14),
        previousVersion: `${imageTag.split('.').slice(0, -1).join('.')}.${parseInt(imageTag.split('.').pop() || '0') - 1}`,
        reason: generateRandomText(5),
        triggeredBy: `user-${Math.floor(Math.random() * 5)}`,
    }] : [],
    trafficSplitPercentage: Math.random() > 0.8 ? (Math.random() > 0.5 ? 50 : 10) : 100,
});

const generateImage = (repo: string, tag: string): ContainerImage => {
    const numLayers = Math.floor(Math.random() * 15) + 5;
    const layers = Array.from({ length: numLayers }, generateLayer);

    const numVulnerabilities = Math.floor(Math.random() * 10);
    const vulnerabilities = Array.from({ length: numVulnerabilities }, () => generateVulnerability(layers[Math.floor(Math.random() * layers.length)]?.id));

    const numDeployments = Math.floor(Math.random() * 3);
    const deploymentTargets = Array.from({ length: numDeployments }, () => generateDeploymentTarget(repo, tag));

    const totalSizeMB = Math.floor(100 + Math.random() * 1500);
    const vulnerabilityScore = Math.floor(Math.random() * 100);
    const scanStatus = Math.random() > 0.2 ? 'COMPLETED' : (Math.random() > 0.5 ? 'SCANNING' : 'NOT_SCANNED');

    return {
        id: generateId(),
        repository: repo,
        tag: tag,
        size: `${totalSizeMB}MB`,
        lastPush: getRandomDate(60),
        digest: `sha256:${generateId()}${generateId()}${generateId()}${generateId()}`,
        status: getRandomImageStatus(),
        architecture: Math.random() > 0.8 ? 'arm64' : 'amd64',
        os: 'linux',
        vulnerabilityScore: vulnerabilityScore,
        vulnerabilities: vulnerabilities,
        layers: layers,
        manifest: btoa(JSON.stringify({ config: { image: repo, tag: tag, os: 'linux', arch: 'amd64', exposedPorts: [80, 443] }, layers: layers.map(l => l.digest) }, null, 2)),
        labels: {
            'org.label-schema.schema-version': '1.0',
            'org.label-schema.vcs-ref': generateId().substring(0, 7),
            'org.label-schema.build-date': getRandomDate(90),
            'com.example.project': repo.split('/')[1],
            'com.example.team': Math.random() > 0.5 ? 'backend' : 'frontend',
        },
        baseImage: Math.random() > 0.5 ? 'alpine:3.18' : 'ubuntu:22.04',
        pullCountLast30Days: Math.floor(Math.random() * 5000),
        pullCountTotal: Math.floor(5000 + Math.random() * 20000),
        lastPulled: getRandomDate(30),
        buildId: Math.random() > 0.5 ? generateId() : undefined,
        deploymentTargets: deploymentTargets,
        retentionPolicyApplied: Math.random() > 0.7 ? 'prod-cleanup-policy-1' : undefined,
        costEstimateUSD: parseFloat((Math.random() * 0.5 + 0.1).toFixed(2)),
        aiInsights: [], // Will be populated later
        metadata: {
            creator: `user-${Math.floor(Math.random() * 5)}`,
            source: Math.random() > 0.6 ? 'CI/CD Pipeline' : 'Local Build',
            scanStatus: scanStatus,
            scanLastRun: scanStatus === 'COMPLETED' ? getRandomDate(7) : undefined,
            scanResultsSummary: scanStatus === 'COMPLETED' ? `${vulnerabilities.filter(v => v.status === 'open' && v.severity === 'CRITICAL').length} critical, ${vulnerabilities.filter(v => v.status === 'open' && v.severity === 'HIGH').length} high vulnerabilities.` : undefined,
        },
        storageDetails: {
            location: Math.random() > 0.5 ? 'us-east-1' : 'eu-west-1',
            compressionRatio: `${(1 + Math.random() * 0.5).toFixed(1)}x`,
            storageClass: Math.random() > 0.8 ? 'cold' : 'standard',
        },
        networkAccess: {
            exposedPorts: Math.random() > 0.6 ? [80, 443] : [8080],
            registryPullAccess: Math.random() > 0.5 ? ['private', 'vpc-only'] : ['public'],
            repoExternalAccess: Math.random() > 0.7 ? 'Read-only for org' : undefined,
        },
        securityContext: {
            runAsUser: Math.random() > 0.7 ? '1000' : 'root',
            capabilities: Math.random() > 0.5 ? ['NET_BIND_SERVICE'] : [],
            seccompProfile: Math.random() > 0.5 ? 'default' : 'unconfined',
        },
        dependencyGraph: {
            packages: Array.from({ length: Math.floor(Math.random() * 10) + 5 }, (_, i) => ({
                name: `dep-pkg-${i}`, version: `${Math.floor(Math.random() * 3)}.${Math.floor(Math.random() * 5)}`, license: Math.random() > 0.7 ? 'MIT' : 'GPLv3', vulnerabilities: Math.random() > 0.6 ? [`CVE-${generateId().substring(0,4)}`] : []
            })),
            osDependencies: Array.from({ length: Math.floor(Math.random() * 5) + 2 }, (_, i) => ({
                name: `os-dep-${i}`, version: `${Math.floor(Math.random() * 2)}.${Math.floor(Math.random() * 5)}`
            })),
        },
    };
};

const generateBuildPipeline = (index: number): BuildPipeline => ({
    id: generateId(),
    name: `frontend-app-ci-${index}`,
    description: `CI/CD pipeline for frontend application number ${index}. Builds and pushes to registry. ${generateRandomText(15)}`,
    repository: `https://github.com/myorg/frontend-app-${index}.git`,
    branch: 'main',
    dockerfilePath: 'Dockerfile',
    contextPath: './',
    buildArguments: { NODE_ENV: 'production', BUILD_VER: `v1.0.${index}` },
    envVariables: { SECRET_KEY: 'encrypted_value', CI_JOB_ID: generateId().substring(0,8) },
    targetImageName: `myorg/frontend-app-${index}`,
    tags: ['latest', `v1.${index}.0`, `build-${generateId().substring(0,5)}`],
    status: Math.random() > 0.2 ? 'active' : 'inactive',
    lastRunId: generateId(),
    lastRunStatus: Math.random() > 0.3 ? 'SUCCESS' : 'FAILED',
    lastRunStartTime: getRandomDate(7),
    lastRunEndTime: getRandomDate(1),
    createdAt: getRandomDate(90),
    updatedAt: getRandomDate(7),
    webhooksEnabled: Math.random() > 0.5,
    cachingStrategy: Math.random() > 0.7 ? 'LAYER' : 'NOCACHE',
    artifactStorageLocation: `s3://build-artifacts/pipeline-${index}`,
    notificationEmails: Math.random() > 0.6 ? [`dev-team-${index}@example.com`] : [],
    buildStages: [
        { name: 'build-frontend', commands: ['npm install', 'npm run build'] },
        { name: 'build-docker-image', commands: ['docker build -t $TARGET_IMAGE .'] },
        { name: 'push-image', commands: ['docker push $TARGET_IMAGE'] }
    ],
    securityScanningAfterBuild: Math.random() > 0.6,
    automaticDeploymentOnSuccess: Math.random() > 0.7,
});

const generateBuildRun = (pipelineId: string): BuildRun => {
    const status = getRandomBuildStatus();
    const startTime = getRandomDate(7);
    const endTime = status !== 'RUNNING' ? getRandomDate(1) : undefined;
    const durationSeconds = endTime ? Math.floor((new Date(endTime).getTime() - new Date(startTime).getTime()) / 1000) : undefined;
    const builtImageDigest = status === 'SUCCESS' ? `sha256:${generateId()}${generateId()}` : undefined;
    const numVulns = Math.floor(Math.random() * 15);

    return {
        id: generateId(),
        pipelineId: pipelineId,
        status: status,
        triggeredBy: Math.random() > 0.7 ? 'webhook' : `user-${Math.floor(Math.random() * 5)}`,
        startTime: startTime,
        endTime: endTime,
        durationSeconds: durationSeconds,
        logOutput: `
Fetching repository...
Checking out branch main...
Building image myorg/frontend-app:latest
Step 1/8 : FROM node:18-alpine
 ---> e7b059728
Step 2/8 : WORKDIR /app
 ---> c1a2b3c4d
Step 3/8 : COPY package*.json ./
 ---> d5e6f7g8h
Step 4/8 : RUN npm install --production
 ---> i9j0k1l2m (cached)
Step 5/8 : COPY . .
 ---> m3n4o5p6q
Step 6/8 : RUN npm run build
 ---> q7r8s9t0u
Step 7/8 : EXPOSE 8080
 ---> u1v2w3x4y
Step 8/8 : CMD [\"npm\", \"start\"]
 ---> y5z6a7b8c
Successfully built ${builtImageDigest || 'xxxxx'}
Successfully tagged myorg/frontend-app:latest
Pushing image myorg/frontend-app:latest...
${status === 'SUCCESS' ? 'Push successful.' : (status === 'FAILED' ? 'ERROR: Failed to push image. Network timeout.' : '')}
`,
        logUrl: `https://ci.example.com/logs/${generateId()}`,
        commitHash: generateId().substring(0, 7),
        commitMessage: `Feat: ${generateRandomText(5)} for new feature.`,
        builtImageDigest: builtImageDigest,
        builtImageTags: ['latest', `v1.${Math.floor(Math.random() * 10)}.0`],
        errorMessage: status === 'FAILED' ? `Build failed due to: ${generateRandomText(10)}` : undefined,
        artifacts: Math.random() > 0.6 ? [{ name: 'bundle.zip', size: '10MB', url: `https://artifacts.example.com/${generateId()}/bundle.zip` }] : [],
        buildArgsUsed: { NODE_ENV: 'production' },
        envVarsUsed: { CI_JOB_ID: generateId().substring(0,8) },
        cpuUsagePercent: parseFloat((20 + Math.random() * 80).toFixed(1)),
        memoryUsageMB: Math.floor(100 + Math.random() * 2000),
        scanResultSummary: Math.random() > 0.4 ? {
            status: Math.random() > 0.1 ? 'COMPLETED' : 'FAILED',
            vulnerabilitiesFound: numVulns,
            criticalCount: Math.floor(Math.random() * Math.min(5, numVulns / 2)),
        } : undefined,
    };
};

const generateWebhook = (index: number): RegistryWebhook => ({
    id: generateId(),
    name: `webhook-notify-${index}`,
    url: `https://my-webhook-receiver.com/hook/${index}`,
    events: ['push', 'scan_completed', 'tag_created'],
    secret: '********',
    headers: Math.random() > 0.5 ? { 'X-Custom-Header': 'value', 'Authorization': 'Bearer token_placeholder' } : {},
    retryPolicy: {
        maxAttempts: 3,
        intervalSeconds: 10,
        backoffFactor: 2,
    },
    eventFilters: Math.random() > 0.5 ? { repositoryRegex: `myorg/service-${Math.floor(index/2)}.*`, minSeverity: 'HIGH' } : {},
    status: Math.random() > 0.2 ? 'active' : (Math.random() > 0.5 ? 'inactive' : 'failed'),
    createdAt: getRandomDate(120),
    lastTriggered: getRandomDate(10),
    lastStatus: Math.random() > 0.1 ? 'SUCCESS' : 'FAILED',
    lastResponseCode: Math.random() > 0.1 ? 200 : (Math.random() > 0.5 ? 500 : 401),
    errorCount: Math.floor(Math.random() * 5),
});

const generateRetentionPolicy = (index: number): RetentionPolicy => ({
    id: generateId(),
    name: `prod-cleanup-policy-${index}`,
    description: `Cleans up old images in production repositories for service ${index}. Ensures critical tags and deployed images are kept. ${generateRandomText(20)}`,
    priority: index,
    repositoryFilter: `myorg/service-${index}.*`,
    tagFilters: {
        keepTagsMatching: 'prod|release.*',
        keepTagsNotMatching: 'temp|dev.*',
    },
    rules: [
        { keepLastNImages: 5 },
        { deleteImagesOlderThanDays: 60, keepIfDeployed: true },
        { keepIfCriticalVulnerabilities: true }
    ],
    schedule: Math.random() > 0.5 ? 'daily' : 'weekly',
    status: Math.random() > 0.2 ? 'active' : 'inactive',
    dryRunMode: Math.random() > 0.8,
    lastRunResult: Math.random() > 0.5 ? `Simulated deletion of ${Math.floor(Math.random() * 10)} images from myorg/service-${index}/backend. Kept 2 images due to deployment.` : 'Policy ran, no images matched deletion criteria.',
    lastRunTimestamp: getRandomDate(7),
    createdAt: getRandomDate(180),
    updatedAt: getRandomDate(10),
    createdBy: `admin-${Math.floor(Math.random() * 3)}`,
    exemptRepositories: Math.random() > 0.7 ? [`myorg/service-${index}-critical`] : [],
    notifyOnDeletion: Math.random() > 0.6 ? [`devops-alerts@example.com`] : [],
});

const generateAuditLogEntry = (): AuditLogEntry => {
    const actionTypes = ['PUSH_IMAGE', 'DELETE_TAG', 'UPDATE_POLICY', 'TRIGGER_BUILD', 'LOGIN_SUCCESS', 'LOGIN_FAILED', 'CHANGE_PERMISSION'];
    const resourceTypes = ['image', 'repository', 'policy', 'webhook', 'build_pipeline', 'user', 'role'];
    const action = actionTypes[Math.floor(Math.random() * actionTypes.length)];
    const resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
    const success = Math.random() > 0.1;

    let details: AuditLogEntry['details'] = {
        ipAddress: `192.168.1.${Math.floor(Math.random() * 255)}`,
        userAgent: `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)`,
        success: success,
    };

    if (!success) {
        details.errorMessage = `Failed to ${action.toLowerCase().replace('_', ' ')}: ${generateRandomText(5)}`;
    }

    if (resourceType === 'image') {
        details.repository = `myorg/app-${generateId().substring(0,4)}`;
        details.tag = `v1.2.${Math.floor(Math.random() * 10)}`;
    } else if (resourceType === 'policy') {
        details.oldValue = { status: 'inactive' };
        details.newValue = { status: 'active' };
    }

    return {
        id: generateId(),
        timestamp: getRandomDate(30),
        user: `user-${Math.floor(Math.random() * 10)}`,
        action: action,
        resourceType: resourceType,
        resourceId: generateId().substring(0, 8),
        details: details,
        severity: success ? 'INFO' : 'CRITICAL',
        location: Math.random() > 0.5 ? 'us-east-1' : 'eu-west-1',
    };
};

const generateUserRole = (isRole: boolean): UserRole => ({
    id: generateId(),
    name: isRole ? `role-${Math.floor(Math.random() * 5)}` : `user-${Math.floor(Math.random() * 10)}`,
    type: isRole ? 'role' : 'user',
    description: `This ${isRole ? 'role' : 'user'} manages ${generateRandomText(5)} in the registry.`,
    permissions: [
        { scope: 'global', resource: '*', actions: ['read', 'pull'] },
        ...(isRole && Math.random() > 0.5 ? [{ scope: 'repository', resource: `myorg/repo-${Math.floor(Math.random() * 3)}`, actions: ['push', 'delete'] }] : []),
    ],
    assignedUsers: isRole ? Array.from({ length: Math.floor(Math.random() * 3) }, () => `user-${Math.floor(Math.random() * 10)}`) : undefined,
    email: isRole ? undefined : `user${Math.floor(Math.random() * 10)}@example.com`,
    mfaEnabled: Math.random() > 0.5,
    lastLogin: Math.random() > 0.2 ? getRandomDate(7) : undefined,
    status: Math.random() > 0.1 ? 'active' : 'suspended',
    createdAt: getRandomDate(365),
    updatedAt: getRandomDate(30),
});

const generateImageAIInsight = (image: ContainerImage): ImageAIInsight => {
    const types: ImageAIInsight['type'][] = ['OPTIMIZATION_SUGGESTION', 'SECURITY_RECOMMENDATION', 'COST_ANALYSIS', 'COMPLIANCE_CHECK', 'CONTENT_SUMMARY', 'PERFORMANCE_TIP'];
    const type = types[Math.floor(Math.random() * types.length)];
    let summary: string;
    let details: string;
    let severity: ImageAIInsight['severity'] = 'INFO';
    const actionableItems: ImageAIInsight['actionableItems'] = [];
    let recommendationCode: string | undefined;
    let costSavingsEstimate: number | undefined;

    switch (type) {
        case 'OPTIMIZATION_SUGGESTION':
            summary = 'Potential image size reduction identified.';
            details = `Detected unnecessary packages in base image '${image.baseImage}' and opportunities for multi-stage builds. Identified unused build arguments. Analyzing image layers, found redundant files in layer ${image.layers[0]?.id.substring(0,10)}.`;
            severity = 'WARNING';
            actionableItems.push(
                { description: 'Review Dockerfile for multi-stage build opportunities.', status: 'OPEN', jiraLink: 'https://jira.example.com/T123', recommendationCode: `FROM alpine:3.18 as builder\nWORKDIR /app\nCOPY . .\nRUN npm install\nFROM node:18-alpine\nCOPY --from=builder /app/build /app/build` },
                { description: 'Replace `apt install` with specific package versions.', status: 'OPEN' }
            );
            costSavingsEstimate = parseFloat((Math.random() * 5 + 1).toFixed(2)); // 1-6 USD
            break;
        case 'SECURITY_RECOMMENDATION':
            summary = 'Critical base image vulnerability detected.';
            details = `Your base image '${image.baseImage}' contains multiple critical CVEs. Upgrade to a newer secure version. Ensure rootless containers are used. Specifically, CVE-2023-XXXX in package 'openssl' found in layer ${image.layers[Math.floor(Math.random() * image.layers.length)]?.id.substring(0,10)}.`;
            severity = 'CRITICAL';
            actionableItems.push(
                { description: 'Upgrade base image to a secure version.', status: 'OPEN' },
                { description: 'Implement rootless container best practices.', status: 'OPEN' }
            );
            break;
        case 'COST_ANALYSIS':
            summary = 'Image pull costs are high for this repository.';
            details = `Repository ${image.repository} has ${image.pullCountLast30Days} pulls in last 30 days, with average size ${image.size}. Estimated storage cost: $${image.costEstimateUSD}. Consider geo-replication for pull cost optimization if users are global. High traffic observed from 'us-west-2' region.`;
            severity = 'INFO';
            actionableItems.push({ description: 'Consider geo-replication to regions with high pull traffic.', status: 'OPEN' }, { description: 'Review image usage patterns and deprecate unused tags.', status: 'OPEN' });
            costSavingsEstimate = parseFloat((Math.random() * 10 + 5).toFixed(2)); // 5-15 USD
            break;
        case 'COMPLIANCE_CHECK':
            summary = 'Potential license compliance issues in detected packages.';
            details = `Detected GPL-licensed libraries that may conflict with your product's licensing model. Review dependencies: \`lib-gpl-v3.0\`, \`tool-lgpl\`. Identified 'lib-gpl-v3.0' in layer ${image.layers[Math.floor(Math.random() * image.layers.length)]?.id.substring(0,10)}.`;
            severity = 'WARNING';
            actionableItems.push({ description: 'Review dependencies licenses and replace conflicting ones.', status: 'OPEN' }, { description: 'Consult legal team for compliance implications.', status: 'OPEN' });
            break;
        case 'CONTENT_SUMMARY':
            summary = 'AI-generated summary of image content and purpose.';
            details = `This image appears to be a Node.js application running on Alpine Linux (version ${image.baseImage.split(':')[1] || 'unknown'}). Detected \`npm\` for package management and a web server on port 3000. It contains standard development tools but no obvious sensitive files. The entrypoint is 'npm start'.`;
            severity = 'INFO';
            break;
        case 'PERFORMANCE_TIP':
            summary = 'Detected inefficient package installation pattern.';
            details = `Your Dockerfile might be causing unnecessary rebuilds of layers due to ` +
                      `installing packages (` + image.layers[Math.floor(Math.random() * image.layers.length)]?.command + `) before ` +
                      `copying application code. Consider moving application code copy to a later stage if dependencies are stable.`;
            severity = 'INFO';
            actionableItems.push(
                { description: 'Reorder Dockerfile commands to leverage build cache effectively.', status: 'OPEN', recommendationCode: `COPY package*.json ./\nRUN npm install\nCOPY . .` },
            );
            break;
    }

    return {
        id: generateId(),
        type,
        summary,
        details,
        severity,
        timestamp: getRandomDate(14),
        actionableItems: actionableItems.length > 0 ? actionableItems : undefined,
        confidenceScore: parseFloat((0.7 + Math.random() * 0.3).toFixed(2)),
        modelUsed: 'gemini-pro-1.5',
        tags: [type.split('_')[0], image.repository.split('/')[1]],
        costSavingsEstimate,
        relatedVulnerabilityIds: type === 'SECURITY_RECOMMENDATION' && image.vulnerabilities.length > 0
            ? [image.vulnerabilities[Math.floor(Math.random() * image.vulnerabilities.length)].id]
            : undefined,
    };
};

const generateMetrics = (): RegistryMetrics => {
    const totalImages = Math.floor(100 + Math.random() * 1000);
    const totalRepositories = Math.floor(10 + Math.random() * 100);
    const totalStorageGB = parseFloat((Math.random() * 2000).toFixed(2));
    const pullsLast24Hours = Math.floor(1000 + Math.random() * 20000);
    const pushesLast24Hours = Math.floor(50 + Math.random() * 1000);
    const criticalVulnerabilitiesCount = Math.floor(Math.random() * 30);
    const highVulnerabilitiesCount = Math.floor(Math.random() * 50);
    const averageImageSizeMB = parseFloat((50 + Math.random() * 700).toFixed(2));

    const storageUsageHistoryGB = Array.from({ length: 30 }, (_, i) => ({
        timestamp: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000).toISOString(),
        value: parseFloat((totalStorageGB * (0.8 + Math.random() * 0.2)).toFixed(2)),
    }));
    const pullRateHistoryHourly = Array.from({ length: 24 }, (_, i) => ({
        timestamp: new Date(Date.now() - (23 - i) * 60 * 60 * 1000).toISOString(),
        value: Math.floor(pullsLast24Hours / 24 * (0.5 + Math.random() * 1.5)),
    }));

    const vulnerabilitySeverityBreakdown = {
        CRITICAL: Math.floor(Math.random() * 30),
        HIGH: Math.floor(Math.random() * 50),
        MEDIUM: Math.floor(Math.random() * 100),
        LOW: Math.floor(Math.random() * 150),
        INFO: Math.floor(Math.random() * 200),
    };

    const deploymentHealthy = Math.floor(Math.random() * 50) + 10;
    const deploymentUnhealthy = Math.floor(Math.random() * 5);
    const deploymentDeploying = Math.floor(Math.random() * 8);

    return {
        totalImages,
        totalRepositories,
        totalStorageGB,
        pullsLast24Hours,
        pushesLast24Hours,
        criticalVulnerabilitiesCount,
        highVulnerabilitiesCount,
        averageImageSizeMB,
        storageUsageBreakdown: Array.from({ length: 5 }, (_, i) => ({
            repository: `myorg/repo-${i}`,
            sizeGB: parseFloat((Math.random() * totalStorageGB / 5).toFixed(2)),
            imageCount: Math.floor(Math.random() * totalImages / 5),
        })).sort((a, b) => b.sizeGB - a.sizeGB),
        topRepositoriesByPulls: Array.from({ length: 5 }, (_, i) => ({
            repository: `myorg/repo-${i}`,
            pulls: Math.floor(Math.random() * 5000),
        })).sort((a, b) => b.pulls - a.pulls),
        storageUsageHistoryGB,
        pullRateHistoryHourly,
        vulnerabilitySeverityBreakdown,
        buildSuccessRate: parseFloat((70 + Math.random() * 30).toFixed(2)),
        deploymentHealthSummary: {
            healthy: deploymentHealthy,
            unhealthy: deploymentUnhealthy,
            deploying: deploymentDeploying,
        },
        geoDistributionPulls: [
            { region: 'us-east-1', count: Math.floor(pullsLast24Hours * 0.4) },
            { region: 'eu-west-1', count: Math.floor(pullsLast24Hours * 0.3) },
            { region: 'ap-southeast-2', count: Math.floor(pullsLast24Hours * 0.2) },
            { region: 'us-west-2', count: Math.floor(pullsLast24Hours * 0.1) },
        ],
    };
};

const MOCK_DATA = {
    images: Array.from({ length: 150 }, (_, i) => generateImage(`myorg/app-service-${Math.floor(i / 15)}`, `v1.0.${i % 15}`)),
    buildPipelines: Array.from({ length: 20 }, (_, i) => generateBuildPipeline(i)),
    webhooks: Array.from({ length: 10 }, (_, i) => generateWebhook(i)),
    retentionPolicies: Array.from({ length: 10 }, (_, i) => generateRetentionPolicy(i)),
    auditLogs: Array.from({ length: 500 }, generateAuditLogEntry).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()),
    userRoles: Array.from({ length: 10 }, (_, i) => generateUserRole(true)).concat(Array.from({ length: 20 }, (_, i) => generateUserRole(false))),
    notifications: Array.from({ length: 20 }, (_, i) => ({
        id: generateId(),
        type: i % 4 === 0 ? 'alert' : (i % 4 === 1 ? 'warning' : (i % 4 === 2 ? 'info' : 'success')),
        message: i % 4 === 0 ? 'Critical vulnerability detected in `myorg/app-backend:latest`!' : (i % 4 === 1 ? 'Retention policy `prod-cleanup-policy-1` failed to run.' : (i % 4 === 2 ? 'New image `myorg/frontend-app:v2.0.0` pushed.' : 'Build pipeline `frontend-app-ci-1` completed successfully.')),
        timestamp: getRandomDate(14),
        read: i % 2 === 0,
        priority: Math.random() > 0.7 ? 'HIGH' : (Math.random() > 0.5 ? 'MEDIUM' : 'LOW'),
        source: ['Registry Scanner', 'Build System', 'User Activity', 'AI Insights'][Math.floor(Math.random() * 4)],
        actions: Math.random() > 0.6 ? [{ label: 'View Image', action: 'view_image', payload: { imageId: MOCK_DATA.images[0]?.id } }] : [],
        expiryDate: Math.random() > 0.8 ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() : undefined,
    })).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()),
    metrics: generateMetrics(),
};

// Populate build runs for pipelines and AI insights for images after initial generation
MOCK_DATA.buildPipelines.forEach(bp => {
    (bp as any).buildRuns = Array.from({ length: Math.floor(Math.random() * 10) + 3 }, () => generateBuildRun(bp.id));
});
MOCK_DATA.images.forEach(img => {
    (img as any).aiInsights = Array.from({ length: Math.floor(Math.random() * 5) }, () => generateImageAIInsight(img));
});

/**
 * Simulates an API call with a delay.
 * @template T
 * @param {T} data - The data to return.
 * @param {number} [delay=500] - The delay in milliseconds.
 * @returns {Promise<T>} A promise that resolves with the data after the delay.
 */
const simulateApiCall = <T,>(data: T, delay: number = 500): Promise<T> => {
    return new Promise(resolve => setTimeout(() => resolve(data), delay));
};


// ====================================================================================================================
// --- Utility Functions & Helper Components ---
// ====================================================================================================================

/**
 * Formats a date string into a human-readable format.
 * @param {string} dateString - The date string to format.
 * @returns {string} The formatted date string.
 */
export const formatDate = (dateString: string | undefined): string => {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return 'Invalid Date';
    return date.toLocaleString();
};

/**
 * Formats a duration in seconds into a human-readable string.
 * @param {number | undefined} seconds - The duration in seconds.
 * @returns {string} The formatted duration string.
 */
export const formatDuration = (seconds: number | undefined): string => {
    if (seconds === undefined || isNaN(seconds)) return 'N/A';
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
};

/**
 * A generic loading spinner component.
 * @returns {JSX.Element}
 */
export const LoadingSpinner: React.FC = () => (
    <div className="flex items-center justify-center p-4">
        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-cyan-500" />
        <span className="ml-2 text-gray-400">Loading...</span>
    </div>
);

/**
 * A simple modal component.
 * @param {object} props
 * @param {boolean} props.isOpen - Whether the modal is open.
 * @param {() => void} props.onClose - Function to call when modal is closed.
 * @param {React.ReactNode} props.children - Modal content.
 * @param {string} [props.title] - Modal title.
 * @param {string} [props.maxWidthClass='max-w-xl'] - Tailwind class for max-width.
 * @param {boolean} [props.disableOverlayClose=false] - If true, clicking overlay does not close modal.
 * @returns {JSX.Element | null}
 */
export const Modal: React.FC<{
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
    title?: string;
    maxWidthClass?: string;
    disableOverlayClose?: boolean;
}> = ({ isOpen, onClose, children, title, maxWidthClass = 'max-w-xl', disableOverlayClose = false }) => {
    if (!isOpen) return null;

    const handleOverlayClick = () => {
        if (!disableOverlayClose) {
            onClose();
        }
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-[100]" onClick={handleOverlayClick}>
            <div className={`bg-gray-800 rounded-lg shadow-2xl w-full ${maxWidthClass}`} onClick={e => e.stopPropagation()}>
                {title && (
                    <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                        <h3 className="text-lg font-semibold text-white">{title}</h3>
                        <button onClick={onClose} className="text-gray-400 hover:text-white">
                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    </div>
                )}
                <div className="p-6 max-h-[80vh] overflow-y-auto">
                    {children}
                </div>
            </div>
        </div>
    );
};

/**
 * A customizable button component.
 * @param {object} props
 * @param {string} props.children - Button text or content.
 * @param {() => void} props.onClick - Click handler.
 * @param {boolean} [props.disabled=false] - Whether the button is disabled.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @param {('primary'|'secondary'|'danger'|'outline')} [props.variant='primary'] - Button style variant.
 * @returns {JSX.Element}
 */
export const Button: React.FC<{
    children: React.ReactNode;
    onClick?: () => void;
    disabled?: boolean;
    className?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'outline';
}> = ({ children, onClick, disabled = false, className = '', variant = 'primary' }) => {
    let baseStyles = "px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 ";
    switch (variant) {
        case 'primary':
            baseStyles += "bg-cyan-600 hover:bg-cyan-700 text-white";
            break;
        case 'secondary':
            baseStyles += "bg-gray-700 hover:bg-gray-600 text-white";
            break;
        case 'danger':
            baseStyles += "bg-red-600 hover:bg-red-700 text-white";
            break;
        case 'outline':
            baseStyles += "border border-gray-600 text-gray-300 hover:bg-gray-700";
            break;
    }
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            className={`${baseStyles} ${disabled ? 'opacity-50 cursor-not-allowed' : ''} ${className}`}
        >
            {children}
        </button>
    );
};

/**
 * A basic text input component.
 * @param {object} props
 * @param {string} props.label - Input label.
 * @param {string} props.value - Input value.
 * @param {(e: React.ChangeEvent<HTMLInputElement>) => void} props.onChange - Change handler.
 * @param {string} [props.type='text'] - Input type.
 * @param {string} [props.placeholder] - Input placeholder.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @param {boolean} [props.readOnly=false] - Whether the input is read-only.
 * @param {string} [props.name] - Name attribute for the input.
 * @returns {JSX.Element}
 */
export const TextInput: React.FC<{
    label: string;
    value: string;
    onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
    type?: string;
    placeholder?: string;
    className?: string;
    readOnly?: boolean;
    name?: string;
}> = ({ label, value, onChange, type = 'text', placeholder, className = '', readOnly = false, name }) => (
    <div className="flex flex-col space-y-1">
        <label className="text-gray-300 text-sm">{label}</label>
        <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            readOnly={readOnly}
            name={name}
            className={`w-full bg-gray-900/50 p-2 rounded text-sm text-white border border-gray-700 focus:ring-cyan-500 focus:border-cyan-500 ${readOnly ? 'opacity-70' : ''} ${className}`}
        />
    </div>
);

/**
 * A basic textarea component.
 * @param {object} props
 * @param {string} props.label - Textarea label.
 * @param {string} props.value - Textarea value.
 * @param {(e: React.ChangeEvent<HTMLTextAreaElement>) => void} props.onChange - Change handler.
 * @param {string} [props.placeholder] - Textarea placeholder.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @param {boolean} [props.readOnly=false] - Whether the textarea is read-only.
 * @param {number} [props.rows=5] - Number of rows.
 * @param {string} [props.name] - Name attribute for the textarea.
 * @returns {JSX.Element}
 */
export const TextareaInput: React.FC<{
    label: string;
    value: string;
    onChange?: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
    placeholder?: string;
    className?: string;
    readOnly?: boolean;
    rows?: number;
    name?: string;
}> = ({ label, value, onChange, placeholder, className = '', readOnly = false, rows = 5, name }) => (
    <div className="flex flex-col space-y-1">
        <label className="text-gray-300 text-sm">{label}</label>
        <textarea
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            readOnly={readOnly}
            rows={rows}
            name={name}
            className={`w-full bg-gray-900/50 p-2 rounded font-mono text-sm text-white border border-gray-700 focus:ring-cyan-500 focus:border-cyan-500 ${readOnly ? 'opacity-70' : ''} ${className}`}
        />
    </div>
);

/**
 * A checkbox component.
 * @param {object} props
 * @param {string} props.label - Checkbox label.
 * @param {boolean} props.checked - Whether the checkbox is checked.
 * @param {(e: React.ChangeEvent<HTMLInputElement>) => void} props.onChange - Change handler.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @param {string} [props.value] - Value attribute for the checkbox.
 * @param {string} [props.name] - Name attribute for the checkbox.
 * @returns {JSX.Element}
 */
export const CheckboxInput: React.FC<{
    label: string;
    checked: boolean;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    className?: string;
    value?: string;
    name?: string;
}> = ({ label, checked, onChange, className = '', value, name }) => (
    <div className={`flex items-center space-x-2 ${className}`}>
        <input
            type="checkbox"
            checked={checked}
            onChange={onChange}
            value={value}
            name={name}
            className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded focus:ring-cyan-500"
        />
        <label className="text-gray-300 text-sm">{label}</label>
    </div>
);

/**
 * A select/dropdown component.
 * @param {object} props
 * @param {string} props.label - Select label.
 * @param {string} props.value - Selected value.
 * @param {(e: React.ChangeEvent<HTMLSelectElement>) => void} props.onChange - Change handler.
 * @param {{value: string; label: string;}[]} props.options - Array of options.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @param {string} [props.name] - Name attribute for the select.
 * @returns {JSX.Element}
 */
export const SelectInput: React.FC<{
    label: string;
    value: string;
    onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
    options: { value: string; label: string; }[];
    className?: string;
    name?: string;
}> = ({ label, value, onChange, options, className = '', name }) => (
    <div className="flex flex-col space-y-1">
        <label className="text-gray-300 text-sm">{label}</label>
        <select
            value={value}
            onChange={onChange}
            name={name}
            className={`w-full bg-gray-900/50 p-2 rounded text-sm text-white border border-gray-700 focus:ring-cyan-500 focus:border-cyan-500 ${className}`}
        >
            {options.map(option => (
                <option key={option.value} value={option.value}>{option.label}</option>
            ))}
        </select>
    </div>
);

/**
 * A Badge component for status or labels.
 * @param {object} props
 * @param {string} props.children - Badge content.
 * @param {('info'|'success'|'warning'|'danger'|'default')} [props.type='default'] - Badge color type.
 * @param {string} [props.className] - Additional Tailwind classes.
 * @returns {JSX.Element}
 */
export const Badge: React.FC<{ children: React.ReactNode; type?: 'info' | 'success' | 'warning' | 'danger' | 'default'; className?: string }> = ({ children, type = 'default', className = '' }) => {
    let colorClass = "bg-gray-600 text-gray-200";
    switch (type) {
        case 'info': colorClass = "bg-blue-600 text-blue-100"; break;
        case 'success': colorClass = "bg-green-600 text-green-100"; break;
        case 'warning': colorClass = "bg-yellow-600 text-yellow-100"; break;
        case 'danger': colorClass = "bg-red-600 text-red-100"; break;
    }
    return (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${colorClass} ${className}`}>
            {children}
        </span>
    );
};

/**
 * Component to display a simple icon.
 * (Placeholder for actual icon library usage to avoid large imports for this exercise).
 * @param {object} props
 * @param {string} props.iconName - Name of the icon (e.g., 'shield', 'rocket', 'plus').
 * @param {string} [props.tooltip] - Text for the tooltip.
 * @param {string} [props.className] - Additional classes for the icon.
 * @returns {JSX.Element}
 */
export const Icon: React.FC<{ iconName: string; tooltip?: string; className?: string }> = ({ iconName, tooltip, className }) => {
    const getIconSvg = (name: string) => {
        switch (name.toLowerCase()) {
            case 'shield': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M10 2.5a.5.5 0 01.5.5v4a.5.5 0 01-1 0V3a.5.5 0 01.5-.5zM5.5 8.5a.5.5 0 010-1h9a.5.5 0 010 1h-9zM15.5 10.5a.5.5 0 000-1h-11a.5.5 0 000 1h11zM10 12.5a.5.5 0 000-1h-5a.5.5 0 000 1h5zM4 14.5a.5.5 0 010-1h12a.5.5 0 010 1H4z" clipRule="evenodd"></path></svg>;
            case 'rocket': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.666 1.334a.667.667 0 00-1.332 0l-1.333 1.333a.667.667 0 00.943.943l.722-.722v2.716l-2.062 2.063a.667.667 0 00-.063.882l.854.854a.667.667 0 00.882-.063L11.5 6.444v2.716l2.063 2.063a.667.667 0 00.882-.063l.854-.854a.667.667 0 00-.063-.882L12.444 6.444V3.728l.722.722a.667.667 0 00.943-.943l-1.333-1.333zM7.333 12.333a.667.667 0 000 1.334h5.334a.667.667 0 000-1.334H7.333zM6.666 14.666a.667.667 0 000 1.334h6.668a.667.667 0 000-1.334H6.666zM6 17a.667.667 0 000 1.334h8a.667.667 0 000-1.334H6z"></path></svg>;
            case 'cogs': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M11.493 3.504a1 1 0 01-.194.275l-2 2a1 1 0 01-1.414-1.414l2-2a1 1 0 011.414 1.414zM16 10a6 6 0 11-12 0 6 6 0 0112 0zm-5 0a1 1 0 11-2 0 1 1 0 012 0zm-3 4a1 1 0 01-1-1v-2a1 1 0 012 0v2a1 1 0 01-1 1zm4 0a1 1 0 01-1-1v-2a1 1 0 012 0v2a1 1 0 01-1 1zm-2-6a1 1 0 011-1h2a1 1 0 010 2h-2a1 1 0 01-1-1z" clipRule="evenodd"></path></svg>;
            case 'sync': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M4 2a2 2 0 00-2 2v2.586a1 1 0 00.293.707l.5.5a1 1 0 001.414 0l.5-.5A1 1 0 005.707 6.586L6 6.293V4a1 1 0 011-1h10a1 1 0 011 1v10a1 1 0 01-1 1h-2.293l-.5.5a1 1 0 000 1.414l.5.5a1 1 0 00.707.293H18a2 2 0 002-2V4a2 2 0 00-2-2H4zm0 2h1a1 1 0 011 1v1.586l-.293.293a.5.5 0 01-.707 0L4 7.293V4zM2 14.5a2.5 2.5 0 012.5-2.5h11a.5.5 0 010 1h-11A1.5 1.5 0 003 14.5v1a.5.5 0 01-1 0v-1z" clipRule="evenodd"></path></svg>;
            case 'trash': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm1 4a1 1 0 100 2h4a1 1 0 100-2H8z" clipRule="evenodd"></path></svg>;
            case 'plus': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd"></path></svg>;
            case 'edit': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fillRule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clipRule="evenodd"></path></svg>;
            case 'eye': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z"></path><path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd"></path></svg>;
            case 'question': return <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5L6.67 11.01a1 1 0 101.732 1L9 10.428V14a1 1 0 102 0v-3.572l.598.604a.5.5 0 00.707 0 .5.5 0 000-.707L10.867 7.5A1 1 0 0010 7zM9 15a1 1 0 102 0 1 1 0 00-2 0z" clipRule="evenodd"></path></svg>;
            case 'docker': return <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 13h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6V4l3-3V1h4l-3 3v3l7-7H6

--- FILE: IncidentResponseView.tsx ---

import React, { useContext, useState, useEffect, useCallback, useReducer, useRef } from 'react';
import Card from '../../../Card';
import { DataContext } from '../../../../context/DataContext';
import { GoogleGenAI } from "@google/genai";
import type { Incident } from '../../../../types';
import { Line, Bar } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend } from 'chart.js';
import { EditorState, convertToRaw, convertFromRaw, ContentState } from 'draft-js';
import 'draft-js/dist/Draft.css';
import { Editor } from 'react-draft-wysiwyg';
import 'react-draft-wysiwyg/dist/react-draft-wysiwyg.css';
import { v4 as uuidv4 } from 'uuid';

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend);

export type IncidentStatus = 'ACTIVE' | 'INVESTIGATING' | 'MITIGATED' | 'RESOLVED' | 'CLOSED' | 'CANCELLED';
export type IncidentSeverity = 'SEV1' | 'SEV2' | 'SEV3' | 'SEV4' | 'SEV5';
export type IncidentSource = 'MONITORING_ALERT' | 'USER_REPORT' | 'API_ERROR' | 'SYSTEM_LOG' | 'MANUAL';

export interface DetailedIncident extends Incident {
    status: IncidentStatus;
    severity: IncidentSeverity;
    source: IncidentSource;
    description: string;
    impactDescription: string;
    rootCauseDescription: string;
    affectedServices: string[];
    affectedComponents: string[];
    detectionTime: string; // ISO string
    startTime: string; // ISO string
    mitigationTime: string | null; // ISO string
    resolutionTime: string | null; // ISO string
    ownerId: string | null;
    currentTeam: string | null;
    relatedAlertIds: string[];
    timelineEvents: IncidentTimelineEvent[];
    actionItems: IncidentActionItem[];
    postmortemDoc: PostmortemDocument | null;
    linkedPlaybookId: string | null;
    tags: string[];
    comments: IncidentComment[];
    createdAt: string; // From base Incident type, ensure it's here too
    updatedAt: string; // To track last update time
}

export interface IncidentTimelineEvent {
    id: string;
    timestamp: string; // ISO string
    eventType: 'STATUS_CHANGE' | 'COMMENT_ADDED' | 'OWNER_ASSIGNED' | 'SEVERITY_CHANGED' | 'ACTION_ITEM_ADDED' | 'MITIGATION_STEP' | 'RESOLUTION_STEP' | 'CUSTOM_EVENT' | 'PLAYBOOK_STEP_EXECUTION';
    description: string;
    details?: Record<string, any>;
    userId?: string;
}

export type ActionItemStatus = 'OPEN' | 'IN_PROGRESS' | 'DONE' | 'BLOCKED';

export interface IncidentActionItem {
    id: string;
    description: string;
    assignedTo: string; // User ID
    status: ActionItemStatus;
    dueDate: string | null; // ISO string
    createdAt: string; // ISO string
    updatedAt: string; // ISO string
}

export type PostmortemSectionType = 'SUMMARY' | 'IMPACT' | 'ROOT_CAUSE' | 'RESOLUTION' | 'ACTION_ITEMS' | 'LESSONS_LEARNED' | 'PREVENTION' | 'TIMELINE';

export interface PostmortemSection {
    id: string;
    title: string;
    content: string; // HTML or Markdown content, stored as JSON string from Draft.js raw
    type: PostmortemSectionType;
    generatedByAI: boolean;
}

export interface PostmortemDocument {
    id: string;
    incidentId: string;
    title: string;
    sections: PostmortemSection[];
    status: 'DRAFT' | 'REVIEW' | 'PUBLISHED';
    createdAt: string;
    updatedAt: string;
    reviewedBy?: string[]; // User IDs
    approvedBy?: string | null; // User ID
}

export interface ServiceHealthMetric {
    serviceName: string;
    status: 'OPERATIONAL' | 'DEGRADED' | 'OUTAGE';
    lastUpdated: string;
    incidentsLast24h: number;
    responseTimeMs: number;
    errorRate: number; // percentage
}

export interface UserProfile {
    id: string;
    name: string;
    email: string;
    role: 'ADMIN' | 'ENGINEER' | 'MANAGER' | 'VIEWER';
    onCall: boolean;
    slackId?: string;
}

export interface Playbook {
    id: string;
    name: string;
    description: string;
    steps: PlaybookStep[];
    tags: string[];
    createdAt: string;
    updatedAt: string;
}

export type PlaybookStepType = 'COMMAND' | 'MANUAL_TASK' | 'NOTIFICATION' | 'API_CALL' | 'CHECK_METRIC';
export type PlaybookStepStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'SKIPPED' | 'FAILED';

export interface PlaybookStep {
    id: string;
    description: string;
    type: PlaybookStepType;
    command?: string; // e.g., 'kubectl get pods'
    target?: string; // e.g., 'Kubernetes', 'Slack'
    expectedOutput?: string;
    status: PlaybookStepStatus;
    executionLog?: string;
    assignedTo?: string; // User ID
    manualConfirmationRequired?: boolean;
    metricToCheck?: {
        service: string;
        metricName: string; // e.g., 'responseTime', 'errorRate'
        operator: 'gt' | 'lt' | 'eq';
        value: number;
    }
}

export interface IncidentComment {
    id: string;
    incidentId: string;
    userId: string;
    userName: string;
    timestamp: string;
    content: string;
}

export interface MetricDataPoint {
    timestamp: string; // ISO string
    value: number;
}

export interface TimeSeriesMetric {
    name: string;
    unit: string;
    data: MetricDataPoint[];
}

const mockUsers: UserProfile[] = [
    { id: 'usr-1', name: 'Alice Smith', email: 'alice@example.com', role: 'ENGINEER', onCall: true, slackId: 'U01ABC' },
    { id: 'usr-2', name: 'Bob Johnson', email: 'bob@example.com', role: 'MANAGER', onCall: false, slackId: 'U01DEF' },
    { id: 'usr-3', name: 'Charlie Brown', email: 'charlie@example.com', role: 'ENGINEER', onCall: true, slackId: 'U01GHI' },
    { id: 'usr-4', name: 'Diana Prince', email: 'diana@example.com', role: 'ADMIN', onCall: false, slackId: 'U01JKL' },
    { id: 'usr-5', name: 'Eve Adams', email: 'eve@example.com', role: 'ENGINEER', onCall: false, slackId: 'U01MNO' },
    { id: 'usr-6', name: 'Frank White', email: 'frank@example.com', role: 'ENGINEER', onCall: false, slackId: 'U01PQR' },
    { id: 'usr-7', name: 'Grace Lee', email: 'grace@example.com', role: 'VIEWER', onCall: false, slackId: 'U01STU' },
    { id: 'usr-8', name: 'Henry King', email: 'henry@example.com', role: 'MANAGER', onCall: true, slackId: 'U01VWX' },
];

const mockServices: ServiceHealthMetric[] = [
    { serviceName: 'AuthService', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 50, errorRate: 0.01 },
    { serviceName: 'PaymentGateway', status: 'DEGRADED', lastUpdated: new Date().toISOString(), incidentsLast24h: 1, responseTimeMs: 350, errorRate: 0.5 },
    { serviceName: 'NotificationService', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 80, errorRate: 0.02 },
    { serviceName: 'DataAnalytics', status: 'OUTAGE', lastUpdated: new Date().toISOString(), incidentsLast24h: 1, responseTimeMs: 0, errorRate: 100 },
    { serviceName: 'UserManagement', status: 'OPERATIONAL', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 60, errorRate: 0.005 },
    { serviceName: 'ImageProcessing', status: 'DEGRADED', lastUpdated: new Date().toISOString(), incidentsLast24h: 0, responseTimeMs: 200, errorRate: 0.1 },
];

const generateMockMetrics = (name: string, unit: string, base: number, fluctuation: number, points: number = 60): TimeSeriesMetric => {
    const data: MetricDataPoint[] = [];
    let currentValue = base;
    for (let i = 0; i < points; i++) {
        const timestamp = new Date(Date.now() - (points - 1 - i) * 60 * 1000).toISOString(); // Last 60 minutes
        currentValue += (Math.random() - 0.5) * fluctuation;
        currentValue = Math.max(0, currentValue); // Ensure non-negative
        data.push({ timestamp, value: parseFloat(currentValue.toFixed(2)) });
    }
    return { name, unit, data };
};

const mockIncidentDetails: DetailedIncident[] = [
    {
        id: 'inc-1', title: 'Payment Gateway Latency Spike', severity: 'SEV2', status: 'INVESTIGATING',
        source: 'MONITORING_ALERT', description: 'Observed a significant increase in latency for the Payment Gateway service, affecting user transactions.',
        impactDescription: 'Users experiencing delays in payment processing, potential revenue loss.',
        rootCauseDescription: '', affectedServices: ['PaymentGateway'], affectedComponents: ['payment-api', 'transaction-db'],
        detectionTime: new Date(Date.now() - 3600 * 1000).toISOString(), startTime: new Date(Date.now() - 3700 * 1000).toISOString(),
        mitigationTime: null, resolutionTime: null, ownerId: 'usr-1', currentTeam: 'SRE-Payments', relatedAlertIds: ['alert-pg-latency-high-1', 'alert-pg-latency-high-2'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 3700 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Issue detected by Prometheus alert.', userId: 'system' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3600 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to ACTIVE.', details: { oldStatus: 'NEW', newStatus: 'ACTIVE' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3550 * 1000).toISOString(), eventType: 'OWNER_ASSIGNED', description: 'Assigned to Alice Smith.', details: { oldOwner: null, newOwner: 'usr-1' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3500 * 1000).toISOString(), eventType: 'COMMENT_ADDED', description: 'Initial investigation ongoing, checking recent deployments.', userId: 'usr-1' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 3000 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to INVESTIGATING.', details: { oldStatus: 'ACTIVE', newStatus: 'INVESTIGATING' }, userId: 'usr-1' },
        ],
        actionItems: [
            { id: uuidv4(), description: 'Review recent deployments in Payment Gateway service.', assignedTo: 'usr-1', status: 'IN_PROGRESS', dueDate: new Date(Date.now() + 2 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Check database connection pool for Payment Gateway.', assignedTo: 'usr-3', status: 'OPEN', dueDate: new Date(Date.now() + 3 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: null, linkedPlaybookId: 'pb-1', tags: ['payments', 'latency', 'production'], comments: [],
        createdAt: new Date(Date.now() - 3700 * 1000).toISOString(), updatedAt: new Date(Date.now() - 3000 * 1000).toISOString(),
    },
    {
        id: 'inc-2', title: 'Data Analytics Service Outage', severity: 'SEV1', status: 'ACTIVE',
        source: 'MONITORING_ALERT', description: 'The Data Analytics service is completely down, leading to reporting failures.',
        impactDescription: 'Critical business reporting unavailable, impacting decision-making.',
        rootCauseDescription: '', affectedServices: ['DataAnalytics'], affectedComponents: ['analytics-backend', 'data-pipeline'],
        detectionTime: new Date(Date.now() - 1200 * 1000).toISOString(), startTime: new Date(Date.now() - 1300 * 1000).toISOString(),
        mitigationTime: null, resolutionTime: null, ownerId: 'usr-3', currentTeam: 'SRE-Data', relatedAlertIds: ['alert-da-down'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 1300 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Paging triggered for Data Analytics team.', userId: 'system' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1250 * 1000).toISOString(), eventType: 'OWNER_ASSIGNED', description: 'Assigned to Charlie Brown.', details: { oldOwner: null, newOwner: 'usr-3' }, userId: 'usr-4' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1200 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Status changed to ACTIVE.', details: { oldStatus: 'NEW', newStatus: 'ACTIVE' }, userId: 'usr-3' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 1100 * 1000).toISOString(), eventType: 'COMMENT_ADDED', description: 'Restarted analytics-backend pods, observing logs.', userId: 'usr-3' },
        ],
        actionItems: [
             { id: uuidv4(), description: 'Escalate to Tier 2 support for database investigation.', assignedTo: 'usr-8', status: 'OPEN', dueDate: new Date(Date.now() + 1 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: null, linkedPlaybookId: 'pb-2', tags: ['data', 'outage', 'critical'], comments: [],
        createdAt: new Date(Date.now() - 1300 * 1000).toISOString(), updatedAt: new Date(Date.now() - 1100 * 1000).toISOString(),
    },
    {
        id: 'inc-3', title: 'Authentication Service Login Failures', severity: 'SEV3', status: 'MITIGATED',
        source: 'USER_REPORT', description: 'Users reporting intermittent login failures on authentication service.',
        impactDescription: 'Some users unable to log in, affecting user experience.',
        rootCauseDescription: 'Database connection pool exhaustion due to misconfigured max connections.',
        affectedServices: ['AuthService'], affectedComponents: ['auth-api', 'user-db'],
        detectionTime: new Date(Date.now() - 10 * 24 * 3600 * 1000).toISOString(), startTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(),
        mitigationTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 30 * 60 * 1000).toISOString(),
        resolutionTime: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 2 * 3600 * 1000).toISOString(),
        ownerId: 'usr-1', currentTeam: 'SRE-Auth', relatedAlertIds: ['alert-auth-login-fail'],
        timelineEvents: [
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(), eventType: 'CUSTOM_EVENT', description: 'Users report login failures.' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000).toISOString(), eventType: 'STATUS_CHANGE', description: 'Incident set to ACTIVE.' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 30 * 60 * 1000).toISOString(), eventType: 'MITIGATION_STEP', description: 'Increased DB connection pool size.' },
            { id: uuidv4(), timestamp: new Date(Date.now() - 10 * 24 * 3600 * 1000 + 2 * 3600 * 1000).toISOString(), eventType: 'RESOLUTION_STEP', description: 'Root cause identified and remediated.' },
        ],
        actionItems: [
            { id: uuidv4(), description: 'Update DB connection pool configuration in production.', assignedTo: 'usr-4', status: 'DONE', dueDate: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Add monitoring for DB connection pool utilization.', assignedTo: 'usr-2', status: 'DONE', dueDate: new Date(Date.now() - 8 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
            { id: uuidv4(), description: 'Review all service configurations for similar pitfalls.', assignedTo: 'usr-2', status: 'OPEN', dueDate: new Date(Date.now() + 7 * 24 * 3600 * 1000).toISOString(), createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        ],
        postmortemDoc: {
            id: 'pm-3', incidentId: 'inc-3', title: 'Postmortem for Auth Service Login Failures', status: 'PUBLISHED',
            createdAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(), updatedAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(),
            sections: [
                { id: uuidv4(), type: 'SUMMARY', title: 'Summary', content: JSON.stringify(convertToRaw(ContentState.createFromText('On YYYY-MM-DD, the Authentication Service experienced intermittent login failures for a duration of ~2 hours due to database connection pool exhaustion.'))), generatedByAI: false },
                { id: uuidv4(), type: 'IMPACT', title: 'Impact', content: JSON.stringify(convertToRaw(ContentState.createFromText('Approximately 15% of login attempts failed, resulting in degraded user experience and potential loss of active users during the incident window.'))), generatedByAI: false },
                { id: uuidv4(), type: 'ROOT_CAUSE', title: 'Root Cause', content: JSON.stringify(convertToRaw(ContentState.createFromText('The primary root cause was an incorrectly configured `max_connections` parameter in the database connection pool, which was exhausted under peak load. A recent deployment increased traffic without adjusting this setting.'))), generatedByAI: false },
                { id: uuidv4(), type: 'RESOLUTION', title: 'Resolution', content: JSON.stringify(convertToRaw(ContentState.createFromText('The incident was mitigated by increasing the `max_connections` parameter and restarting the AuthService instances. Full resolution involved a configuration update.'))), generatedByAI: false },
                { id: uuidv4(), type: 'ACTION_ITEMS', title: 'Action Items', content: JSON.stringify(convertToRaw(ContentState.createFromText('1. Update DB connection pool configuration (DONE). 2. Add monitoring for DB connection pool utilization (DONE). 3. Review all service configurations for similar pitfalls (OPEN).'))), generatedByAI: false },
            ],
            approvedBy: 'usr-2',
        },
        linkedPlaybookId: null, tags: ['auth', 'database', 'resolved'], comments: [],
        createdAt: new Date(Date.now() - 10 * 24 * 3600 * 1000 - 60 * 60 * 1000).toISOString(), updatedAt: new Date(Date.now() - 9 * 24 * 3600 * 1000).toISOString(),
    },
    ...Array.from({ length: 20 }).map((_, i) => {
        const id = `inc-${i + 4}`;
        const severity: IncidentSeverity = ['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'][Math.floor(Math.random() * 5)] as IncidentSeverity;
        const status: IncidentStatus = ['ACTIVE', 'INVESTIGATING', 'MITIGATED', 'RESOLVED', 'CLOSED'][Math.floor(Math.random() * 5)] as IncidentStatus;
        const services = ['AuthService', 'PaymentGateway', 'NotificationService', 'DataAnalytics', 'UserManagement', 'ImageProcessing'];
        const affectedService = services[Math.floor(Math.random() * services.length)];
        const title = `${affectedService} - Random Issue ${i + 1}`;
        const startTime = new Date(Date.now() - Math.random() * 30 * 24 * 3600 * 1000).toISOString();
        const detectionTime = new Date(new Date(startTime).getTime() + Math.random() * 60 * 1000).toISOString();
        const ownerId = mockUsers[Math.floor(Math.random() * mockUsers.length)].id;
        const hasPostmortem = Math.random() > 0.5;

        return {
            id, title, severity, status,
            source: 'MONITORING_ALERT', description: `Simulated incident for ${affectedService}. Details about performance degradation.`,
            impactDescription: `Minor impact on ${affectedService} users.`,
            rootCauseDescription: hasPostmortem ? 'Simulated root cause for testing purposes.' : '',
            affectedServices: [affectedService], affectedComponents: [],
            detectionTime, startTime,
            mitigationTime: status === 'MITIGATED' || status === 'RESOLVED' || status === 'CLOSED' ? new Date(new Date(detectionTime).getTime() + Math.random() * 30 * 60 * 1000).toISOString() : null,
            resolutionTime: status === 'RESOLVED' || status === 'CLOSED' ? new Date(new Date(detectionTime).getTime() + Math.random() * 120 * 60 * 1000).toISOString() : null,
            ownerId, currentTeam: 'SRE-General', relatedAlertIds: [], timelineEvents: [], actionItems: [],
            postmortemDoc: hasPostmortem ? {
                id: `pm-${id}`, incidentId: id, title: `Postmortem for ${id}`, status: Math.random() > 0.5 ? 'PUBLISHED' : 'DRAFT',
                createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), sections: [],
            } : null,
            linkedPlaybookId: Math.random() > 0.7 ? (Math.random() > 0.5 ? 'pb-1' : 'pb-2') : null, tags: [affectedService.toLowerCase(), 'simulated'], comments: [],
            createdAt: startTime, updatedAt: new Date().toISOString(),
        };
    })
];


const mockPlaybooks: Playbook[] = [
    {
        id: 'pb-1', name: 'Payment Gateway Latency Debug', description: 'Steps to debug and resolve payment gateway latency issues.',
        steps: [
            { id: uuidv4(), description: 'Check Payment Gateway service metrics for high response times.', type: 'CHECK_METRIC', metricToCheck: { service: 'PaymentGateway', metricName: 'responseTime', operator: 'gt', value: 200 }, status: 'PENDING', assignedTo: 'usr-1' },
            { id: uuidv4(), description: 'Review recent deployments to Payment Gateway service.', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-1' },
            { id: uuidv4(), description: 'Scale up Payment Gateway application instances.', type: 'COMMAND', command: 'kubectl scale deployment payment-gateway --replicas=5', target: 'Kubernetes', status: 'PENDING' },
            { id: uuidv4(), description: 'Notify #payment-alerts Slack channel of ongoing issue.', type: 'NOTIFICATION', target: 'Slack', status: 'PENDING' },
            { id: uuidv4(), description: 'Verify latency reduction via monitoring dashboards.', type: 'CHECK_METRIC', metricToCheck: { service: 'PaymentGateway', metricName: 'responseTime', operator: 'lt', value: 100 }, status: 'PENDING', assignedTo: 'usr-1' },
        ],
        tags: ['payments', 'playbook'], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
    },
    {
        id: 'pb-2', name: 'Data Analytics Service Restart', description: 'Procedure to restart and verify the Data Analytics service.',
        steps: [
            { id: uuidv4(), description: 'Confirm Data Analytics service is down via monitoring.', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-3', manualConfirmationRequired: true },
            { id: uuidv4(), description: 'Restart analytics-backend pods.', type: 'COMMAND', command: 'kubectl rollout restart deployment analytics-backend', target: 'Kubernetes', status: 'PENDING' },
            { id: uuidv4(), description: 'Verify service status and data processing via dashboards.', type: 'MANUAL_TASK', status: 'PENDING', assignedTo: 'usr-3' },
            { id: uuidv4(), description: 'Post update in #data-analytics Slack channel.', type: 'NOTIFICATION', target: 'Slack', status: 'PENDING' },
        ],
        tags: ['data', 'playbook'], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
    },
];

let incidentDataStore: DetailedIncident[] = [...mockIncidentDetails];

export const IncidentApiService = {
    fetchIncidents: async (filters?: { status?: IncidentStatus[], severity?: IncidentSeverity[], service?: string, search?: string }): Promise<DetailedIncident[]> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        let filtered = incidentDataStore;

        if (filters?.status && filters.status.length > 0) {
            filtered = filtered.filter(inc => filters.status!.includes(inc.status));
        }
        if (filters?.severity && filters.severity.length > 0) {
            filtered = filtered.filter(inc => filters.severity!.includes(inc.severity));
        }
        if (filters?.service) {
            filtered = filtered.filter(inc => inc.affectedServices.includes(filters.service!));
        }
        if (filters?.search) {
            const searchTerm = filters.search.toLowerCase();
            filtered = filtered.filter(inc =>
                inc.title.toLowerCase().includes(searchTerm) ||
                inc.description.toLowerCase().includes(searchTerm) ||
                inc.id.toLowerCase().includes(searchTerm) ||
                inc.affectedServices.some(s => s.toLowerCase().includes(searchTerm)) ||
                inc.tags.some(t => t.toLowerCase().includes(searchTerm))
            );
        }

        return JSON.parse(JSON.stringify(filtered));
    },

    fetchIncidentById: async (id: string): Promise<DetailedIncident | null> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        return JSON.parse(JSON.stringify(incidentDataStore.find(inc => inc.id === id) || null));
    },

    updateIncident: async (incident: DetailedIncident, userId: string = 'system'): Promise<DetailedIncident> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const index = incidentDataStore.findIndex(inc => inc.id === incident.id);
        if (index > -1) {
            const oldIncident = incidentDataStore[index];
            const updatedIncident = { ...oldIncident, ...incident, updatedAt: new Date().toISOString() };

            const newTimelineEvents: IncidentTimelineEvent[] = [];
            if (oldIncident.status !== updatedIncident.status) {
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'STATUS_CHANGE',
                    description: `Status changed from ${oldIncident.status} to ${updatedIncident.status}.`,
                    details: { oldStatus: oldIncident.status, newStatus: updatedIncident.status }, userId
                });
            }
            if (oldIncident.severity !== updatedIncident.severity) {
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'SEVERITY_CHANGED',
                    description: `Severity changed from ${oldIncident.severity} to ${updatedIncident.severity}.`,
                    details: { oldSeverity: oldIncident.severity, newSeverity: updatedIncident.severity }, userId
                });
            }
            if (oldIncident.ownerId !== updatedIncident.ownerId) {
                const oldOwnerName = mockUsers.find(u => u.id === oldIncident.ownerId)?.name || 'Unassigned';
                const newOwnerName = mockUsers.find(u => u.id === updatedIncident.ownerId)?.name || 'Unassigned';
                newTimelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'OWNER_ASSIGNED',
                    description: `Owner changed from ${oldOwnerName} to ${newOwnerName}.`,
                    details: { oldOwner: oldIncident.ownerId, newOwner: updatedIncident.ownerId }, userId
                });
            }
            // Add other field change tracking as needed

            updatedIncident.timelineEvents = [...updatedIncident.timelineEvents, ...newTimelineEvents];
            incidentDataStore[index] = updatedIncident;
            return JSON.parse(JSON.stringify(incidentDataStore[index]));
        }
        throw new Error('Incident not found');
    },

    createIncident: async (newIncidentData: Partial<DetailedIncident>, userId: string = 'system'): Promise<DetailedIncident> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const now = new Date().toISOString();
        const newIncident: DetailedIncident = {
            id: `inc-${uuidv4().substring(0, 8)}`,
            title: newIncidentData.title || 'New Incident',
            severity: newIncidentData.severity || 'SEV3',
            status: newIncidentData.status || 'ACTIVE',
            source: newIncidentData.source || 'MANUAL',
            description: newIncidentData.description || 'No description provided.',
            impactDescription: newIncidentData.impactDescription || '',
            rootCauseDescription: '',
            affectedServices: newIncidentData.affectedServices || [],
            affectedComponents: newIncidentData.affectedComponents || [],
            detectionTime: newIncidentData.detectionTime || now,
            startTime: newIncidentData.startTime || now,
            mitigationTime: null,
            resolutionTime: null,
            ownerId: newIncidentData.ownerId || null,
            currentTeam: newIncidentData.currentTeam || null,
            relatedAlertIds: newIncidentData.relatedAlertIds || [],
            timelineEvents: [
                { id: uuidv4(), timestamp: now, eventType: 'CUSTOM_EVENT', description: 'Incident created.', userId }
            ],
            actionItems: [],
            postmortemDoc: null,
            linkedPlaybookId: newIncidentData.linkedPlaybookId || null,
            tags: newIncidentData.tags || [],
            comments: [],
            createdAt: now,
            updatedAt: now,
        };
        incidentDataStore.push(newIncident);
        return JSON.parse(JSON.stringify(newIncident));
    },

    fetchUsers: async (): Promise<UserProfile[]> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockUsers));
    },

    fetchServiceHealth: async (): Promise<ServiceHealthMetric[]> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        return JSON.parse(JSON.stringify(mockServices));
    },

    fetchMetricData: async (metricName: string, serviceName?: string, durationMinutes: number = 60): Promise<TimeSeriesMetric> => {
        await new Promise(resolve => setTimeout(resolve, 150));
        let baseValue = 0;
        let fluctuation = 0;
        let unit = '';

        if (metricName === 'responseTime') {
            baseValue = serviceName === 'PaymentGateway' ? 300 : (serviceName === 'DataAnalytics' ? 0 : 80);
            fluctuation = serviceName === 'PaymentGateway' ? 100 : 20;
            unit = 'ms';
        } else if (metricName === 'errorRate') {
            baseValue = serviceName === 'PaymentGateway' ? 0.5 : (serviceName === 'DataAnalytics' ? 100 : 0.05);
            fluctuation = serviceName === 'PaymentGateway' ? 0.3 : 0.03;
            unit = '%';
        } else if (metricName === 'incidentCount') {
            baseValue = 1;
            fluctuation = 0.5;
            unit = 'incidents';
        } else {
            baseValue = 100;
            fluctuation = 10;
            unit = 'units';
        }
        return generateMockMetrics(metricName, unit, baseValue, fluctuation, durationMinutes);
    },

    addIncidentComment: async (incidentId: string, userId: string, userName: string, content: string): Promise<IncidentComment> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const now = new Date().toISOString();
        const newComment: IncidentComment = {
            id: uuidv4(),
            incidentId,
            userId,
            userName,
            timestamp: now,
            content,
        };
        incident.comments.push(newComment);
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'COMMENT_ADDED', description: `Comment added by ${userName}.`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(newComment));
    },

    addActionItem: async (incidentId: string, description: string, assignedTo: string, dueDate: string | null, userId: string = 'system'): Promise<IncidentActionItem> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const now = new Date().toISOString();
        const newActionItem: IncidentActionItem = {
            id: uuidv4(),
            description,
            assignedTo,
            status: 'OPEN',
            dueDate,
            createdAt: now,
            updatedAt: now,
        };
        incident.actionItems.push(newActionItem);
        const assigneeName = mockUsers.find(u => u.id === assignedTo)?.name || 'Unknown User';
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'ACTION_ITEM_ADDED', description: `Action item created: "${description}" assigned to ${assigneeName}.`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(newActionItem));
    },

    updateActionItem: async (incidentId: string, actionItem: IncidentActionItem, userId: string = 'system'): Promise<IncidentActionItem> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident) throw new Error('Incident not found');

        const index = incident.actionItems.findIndex(ai => ai.id === actionItem.id);
        if (index > -1) {
            const oldStatus = incident.actionItems[index].status;
            incident.actionItems[index] = { ...incident.actionItems[index], ...actionItem, updatedAt: new Date().toISOString() };
            if (oldStatus !== actionItem.status) {
                incident.timelineEvents.push({
                    id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: `Action item "${actionItem.description}" status updated from ${oldStatus} to ${actionItem.status}.`, userId
                });
            }
            incident.updatedAt = new Date().toISOString();
            return JSON.parse(JSON.stringify(incident.actionItems[index]));
        }
        throw new Error('Action item not found');
    },

    fetchPlaybooks: async (): Promise<Playbook[]> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockPlaybooks));
    },

    fetchPlaybookById: async (id: string): Promise<Playbook | null> => {
        await new Promise(resolve => setTimeout(resolve, 100));
        return JSON.parse(JSON.stringify(mockPlaybooks.find(pb => pb.id === id) || null));
    },

    updatePlaybookStepStatus: async (incidentId: string, playbookId: string, stepId: string, status: PlaybookStepStatus, userId: string = 'system'): Promise<Playbook> => {
        await new Promise(resolve => setTimeout(resolve, 200));
        const playbook = mockPlaybooks.find(pb => pb.id === playbookId);
        if (!playbook) throw new Error('Playbook not found');

        const step = playbook.steps.find(s => s.id === stepId);
        if (!step) throw new Error('Playbook step not found');

        const oldStatus = step.status;
        step.status = status;
        step.executionLog = (step.executionLog || '') + `\n[${formatTimestamp(new Date().toISOString())}] Step status changed to ${status} by ${mockUsers.find(u => u.id === userId)?.name || 'System'}.`;

        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (incident && oldStatus !== status) {
            incident.timelineEvents.push({
                id: uuidv4(),
                timestamp: new Date().toISOString(),
                eventType: 'PLAYBOOK_STEP_EXECUTION',
                description: `Playbook step "${step.description}" status changed to ${status}.`,
                details: { playbookId, stepId, oldStatus, newStatus: status },
                userId
            });
            incident.updatedAt = new Date().toISOString();
        }
        return JSON.parse(JSON.stringify(playbook));
    },

    savePostmortem: async (postmortem: PostmortemDocument, userId: string = 'system'): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 500));
        const incident = incidentDataStore.find(inc => inc.id === postmortem.incidentId);
        if (!incident) throw new Error('Incident not found for postmortem');

        const now = new Date().toISOString();
        if (!incident.postmortemDoc) {
            incident.postmortemDoc = { ...postmortem, id: `pm-${incident.id}`, createdAt: now, updatedAt: now };
        } else {
            incident.postmortemDoc = { ...incident.postmortemDoc, ...postmortem, updatedAt: now };
        }
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: now, eventType: 'CUSTOM_EVENT', description: `Postmortem document saved (Status: ${postmortem.status}).`, userId
        });
        incident.updatedAt = now;
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },

    submitPostmortemForReview: async (pmId: string, incidentId: string, userId: string = 'system'): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident?.postmortemDoc || incident.postmortemDoc.id !== pmId) throw new Error('Postmortem not found');

        incident.postmortemDoc.status = 'REVIEW';
        incident.postmortemDoc.updatedAt = new Date().toISOString();
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: 'Postmortem submitted for review.', userId
        });
        incident.updatedAt = new Date().toISOString();
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },

    approvePostmortem: async (pmId: string, incidentId: string, approverId: string): Promise<PostmortemDocument> => {
        await new Promise(resolve => setTimeout(resolve, 300));
        const incident = incidentDataStore.find(inc => inc.id === incidentId);
        if (!incident?.postmortemDoc || incident.postmortemDoc.id !== pmId) throw new Error('Postmortem not found');

        incident.postmortemDoc.status = 'PUBLISHED';
        incident.postmortemDoc.approvedBy = approverId;
        incident.postmortemDoc.updatedAt = new Date().toISOString();
        incident.timelineEvents.push({
            id: uuidv4(), timestamp: new Date().toISOString(), eventType: 'CUSTOM_EVENT', description: `Postmortem approved and published by ${mockUsers.find(u => u.id === approverId)?.name || 'Unknown'}.`, userId: approverId
        });
        incident.updatedAt = new Date().toISOString();
        return JSON.parse(JSON.stringify(incident.postmortemDoc));
    },
};

export const formatTimestamp = (isoString: string | null, includeTime: boolean = true): string => {
    if (!isoString) return 'N/A';
    const date = new Date(isoString);
    if (isNaN(date.getTime())) return 'Invalid Date';
    return date.toLocaleString(undefined, {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: includeTime ? '2-digit' : undefined,
        minute: includeTime ? '2-digit' : undefined,
        second: includeTime ? '2-digit' : undefined,
        hour12: false
    });
};

export const getSeverityColorClass = (severity: IncidentSeverity): string => {
    switch (severity) {
        case 'SEV1': return 'bg-red-700 text-white';
        case 'SEV2': return 'bg-orange-600 text-white';
        case 'SEV3': return 'bg-yellow-500 text-black';
        case 'SEV4': return 'bg-blue-500 text-white';
        case 'SEV5': return 'bg-green-500 text-white';
        default: return 'bg-gray-500 text-white';
    }
};

export const getStatusColorClass = (status: IncidentStatus): string => {
    switch (status) {
        case 'ACTIVE': return 'text-red-400';
        case 'INVESTIGATING': return 'text-orange-400';
        case 'MITIGATED': return 'text-yellow-400';
        case 'RESOLVED': return 'text-green-400';
        case 'CLOSED': return 'text-gray-500';
        case 'CANCELLED': return 'text-gray-600';
        default: return 'text-gray-400';
    }
};

export const IncidentDetailsModal: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onClose: () => void;
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident, users, onClose, onUpdateIncident }) => {
    const [currentIncident, setCurrentIncident] = useState<DetailedIncident>(incident);
    const [activeTab, setActiveTab] = useState<'overview' | 'timeline' | 'action-items' | 'comments' | 'postmortem' | 'playbook' | 'metrics'>('overview');
    const [isSaving, setIsSaving] = useState(false);
    const { currentUser } = useContext(DataContext);

    useEffect(() => {
        setCurrentIncident(incident);
        if (incident.linkedPlaybookId && activeTab !== 'playbook' && activeTab !== 'overview' && activeTab !== 'metrics') {
            setActiveTab('playbook'); // Automatically switch to playbook if linked and not already on a primary tab
        } else if (!incident.linkedPlaybookId && activeTab === 'playbook') {
            setActiveTab('overview'); // Switch back if playbook unlinked
        }
    }, [incident]);

    const handleFieldChange = useCallback((field: keyof DetailedIncident, value: any) => {
        setCurrentIncident(prev => ({ ...prev, [field]: value }));
    }, []);

    const handleSaveIncident = async () => {
        setIsSaving(true);
        try {
            const updated = await IncidentApiService.updateIncident(currentIncident, currentUser?.id || 'system');
            onUpdateIncident(updated);
            alert('Incident updated successfully!');
        } catch (error) {
            console.error('Failed to update incident:', error);
            alert('Failed to update incident.');
        } finally {
            setIsSaving(false);
        }
    };

    const getOwnerName = (ownerId: string | null) => users.find(u => u.id === ownerId)?.name || 'Unassigned';
    const getAssigneeName = (assigneeId: string) => users.find(u => u.id === assigneeId)?.name || 'Unknown User';

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-5xl w-full h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">{currentIncident.title} <span className={`ml-2 text-sm px-2 py-1 rounded-full ${getSeverityColorClass(currentIncident.severity)}`}>{currentIncident.severity}</span></h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl font-bold leading-none">&times;</button>
                </div>
                <div className="flex-grow flex flex-col">
                    <div className="flex border-b border-gray-700 overflow-x-auto">
                        {['overview', 'timeline', 'action-items', 'comments', 'postmortem', (currentIncident.linkedPlaybookId ? 'playbook' : null), 'metrics'].filter(Boolean).map(tab => (
                            <button
                                key={tab}
                                className={`flex-shrink-0 py-3 px-6 text-sm font-medium ${activeTab === tab ? 'text-cyan-400 border-b-2 border-cyan-400' : 'text-gray-400 hover:text-white'}`}
                                onClick={() => setActiveTab(tab as any)}
                            >
                                {tab?.replace('-', ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}
                            </button>
                        ))}
                    </div>

                    <div className="flex-grow p-6 space-y-4 overflow-y-auto">
                        {activeTab === 'overview' && (
                            <IncidentOverviewTab incident={currentIncident} users={users} onFieldChange={handleFieldChange} onSave={handleSaveIncident} isSaving={isSaving} getOwnerName={getOwnerName} />
                        )}
                        {activeTab === 'timeline' && (
                            <IncidentTimelineTab incident={currentIncident} users={users} />
                        )}
                        {activeTab === 'action-items' && (
                            <IncidentActionItemsTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} getAssigneeName={getAssigneeName} />
                        )}
                        {activeTab === 'comments' && (
                            <IncidentCommentsTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'postmortem' && (
                            <IncidentPostmortemTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'playbook' && currentIncident.linkedPlaybookId && (
                            <IncidentPlaybookTab incident={currentIncident} users={users} onUpdateIncident={onUpdateIncident} />
                        )}
                        {activeTab === 'metrics' && (
                            <IncidentMetricsTab incident={currentIncident} />
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export const IncidentOverviewTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onFieldChange: (field: keyof DetailedIncident, value: any) => void;
    onSave: () => void;
    isSaving: boolean;
    getOwnerName: (ownerId: string | null) => string;
}> = ({ incident, users, onFieldChange, onSave, isSaving, getOwnerName }) => {
    const { currentUser } = useContext(DataContext);
    const [selectedUserForAssignment, setSelectedUserForAssignment] = useState(incident.ownerId || '');

    useEffect(() => {
        if (selectedUserForAssignment !== incident.ownerId) {
            onFieldChange('ownerId', selectedUserForAssignment || null);
        }
    }, [selectedUserForAssignment, incident.ownerId, onFieldChange]);

    const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const tags = e.target.value.split(',').map(tag => tag.trim()).filter(Boolean);
        onFieldChange('tags', tags);
    };

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="col-span-1 md:col-span-2 space-y-4">
                <label className="block text-gray-300 text-sm font-bold mb-1">Title:</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.title}
                    onChange={(e) => onFieldChange('title', e.target.value)}
                />

                <label className="block text-gray-300 text-sm font-bold mb-1">Description:</label>
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-24"
                    value={incident.description}
                    onChange={(e) => onFieldChange('description', e.target.value)}
                />

                <label className="block text-gray-300 text-sm font-bold mb-1">Impact Description:</label>
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-20"
                    value={incident.impactDescription}
                    onChange={(e) => onFieldChange('impactDescription', e.target.value)}
                />
            </div>

            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Severity:</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.severity}
                    onChange={(e) => onFieldChange('severity', e.target.value as IncidentSeverity)}
                >
                    {['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'].map(sev => <option key={sev} value={sev}>{sev}</option>)}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Status:</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.status}
                    onChange={(e) => onFieldChange('status', e.target.value as IncidentStatus)}
                >
                    {['ACTIVE', 'INVESTIGATING', 'MITIGATED', 'RESOLVED', 'CLOSED', 'CANCELLED'].map(s => <option key={s} value={s}>{s}</option>)}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Owner:</label>
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={selectedUserForAssignment}
                    onChange={(e) => setSelectedUserForAssignment(e.target.value)}
                >
                    <option value="">Unassigned</option>
                    {users.filter(u => u.role === 'ENGINEER' || u.role === 'MANAGER' || u.onCall).map(user => (
                        <option key={user.id} value={user.id}>{user.name} {user.onCall && '(On-Call)'}</option>
                    ))}
                </select>
            </div>
            <div>
                <label className="block text-gray-300 text-sm font-bold mb-1">Current Team:</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.currentTeam || ''}
                    onChange={(e) => onFieldChange('currentTeam', e.target.value)}
                />
            </div>
            <div className="col-span-1 md:col-span-2">
                <label className="block text-gray-300 text-sm font-bold mb-1">Affected Services (comma-separated):</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.affectedServices.join(', ')}
                    onChange={(e) => onFieldChange('affectedServices', e.target.value.split(',').map(s => s.trim()).filter(Boolean))}
                />
            </div>
            <div className="col-span-1 md:col-span-2">
                <label className="block text-gray-300 text-sm font-bold mb-1">Tags (comma-separated):</label>
                <input
                    type="text"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                    value={incident.tags.join(', ')}
                    onChange={handleTagsChange}
                />
            </div>
            <div className="col-span-1 md:col-span-2 flex justify-end mt-4">
                <button
                    onClick={onSave}
                    className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isSaving}
                >
                    {isSaving ? 'Saving...' : 'Save Changes'}
                </button>
            </div>
            <div className="col-span-1 md:col-span-2 mt-4 text-sm text-gray-400 border-t border-gray-700 pt-4">
                <p><strong>Incident ID:</strong> {incident.id}</p>
                <p><strong>Source:</strong> {incident.source}</p>
                <p><strong>Created At:</strong> {formatTimestamp(incident.createdAt)}</p>
                <p><strong>Last Updated:</strong> {formatTimestamp(incident.updatedAt)}</p>
                <p><strong>Detected:</strong> {formatTimestamp(incident.detectionTime)}</p>
                <p><strong>Started:</strong> {formatTimestamp(incident.startTime)}</p>
                <p><strong>Mitigated:</strong> {formatTimestamp(incident.mitigationTime)}</p>
                <p><strong>Resolved:</strong> {formatTimestamp(incident.resolutionTime)}</p>
                <p><strong>Assigned Owner:</strong> {getOwnerName(incident.ownerId)}</p>
                {incident.linkedPlaybookId && <p><strong>Linked Playbook:</strong> {incident.linkedPlaybookId}</p>}
                {incident.relatedAlertIds.length > 0 && <p><strong>Related Alerts:</strong> {incident.relatedAlertIds.join(', ')}</p>}
            </div>
        </div>
    );
};

export const IncidentTimelineTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
}> = ({ incident, users }) => {
    const getUserName = (userId: string | undefined) => users.find(u => u.id === userId)?.name || 'System';

    const sortedEvents = [...incident.timelineEvents].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white mb-4">Incident Timeline</h4>
            {sortedEvents.length === 0 ? (
                <p className="text-gray-400">No timeline events recorded.</p>
            ) : (
                <div className="relative pl-8">
                    <div className="absolute left-0 top-0 bottom-0 w-0.5 bg-gray-700"></div>
                    {sortedEvents.map((event, index) => (
                        <div key={event.id} className="mb-8 flex items-start relative">
                            <div className="absolute left-0 -ml-2 w-4 h-4 rounded-full bg-cyan-500 border-2 border-gray-800"></div>
                            <div className="ml-8 w-full">
                                <p className="text-gray-400 text-xs mb-1">{formatTimestamp(event.timestamp)}</p>
                                <p className="font-semibold text-white">{event.description}</p>
                                <p className="text-gray-500 text-sm">by {getUserName(event.userId)}</p>
                                {event.details && (
                                    <div className="mt-2 text-xs text-gray-500 bg-gray-700/50 p-2 rounded-md">
                                        <p className="font-semibold">Details:</p>
                                        <pre className="whitespace-pre-wrap">{JSON.stringify(event.details, null, 2)}</pre>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

export const IncidentActionItemsTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
    getAssigneeName: (assigneeId: string) => string;
}> = ({ incident, users, onUpdateIncident, getAssigneeName }) => {
    const [actionItems, setActionItems] = useState<IncidentActionItem[]>(incident.actionItems);
    const [newActionItemDescription, setNewActionItemDescription] = useState('');
    const [newActionItemAssignee, setNewActionItemAssignee] = useState('');
    const [newActionItemDueDate, setNewActionItemDueDate] = useState('');
    const [isAdding, setIsAdding] = useState(false);
    const { currentUser } = useContext(DataContext);

    useEffect(() => {
        setActionItems(incident.actionItems);
    }, [incident.actionItems]);

    const handleAddActionItem = async () => {
        if (!newActionItemDescription || !newActionItemAssignee) {
            alert('Description and Assignee are required.');
            return;
        }
        setIsAdding(true);
        try {
            const addedItem = await IncidentApiService.addActionItem(
                incident.id,
                newActionItemDescription,
                newActionItemAssignee,
                newActionItemDueDate || null,
                currentUser?.id || 'system'
            );
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id); // Re-fetch for full timeline updates
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            setNewActionItemDescription('');
            setNewActionItemAssignee('');
            setNewActionItemDueDate('');
        } catch (error) {
            console.error('Failed to add action item:', error);
            alert('Failed to add action item.');
        } finally {
            setIsAdding(false);
        }
    };

    const handleUpdateActionItemStatus = async (item: IncidentActionItem, newStatus: ActionItemStatus) => {
        const updatedItem = { ...item, status: newStatus };
        try {
            await IncidentApiService.updateActionItem(incident.id, updatedItem, currentUser?.id || 'system');
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id); // Re-fetch for full timeline updates
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
        } catch (error) {
            console.error('Failed to update action item status:', error);
            alert('Failed to update action item status.');
        }
    };

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Action Items</h4>

            <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                <h5 className="text-lg font-semibold text-white">Add New Action Item</h5>
                <input
                    type="text"
                    placeholder="Description"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemDescription}
                    onChange={(e) => setNewActionItemDescription(e.target.value)}
                />
                <select
                    className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemAssignee}
                    onChange={(e) => setNewActionItemAssignee(e.target.value)}
                >
                    <option value="">Select Assignee</option>
                    {users.filter(u => u.role === 'ENGINEER' || u.role === 'MANAGER' || u.onCall).map(user => (
                        <option key={user.id} value={user.id}>{user.name} {user.onCall && '(On-Call)'}</option>
                    ))}
                </select>
                <input
                    type="date"
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600"
                    value={newActionItemDueDate}
                    onChange={(e) => setNewActionItemDueDate(e.target.value)}
                />
                <button
                    onClick={handleAddActionItem}
                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isAdding}
                >
                    {isAdding ? 'Adding...' : 'Add Action Item'}
                </button>
            </div>

            <div className="space-y-4">
                {actionItems.length === 0 && <p className="text-gray-400">No action items for this incident.</p>}
                {actionItems.map(item => (
                    <Card key={item.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-2">
                            <p className="font-semibold text-white">{item.description}</p>
                            <span className={`text-xs px-2 py-1 rounded-full ${item.status === 'DONE' ? 'bg-green-600' : item.status === 'IN_PROGRESS' ? 'bg-blue-600' : item.status === 'BLOCKED' ? 'bg-red-600' : 'bg-gray-600'} text-white`}>
                                {item.status.replace('_', ' ')}
                            </span>
                        </div>
                        <p className="text-sm text-gray-400">Assigned To: {getAssigneeName(item.assignedTo)}</p>
                        {item.dueDate && <p className="text-sm text-gray-400">Due: {formatTimestamp(item.dueDate, false)}</p>}
                        <div className="mt-3 flex space-x-2">
                            {item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'DONE')}
                                    className="bg-green-700 hover:bg-green-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Mark Done
                                </button>
                            )}
                            {item.status !== 'IN_PROGRESS' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'IN_PROGRESS')}
                                    className="bg-blue-700 hover:bg-blue-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    In Progress
                                </button>
                            )}
                            {item.status !== 'OPEN' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'OPEN')}
                                    className="bg-gray-700 hover:bg-gray-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Re-open
                                </button>
                            )}
                             {item.status !== 'BLOCKED' && item.status !== 'DONE' && (
                                <button
                                    onClick={() => handleUpdateActionItemStatus(item, 'BLOCKED')}
                                    className="bg-red-700 hover:bg-red-800 text-white text-xs px-3 py-1 rounded"
                                >
                                    Blocked
                                </button>
                            )}
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

export const IncidentCommentsTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident, users, onUpdateIncident }) => {
    const [newComment, setNewComment] = useState('');
    const [isPosting, setIsPosting] = useState(false);
    const { currentUser } = useContext(DataContext);

    const handlePostComment = async () => {
        if (!newComment.trim()) return;
        if (!currentUser) {
            alert('Current user context missing. Cannot post comment.');
            return;
        }

        setIsPosting(true);
        try {
            await IncidentApiService.addIncidentComment(
                incident.id,
                currentUser.id,
                currentUser.name,
                newComment
            );
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id);
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            setNewComment('');
        } catch (error) {
            console.error('Failed to add comment:', error);
            alert('Failed to add comment.');
        } finally {
            setIsPosting(false);
        }
    };

    const getCommenterName = (userId: string) => users.find(u => u.id === userId)?.name || 'Unknown User';

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Comments</h4>

            <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                <textarea
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-800 border-gray-600 h-24"
                    placeholder="Add a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                />
                <button
                    onClick={handlePostComment}
                    className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                    disabled={isPosting || !newComment.trim()}
                >
                    {isPosting ? 'Posting...' : 'Post Comment'}
                </button>
            </div>

            <div className="space-y-4 max-h-96 overflow-y-auto custom-scrollbar">
                {incident.comments.length === 0 && <p className="text-gray-400">No comments yet.</p>}
                {incident.comments.sort((a,b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).map(comment => (
                    <Card key={comment.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-1">
                            <p className="font-semibold text-white">{getCommenterName(comment.userId)}</p>
                            <p className="text-xs text-gray-400">{formatTimestamp(comment.timestamp)}</p>
                        </div>
                        <p className="text-sm text-gray-300 whitespace-pre-line">{comment.content}</p>
                    </Card>
                ))}
            </div>
        </div>
    );
};

export const IncidentPostmortemTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident, users, onUpdateIncident }) => {
    const [postmortemDoc, setPostmortemDoc] = useState<PostmortemDocument | null>(incident.postmortemDoc);
    const [isLoadingAI, setIsLoadingAI] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const [editorStates, setEditorStates] = useState<Record<string, EditorState>>({});
    const { currentUser } = useContext(DataContext);
    const [aiGeneratingSection, setAiGeneratingSection] = useState<PostmortemSectionType | null>(null);

    const initializeEditorStates = useCallback((pmDoc: PostmortemDocument) => {
        const initialEditorStates: Record<string, EditorState> = {};
        pmDoc.sections.forEach(section => {
            try {
                const contentState = section.content ? convertFromRaw(JSON.parse(section.content)) : ContentState.createFromText('');
                initialEditorStates[section.id] = EditorState.createWithContent(contentState);
            } catch (e) {
                initialEditorStates[section.id] = EditorState.createWithContent(ContentState.createFromText(section.content || ''));
            }
        });
        setEditorStates(initialEditorStates);
    }, []);

    useEffect(() => {
        setPostmortemDoc(incident.postmortemDoc);
        if (incident.postmortemDoc) {
            initializeEditorStates(incident.postmortemDoc);
        } else {
            setEditorStates({});
        }
    }, [incident.postmortemDoc, initializeEditorStates]);

    const handleGenerateAISection = async (sectionType: PostmortemSectionType) => {
        setIsLoadingAI(true);
        setAiGeneratingSection(sectionType);
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            let prompt = `For the incident titled "${incident.title}" (Incident ID: ${incident.id}, Severity: ${incident.severity}, Status: ${incident.status}, Description: "${incident.description}"), generate a detailed "${sectionType.replace(/_/g, ' ')}" section for a postmortem report. Focus on factual and concise information.`;

            if (sectionType === 'ROOT_CAUSE' && incident.timelineEvents.length > 0) {
                prompt += ` Consider the following incident details and timeline events:\n`;
                prompt += `Affected Services: ${incident.affectedServices.join(', ')}\n`;
                prompt += `Timeline: ${incident.timelineEvents.map(e => `${formatTimestamp(e.timestamp)}: ${e.description}`).join('; ')}\n`;
                prompt += `Impact Description: ${incident.impactDescription}\n`;
                prompt += `Based on this, what are the most likely root causes?`;
            } else if (sectionType === 'ACTION_ITEMS') {
                prompt += ` Current status: ${incident.status}. Previous action items: ${incident.actionItems.map(ai => `- ${ai.description} (${ai.status})`).join('\n') || 'None'}. Suggest specific, actionable, and measurable items to prevent recurrence or improve response time. Categorize them by short-term and long-term.`;
            } else if (sectionType === 'IMPACT') {
                prompt += ` The incident had impact: "${incident.impactDescription}". Elaborate on the quantitative and qualitative impact on users, business, and reputation.`;
            } else if (sectionType === 'RESOLUTION') {
                prompt += ` The incident is currently ${incident.status}. If it's mitigated or resolved, describe the steps taken, tools used, and the personnel involved in resolving the incident.`;
            } else if (sectionType === 'SUMMARY') {
                prompt += ` Summarize the incident, including when it started, when it was detected, key impacts, and its current status.`;
            } else if (sectionType === 'LESSONS_LEARNED') {
                prompt += ` Based on the incident, what are the key lessons learned regarding detection, response, communication, and prevention?`;
            } else if (sectionType === 'PREVENTION') {
                prompt += ` What concrete steps can be taken to prevent a similar incident from happening again, or to minimize its impact if it does?`;
            } else if (sectionType === 'TIMELINE') {
                 prompt += ` Reconstruct a detailed timeline from these events, focusing on key milestones and actions.
                Events: ${incident.timelineEvents.map(e => `${formatTimestamp(e.timestamp)} (${e.eventType}): ${e.description} by ${users.find(u => u.id === e.userId)?.name || 'System'}`).join('\n')}`;
            }

            prompt += ` Provide the response in a structured text format suitable for a report, no more than 500 words.`;

            const response = await ai.models.generateContent({ model: 'gemini-1.5-flash', contents: [{ text: prompt }] });
            const generatedContent = response.text;

            const newSection: PostmortemSection = {
                id: uuidv4(),
                type: sectionType,
                title: sectionType.replace(/_/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
                content: JSON.stringify(convertToRaw(ContentState.createFromText(generatedContent))),
                generatedByAI: true,
            };

            let updatedSections: PostmortemSection[] = [];
            let currentPostmortem = postmortemDoc;
            if (currentPostmortem) {
                const existingIndex = currentPostmortem.sections.findIndex(s => s.type === sectionType);
                if (existingIndex > -1) {
                    updatedSections = currentPostmortem.sections.map((s, idx) => idx === existingIndex ? newSection : s);
                } else {
                    updatedSections = [...currentPostmortem.sections, newSection];
                }
            } else {
                updatedSections = [newSection];
            }

            const newPostmortemDoc: PostmortemDocument = currentPostmortem ?
                { ...currentPostmortem, sections: updatedSections } :
                {
                    id: `pm-${incident.id}`,
                    incidentId: incident.id,
                    title: `Postmortem for ${incident.title}`,
                    sections: updatedSections,
                    status: 'DRAFT',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                };

            const savedPm = await IncidentApiService.savePostmortem(newPostmortemDoc, currentUser?.id || 'system');
            onUpdateIncident({ ...incident, postmortemDoc: savedPm });
            setPostmortemDoc(savedPm); // Update local state for immediate re-render
            initializeEditorStates(savedPm); // Re-initialize editors with new content
            alert(`${sectionType} section generated by AI and saved.`);

        } catch (err) {
            console.error(`Error generating AI ${sectionType} section:`, err);
            alert(`Failed to generate AI ${sectionType} section. Check console for details.`);
        } finally {
            setIsLoadingAI(false);
            setAiGeneratingSection(null);
        }
    };

    const handleSavePostmortem = async () => {
        if (!postmortemDoc) return;
        setIsSaving(true);
        try {
            const updatedSections = postmortemDoc.sections.map(section => ({
                ...section,
                content: JSON.stringify(convertToRaw(editorStates[section.id]?.getCurrentContent() || ContentState.createFromText('')))
            }));
            const updatedPostmortemDoc = { ...postmortemDoc, sections: updatedSections };
            const savedPm = await IncidentApiService.savePostmortem(updatedPostmortemDoc, currentUser?.id || 'system');
            onUpdateIncident({ ...incident, postmortemDoc: savedPm });
            setPostmortemDoc(savedPm);
            alert('Postmortem saved successfully!');
        } catch (error) {
            console.error('Failed to save postmortem:', error);
            alert('Failed to save postmortem.');
        } finally {
            setIsSaving(false);
        }
    };

    const handleEditorStateChange = (sectionId: string, newEditorState: EditorState) => {
        setEditorStates(prev => ({ ...prev, [sectionId]: newEditorState }));
    };

    const handleAddSection = (type: PostmortemSectionType) => {
        const newSection: PostmortemSection = {
            id: uuidv4(),
            type,
            title: type.replace(/_/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '),
            content: '',
            generatedByAI: false,
        };
        const updatedDoc = postmortemDoc ? { ...postmortemDoc, sections: [...postmortemDoc.sections, newSection] } : {
            id: `pm-${incident.id}`, incidentId: incident.id, title: `Postmortem for ${incident.title}`, sections: [newSection], status: 'DRAFT',
            createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
        };
        setPostmortemDoc(updatedDoc);
        setEditorStates(prev => ({ ...prev, [newSection.id]: EditorState.createEmpty() }));
    };

    const handleRemoveSection = (sectionId: string) => {
        if (!postmortemDoc) return;
        const updatedSections = postmortemDoc.sections.filter(s => s.id !== sectionId);
        setPostmortemDoc({ ...postmortemDoc, sections: updatedSections });
        setEditorStates(prev => {
            const newStates = { ...prev };
            delete newStates[sectionId];
            return newStates;
        });
    };

    const handleStatusUpdate = async (newStatus: 'REVIEW' | 'PUBLISHED') => {
        if (!postmortemDoc) return;
        setIsSaving(true);
        try {
            let updatedPm: PostmortemDocument;
            if (newStatus === 'REVIEW') {
                updatedPm = await IncidentApiService.submitPostmortemForReview(postmortemDoc.id, incident.id, currentUser?.id || 'system');
            } else { // PUBLISHED
                if (!currentUser) { alert('Current user context missing for approval.'); return; }
                updatedPm = await IncidentApiService.approvePostmortem(postmortemDoc.id, incident.id, currentUser.id);
            }
            onUpdateIncident({ ...incident, postmortemDoc: updatedPm });
            setPostmortemDoc(updatedPm);
            alert(`Postmortem status updated to ${newStatus}.`);
        } catch (error) {
            console.error('Failed to update postmortem status:', error);
            alert('Failed to update postmortem status.');
        } finally {
            setIsSaving(false);
        }
    };

    const renderPostmortemContent = (section: PostmortemSection) => {
        if (section.content) {
            try {
                const contentState = convertFromRaw(JSON.parse(section.content));
                return <div className="text-sm text-gray-300 read-only-editor" dangerouslySetInnerHTML={{ __html: editorStates[section.id] ? (EditorState.createWithContent(contentState) as any).toHTML() : '' }}></div>;
            } catch (e) {
                return <div className="prose prose-invert text-sm text-gray-300 whitespace-pre-line">{section.content}</div>;
            }
        }
        return <p className="text-gray-500 text-sm">No content yet.</p>;
    };

    const canEdit = postmortemDoc?.status === 'DRAFT';
    const canSubmitForReview = postmortemDoc?.status === 'DRAFT' && postmortemDoc.sections.length > 0;
    const canApprove = postmortemDoc?.status === 'REVIEW' && (currentUser?.role === 'ADMIN' || currentUser?.role === 'MANAGER');
    const canGenerateAI = true; // AI generation is always possible, but content can be overwritten

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Postmortem Document</h4>

            {!postmortemDoc ? (
                <div className="text-center p-8 bg-gray-700/50 rounded-md">
                    <p className="text-gray-300 mb-4">No postmortem document exists yet for this incident.</p>
                    <button
                        onClick={() => {
                            const newPm = {
                                id: `pm-${incident.id}`, incidentId: incident.id, title: `Postmortem for ${incident.title}`, sections: [], status: 'DRAFT' as 'DRAFT',
                                createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
                            };
                            setPostmortemDoc(newPm);
                            IncidentApiService.savePostmortem(newPm, currentUser?.id || 'system');
                        }}
                        className="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded"
                    >
                        Create New Postmortem
                    </button>
                </div>
            ) : (
                <div className="space-y-6">
                    <div className="flex flex-col md:flex-row justify-between items-center bg-gray-700/50 p-4 rounded-md">
                        <p className="text-gray-300 mb-2 md:mb-0">Status: <span className={`font-semibold ${postmortemDoc.status === 'PUBLISHED' ? 'text-green-400' : postmortemDoc.status === 'REVIEW' ? 'text-orange-400' : 'text-gray-400'}`}>{postmortemDoc.status}</span></p>
                        <div className="flex space-x-2 flex-wrap justify-end">
                            {canEdit && (
                                <button
                                    onClick={handleSavePostmortem}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    {isSaving ? 'Saving...' : 'Save Postmortem'}
                                </button>
                            )}
                            {canSubmitForReview && (
                                <button
                                    onClick={() => handleStatusUpdate('REVIEW')}
                                    className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    Submit for Review
                                </button>
                            )}
                            {canApprove && (
                                <button
                                    onClick={() => handleStatusUpdate('PUBLISHED')}
                                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px] mb-2 md:mb-0"
                                    disabled={isSaving}
                                >
                                    Approve & Publish
                                </button>
                            )}
                             {(postmortemDoc.status === 'REVIEW' || postmortemDoc.status === 'PUBLISHED') && !canEdit && (
                                <button
                                    onClick={() => alert('Feature to revert to draft or make a new version is not implemented.')}
                                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded text-sm disabled:opacity-50 min-w-[120px]"
                                    disabled={true} // Placeholder to indicate this is a future feature
                                >
                                    Revert/New Version
                                </button>
                            )}
                        </div>
                    </div>

                    <div className="p-4 bg-gray-700/50 rounded-md space-y-3">
                        <h5 className="text-lg font-semibold text-white">AI Generation & Section Management</h5>
                        <div className="grid grid-cols-2 lg:grid-cols-4 gap-2">
                            {['SUMMARY', 'IMPACT', 'ROOT_CAUSE', 'RESOLUTION', 'ACTION_ITEMS', 'LESSONS_LEARNED', 'PREVENTION', 'TIMELINE'].map(type => (
                                <div key={type} className="flex items-center space-x-2">
                                    <button
                                        onClick={() => handleGenerateAISection(type as PostmortemSectionType)}
                                        className="flex-grow bg-indigo-600 hover:bg-indigo-700 text-white text-xs px-3 py-2 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                        disabled={isLoadingAI && aiGeneratingSection === type}
                                    >
                                        {isLoadingAI && aiGeneratingSection === type ? `Generating ${type.replace(/_/g, ' ')}...` : `Generate AI ${type.replace(/_/g, ' ')}`}
                                    </button>
                                    {canEdit && (
                                        <button
                                            onClick={() => handleAddSection(type as PostmortemSectionType)}
                                            className="bg-gray-600 hover:bg-gray-700 text-white text-xs px-2 py-2 rounded disabled:opacity-50 transition-colors"
                                            title="Add empty section"
                                        >
                                            +
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="space-y-8">
                        {postmortemDoc.sections.length === 0 && <p className="text-gray-400">No sections added to postmortem yet.</p>}
                        {postmortemDoc.sections.map(section => (
                            <Card key={section.id} className="p-6 bg-gray-800 border border-gray-700">
                                <div className="flex justify-between items-center mb-4">
                                    <h5 className="text-xl font-semibold text-white">{section.title}</h5>
                                    <div className="flex items-center space-x-2">
                                        {section.generatedByAI && <span className="text-xs text-indigo-400">AI Generated</span>}
                                        {canEdit && (
                                            <button
                                                onClick={() => handleRemoveSection(section.id)}
                                                className="text-red-500 hover:text-red-700 text-sm"
                                                title="Remove section"
                                            >
                                                &times;
                                            </button>
                                        )}
                                    </div>
                                </div>
                                {canEdit ? (
                                    <div className="bg-gray-900 border border-gray-600 rounded p-2 min-h-[10rem]">
                                        <Editor
                                            editorState={editorStates[section.id] || EditorState.createEmpty()}
                                            onEditorStateChange={(newState) => handleEditorStateChange(section.id, newState)}
                                            wrapperClassName="draft-editor-wrapper"
                                            editorClassName="draft-editor-content text-white"
                                            toolbarClassName="draft-editor-toolbar bg-gray-700 border-gray-600 rounded-t"
                                            toolbar={{
                                                options: ['inline', 'blockType', 'list', 'textAlign', 'link', 'emoji', 'remove', 'history'],
                                                inline: { inDropdown: false, options: ['bold', 'italic', 'underline', 'strikethrough'] },
                                                list: { inDropdown: false, options: ['unordered', 'ordered'] },
                                                textAlign: { inDropdown: true },
                                            }}
                                        />
                                    </div>
                                ) : (
                                    renderPostmortemContent(section)
                                )}
                            </Card>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
};

export const IncidentPlaybookTab: React.FC<{
    incident: DetailedIncident;
    users: UserProfile[];
    onUpdateIncident: (incident: DetailedIncident) => void;
}> = ({ incident, users, onUpdateIncident }) => {
    const [playbook, setPlaybook] = useState<Playbook | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [executingStepId, setExecutingStepId] = useState<string | null>(null);
    const { currentUser } = useContext(DataContext);
    const [metricCheckResults, setMetricCheckResults] = useState<Record<string, boolean | null>>({});

    const fetchPlaybookData = useCallback(async () => {
        if (incident.linkedPlaybookId) {
            setIsLoading(true);
            try {
                const pb = await IncidentApiService.fetchPlaybookById(incident.linkedPlaybookId);
                setPlaybook(pb);
            } catch (error) {
                console.error('Failed to fetch playbook:', error);
                setPlaybook(null);
            } finally {
                setIsLoading(false);
            }
        } else {
            setPlaybook(null);
            setIsLoading(false);
        }
    }, [incident.linkedPlaybookId]);

    useEffect(() => {
        fetchPlaybookData();
    }, [fetchPlaybookData]);

    const handleStepStatusChange = async (stepId: string, newStatus: PlaybookStepStatus) => {
        if (!playbook) return;
        setExecutingStepId(stepId);
        try {
            await IncidentApiService.updatePlaybookStepStatus(incident.id, playbook.id, stepId, newStatus, currentUser?.id || 'system');
            const updatedIncident = await IncidentApiService.fetchIncidentById(incident.id);
            if(updatedIncident) {
                onUpdateIncident(updatedIncident);
            }
            fetchPlaybookData(); // Re-fetch playbook to get updated status
        } catch (error) {
            console.error('Failed to update playbook step status:', error);
            alert('Failed to update playbook step status.');
        } finally {
            setExecutingStepId(null);
        }
    };

    const handleExecuteCommand = async (step: PlaybookStep) => {
        if (!step.command) return;
        setExecutingStepId(step.id);
        alert(`Simulating execution of command: ${step.command} on ${step.target || 'N/A'}`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate command execution time
        await handleStepStatusChange(step.id, 'COMPLETED'); // Mark as completed after simulation
        setExecutingStepId(null);
    };

    const handleMetricCheck = async (step: PlaybookStep) => {
        if (!step.metricToCheck) return;
        setExecutingStepId(step.id);
        const { service, metricName, operator, value } = step.metricToCheck;
        try {
            const metric = await IncidentApiService.fetchMetricData(metricName, service, 5); // Fetch last 5 mins
            const latestValue = metric.data[metric.data.length - 1]?.value;

            if (latestValue === undefined) {
                setMetricCheckResults(prev => ({ ...prev, [step.id]: null })); // Indicate no data
                alert(`No data for ${metricName} on ${service}.`);
                await handleStepStatusChange(step.id, 'FAILED');
                return;
            }

            let checkPassed = false;
            switch (operator) {
                case 'gt': checkPassed = latestValue > value; break;
                case 'lt': checkPassed = latestValue < value; break;
                case 'eq': checkPassed = latestValue === value; break;
            }

            setMetricCheckResults(prev => ({ ...prev, [step.id]: checkPassed }));
            if (checkPassed) {
                alert(`Metric check passed! ${metricName} (${latestValue}) is ${operator} ${value}.`);
                await handleStepStatusChange(step.id, 'COMPLETED');
            } else {
                alert(`Metric check failed! ${metricName} (${latestValue}) is NOT ${operator} ${value}.`);
                await handleStepStatusChange(step.id, 'FAILED');
            }
        } catch (error) {
            console.error('Error during metric check:', error);
            alert('Failed to perform metric check.');
            setMetricCheckResults(prev => ({ ...prev, [step.id]: null }));
            await handleStepStatusChange(step.id, 'FAILED');
        } finally {
            setExecutingStepId(null);
        }
    };


    if (isLoading) {
        return <p className="text-gray-400">Loading playbook...</p>;
    }

    if (!playbook) {
        return <p className="text-gray-400">No linked playbook for this incident.</p>;
    }

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Linked Playbook: {playbook.name}</h4>
            <p className="text-gray-400">{playbook.description}</p>

            <div className="space-y-4">
                {playbook.steps.map((step, index) => (
                    <Card key={step.id} className="p-4 bg-gray-800 border border-gray-700">
                        <div className="flex justify-between items-center mb-2">
                            <p className="font-semibold text-white">Step {index + 1}: {step.description}</p>
                            <span className={`text-xs px-2 py-1 rounded-full ${step.status === 'COMPLETED' ? 'bg-green-600' : step.status === 'IN_PROGRESS' ? 'bg-blue-600' : step.status === 'FAILED' ? 'bg-red-600' : 'bg-gray-600'} text-white`}>
                                {step.status.replace('_', ' ')}
                            </span>
                        </div>
                        <p className="text-sm text-gray-400">Type: {step.type.replace('_', ' ')}</p>
                        {step.assignedTo && <p className="text-sm text-gray-400">Assigned To: {users.find(u => u.id === step.assignedTo)?.name || 'Unassigned'}</p>}
                        {step.command && <p className="text-sm text-gray-400">Command: <code className="bg-gray-700 px-2 py-1 rounded text-cyan-300">{step.command}</code></p>}
                        {step.target && <p className="text-sm text-gray-400">Target: {step.target}</p>}
                        {step.metricToCheck && (
                            <p className="text-sm text-gray-400">Metric Check: {step.metricToCheck.service} - {step.metricToCheck.metricName} {step.metricToCheck.operator} {step.metricToCheck.value}</p>
                        )}
                        {step.executionLog && <p className="text-sm text-gray-500 mt-2 italic">Log: {step.executionLog}</p>}
                        {step.manualConfirmationRequired && <p className="text-sm text-orange-400 font-medium mt-1">Manual Confirmation Required</p>}
                        {metricCheckResults[step.id] !== undefined && metricCheckResults[step.id] !== null && (
                            <p className={`text-sm mt-1 ${metricCheckResults[step.id] ? 'text-green-400' : 'text-red-400'}`}>
                                Metric Check Result: {metricCheckResults[step.id] ? 'Passed' : 'Failed'}
                            </p>
                        )}
                        {metricCheckResults[step.id] === null && (
                            <p className="text-sm mt-1 text-gray-500">Metric Check Result: No data.</p>
                        )}

                        <div className="mt-3 flex space-x-2 flex-wrap">
                            {step.status !== 'COMPLETED' && step.status !== 'FAILED' && step.type === 'MANUAL_TASK' && (
                                <button
                                    onClick={() => handleStepStatusChange(step.id, 'COMPLETED')}
                                    className="bg-green-700 hover:bg-green-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Completing...' : 'Mark Completed'}
                                </button>
                            )}
                            {step.status !== 'COMPLETED' && step.status !== 'FAILED' && step.type === 'COMMAND' && (
                                <button
                                    onClick={() => handleExecuteCommand(step)}
                                    className="bg-blue-700 hover:bg-blue-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Executing...' : 'Execute Command'}
                                </button>
                            )}
                            {step.status !== 'COMPLETED' && step.status !== 'FAILED' && step.type === 'CHECK_METRIC' && (
                                <button
                                    onClick={() => handleMetricCheck(step)}
                                    className="bg-indigo-700 hover:bg-indigo-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Checking Metric...' : 'Run Metric Check'}
                                </button>
                            )}
                             {step.status !== 'FAILED' && step.status !== 'COMPLETED' && (
                                <button
                                    onClick={() => handleStepStatusChange(step.id, 'FAILED')}
                                    className="bg-red-700 hover:bg-red-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Failing...' : 'Mark Failed'}
                                </button>
                            )}
                            {step.status !== 'IN_PROGRESS' && step.status !== 'COMPLETED' && step.status !== 'FAILED' && (
                                <button
                                    onClick={() => handleStepStatusChange(step.id, 'IN_PROGRESS')}
                                    className="bg-gray-700 hover:bg-gray-800 text-white text-xs px-3 py-1 rounded disabled:opacity-50"
                                    disabled={executingStepId === step.id}
                                >
                                    {executingStepId === step.id ? 'Starting...' : 'Start Progress'}
                                </button>
                            )}
                        </div>
                    </Card>
                ))}
            </div>
        </div>
    );
};

export const IncidentMetricsTab: React.FC<{
    incident: DetailedIncident;
}> = ({ incident }) => {
    const [metricData, setMetricData] = useState<Record<string, TimeSeriesMetric | null>>({});
    const [isLoadingMetrics, setIsLoadingMetrics] = useState(false);
    const [selectedMetric, setSelectedMetric] = useState<string>('responseTime');
    const [duration, setDuration] = useState<number>(60); // In minutes

    const affectedService = incident.affectedServices.length > 0 ? incident.affectedServices[0] : null;

    const fetchMetrics = useCallback(async () => {
        if (!affectedService) {
            setMetricData({});
            return;
        }

        setIsLoadingMetrics(true);
        try {
            const responseTime = await IncidentApiService.fetchMetricData('responseTime', affectedService, duration);
            const errorRate = await IncidentApiService.fetchMetricData('errorRate', affectedService, duration);
            const incidentCount = await IncidentApiService.fetchMetricData('incidentCount', affectedService, duration);
            setMetricData({ responseTime, errorRate, incidentCount });
        } catch (error) {
            console.error('Failed to fetch metrics:', error);
            setMetricData({});
        } finally {
            setIsLoadingMetrics(false);
        }
    }, [affectedService, duration]);

    useEffect(() => {
        fetchMetrics();
    }, [fetchMetrics]);

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                labels: {
                    color: 'white',
                },
            },
            title: {
                display: true,
                text: `${affectedService || 'Service'} - ${selectedMetric === 'responseTime' ? 'Response Time' : selectedMetric === 'errorRate' ? 'Error Rate' : 'Incident Count'} (Last ${duration} mins)`,
                color: 'white',
            },
        },
        scales: {
            x: {
                ticks: {
                    color: 'gray',
                    callback: function(this: any, val: any, index: number) {
                        return index % Math.ceil(duration / 10) === 0 ? formatTimestamp(this.getLabelForValue(val) as string, true).split(' ')[1] : '';
                    }
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                },
            },
            y: {
                ticks: {
                    color: 'gray',
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                },
                title: {
                    display: true,
                    text: metricData[selectedMetric]?.unit || '',
                    color: 'white',
                },
            },
        },
    };

    const currentMetric = metricData[selectedMetric];
    const chartData = {
        labels: currentMetric?.data.map(dp => dp.timestamp) || [],
        datasets: [
            {
                label: currentMetric?.name || '',
                data: currentMetric?.data.map(dp => dp.value) || [],
                borderColor: selectedMetric === 'responseTime' ? 'rgb(75, 192, 192)' : selectedMetric === 'errorRate' ? 'rgb(255, 99, 132)' : 'rgb(54, 162, 235)',
                backgroundColor: selectedMetric === 'responseTime' ? 'rgba(75, 192, 192, 0.2)' : selectedMetric === 'errorRate' ? 'rgba(255, 99, 132, 0.2)' : 'rgba(54, 162, 235, 0.2)',
                tension: 0.1,
                fill: true,
            },
        ],
    };

    if (!affectedService) {
        return <p className="text-gray-400">No affected services identified to display metrics.</p>;
    }

    if (isLoadingMetrics) {
        return <p className="text-gray-400">Loading metrics...</p>;
    }

    return (
        <div className="space-y-6">
            <h4 className="text-xl font-bold text-white">Service Metrics for {affectedService}</h4>
            <div className="flex flex-wrap gap-4">
                <div className="flex space-x-2">
                    {['responseTime', 'errorRate', 'incidentCount'].map(metric => (
                        <button
                            key={metric}
                            onClick={() => setSelectedMetric(metric)}
                            className={`py-2 px-4 rounded ${selectedMetric === metric ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-300'}`}
                        >
                            {metric.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}
                        </button>
                    ))}
                </div>
                <div className="flex space-x-2">
                    {[30, 60, 120, 240].map(d => (
                        <button
                            key={d}
                            onClick={() => setDuration(d)}
                            className={`py-2 px-4 rounded ${duration === d ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-300'}`}
                        >
                            {d}m
                        </button>
                    ))}
                </div>
            </div>
            <div className="h-96">
                {currentMetric && currentMetric.data.length > 0 ? (
                    <Line data={chartData} options={chartOptions as any} />
                ) : (
                    <p className="text-gray-400">No metric data available for {selectedMetric}.</p>
                )}
            </div>
        </div>
    );
};

export const MetricCard: React.FC<{
    title: string;
    value: string;
    unit?: string;
    trend?: 'up' | 'down' | 'stable';
    trendValue?: string;
    colorClass?: string;
}> = ({ title, value, unit, trend, trendValue, colorClass = 'text-white' }) => {
    const trendIcon = trend === 'up' ? '' : trend === 'down' ? '' : '';
    const trendColor = trend === 'up' ? 'text-green-500' : trend === 'down' ? 'text-red-500' : 'text-gray-500';

    return (
        <Card className="text-center p-4">
            <p className={`text-4xl font-bold ${colorClass}`}>{value}{unit && <span className="text-xl ml-1">{unit}</span>}</p>
            <p className="text-sm text-gray-400 mt-2">{title}</p>
            {trend && trendValue && (
                <p className={`text-xs mt-1 ${trendColor}`}>
                    {trendIcon} {trendValue}
                </p>
            )}
        </Card>
    );
};

export const ServiceHealthStatus: React.FC<{
    serviceMetrics: ServiceHealthMetric[];
}> = ({ serviceMetrics }) => {
    return (
        <Card title="Service Health Overview" className="p-4">
            <div className="space-y-3">
                {serviceMetrics.length === 0 && <p className="text-gray-400">No service health data available.</p>}
                {serviceMetrics.map(service => (
                    <div key={service.serviceName} className="flex justify-between items-center py-2 px-3 bg-gray-800 rounded-md">
                        <p className="font-semibold text-white">{service.serviceName}</p>
                        <div className="flex items-center space-x-2">
                            <span className={`text-sm px-2 py-1 rounded-full ${service.status === 'OPERATIONAL' ? 'bg-green-600' : service.status === 'DEGRADED' ? 'bg-orange-600' : 'bg-red-600'} text-white`}>
                                {service.status}
                            </span>
                            <p className="text-xs text-gray-400">Incidents: {service.incidentsLast24h}</p>
                            <p className="text-xs text-gray-400">RT: {service.responseTimeMs}ms</p>
                        </div>
                    </div>
                ))}
            </div>
        </Card>
    );
};

export const IncidentSummaryMetrics: React.FC<{
    incidents: DetailedIncident[];
}> = ({ incidents }) => {
    const activeSev1 = incidents.filter(i => i.severity === 'SEV1' && i.status === 'ACTIVE').length;
    const activeSev2 = incidents.filter(i => i.severity === 'SEV2' && i.status === 'ACTIVE').length;
    const activeSev3 = incidents.filter(i => i.severity === 'SEV3' && i.status === 'ACTIVE').length;

    const calculateMTTA = (incList: DetailedIncident[]) => {
        const relevantIncidents = incList.filter(inc => inc.detectionTime && inc.startTime && new Date(inc.startTime).getTime() >= new Date(inc.detectionTime).getTime());
        if (relevantIncidents.length === 0) return 'N/A';
        const totalTimeToAcknowledge = relevantIncidents.reduce((sum, inc) => {
            const detection = new Date(inc.detectionTime).getTime();
            const start = new Date(inc.startTime).getTime();
            return sum + (start - detection);
        }, 0);
        const avgMinutes = totalTimeToAcknowledge / relevantIncidents.length / 60 / 1000;
        return `${Math.round(avgMinutes)}m`;
    };

    const calculateMTTR = (incList: DetailedIncident[]) => {
        const relevantIncidents = incList.filter(inc => inc.resolutionTime && inc.startTime && new Date(inc.resolutionTime!).getTime() >= new Date(inc.startTime).getTime());
        if (relevantIncidents.length === 0) return 'N/A';
        const totalTimeToResolve = relevantIncidents.reduce((sum, inc) => {
            const start = new Date(inc.startTime).getTime();
            const resolution = new Date(inc.resolutionTime!).getTime();
            return sum + (resolution - start);
        }, 0);
        const avgMinutes = totalTimeToResolve / relevantIncidents.length / 60 / 1000;
        return `${Math.round(avgMinutes)}m`;
    };

    const incidentsLast24h = incidents.filter(i => new Date(i.createdAt).getTime() > Date.now() - 24 * 3600 * 1000).length;
    const totalOpenIncidents = incidents.filter(i => i.status !== 'CLOSED' && i.status !== 'RESOLVED' && i.status !== 'CANCELLED').length;
    const thirtyDayUptime = '99.98%'; // Placeholder, would integrate with actual SLOs

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            <MetricCard title="Active SEV1" value={activeSev1.toString()} colorClass="text-red-400" />
            <MetricCard title="Active SEV2" value={activeSev2.toString()} colorClass="text-orange-400" />
            <MetricCard title="Active SEV3" value={activeSev3.toString()} colorClass="text-yellow-400" />
            <MetricCard title="Total Open Incidents" value={totalOpenIncidents.toString()} />
            <MetricCard title="MTTA (30d)" value={calculateMTTA(incidents)} unit="" />
            <MetricCard title="MTTR (30d)" value={calculateMTTR(incidents)} unit="" />
            <MetricCard title="Uptime (30d)" value={thirtyDayUptime} unit="" colorClass="text-green-400" />
            <MetricCard title="New Incidents (24h)" value={incidentsLast24h.toString()} />
        </div>
    );
};

export const GlobalSearch: React.FC<{
    onSearch: (searchTerm: string) => void;
}> = ({ onSearch }) => {
    const [searchTerm, setSearchTerm] = useState('');

    const handleSearchSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSearch(searchTerm);
    };

    return (
        <form onSubmit={handleSearchSubmit} className="flex-grow max-w-lg">
            <div className="relative">
                <input
                    type="text"
                    placeholder="Search incidents, services, tags..."
                    className="w-full pl-10 pr-4 py-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:border-cyan-500"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                />
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <svg className="h-5 w-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clipRule="evenodd" />
                    </svg>
                </div>
            </div>
        </form>
    );
};

export const FilterPanel: React.FC<{
    onFilterChange: (filters: { status?: IncidentStatus[], severity?: IncidentSeverity[], service?: string }) => void;
    currentFilters: { status: IncidentStatus[], severity: IncidentSeverity[], service: string };
    allServices: string[];
}> = ({ onFilterChange, currentFilters, allServices }) => {
    const [open, setOpen] = useState(false);
    const filterRef = useRef<HTMLDivElement>(null);

    const handleStatusChange = (status: IncidentStatus, checked: boolean) => {
        const newStatuses = checked
            ? [...currentFilters.status, status]
            : currentFilters.status.filter(s => s !== status);
        onFilterChange({ ...currentFilters, status: newStatuses });
    };

    const handleSeverityChange = (severity: IncidentSeverity, checked: boolean) => {
        const newSeverities = checked
            ? [...currentFilters.severity, severity]
            : currentFilters.severity.filter(s => s !== severity);
        onFilterChange({ ...currentFilters, severity: newSeverities });
    };

    const handleServiceChange = (service: string) => {
        onFilterChange({ ...currentFilters, service: service === '' ? undefined : service });
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (filterRef.current && !filterRef.current.contains(event.target as Node)) {
                setOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    return (
        <div className="relative" ref={filterRef}>
            <button
                onClick={() => setOpen(!open)}
                className="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded-lg flex items-center space-x-2 transition-colors"
            >
                <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z" clipRule="evenodd" /></svg>
                <span>Filters</span>
                {(currentFilters.status.length > 0 || currentFilters.severity.length > 0 || currentFilters.service) && (
                    <span className="ml-2 px-2 py-0.5 bg-cyan-600 rounded-full text-xs">
                        {currentFilters.status.length + currentFilters.severity.length + (currentFilters.service ? 1 : 0)}
                    </span>
                )}
            </button>

            {open && (
                <Card className="absolute left-0 mt-2 p-4 w-72 bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10">
                    <div className="mb-4">
                        <h6 className="text-sm font-semibold text-gray-300 mb-2">Status</h6>
                        <div className="flex flex-col space-y-1">
                            {['ACTIVE', 'INVESTIGATING', 'MITIGATED', 'RESOLVED', 'CLOSED', 'CANCELLED'].map(status => (
                                <label key={status} className="flex items-center text-gray-400 text-sm">
                                    <input
                                        type="checkbox"
                                        className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                                        checked={currentFilters.status.includes(status as IncidentStatus)}
                                        onChange={(e) => handleStatusChange(status as IncidentStatus, e.target.checked)}
                                    />
                                    <span className="ml-2">{status}</span>
                                </label>
                            ))}
                        </div>
                    </div>
                    <div className="mb-4">
                        <h6 className="text-sm font-semibold text-gray-300 mb-2">Severity</h6>
                        <div className="flex flex-col space-y-1">
                            {['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'].map(severity => (
                                <label key={severity} className="flex items-center text-gray-400 text-sm">
                                    <input
                                        type="checkbox"
                                        className="form-checkbox h-4 w-4 text-cyan-600 bg-gray-700 border-gray-600 rounded"
                                        checked={currentFilters.severity.includes(severity as IncidentSeverity)}
                                        onChange={(e) => handleSeverityChange(severity as IncidentSeverity, e.target.checked)}
                                    />
                                    <span className="ml-2">{severity}</span>
                                </label>
                            ))}
                        </div>
                    </div>
                    <div>
                        <h6 className="text-sm font-semibold text-gray-300 mb-2">Service</h6>
                        <select
                            className="w-full py-2 px-3 rounded-md bg-gray-700 border border-gray-600 text-white text-sm"
                            value={currentFilters.service || ''}
                            onChange={(e) => handleServiceChange(e.target.value)}
                        >
                            <option value="">All Services</option>
                            {allServices.map(service => (
                                <option key={service} value={service}>{service}</option>
                            ))}
                        </select>
                    </div>
                </Card>
            )}
        </div>
    );
};

export const NewIncidentModal: React.FC<{
    onClose: () => void;
    onIncidentCreated: (incident: DetailedIncident) => void;
    users: UserProfile[];
    services: ServiceHealthMetric[];
}> = ({ onClose, onIncidentCreated, users, services }) => {
    const [newIncident, setNewIncident] = useState<Partial<DetailedIncident>>({
        title: '',
        description: '',
        severity: 'SEV3',
        status: 'ACTIVE',
        source: 'MANUAL',
        affectedServices: [],
        ownerId: '',
        tags: [],
    });
    const [isCreating, setIsCreating] = useState(false);
    const { currentUser } = useContext(DataContext);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setNewIncident(prev => ({ ...prev, [name]: value }));
    };

    const handleServiceSelect = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const selectedOptions = Array.from(e.target.selectedOptions, option => option.value);
        setNewIncident(prev => ({ ...prev, affectedServices: selectedOptions }));
    };

    const handleTagsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const tags = e.target.value.split(',').map(tag => tag.trim()).filter(Boolean);
        setNewIncident(prev => ({ ...prev, tags }));
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!newIncident.title || !newIncident.description) {
            alert('Title and Description are required.');
            return;
        }

        setIsCreating(true);
        try {
            const createdIncident = await IncidentApiService.createIncident(newIncident, currentUser?.id || 'system');
            onIncidentCreated(createdIncident);
            onClose();
            alert('Incident created successfully!');
        } catch (error) {
            console.error('Error creating incident:', error);
            alert('Failed to create incident.');
        } finally {
            setIsCreating(false);
        }
    };

    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full" onClick={e => e.stopPropagation()}>
                <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">Create New Incident</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl font-bold leading-none">&times;</button>
                </div>
                <form onSubmit={handleSubmit} className="p-6 space-y-4 max-h-[70vh] overflow-y-auto">
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="title">Title:</label>
                        <input
                            type="text" id="title" name="title"
                            className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                            value={newIncident.title} onChange={handleInputChange} required
                        />
                    </div>
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="description">Description:</label>
                        <textarea
                            id="description" name="description"
                            className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-24"
                            value={newIncident.description} onChange={handleInputChange} required
                        />
                    </div>
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="impactDescription">Impact Description:</label>
                        <textarea
                            id="impactDescription" name="impactDescription"
                            className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-16"
                            value={newIncident.impactDescription || ''} onChange={handleInputChange}
                        />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="severity">Severity:</label>
                            <select
                                id="severity" name="severity"
                                className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                                value={newIncident.severity} onChange={handleInputChange}
                            >
                                {['SEV1', 'SEV2', 'SEV3', 'SEV4', 'SEV5'].map(sev => <option key={sev} value={sev}>{sev}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="source">Source:</label>
                            <select
                                id="source" name="source"
                                className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                                value={newIncident.source} onChange={handleInputChange}
                            >
                                {['MANUAL', 'MONITORING_ALERT', 'USER_REPORT', 'API_ERROR', 'SYSTEM_LOG'].map(src => <option key={src} value={src}>{src.replace('_', ' ')}</option>)}
                            </select>
                        </div>
                    </div>
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="affectedServices">Affected Services:</label>
                        <select
                            id="affectedServices" name="affectedServices" multiple
                            className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600 h-24"
                            value={newIncident.affectedServices} onChange={handleServiceSelect}
                        >
                            {services.map(s => <option key={s.serviceName} value={s.serviceName}>{s.serviceName}</option>)}
                        </select>
                    </div>
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="ownerId">Assign Owner:</label>
                        <select
                            id="ownerId" name="ownerId"
                            className="shadow border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                            value={newIncident.ownerId} onChange={handleInputChange}
                        >
                            <option value="">Unassigned</option>
                            {users.filter(u => u.role === 'ENGINEER' || u.role === 'MANAGER' || u.onCall).map(user => (
                                <option key={user.id} value={user.id}>{user.name} {user.onCall && '(On-Call)'}</option>
                            ))}
                        </select>
                    </div>
                    <div>
                        <label className="block text-gray-300 text-sm font-bold mb-1" htmlFor="tags">Tags (comma-separated):</label>
                        <input
                            type="text" id="tags" name="tags"
                            className="shadow appearance-none border rounded w-full py-2 px-3 text-white leading-tight focus:outline-none focus:shadow-outline bg-gray-700 border-gray-600"
                            value={newIncident.tags?.join(', ') || ''} onChange={handleTagsChange}
                        />
                    </div>
                    <div className="flex justify-end space-x-4 pt-4 border-t border-gray-700 mt-6">
                        <button
                            type="button"
                            onClick={onClose}
                            className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                        >
                            Cancel
                        </button>
                        <button
                            type="submit"
                            className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                            disabled={isCreating}
                        >
                            {isCreating ? 'Creating...' : 'Create Incident'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};


const IncidentResponseView: React.FC = () => {
    const context = useContext(DataContext);
    if (!context) throw new Error("IncidentResponseView must be within DataProvider");

    const { currentUser } = context;
    const [incidents, setIncidents] = useState<DetailedIncident[]>([]);
    const [selectedIncident, setSelectedIncident] = useState<DetailedIncident | null>(null);
    const [isLoadingIncidents, setIsLoadingIncidents] = useState(true);
    const [serviceHealthMetrics, setServiceHealthMetrics] = useState<ServiceHealthMetric[]>([]);
    const [users, setUsers] = useState<UserProfile[]>([]);
    const [isNewIncidentModalOpen, setIsNewIncidentModalOpen] = useState(false);
    const [filters, setFilters] = useState<{ status: IncidentStatus[], severity: IncidentSeverity[], service: string, search: string }>({
        status: ['ACTIVE', 'INVESTIGATING'],
        severity: [],
        service: '',
        search: ''
    });

    const fetchAllData = useCallback(async () => {
        setIsLoadingIncidents(true);
        try {
            const fetchedIncidents = await IncidentApiService.fetchIncidents(filters);
            setIncidents(fetchedIncidents);

            const fetchedServiceHealth = await IncidentApiService.fetchServiceHealth();
            setServiceHealthMetrics(fetchedServiceHealth);

            const fetchedUsers = await IncidentApiService.fetchUsers();
            setUsers(fetchedUsers);
        } catch (error) {
            console.error('Error fetching data:', error);
        } finally {
            setIsLoadingIncidents(false);
        }
    }, [filters]);

    useEffect(() => {
        fetchAllData();
        const intervalId = setInterval(fetchAllData, 30000);
        return () => clearInterval(intervalId);
    }, [fetchAllData]);

    const handleIncidentSelect = async (inc: Incident) => {
        try {
            const detailedInc = await IncidentApiService.fetchIncidentById(inc.id);
            if (detailedInc) {
                setSelectedIncident(detailedInc);
            } else {
                console.error('Detailed incident not found:', inc.id);
            }
        } catch (error) {
            console.error('Error fetching detailed incident:', error);
        }
    };

    const handleUpdateIncidentInList = (updatedIncident: DetailedIncident) => {
        setIncidents(prev => prev.map(inc => inc.id === updatedIncident.id ? updatedIncident : inc));
        setSelectedIncident(updatedIncident);
        fetchAllData();
    };

    const handleFilterChange = (newFilters: Partial<{ status: IncidentStatus[], severity: IncidentSeverity[], service: string }>) => {
        setFilters(prev => ({ ...prev, ...newFilters }));
    };

    const handleSearch = (searchTerm: string) => {
        setFilters(prev => ({ ...prev, search: searchTerm }));
    };

    const handleNewIncidentCreated = (newIncident: DetailedIncident) => {
        setIncidents(prev => [newIncident, ...prev]);
        fetchAllData(); // Refresh all data to ensure metrics etc. are up to date
    };

    const availableServices = [...new Set(serviceHealthMetrics.map(s => s.serviceName))];

    const [originalSelectedIncidentForPostmortem, setOriginalSelectedIncidentForPostmortem] = useState<Incident | null>(null);
    const [originalPostmortemText, setOriginalPostmortemText] = useState('');
    const [originalIsLoading, setOriginalIsLoading] = useState(false);

    const handleOriginalGenerate = async (incident: Incident) => {
        setOriginalSelectedIncidentForPostmortem(incident);
        setOriginalIsLoading(true); setOriginalPostmortemText('');
        try {
            const ai = new GoogleGenAI({apiKey: process.env.API_KEY as string});
            const prompt = `Generate a postmortem for this incident: "${incident.title}" (Severity: ${incident.severity}). Include sections for Summary, Impact, Root Cause, and Action Items.`;
            const response = await ai.models.generateContent({model: 'gemini-1.5-flash', contents: [{ text: prompt }]});
            setOriginalPostmortemText(response.text);
        } catch(err) { console.error(err); } finally { setOriginalIsLoading(false); }
    };

    return (
        <>
        <div className="space-y-8 pb-10">
            <div className="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4">
                <h2 className="text-4xl font-extrabold text-white tracking-wider flex-shrink-0">Incident Response Dashboard</h2>
                <div className="flex flex-grow w-full md:w-auto items-center space-x-4 justify-end">
                    <GlobalSearch onSearch={handleSearch} />
                    <FilterPanel onFilterChange={handleFilterChange} currentFilters={filters} allServices={availableServices} />
                    <button onClick={() => setIsNewIncidentModalOpen(true)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex items-center space-x-2 transition-colors">
                        <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" /></svg>
                        <span>New Incident</span>
                    </button>
                </div>
            </div>

            <IncidentSummaryMetrics incidents={incidents} />

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2">
                    <Card title="Incident Queue" className="h-full">
                        {isLoadingIncidents ? (
                            <p className="text-gray-400 text-center py-8">Loading incidents...</p>
                        ) : incidents.length === 0 ? (
                            <p className="text-gray-400 text-center py-8">No incidents found matching current filters.</p>
                        ) : (
                            <div className="overflow-x-auto custom-scrollbar">
                                <table className="min-w-full text-sm divide-y divide-gray-700">
                                    <thead className="text-xs text-gray-300 uppercase bg-gray-900/30 sticky top-0">
                                        <tr>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">ID</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Title</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Severity</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Status</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Owner</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Affected Services</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Created</th>
                                            <th scope="col" className="px-6 py-3 text-left font-medium">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-800">
                                        {incidents.map(inc => (
                                            <tr key={inc.id} className="hover:bg-gray-800/50 transition-colors">
                                                <td className="px-6 py-4 text-gray-400">{inc.id}</td>
                                                <td className="px-6 py-4 text-white font-medium cursor-pointer hover:text-cyan-400" onClick={() => handleIncidentSelect(inc)}>
                                                    {inc.title}
                                                </td>
                                                <td className="px-6 py-4">
                                                    <span className={`px-2 py-1 text-xs font-semibold rounded-full ${getSeverityColorClass(inc.severity)}`}>
                                                        {inc.severity}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4">
                                                    <span className={`font-semibold ${getStatusColorClass(inc.status)}`}>
                                                        {inc.status}
                                                    </span>
                                                </td>
                                                <td className="px-6 py-4 text-gray-300">
                                                    {users.find(u => u.id === inc.ownerId)?.name || 'Unassigned'}
                                                </td>
                                                <td className="px-6 py-4 text-gray-300">
                                                    {inc.affectedServices.join(', ') || 'N/A'}
                                                </td>
                                                <td className="px-6 py-4 text-gray-300 text-xs">
                                                    {formatTimestamp(inc.createdAt, false)}
                                                </td>
                                                <td className="px-6 py-4 text-center whitespace-nowrap">
                                                    <button onClick={() => handleIncidentSelect(inc)} className="text-xs text-cyan-400 hover:text-cyan-300 mr-2">View Details</button>
                                                    <button onClick={() => handleOriginalGenerate(inc)} className="text-xs text-indigo-400 hover:text-indigo-300">AI Postmortem (Legacy)</button>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </Card>
                </div>
                <div className="lg:col-span-1 flex flex-col space-y-6">
                    <ServiceHealthStatus serviceMetrics={serviceHealthMetrics} />
                    <Card title="On-Call Engineers" className="p-4">
                        <div className="space-y-3">
                            {users.filter(u => u.onCall).length === 0 && <p className="text-gray-400">No one is currently on-call.</p>}
                            {users.filter(u => u.onCall).map(user => (
                                <div key={user.id} className="flex items-center space-x-3 py-2 px-3 bg-gray-800 rounded-md">
                                    <span className="relative flex h-3 w-3">
                                        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                                        <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
                                    </span>
                                    <p className="font-semibold text-white">{user.name}</p>
                                    <p className="text-sm text-gray-400 flex-grow text-right">{user.role}</p>
                                    {user.slackId && (
                                        <a href={`https://slack.com/app_redirect?channel=${user.slackId}`} target="_blank" rel="noopener noreferrer" className="text-cyan-400 text-sm hover:underline">Slack</a>
                                    )}
                                </div>
                            ))}
                        </div>
                    </Card>
                </div>
            </div>

            <Card title="Historical Incident Trends (Last 30 Days)">
                <div className="h-72 w-full flex items-center justify-center text-gray-500">
                    <p>Advanced charting for incident volume, MTTR, etc. over time would be implemented here using a charting library.</p>
                </div>
            </Card>

        </div>
        {selectedIncident && (
            <IncidentDetailsModal
                incident={selectedIncident}
                users={users}
                onClose={() => setSelectedIncident(null)}
                onUpdateIncident={handleUpdateIncidentInList}
            />
        )}
        {isNewIncidentModalOpen && (
            <NewIncidentModal
                onClose={() => setIsNewIncidentModalOpen(false)}
                onIncidentCreated={handleNewIncidentCreated}
                users={users}
                services={serviceHealthMetrics}
            />
        )}
        {originalSelectedIncidentForPostmortem && (
             <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50" onClick={() => setOriginalSelectedIncidentForPostmortem(null)}>
                <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full" onClick={e=>e.stopPropagation()}>
                    <div className="p-4 border-b border-gray-700"><h3 className="text-lg font-semibold text-white">AI Postmortem for {originalSelectedIncidentForPostmortem.id} (Legacy)</h3></div>
                    <div className="p-6 space-y-4 max-h-[70vh] overflow-y-auto custom-scrollbar">
                       <div className="min-h-[15rem] whitespace-pre-line text-sm text-gray-300">{originalIsLoading ? 'Generating...' : originalPostmortemText}</div>
                    </div>
                    <div className="p-4 border-t border-gray-700 flex justify-end">
                        <button onClick={() => setOriginalSelectedIncidentForPostmortem(null)} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Close</button>
                    </div>
                </div>
             </div>
        )}
        </>
    );
};

export default IncidentResponseView;

--- FILE: ObservabilityView.tsx ---

import React, { useState, useEffect, useRef, useCallback, useReducer, createContext, useContext } from 'react';
import Card from '../../../Card';
import { GoogleGenAI } from "@google/genai";
// import type { MessageContent, Part } from "@google/genai"; // Assuming these types exist in @google/genai if we were to use them explicitly
import {
    ChevronDownIcon, ChevronUpIcon, MagnifyingGlassIcon, ChartBarIcon,
    BellIcon, CubeIcon, Squares2X2Icon, BoltIcon, Cog6ToothIcon, ClockIcon,
    ArrowPathIcon, ExclamationTriangleIcon, InformationCircleIcon, CheckCircleIcon,
    PlusIcon, PencilIcon, TrashIcon, DocumentDuplicateIcon, PlayIcon, StopIcon,
    TableCellsIcon, CodeBracketIcon, ServerStackIcon, EyeIcon, AdjustmentsHorizontalIcon,
    FunnelIcon, ShareIcon, PrinterIcon, ArrowTopRightOnSquareIcon, MinusIcon, SunIcon, MoonIcon,
    Bars3BottomLeftIcon, XMarkIcon,
} from '@heroicons/react/24/outline'; // Assuming Heroicons for a richer UI

// --- Start of new code for 10000 lines ---

// #region 1. Global Constants and Configurations

/**
 * @file This file contains the ObservabilityView component, a comprehensive
 * dashboard for logs, metrics, traces, alerts, and AI-driven insights.
 * It is designed to be a "real application in the real world" by providing
 * a vast array of features and functionalities, even if some backend integrations
 * are simulated for the purpose of this example.
 *
 * The goal is to demonstrate a large-scale, enterprise-grade observability platform
 * within a single file, showcasing a wide range of React patterns, state management,
 * data structures, and UI components.
 */

export const APP_NAME = "MegaDashboard Observability";
export const API_BASE_URL = "/api/observability"; // Placeholder for API endpoints
export const DEFAULT_TIME_RANGE_MS = 60 * 60 * 1000; // 1 hour
export const REFRESH_INTERVAL_MS = 30 * 1000; // 30 seconds
export const MAX_LOG_LINES_DISPLAY = 1000;
export const MAX_AI_TOKEN_LENGTH = 4000; // Example for Gemini 1.0 Pro
export const VIRTUALIZED_ROW_HEIGHT = 28; // Pixels for log table rows

export enum ObservabilityTab {
    Logs = 'logs',
    Metrics = 'metrics',
    Traces = 'traces',
    Alerts = 'alerts',
    Dashboards = 'dashboards',
    AIInsights = 'ai-insights',
    Settings = 'settings',
}

export enum LogLevel {
    DEBUG = 'DEBUG',
    INFO = 'INFO',
    WARN = 'WARN',
    ERROR = 'ERROR',
    CRITICAL = 'CRITICAL',
}

export enum MetricAggregationType {
    SUM = 'sum',
    AVG = 'avg',
    MIN = 'min',
    MAX = 'max',
    COUNT = 'count',
    P99 = 'p99',
    P95 = 'p95',
}

export enum AlertSeverity {
    INFO = 'info',
    WARNING = 'warning',
    CRITICAL = 'critical',
    EMERGENCY = 'emergency',
}

export enum DataSourceType {
    LOGS = 'logs',
    METRICS = 'metrics',
    TRACES = 'traces',
    COMBINED = 'combined', // For data sources that provide multiple types
}

export enum AIInsightType {
    SUMMARY = 'summary',
    ROOT_CAUSE = 'root_cause',
    ANOMALY_EXPLANATION = 'anomaly_explanation',
    RECOMMENDATION = 'recommendation',
    PREDICTION = 'prediction',
}

export const QUICK_TIME_RANGES = [
    { label: 'Last 5 minutes', value: 5 * 60 * 1000 },
    { label: 'Last 15 minutes', value: 15 * 60 * 1000 },
    { label: 'Last 30 minutes', value: 30 * 60 * 1000 },
    { label: 'Last 1 hour', value: 60 * 60 * 1000 },
    { label: 'Last 3 hours', value: 3 * 60 * 60 * 1000 },
    { label: 'Last 6 hours', value: 6 * 60 * 60 * 1000 },
    { label: 'Last 12 hours', value: 12 * 60 * 60 * 1000 },
    { label: 'Last 24 hours', value: 24 * 60 * 60 * 1000 },
    { label: 'Last 7 days', value: 7 * 24 * 60 * 60 * 1000 },
    { label: 'Last 30 days', value: 30 * 24 * 60 * 60 * 1000 },
];

export const SERVICE_NAMES = [
    'payments-api', 'auth-service', 'user-profile-service', 'inventory-service',
    'order-processing', 'notification-service', 'frontend-bff', 'data-ingestion-worker',
    'reporting-service', 'search-engine', 'billing-processor', 'shipping-tracker',
];

export const HTTP_STATUS_CODES = [200, 201, 204, 400, 401, 403, 404, 429, 500, 502, 503, 504];

export const LOG_FIELDS_COMMON = [
    'timestamp', 'level', 'service', 'message', 'traceId', 'spanId', 'userId',
    'requestId', 'statusCode', 'method', 'path', 'durationMs', 'region',
    'env', 'host', 'containerId', 'threadName', 'className',
];

// #endregion

// #region 2. Interfaces and Types

export interface TimeRange {
    start: number; // Unix timestamp in milliseconds
    end: number;   // Unix timestamp in milliseconds
    label?: string; // e.g., "Last 1 hour"
}

export interface LogEntry {
    id: string;
    timestamp: number; // Unix timestamp in milliseconds
    level: LogLevel;
    service: string;
    message: string;
    // biome-ignore lint/suspicious/noExplicitAny: Dynamic log fields
    [key: string]: any; // Arbitrary additional fields
}

export interface LogFilter {
    timeRange: TimeRange;
    levels: LogLevel[];
    services: string[];
    searchText: string;
    fields: Record<string, string>; // e.g., { 'statusCode': '500' }
    pageSize: number;
    page: number;
    sortField: keyof LogEntry;
    sortOrder: 'asc' | 'desc';
}

export interface LogAggregationResult {
    timestamp: number;
    count: number;
    levels: Record<LogLevel, number>;
}

export interface MetricSeries {
    name: string;
    labels: Record<string, string>;
    datapoints: Array<[number, number]>; // [timestamp, value]
}

export interface MetricQueryConfig {
    metricName: string;
    aggregation: MetricAggregationType;
    groupBy: string[]; // Labels to group by
    filters: Record<string, string>; // Label filters
    timeRange: TimeRange;
    resolutionMs: number; // Interval between datapoints
}

export interface TraceSpan {
    traceId: string;
    spanId: string;
    parentSpanId?: string;
    serviceName: string;
    operationName: string;
    startTime: number; // Unix timestamp in microseconds
    duration: number;  // Microseconds
    // biome-ignore lint/suspicious/noExplicitAny: Dynamic trace tags
    tags: Record<string, any>;
    logs?: LogEntry[]; // Associated logs
    error?: boolean;
}

export interface TraceSegment {
    id: string;
    parentId?: string;
    traceId: string;
    serviceName: string;
    operationName: string;
    startTime: number;
    duration: number;
    // biome-ignore lint/suspicious/noExplicitAny: Dynamic trace tags
    tags: Record<string, any>;
    children: TraceSegment[];
    logs?: LogEntry[];
    error: boolean;
}

export interface AlertCondition {
    metricName: string;
    threshold: number;
    operator: '>' | '<' | '>=' | '<=' | '==' | '!=';
    aggregation: MetricAggregationType;
    durationMs: number; // How long condition must be met
}

export interface AlertNotificationChannel {
    type: 'email' | 'slack' | 'webhook';
    target: string; // e.g., email address, slack channel ID, webhook URL
}

export interface AlertRule {
    id: string;
    name: string;
    description: string;
    severity: AlertSeverity;
    enabled: boolean;
    conditions: AlertCondition[];
    notificationChannels: AlertNotificationChannel[];
    lastEvaluated?: number;
    lastTriggered?: number;
}

export interface ActiveAlert extends AlertRule {
    triggeredAt: number;
    resolvedAt?: number;
    currentValue: number;
    triggeringCondition: AlertCondition;
    status: 'triggered' | 'acknowledged' | 'resolved';
}

export interface DashboardPanel {
    id: string;
    title: string;
    type: 'logTable' | 'metricChart' | 'traceServiceMap' | 'alertSummary' | 'customMarkdown';
    // biome-ignore lint/suspicious/noExplicitAny: Dynamic panel config
    config: any; // e.g., LogFilter for logTable, MetricQueryConfig for metricChart
    x: number;
    y: number;
    w: number;
    h: number;
}

export interface DashboardConfig {
    id: string;
    name: string;
    description?: string;
    panels: DashboardPanel[];
    layout: 'grid' | 'freeform';
    timeRange?: TimeRange;
    isPublic: boolean;
    createdAt: number;
    updatedAt: number;
}

export interface DataSourceConfig {
    id: string;
    name: string;
    type: DataSourceType;
    endpoint: string;
    apiKey?: string;
    enabled: boolean;
    metadata?: Record<string, string>; // e.g., region, provider
}

export interface SavedQuery {
    id: string;
    name: string;
    description?: string;
    queryType: ObservabilityTab; // e.g., 'logs', 'metrics'
    // biome-ignore lint/suspicious/noExplicitAny: Dynamic query config
    queryConfig: any; // e.g., LogFilter, MetricQueryConfig
    createdAt: number;
    lastUsedAt: number;
}

export interface AIAnalysisResult {
    id: string;
    type: AIInsightType;
    timestamp: number;
    summary