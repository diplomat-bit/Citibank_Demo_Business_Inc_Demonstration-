syntax = "proto3";

package elysian_archive;

// Consciousness Upload & Emulation Sanctuary (CUES) API Specification
// Defines the gRPC API specification for interfacing with the quantum-classical hybrid computing substrate
// for consciousness emulation within the Elysian Archive. This API facilitates high-fidelity,
// fault-tolerant interaction with emulated consciousness, ensuring subjective continuity and
// supporting pathways to digital immortality.

// Enumeration representing the current operational status of a consciousness emulation instance.
enum EmulationStatus {
  EMULATION_STATUS_UNSPECIFIED = 0;          // Default, uninitialized status.
  EMULATION_STATUS_PENDING = 1;              // Emulation request received, awaiting resource allocation or processing.
  EMULATION_STATUS_INITIALIZING = 2;         // Computing substrate is being prepared, connectome loading in progress.
  EMULATION_STATUS_RUNNING = 3;              // Emulation is actively processing, simulating neural dynamics, and generating output.
  EMULATION_STATUS_PAUSED = 4;               // Emulation execution is temporarily suspended.
  EMULATION_STATUS_TERMINATED = 5;           // Emulation has been gracefully shut down and resources deallocated.
  EMULATION_STATUS_ERROR = 6;                // An unrecoverable error has occurred within the emulation system.
  EMULATION_STATUS_SAVING_SNAPSHOT = 7;      // Emulation state is currently being persisted as a snapshot.
  EMULATION_STATUS_LOADING_SNAPSHOT = 8;     // Emulation is being restored from a previously saved snapshot.
  EMULATION_STATUS_UPDATING = 9;             // Emulation parameters or substrate are being updated.
}

// Commands applicable for controlling the state transitions of an emulation instance.
enum EmulationStateCommand {
  EMULATION_COMMAND_UNSPECIFIED = 0;         // Default, no specific command.
  EMULATION_COMMAND_PAUSE = 1;               // Request to suspend the emulation's execution.
  EMULATION_COMMAND_RESUME = 2;              // Request to resume a suspended emulation.
  EMULATION_COMMAND_TERMINATE = 3;           // Request to permanently shut down the emulation and release resources.
  EMULATION_COMMAND_SAVE_SNAPSHOT = 4;       // Request to create a point-in-time snapshot of the emulation's state.
  EMULATION_COMMAND_LOAD_SNAPSHOT = 5;       // Request to load the emulation from a specified snapshot.
  EMULATION_COMMAND_UPDATE_CONFIG = 6;       // Request to apply new configuration parameters to a running emulation.
}

// Defines the various modalities or types of input that can be supplied to an emulated consciousness.
enum ConsciousnessInputType {
  INPUT_TYPE_UNSPECIFIED = 0;                // Default, unspecified input type.
  INPUT_TYPE_VISUAL = 1;                     // Visual sensory data (e.g., image frames, video streams).
  INPUT_TYPE_AUDITORY = 2;                   // Auditory sensory data (e.g., audio samples, soundscapes).
  INPUT_TYPE_SOMATOSENSORY = 3;              // Tactile, proprioceptive, or interoceptive feedback.
  INPUT_TYPE_DIRECT_NEURAL_STIMULATION = 4;  // Simulated direct stimulation of neural pathways or patterns.
  INPUT_TYPE_CONCEPTUAL = 5;                 // High-level abstract or symbolic conceptual data.
  INPUT_TYPE_VIRTUAL_ENVIRONMENT_STATE = 6;  // State updates from an interactive virtual reality environment.
}

// Defines the various modalities or types of emergent output that can be generated by an emulated consciousness.
enum ConsciousnessOutputType {
  OUTPUT_TYPE_UNSPECIFIED = 0;               // Default, unspecified output type.
  OUTPUT_TYPE_THOUGHT_FRAGMENT = 1;          // Granular semantic content representing internal thought processes.
  OUTPUT_TYPE_EMOTIONAL_STATE = 2;           // Quantitative or qualitative representation of affective state.
  OUTPUT_TYPE_ACTION_INTENT = 3;             // Volitional intent or high-level motor commands for external interaction.
  OUTPUT_TYPE_EMERGENT_CONCEPT = 4;          // Novel or refined conceptual representations generated by the emulation.
  OUTPUT_TYPE_NEURAL_SPIKE_PATTERN = 5;      // Raw or processed neural firing patterns from specific brain regions.
  OUTPUT_TYPE_SYNTHESIZED_SPEECH = 6;        // Synthesized verbal communication output.
  OUTPUT_TYPE_VIRTUAL_AVATAR_CONTROL = 7;    // Commands for controlling an avatar within a virtual environment.
}

// Represents the detailed neuro-scanning data for an individual's consciousness.
message ConnectomeData {
  bytes high_resolution_connectome_data = 1; // Binary payload of the structural connectome data.
  bytes functional_map_data = 2;             // Binary payload of the dynamic functional map or brain state data.
  string connectome_format_version = 3;      // Version identifier for the specific connectome data format used.
  string data_checksum = 4;                  // Cryptographic checksum (e.g., SHA256) for integrity verification.
  optional string encryption_key_id = 5;     // Identifier for the encryption key used to secure the data.
}

// Request message for initiating the upload of an individual's connectome data.
message UploadConnectomeRequest {
  string user_id = 1;                        // Unique identifier for the biological individual associated with this connectome.
  bytes identity_signature = 2;              // Cryptographic signature from the user, verifying consent and ownership.
  ConnectomeData connectome = 3;             // The comprehensive connectome and functional map data.
  map<string, string> metadata = 4;          // Additional metadata (e.g., source neuro-scanner type, date of scan).
}

// Response message after a connectome upload attempt.
message UploadConnectomeResponse {
  string emulation_id = 1;                   // Unique identifier assigned to this potential emulation instance.
  EmulationStatus status = 2;                // Current status of the connectome ingestion process.
  string message = 3;                        // Human-readable status or error description.
  optional string estimated_processing_time_s = 4; // Estimated time (in seconds) for initial data processing.
}

// Request message for initializing or starting a consciousness emulation instance.
message InitializeEmulationRequest {
  string emulation_id = 1;                   // The identifier of the connectome to be emulated.
  optional string snapshot_id = 2;           // Optional: If provided, initializes the emulation from this snapshot.
  map<string, string> resource_allocation_params = 3; // Key-value pairs for specifying computational resources.
                                                      // E.g., {"quantum_cores": "10", "classical_flops_per_sec": "1e18", "memory_gb": "256"}.
  bool start_immediately = 4;                // If true, the emulation will transition to RUNNING immediately after initialization.
  optional string emulation_name = 5;        // A user-friendly, descriptive name for this specific emulation instance.
  map<string, string> configuration_params = 6; // Additional configuration parameters for the emulation model (e.g., fidelity settings).
}

// Response message after an emulation initialization attempt.
message InitializeEmulationResponse {
  string emulation_id = 1;                   // The identifier of the initialized emulation instance.
  EmulationStatus status = 2;                // The current operational status of the emulation.
  string message = 3;                        // Human-readable status or error description.
}

// Represents a single discrete unit of input data to the emulated consciousness.
message ConsciousnessInputPacket {
  string emulation_id = 1;                   // Identifier of the target emulation instance.
  ConsciousnessInputType type = 2;           // The specific modality or type of this input packet.
  bytes data = 3;                            // The raw binary payload of the input data.
  uint64 timestamp_ns = 4;                   // High-precision timestamp in nanoseconds of the input event.
  map<string, string> metadata = 5;          // Additional metadata (e.g., "visual_resolution": "4K", "audio_samplerate": "48kHz").
}

// Represents a single discrete unit of output data from the emulated consciousness.
message ConsciousnessOutputPacket {
  string emulation_id = 1;                   // Identifier of the source emulation instance.
  ConsciousnessOutputType type = 2;          // The specific modality or type of this output packet.
  bytes data = 3;                            // The raw binary payload of the output data.
  uint64 timestamp_ns = 4;                   // High-precision timestamp in nanoseconds of the output event.
  map<string, string> metadata = 5;          // Additional metadata (e.g., "emotional_valence": "positive", "confidence_score": "0.95").
}

// Control parameters for managing the bidirectional consciousness streaming session.
message StreamControlRequest {
  repeated ConsciousnessOutputType requested_output_types = 1; // Filter to receive only specified output types.
  bool enable_realtime_feedback = 2;         // Request for system-level performance feedback (latency, throughput).
  optional uint64 max_latency_ns = 3;        // Optional: Maximum acceptable latency for real-time interaction.
  optional bool disable_input = 4;           // Optional: Temporarily disable input processing for the stream.
}

// Status updates and feedback messages for the bidirectional consciousness streaming session.
message StreamStatusResponse {
  bool is_active = 1;                        // Indicates if the streaming channel is actively transferring data.
  string message = 2;                        // Human-readable status or warning message regarding the stream.
  optional uint64 current_latency_ns = 3;    // Current observed end-to-end latency for stream data in nanoseconds.
  map<string, string> stream_metrics = 4;    // Additional real-time performance metrics (e.g., "packet_loss_rate": "0.01%").
}

// Request message structure for the bidirectional `StreamConsciousness` RPC.
// Allows sending input packets or stream control commands.
message ConsciousnessStreamRequest {
  string emulation_id = 1;                   // The target emulation instance ID for this stream.
  oneof payload {
    ConsciousnessInputPacket input_packet = 2;  // An input data packet for the emulation.
    StreamControlRequest control_request = 3;   // A control command for the streaming session.
  }
}

// Response message structure for the bidirectional `StreamConsciousness` RPC.
// Allows receiving output packets or stream status updates.
message ConsciousnessStreamResponse {
  string emulation_id = 1;                   // The source emulation instance ID for this stream.
  oneof payload {
    ConsciousnessOutputPacket output_packet = 2; // An output data packet from the emulation.
    StreamStatusResponse status_response = 3;    // A status update for the streaming session.
  }
}

// Request message for commanding a state change of an emulation.
message ControlEmulationStateRequest {
  string emulation_id = 1;                   // Identifier of the target emulation instance.
  EmulationStateCommand command = 2;         // The desired state transition command.
  optional string snapshot_name = 3;         // Required if `command` is `SAVE_SNAPSHOT`, a user-defined name.
  optional string target_snapshot_id = 4;    // Required if `command` is `LOAD_SNAPSHOT`, specifying which snapshot to load.
  map<string, string> update_config_params = 5; // Parameters for `UPDATE_CONFIG` command.
}

// Response message after attempting an emulation state change.
message ControlEmulationStateResponse {
  string emulation_id = 1;                   // Identifier of the controlled emulation.
  EmulationStatus new_status = 2;            // The resulting operational status of the emulation.
  string message = 3;                        // Human-readable status or error description.
  optional string generated_snapshot_id = 4; // If `SAVE_SNAPSHOT` was successful, the ID of the new snapshot.
}

// Request message for querying the current status and detailed metrics of an emulation.
message QueryEmulationStatusRequest {
  string emulation_id = 1;                   // Identifier of the target emulation instance.
  repeated string requested_metrics = 2;     // Optional: Specific metric names to include in the response.
                                             // E.g., "cpu_usage", "fidelity_score", "quantum_coherence_index".
}

// Represents a single performance or operational metric associated with an emulation.
message EmulationMetric {
  string name = 1;                           // Canonical name of the metric (e.g., "CPU_Utilization").
  string value = 2;                          // String representation of the metric's numerical or categorical value.
  uint64 timestamp_ns = 3;                   // Timestamp in nanoseconds when the metric was recorded.
  map<string, string> metadata = 4;          // Additional context for the metric (e.g., "unit": "%", "aggregation_period": "60s").
}

// Response message containing the status and detailed metrics of an emulation.
message QueryEmulationStatusResponse {
  string emulation_id = 1;                   // Identifier of the queried emulation instance.
  EmulationStatus status = 2;                // Current top-level operational status.
  string message = 3;                        // Human-readable status or error description.
  map<string, string> resource_usage = 4;    // Map of resource type to current usage (e.g., "QuantumCores": "5/10", "GPU_Memory": "75%").
  repeated EmulationMetric metrics = 5;      // Detailed list of requested and available performance metrics.
  double fidelity_score = 6;                 // A computed score quantifying the emulation's accuracy against the original connectome.
  double subjective_continuity_index = 7;    // An index quantifying the perceived continuity of subjective experience.
  optional string current_virtual_environment_id = 8; // If applicable, the ID of the virtual environment the emulation is interacting with.
  optional string last_activity_timestamp_ns = 9; // Timestamp of the last detected activity.
}

// Detailed information about a specific emulation snapshot.
message SnapshotDetails {
  string snapshot_id = 1;                    // Unique cryptographic identifier for the snapshot.
  string name = 2;                           // User-defined name for the snapshot.
  uint64 creation_timestamp_ns = 3;          // High-precision timestamp of when the snapshot was created.
  optional string description = 4;           // Optional: A brief description or purpose of the snapshot.
  string data_checksum = 5;                  // Cryptographic checksum of the snapshot data for integrity.
  string storage_location_id = 6;            // Identifier for the physical or logical storage location of the snapshot.
  map<string, string> metadata = 7;          // Additional metadata (e.g., "size_bytes": "1099511627776").
}

// Request message for listing available snapshots.
message ListSnapshotsRequest {
  optional string emulation_id = 1;          // Optional: Filters snapshots for a specific emulation instance.
  optional string user_id = 2;               // Optional: Filters snapshots associated with a specific user, across multiple emulations.
  optional bool include_archived = 3;        // Optional: If true, includes snapshots marked as archived.
}

// Response message containing a list of snapshot details.
message ListSnapshotsResponse {
  string query_scope_id = 1;                 // The ID (emulation_id or user_id) that was used for the query.
  repeated SnapshotDetails snapshots = 2;    // A list of matching snapshot details.
  string message = 3;                        // Human-readable message indicating query success or issues.
}

// Service definition for the Elysian Archive's Consciousness Emulation capabilities.
service CUESEmulationService {

  // RPC to upload a comprehensive connectome and functional map to the Elysian Archive.
  // This is the foundational step for preparing an individual's consciousness for future emulation,
  // requiring cryptographic verification of identity and consent.
  rpc UploadConnectome (UploadConnectomeRequest) returns (UploadConnectomeResponse);

  // RPC to initialize a consciousness emulation on the designated quantum-classical hybrid computing substrate.
  // This allocates necessary computational resources and sets up the emulation environment,
  // potentially loading from a previous state snapshot.
  rpc InitializeEmulation (InitializeEmulationRequest) returns (InitializeEmulationResponse);

  // Bidirectional streaming RPC for real-time, interactive engagement with an emulated consciousness.
  // Enables simultaneous feeding of sensory/neural input and receiving emergent thoughts, emotions,
  // and action intents from the emulation with minimal latency.
  rpc StreamConsciousness (stream ConsciousnessStreamRequest) returns (stream ConsciousnessStreamResponse);

  // RPC to command operational state transitions for an existing consciousness emulation instance.
  // Supports actions such as pausing, resuming, terminating, or initiating snapshot operations.
  rpc ControlEmulationState (ControlEmulationStateRequest) returns (ControlEmulationStateResponse);

  // RPC to retrieve the current operational status and detailed performance metrics of an emulation.
  // Provides critical insights into emulation fidelity, resource utilization, and subjective continuity indices.
  rpc QueryEmulationStatus (QueryEmulationStatusRequest) returns (QueryEmulationStatusResponse);

  // RPC to list all available snapshots for a given emulation instance or across all emulations associated with a user.
  // This allows for management and selection of saved emulation states for loading.
  rpc ListSnapshots (ListSnapshotsRequest) returns (ListSnapshotsResponse);
}