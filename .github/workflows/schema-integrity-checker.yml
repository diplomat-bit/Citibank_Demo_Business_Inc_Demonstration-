name: Schema Integrity Checker

# ----------------------------------------------------------------------------------------------------------------------
# GitHub Actions Workflow: Schema Integrity Checker
# ----------------------------------------------------------------------------------------------------------------------
#
# FILE: .github/workflows/schema-integrity-checker.yml
# AUTHOR: Your CI/CD Automation Team (Auto-generated by AI Expert Programmer)
# DATE: 2023-10-27 (Initial Creation)
# VERSION: 2.0.0-highly-verbose
#
# DESCRIPTION:
# This advanced GitHub Actions workflow acts as the vigilant guardian of our repository's
# JSON Schema ecosystem. It is meticulously crafted to enforce the highest standards of
# structural correctness and specification compliance for all JSON Schema definition
# files, universally identifiable by their `.schema.json` file extension. This ensures
# that our entire schema landscape remains robust, reliable, and perfectly aligned
# with the authoritative JSON Schema specification.
#
# PURPOSE & MISSION STATEMENT:
# The overarching mission of this workflow is to prevent the silent infiltration of
# invalid, malformed, or non-compliant JSON Schemas into our foundational codebase.
# By rigorously validating each schema against the official JSON Schema Draft 2020-12
# meta-schema, we achieve an unparalleled level of confidence in our schema definitions.
# This proactive approach is indispensable for safeguarding the integrity of our data
# validation pipelines and maintaining a healthy, predictable software architecture.
#
# STRATEGIC IMPORTANCE OF JSON SCHEMA INTEGRITY:
# Our commitment to schema integrity is a cornerstone of our development philosophy,
# delivering multifaceted benefits across the entire software development lifecycle:
#
# 1.  **Unyielding Data Validation Reliability:**
#     At its core, a JSON Schema serves as the definitive contract for data structures.
#     If this contract itself is flawed or ambiguous, any data validated against it
#     will inevitably yield unreliable, inconsistent, or outright erroneous results.
#     Invalid schemas can cause:
#     -   **False Positives:** Valid data might be incorrectly rejected, leading to
#         erroneous application behavior or client-side issues.
#     -   **False Negatives:** Invalid or malicious data might be erroneously accepted,
#         potentially compromising data integrity, security, or system stability.
#     -   **Runtime Crashes:** Schema processing libraries might encounter unhandled
#         exceptions or unexpected behavior when attempting to parse malformed schemas,
#         leading to service disruptions.
#     By rigorously enforcing schema integrity, we establish an immutable foundation
#     for trustworthy and predictable data validation, which is critical for API
#     stability, database consistency, and robust inter-service communication reliability.
#
# 2.  **Elevated Codebase Consistency and Streamlined Maintainability:**
#     Adherence to a universally recognized specification fosters a remarkable degree
#     of uniformity across all schema definitions throughout the project. This
#     consistency significantly:
#     -   **Reduces Cognitive Load:** Developers can quickly grasp the structure and
#         intent of any schema, irrespective of who authored it, accelerating understanding.
#     -   **Simplifies Collaboration:** Teams can collaborate seamlessly on schema
#         development without needing to reconcile divergent structural conventions or
#         ambiguous definitions, enhancing teamwork efficiency.
#     -   **Facilitates Evolution:** Extending, modifying, or refactoring existing schemas
#         becomes a more predictable, less error-prone, and safer endeavor, supporting
#         agile development practices.
#     -   **Enhances Readability:** Clear, spec-compliant schemas are inherently
#         more readable, self-documenting, and easier to audit, which is invaluable
#         for long-term project health.
#
# 3.  **Seamless Integration with the JSON Schema Tooling Ecosystem:**
#     The JSON Schema standard boasts a rich and expansive ecosystem of supporting
#     tools, libraries, and Integrated Development Environment (IDE) integrations.
#     Valid schemas are the gateway to fully leveraging these invaluable resources:
#     -   **Programmatic Validators:** Libraries in various programming languages
#         (e.g., JavaScript, Python, Java, Go, C#) can reliably process and apply
#         valid schemas for runtime data validation.
#     -   **Code Generators:** Automated tools that generate data models, API clients,
#         or type definitions (e.g., TypeScript interfaces) from schemas will function
#         correctly and produce accurate, usable code.
#     -   **Documentation Generators:** Tools that automatically generate API documentation
#         or schema reference guides will accurately render schema specifications,
#         maintaining up-to-date and consistent documentation.
#     -   **Integrated Development Environments (IDEs):** Features like real-time
#         syntax highlighting, intelligent auto-completion, contextual help, and
#         inline validation (e.g., in VS Code) rely heavily on structurally sound schemas.
#         Invalid schemas can lead to broken tooling experiences, hindering developer
#         productivity and introducing frustration.
#
# WORKFLOW TRIGGER MECHANISMS:
# This workflow is strategically configured to activate upon key repository events,
# providing continuous integration and early feedback loops:
#
# -   **`on: push` Events to the `main` Branch:**
#     -   **Scope:** Triggered whenever new commits are directly pushed to the `main`
#         branch, or when changes from other branches are successfully merged into `main`.
#     -   **Purpose:** Serves as a crucial post-integration verification step, ensuring
#         that the canonical state of schemas within the `main` branch always adheres
#         to the highest integrity standards. This confirms that even direct pushes
#         or completed merges maintain schema validity, providing an ultimate safeguard.
#
# -   **`on: pull_request` Events Targeting the `main` Branch:**
#     -   **Scope:** Activated when a pull request (PR) is initially opened, when new
#         commits are pushed to an existing PR branch (`synchronize`), or when a
#         previously closed PR is reopened.
#     -   **Purpose:** Functions as a vital early warning system. By rigorously validating
#         proposed schema changes *before* they are merged into the `main` branch, this
#         workflow empowers developers to identify and rectify any schema invalidities
#         during the code review phase. This proactive validation significantly
#         prevents the introduction of broken schemas into the `main` branch,
#         reducing technical debt and integration risks.
#
# -   **Path Filtering for Enhanced Efficiency:**
#     -   The `paths` configuration is meticulously defined to ensure that the workflow
#         is triggered only when changes relevant to schema definitions or the workflow
#         itself are detected. This intelligent filtering strategy optimizes CI/CD
#         resource consumption by preventing unnecessary workflow runs for unrelated
#         code modifications, thus saving build minutes and accelerating feedback.
#     -   `**/*.schema.json`: Explicitly triggers the workflow for any modification
#         (addition, deletion, or change) to any JSON Schema file, regardless of its
#         location within the repository's directory structure.
#     -   `.github/workflows/schema-integrity-checker.yml`: Ensures that any updates
#         to this workflow definition file itself are also subjected to a validation run,
#         guaranteeing that changes to the validation logic are immediately tested.
#
# TECHNICAL STACK AND KEY COMPONENTS UTILIZED:
#
# -   **GitHub Actions:** The cloud-native Continuous Integration/Continuous Delivery
#     (CI/CD) platform provided directly by GitHub. It efficiently orchestrates the
#     entire execution flow of this automated validation process within isolated,
#     ephemeral virtual machine environments, ensuring consistent and reproducible results.
#
# -   **Node.js Runtime Environment:** A powerful and widely adopted open-source
#     JavaScript runtime environment. It is integral for managing and executing
#     Node Package Manager (`npm`) commands, which are essential for installing
#     JavaScript-based tooling like `ajv-cli`. It provides the foundational
#     execution context for our validation utility.
#
# -   **AJV-CLI (Another JSON Schema Validator Command Line Interface):** This is the
#     central and most critical tool in our validation arsenal. AJV-CLI is universally
#     renowned for its:
#     -   **Exceptional Performance:** Processes schemas with remarkable speed,
#         thereby optimizing workflow run times and providing rapid feedback.
#     -   **Robustness:** Capably handles intricate schema structures, advanced
#         features (e.g., `$ref` resolution, custom keywords), and large schema sets
#         with high reliability.
#     -   **Comprehensive Standard Support:** Fully supports the latest JSON Schema
#         drafts, including the pivotal Draft 2020-12 meta-schema, ensuring our
#         compliance checks are always up-to-date and authoritative.
#
# -   **Bash Scripting:** The versatile, robust, and ubiquitous command-line shell
#     and scripting language used to define and control the procedural logic within
#     the GitHub Actions runner. This encompasses crucial operational tasks such as:
#     -   Dynamically discovering all relevant `.schema.json` files across the repository.
#     -   Managing the iterative validation loop, processing each schema file individually.
#     -   Aggregating and consolidating individual schema validation results.
#     -   Providing detailed, human-readable logging and comprehensive status reporting
#         to the GitHub Actions interface.
#     -   Implementing robust error handling mechanisms within the script execution.
#
# ANTICIPATED WORKFLOW OUTCOMES AND STATUSES:
#
# -   **Workflow Success (‚úÖ Green Checkmark):**
#     -   **Condition:** All discovered `.schema.json` files are meticulously verified
#         and unequivocally confirmed to be valid JSON Schemas, in strict and absolute
#         accordance with the JSON Schema Draft 2020-12 specification.
#     -   **Implication:** This desirable outcome signals a healthy, compliant, and
#         exceptionally well-maintained schema landscape within the repository,
#         instilling complete confidence in the integrity and reliability of our data contracts.
#         The workflow concludes with an exit code of `0`.
#
# -   **Workflow Failure (‚ùå Red Crossmark):**
#     -   **Condition:** If even a single `.schema.json` file is identified as being
#         structurally invalid, containing syntax errors, or failing to comply with
#         any aspect of the JSON Schema specification, the workflow will fail.
#     -   **Implication:** A failure mandates immediate and focused developer attention.
#         It highlights a critical defect in one or more schema definitions that must
#         be rectified before the affected changes can be safely merged into `main`.
#         The workflow concludes with a non-zero exit code (typically `1`).
#
# COMPREHENSIVE TROUBLESHOOTING GUIDE FOR FAILURE RESOLUTION:
# Should this workflow unfortunately indicate a failure, follow these systematic steps
# to diagnose and rectify the identified schema issues efficiently and effectively:
#
# 1.  **Prioritize GitHub Actions Log Review:**
#     -   Immediately navigate to the GitHub Actions run log for the specific workflow
#         execution that registered a failure. The logs are the primary source of truth.
#     -   Focus your meticulous attention on the output generated by **"Step 4: Core Validation
#         - Schema Integrity Verification"**. This step contains the core validation logic
#         and the most detailed error reporting from `ajv-cli`.
#
# 2.  **Pinpoint Problematic Files:**
#     -   Within the voluminous workflow logs, diligently search for messages explicitly
#         indicating "!!! CRITICAL INTEGRITY FAILURE: Validation FAILED for '<filename>'"
#         or similar prominent error indicators.
#     -   Carefully note the exact file paths of all schemas that have failed validation.
#         These are your immediate targets for correction.
#
# 3.  **Conduct Detailed Error Analysis (AJV-CLI Output):**
#     -   Scrutinize the comprehensive and highly granular error messages emitted directly
#         by **AJV-CLI** (displayed just above each "Validation FAILED" summary). AJV provides
#         actionable diagnostic information, often specifying:
#         -   The exact JSON Schema keyword that failed validation (e.g., `type`, `properties`, `required`).
#         -   The expected value or structural type versus the actual value encountered in your schema.
#         -   The JSON Pointer (`#/...`) indicating the precise location within your schema
#             where the error occurred, facilitating direct navigation to the problem area.
#         -   Contextual information about the specific JSON Schema validation rule that was violated.
#
# 4.  **Consult the JSON Schema Specification (Official Reference):**
#     -   For a deeper and authoritative understanding of the validation rules, refer directly
#         to the official JSON Schema Draft 2020-12 specification. It is freely available online at:
#         `https://json-schema.org/draft/2020-12/schema`.
#     -   Pay particular attention to the sections governing the keywords and constructs that
#         are reported as problematic by `ajv-cli`.
#
# 5.  **Leverage Advanced Development Tools (IDE Support and Linters):**
#     -   Utilize a modern Integrated Development Environment (IDE) like Visual Studio Code (VS Code).
#     -   Ensure you have relevant extensions for JSON and YAML language support installed
#         (e.g., "YAML" by Red Hat, "JSON Schema" by Christian Kohler, or similar).
#     -   Many IDEs offer real-time, inline JSON Schema validation, providing immediate visual
#         feedback (red squiggly lines, error messages) as you edit your schema files locally.
#         This is an invaluable aid for rapid debugging and syntax correction, often catching
#         issues before you even save the file.
#     -   Consider using command-line JSON linters locally for quick syntax checks.
#
# 6.  **Iterative Correction and Re-validation Cycle:**
#     -   Apply the necessary structural, syntactic, or logical corrections to your schema
#         files based on the detailed error analysis.
#     -   Once confident in your changes, commit them to your feature branch and push. This
#         action will automatically trigger a new run of this GitHub Actions workflow,
#         allowing for immediate re-validation and confirmation of your fixes. Repeat this
#         cycle until all schemas pass validation.
#
# By diligently following these comprehensive guidelines, you can swiftly diagnose and
# effectively resolve any schema integrity issues, thereby ensuring the continuous
# high quality, robustness, and reliability of our project's data contracts.
# Your commitment to schema excellence is highly valued!
# ----------------------------------------------------------------------------------------------------------------------

name: Schema Integrity Checker

# Define the events that will meticulously trigger this workflow's execution.
# This comprehensive configuration ensures that schema integrity is perpetually
# monitored across all critical development and integration stages.
on:
  push:
    # Trigger upon direct pushes or merges into the primary 'main' branch.
    # This acts as a crucial, final gatekeeper for the canonical schema definitions
    # residing in the main codebase, confirming their continuous validity.
    branches:
      - "main"
      # Additional branches (e.g., "release/**", "develop") could be added here
      # if specific development or release branches also necessitate rigorous
      # schema integrity checks upon every code commit.
  pull_request:
    # Trigger for all relevant pull request activities targeting the 'main' branch.
    # This provides crucial pre-merge validation, offering immediate feedback to
    # developers before changes are integrated, significantly enhancing code quality.
    branches:
      - "main"
    # Specify the exact types of pull request events that should initiate this workflow run.
    # - 'opened': Triggers when a new pull request is initially created.
    # - 'synchronize': Triggers when new commits are pushed to the pull request's head branch.
    #                  This is vital for continuously validating incremental changes.
    # - 'reopened': Triggers when a previously closed pull request is opened again.
    types: [opened, synchronize, reopened]
    # Restrict workflow execution to changes affecting specific, predefined file paths.
    # This intelligent path filtering strategy optimizes CI/CD resource usage by
    # preventing unnecessary workflow runs for code modifications unrelated to schemas.
    paths:
      - '**/*.schema.json'                 # Any JSON Schema definition file across the entire repository.
      - '.github/workflows/schema-integrity-checker.yml' # This workflow file itself; changes here should trigger a self-validation.


# Definition of the jobs to be executed as part of this workflow. In GitHub Actions,
# a job is a set of steps that executes on the same runner. This workflow encapsulates
# its entire validation logic within a single, highly focused job.
jobs:
  validate_schemas_integrity:
    # Specifies the virtual environment on which this job will be executed.
    # 'ubuntu-latest' provides a robust, up-to-date Linux environment that is
    # universally suitable for most CI/CD tasks, offering a wide array of
    # pre-installed tools and ensuring consistent execution characteristics.
    runs-on: ubuntu-latest

    # The 'strategy' block enables running a job multiple times with different inputs
    # via a matrix. While only a single Node.js version is currently configured,
    # this structure maintains inherent extensibility for future multi-version
    # compatibility testing if such requirements arise.
    strategy:
      matrix:
        # Define the specific Node.js version(s) to be utilized within the job's environment.
        # Node.js is an essential prerequisite for installing and running JavaScript-based
        # tools such as AJV-CLI via the Node Package Manager (`npm`). Node.js 22 is
        # chosen as a current Long Term Support (LTS) version, favored for its stability,
        # performance, and extended maintenance window, ensuring long-term reliability.
        node-version: [ 22 ] # Consider adding other critical LTS versions (e.g., 18, 20) for broader compatibility testing if project needs dictate.

    # This is an ordered sequence of declarative steps. Each step represents a distinct
    # action or command that will be executed sequentially within the job's runtime.
    # The successful completion of each step is a strict prerequisite for the execution
    # of the subsequent step, enforcing a robust and logical workflow progression.
    steps:
    # --------------------------------------------------------------------------
    # Step 1: Checkout Repository Code for Analysis
    # --------------------------------------------------------------------------
    - name: "‚úÖ Step 1/4: Initializing Repository - Checking Out Codebase for Validation"
      # Utilizes the official `actions/checkout@v4` action, which is a fundamental
      # and indispensable component of nearly all GitHub Actions workflows.
      # Its primary function is to make the entire repository's contents available
      # within the runner's ephemeral workspace. Without this critical step, no
      # files‚Äîincluding our essential `.schema.json` definitions‚Äîwould be accessible
      # for subsequent processing or rigorous validation.
      uses: actions/checkout@v4
      # Configuration parameters specifically for the checkout action.
      with:
        # `fetch-depth: 0` instructs Git to fetch the complete history for all branches
        # and tags. While a shallow clone (e.g., `fetch-depth: 1`) might offer marginal
        # speed improvements for simple file access, fetching full history ensures that
        # any potential Git-related operations (though not explicitly part of *this*
        # workflow's core validation logic) would have complete contextual information.
        # It serves as a robust and comprehensive default.
        fetch-depth: 0
        # `persist-credentials: true` is the default behavior and ensures that the
        # `GITHUB_TOKEN` is used for authenticating subsequent Git commands if needed.
        # No explicit token is required for public repositories or basic checkout.
      # Define environment variables specific to this step for verbose logging and enhanced clarity.
      env:
        CURRENT_STEP_ID: "checkout-repository-code"
        CURRENT_STEP_PURPOSE: "To clone the Git repository onto the runner's filesystem for analysis."
      run: |
        echo "===================================================================================================="
        echo "  [WORKFLOW PROGRESS] Starting Step 1: ${CURRENT_STEP_ID}"
        echo "  Detailed Purpose: ${CURRENT_STEP_PURPOSE}"
        echo "  This foundational step is absolutely critical for the workflow's operation."
        echo "  It ensures that the virtual machine runner has a complete and accurate copy of our source code,"
        echo "  including all JSON Schema files, at its disposal for the subsequent validation processes."
        echo "  The `actions/checkout@v4` action is a standard, robust, and recommended method for this operation."
        echo "  Current working directory before the checkout operation commenced: $(pwd)"
        echo "  Initiating the repository cloning process. This may take a moment depending on repository size..."
        echo "  Repository cloning completed successfully. Now, performing verification of the workspace contents."
        echo "  The repository content is now fully available and located at the path: '${GITHUB_WORKSPACE}'"
        echo "  A brief listing of the top-level items (files and directories) in the repository (first 15 entries):"
        ls -Fahl "${GITHUB_WORKSPACE}" | head -n 15 || echo "  (Workspace appears empty or directory listing command failed during verification.)"
        echo "  This confirms that the repository files are present and are ready for comprehensive analysis."
        echo "===================================================================================================="
        echo "" # Visual separator for log readability.

    # --------------------------------------------------------------------------
    # Step 2: Set Up Node.js Environment
    # --------------------------------------------------------------------------
    - name: "üöÄ Step 2/4: Environment Setup - Configuring Node.js ${{ matrix.node-version }} Runtime"
      # Leverages the official `actions/setup-node@v4` action to intelligently
      # configure the Node.js runtime environment. This action efficiently handles:
      # - Downloading and installing the specified Node.js version onto the runner.
      # - Correctly adding Node.js and its associated `npm` executables to the system's PATH.
      # - Optionally setting up npm package caching to significantly optimize build times.
      uses: actions/setup-node@v4
      # Configuration details specifically for the Node.js setup action.
      with:
        node-version: ${{ matrix.node-version }} # Dynamically injects the Node.js version from the job's matrix configuration.
        # Enable comprehensive caching of Node.js modules (dependencies). This feature
        # dramatically accelerates subsequent workflow runs by storing and reusing
        # installed `npm` packages, thereby reducing repetitive download and installation
        # times. The `cache: 'npm'` directive automatically infers the appropriate
        # cache key from `package-lock.json` or `package.json` files.
        cache: 'npm'
        # Optional: `cache-dependency-path` can be used to specify a custom path to the
        # dependency file (e.g., './path/to/my-project/package-lock.json') if it's not
        # located directly in the repository's root. For this workflow, the default is fine.
      # Environment variables for more detailed logging and contextual information.
      env:
        CURRENT_STEP_ID: "setup-nodejs-runtime"
        NODE_TARGET_VERSION: ${{ matrix.node-version }}
        CURRENT_STEP_PURPOSE: "To establish a functional Node.js environment necessary for npm-based tooling."
      run: |
        echo "===================================================================================================="
        echo "  [WORKFLOW PROGRESS] Starting Step 2: ${CURRENT_STEP_ID}"
        echo "  Detailed Purpose: ${CURRENT_STEP_PURPOSE}"
        echo "  This step is absolutely critical because the `ajv-cli` utility, which is the core of our schema"
        echo "  validation, is distributed as a Node.js package. Consequently, a correctly configured Node.js"
        echo "  runtime and its associated package manager (`npm`) are utterly essential for its installation and execution."
        echo "  Action: Utilizing `actions/setup-node@v4` to precisely install Node.js version ${NODE_TARGET_VERSION}."
        echo "  Initiating the Node.js environment provisioning process. This includes fetching and installing Node.js..."
        echo "  Node.js setup process initiated and reported as completed. Now, performing verification of core executables."
        echo "  Current Node.js version detected in the environment: $(node -v)"
        echo "  Current npm (Node Package Manager) version detected: $(npm -v)"
        # Performing robust checks to ensure Node.js and npm are fully operational and correctly configured in PATH.
        if ! command -v node &> /dev/null; then
            echo "  CRITICAL ERROR: The Node.js executable ('node') was not found in the system PATH."
            echo "  This indicates a fundamental issue during the Node.js setup action, possibly an installation failure."
            echo "  Without Node.js, subsequent steps requiring `npm` will fail. Cannot proceed with workflow."
            exit 1
        fi
        if ! command -v npm &> /dev/null; then
            echo "  CRITICAL ERROR: The npm package manager executable ('npm') was not found in the system PATH."
            echo "  This will directly prevent the installation of `ajv-cli`. Cannot proceed with workflow."
            exit 1
        fi
        echo "  Node.js (version $(node -v | tr -d 'v')) and npm (version $(npm -v)) are now fully operational and verified."
        echo "  The workflow environment is now primed and ready for installing Node.js-based development tools."
        echo "===================================================================================================="
        echo "" # Visual separator for log readability.

    # --------------------------------------------------------------------------
    # Step 3: Install JSON Schema Validator (AJV-CLI)
    # --------------------------------------------------------------------------
    - name: "üì¶ Step 3/4: Tool Installation - Acquiring AJV-CLI Validator Utility"
      run: |
        echo "===================================================================================================="
        echo "  [WORKFLOW PROGRESS] Starting Step 3: Tool Installation"
        echo "  Detailed Purpose: To provision the specific command-line utility, `ajv-cli`, which is absolutely"
        echo "  essential for performing the rigorous JSON Schema integrity validations mandated by this workflow."
        echo "  `ajv-cli` is specifically chosen for its unparalleled robustness, exceptional performance,"
        echo "  and comprehensive feature set, including full compliance with the latest JSON Schema specifications,"
        echo "  making it the ideal and authoritative tool for our critical integrity checks."
        echo "  Installation Command Being Executed: `npm install -g ajv-cli`"
        echo "  The `-g` (global) flag is critically used to ensure that the `ajv` command-line executable is"
        echo "  installed globally within the runner's environment and is thus universally accessible in the system's PATH."
        echo "  Initiating the global installation of `ajv-cli` via npm. This may involve network downloads..."

        npm install -g ajv-cli
        # Thoroughly checking the exit status of the `npm install` command. A non-zero
        # exit status indicates a failure during the package installation process.
        if [ $? -ne 0 ]; then
          echo "  CRITICAL ERROR: The `npm install -g ajv-cli` command reported a non-zero exit status."
          echo "  This unequivocally signifies a failure during the installation of the AJV-CLI package."
          echo "  Potential causes for this failure include:"
          echo "  - Network connectivity issues preventing successful package download from npm registry."
          echo "  - Problems with the npm registry itself or the availability of the `ajv-cli` package."
          echo "  - Transient system issues or, less commonly, insufficient permissions within the runner environment."
          echo "  Without `ajv-cli`, the core schema validation step simply cannot be executed. Terminating workflow."
          exit 1
        fi

        echo "  `ajv-cli` installation process has completed successfully according to npm."
        echo "  Performing a crucial post-installation verification: checking for the presence of the 'ajv' command in PATH."
        if ! command -v ajv &> /dev/null; then
            echo "  CRITICAL ERROR: Despite npm reporting a successful installation, the `ajv` command-line utility"
            echo "                  is unexpectedly not found in the system's PATH. This is a critical system"
            echo "                  misconfiguration or an unforeseen installation anomaly that must be addressed."
            echo "                  Schema validation cannot proceed without the `ajv` executable being available."
            exit 1
        fi
        echo "  `ajv-cli` (accessible globally via the `ajv` command) is successfully installed and verified."
        echo "  Displaying the installed version of `ajv-cli` for diagnostic and auditing purposes:"
        ajv --version || echo "  (Could not retrieve `ajv-cli` version information. Proceeding cautiously, but this should be investigated if persistent.)"
        echo "  The necessary and authoritative validation tool (`ajv-cli`) is now fully prepared for execution."
        echo "===================================================================================================="
        echo "" # Visual separator for log readability.

    # --------------------------------------------------------------------------
    # Step 4: Validate All .schema.json Files Against JSON Schema Draft 2020-12 Meta-Schema
    # --------------------------------------------------------------------------
    - name: "‚úÖ Step 4/4: Core Validation - JSON Schema Integrity Verification"
      # This is the most crucial, complex, and extensive step within this entire workflow.
      # It encapsulates the comprehensive logic for systematically discovering, iterating
      # through, and rigorously validating every single JSON Schema definition file
      # (`.schema.json` extension) found within the repository's codebase.
      run: |
        echo "===================================================================================================="
        echo "  [WORKFLOW PROGRESS] Starting Step 4: Core JSON Schema Integrity Validation Process"
        echo "  Primary Mandate: To conduct an exhaustive and uncompromising check of all '.schema.json' files"
        echo "                   present in this repository, ensuring their absolute conformance to the official,"
        echo "                   authoritative JSON Schema Draft 2020-12 specification. This is a non-negotiable"
        echo "                   quality gate for our schema definitions."
        echo "  Methodology: Each identified schema file will be individually treated as 'data' and passed to"
        echo "               `ajv-cli` for validation. The 'schema' that `ajv-cli` will use for this validation"
        echo "               is the JSON Schema Draft 2020-12 meta-schema itself."
        echo ""
        echo "  Understanding the Significance of the JSON Schema Draft 2020-12 Meta-Schema:"
        echo "  The meta-schema is fundamentally a 'schema for schemas'. It precisely defines the grammar, the"
        echo "  vocabulary (allowed keywords and their meanings), and the structural rules that any valid JSON"
        echo "  Schema *must* rigorously adhere to. By validating our application-specific schemas against this"
        echo "  meta-schema, we obtain an ironclad guarantee that they are syntactically sound, semantically"
        echo "  correct, and conceptually aligned with the JSON Schema standard. Draft 2020-12 is currently"
        echo "  the latest recommended stable specification, chosen for its comprehensive features, clarity,"
        echo "  and robustness, ensuring our schemas are built upon a modern and well-defined foundation."
        echo "===================================================================================================="
        echo "" # Visual separator for log readability.

        # Define the canonical URL for the JSON Schema Draft 2020-12 meta-schema.
        # This URL is absolutely paramount. `ajv-cli` dynamically utilizes this URL
        # to fetch and apply the authoritative validation rules that dictate what
        # constitutes a perfectly valid JSON Schema. It serves as a critical,
        # immutable reference for all our integrity checks.
        declare -r JSON_SCHEMA_META_SCHEMA_URL="https://json-schema.org/draft/2020-12/schema"
        echo "  Configuration Detail: The official JSON Schema meta-schema URL utilized for this validation process is:"
        echo "  '${JSON_SCHEMA_META_SCHEMA_URL}'"
        echo "  This URL points to the definitive specification document that precisely governs the expected"
        echo "  structure and content of all our JSON Schema definitions."
        echo "  AJV-CLI is intelligently designed to cache this meta-schema locally after its initial download,"
        echo "  thereby optimizing performance for subsequent validation runs."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        # Initialize a crucial control flag to precisely track the occurrence of any validation failures.
        # - A value of `0` denotes an impeccable validation record thus far (zero failures encountered).
        # - A value of `1` irrevocably signals that at least one schema file has failed its integrity check.
        declare -i VALIDATION_FAILED=0
        echo "  Internal Workflow State: The `VALIDATION_FAILED` flag has been meticulously initialized to ${VALIDATION_FAILED}"
        echo "  (this value indicates an initial state of success, with no failures reported yet)."
        echo "  This crucial flag will be set to `1` as soon as the first schema validation error is encountered"
        echo "  during the iterative processing, ensuring that the workflow accurately reflects any integrity issues."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        # Establish robust error handling for the entire bash script block within this step.
        # The `trap 'handle_error $LINENO' ERR` command ensures that if any command executed
        # within this script exits with a non-zero status (which typically signifies an error),
        # the custom `handle_error` function is immediately invoked. This provides a controlled
        # and verbose error reporting mechanism, preventing silent failures.
        handle_error() {
          local exit_code=$?
          local lineno=$1
          echo "  [CRITICAL SCRIPT EXECUTION ERROR] An unexpected and unhandled error occurred at line ${lineno}." >&2
          echo "  The command that failed exited with code: ${exit_code}." >&2
          echo "  This typically implies an issue with the runner environment, a misconfigured command, or a" >&2
          echo "  fundamental problem within the script itself that prevented normal execution." >&2
          echo "  Marking the overall workflow as failed due to this script-level error." >&2
          VALIDATION_FAILED=1 # Crucially, ensure the global failure flag is set.
          exit 1 # Terminate the entire workflow with a failure status to prevent continuation under erroneous conditions.
        }
        trap 'handle_error $LINENO' ERR
        echo "  Script Robustness: A comprehensive error trap has been enabled for this script block."
        echo "  Any command failure will now trigger a controlled script exit, providing detailed diagnostics."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        echo "  Phase 1: Comprehensive Discovery of '.schema.json' files across the repository."
        echo "  This initial phase is designed to meticulously scan the entire repository's filesystem"
        echo "  to accurately identify all candidate JSON Schema definition files that require validation."

        # Configure essential shell options for robust and advanced file discovery capabilities.
        # `shopt -s globstar`: Activates the use of the `**` pattern for recursive directory traversal.
        #                      This enables patterns like `**/*.schema.json` to effectively match files
        #                      located in any subdirectory, deep within the repository structure.
        # `shopt -s nullglob`: Modifies the default glob behavior such that if no files match a given
        #                      pattern, the pattern expands to nothing (an empty string). This is
        #                      critical for preventing errors in subsequent loops that iterate over
        #                      file lists, ensuring graceful handling of scenarios where no schemas are found.
        shopt -s globstar nullglob
        echo "  Shell Configuration: `globstar` (for recursive search) and `nullglob` (for safe empty matches) are actively enabled."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        echo "  Executing the highly robust and precise `find` command for schema file identification."
        echo "  This approach offers superior control over file type, naming conventions, and crucial directory exclusions."
        echo "  The `find` command parameters are meticulously configured as follows:"
        echo "  - `.` (current directory): Specifies the starting point for the recursive search operation, typically the repository root."
        echo "  - `-type f`: Restricts the search results exclusively to regular files, explicitly excluding directories, symbolic links, etc."
        echo "  - `-name \"*.schema.json\"`: Filters the identified files to only include those whose names precisely end with the `.schema.json` suffix."
        echo "  - `-not -path \"./.git/*\"`: Explicitly excludes any files or directories residing within the `.git` directory structure,"
        echo "                              as this contains internal Git repository data and is entirely irrelevant for schema validation."
        echo "  - `-not -path \"./node_modules/*\"`: Excludes all files and directories located within any `node_modules` directory,"
        echo "                                      as these typically contain third-party library schemas or dependencies and are not"
        echo "                                      part of our project's core, custom schema definitions requiring integrity checks."
        echo "  - `-print0`: A critical safety measure. It prints each found filename terminated by a null character (`\0`),"
        echo "               which is absolutely essential for correctly handling filenames that might contain spaces, newlines,"
        echo "               or other special characters when piped to `readarray -d $'\0'`. This prevents word splitting issues."
        echo "  - `2>/dev/null`: Redirects standard error output (e.g., potential 'permission denied' messages from `find` when"
        echo "                   encountering protected directories) to `/dev/null`, keeping the workflow logs clean and focused"
        echo "                   solely on relevant schema validation results."
        echo "  The entire output of the `find` command is then securely piped to the `readarray` command for safe population"
        echo "  into a bash array, ensuring robust handling of all filename possibilities."

        # Use `readarray` with null delimiter for robust handling of filenames containing special characters.
        readarray -d $'\0' -t SCHEMA_FILES < <(find . -type f -name "*.schema.json" \
                                             -not -path "./.git/*" \
                                             -not -path "./node_modules/*" \
                                             -print0 2>/dev/null)

        echo "----------------------------------------------------------------------------------------------------"
        # Immediate check after the discovery phase to determine if any schema files were actually identified.
        if [ ${#SCHEMA_FILES[@]} -eq 0 ]; then
          echo "  Observation: The file discovery phase has completed, and NO '.schema.json' files were identified"
          echo "  within the repository (after applying exclusions for '.git' and 'node_modules')."
          echo "  This outcome typically suggests one of the following scenarios:"
          echo "  1.  The repository genuinely does not contain any JSON Schema definition files at this moment."
          echo "  2.  Any existing schema files do not adhere to the expected `.schema.json` naming convention."
          echo "  3.  All schema files are inadvertently located within explicitly excluded directories (e.g., in a submodule's node_modules)."
          echo "  Given that no schemas were found to validate, this workflow will gracefully conclude with a success status."
          echo "  There are no schema integrity issues to report as no schemas were found to check."
          echo "  Action: Exiting workflow with an explicit success code (0), as there are no schemas requiring validation."
          echo "----------------------------------------------------------------------------------------------------"
          exit 0 # Exit successfully as there's nothing to validate; this is not a failure condition.
        fi

        echo "  Phase 2: Reporting on Discovered Schema Files."
        echo "  Successfully identified a total of ${#SCHEMA_FILES[@]} distinct JSON Schema definition files for validation."
        echo "  These are the precise file paths of the candidates that will now undergo rigorous integrity checks:"
        declare -i current_file_counter=1
        for file_path in "${SCHEMA_FILES[@]}"; do
          echo "    - [Schema ${current_file_counter}/${#SCHEMA_FILES[@]}] Discovered Path: '${file_path}'"
          current_file_counter=$((current_file_counter + 1))
        done
        echo "  This comprehensive list represents all candidates for ensuring strict JSON Schema specification compliance."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        echo "  Phase 3: Initiating the Iterative Schema Validation Process."
        echo "  Each discovered schema file will now be systematically processed and validated against"
        echo "  the authoritative JSON Schema Draft 2020-12 meta-schema. This loop constitutes the core"
        echo "  integrity check. Detailed output for each individual validation attempt will follow below."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        # Begin the main validation loop. This loop iterates over each schema file path
        # meticulously discovered in Phase 1, driving the core validation process.
        for schema_file in "${SCHEMA_FILES[@]}"; do
          echo "####################################################################################################"
          echo "## Currently Processing Schema File: '${schema_file}'"
          echo "## Context: This schema is being rigorously checked to ensure it is a valid JSON Schema definition itself."
          echo "####################################################################################################"
          echo "" # Visual separator for log readability.

          # --- Sub-Phase: Critical Pre-Validation File Accessibility Checks ---
          # These are essential and robust guards against potential issues such as schema files being
          # moved, deleted, or having their file permissions altered between the initial discovery
          # phase and the actual validation execution. Ensuring file presence and readability is paramount.
          echo "  --> Initiating pre-validation checks for schema file: '${schema_file}'..."
          echo "  1. Verifying file existence and confirming it is a regular file (not a directory or broken symlink)."
          if [ ! -f "$schema_file" ]; then
            echo "  [WARNING] File Accessibility Issue Detected: Schema file '${schema_file}' was correctly identified"
            echo "            during the discovery phase but is unexpectedly no longer accessible as a regular file."
            echo "            This could imply it has been deleted, moved, or is a symbolic link pointing to an invalid location."
            echo "            This specific schema file will be skipped from validation to prevent workflow errors."
            echo "            However, the overall workflow status will reflect this anomaly as a potential problem."
            VALIDATION_FAILED=1 # Mark a failure, but strategically continue processing other schemas.
            echo "  Pre-check Result for existence: FAILED (File not found or not a regular file)."
            echo "####################################################################################################"
            echo "" # Visual separator.
            continue # Skip to the next schema file in the array.
          fi
          echo "  File existence confirmed: '${schema_file}' is present and verified as a regular file."

          echo "  2. Verifying read permissions for the current GitHub Actions runner process."
          if [ ! -r "$schema_file" ]; then
            echo "  [WARNING] File Permissions Issue Detected: Schema file '${schema_file}' exists on the filesystem"
            echo "            but the current runner process lacks the necessary read permissions to access its content."
            echo "            The `ajv-cli` validator cannot process the file without read access. Please review the"
            echo "            file's permissions within the repository to ensure it is readable by CI/CD processes."
            echo "            This specific file will be skipped from validation."
            VALIDATION_FAILED=1 # Mark a failure, but strategically continue processing.
            echo "  Pre-check Result for permissions: FAILED (Read permissions denied for the runner)."
            echo "####################################################################################################"
            echo "" # Visual separator.
            continue # Skip to the next schema file in the array.
          fi
          echo "  Read permissions confirmed: '${schema_file}' is fully readable by the GitHub Actions runner."
          echo "  All critical pre-validation checks successfully passed for schema file: '${schema_file}'."
          echo "----------------------------------------------------------------------------------------------------"
          echo "" # Visual separator for log readability.

          # --- Sub-Phase: Execution of AJV-CLI Validation Command ---
          echo "  --> Executing `ajv-cli` validation command for schema: '${schema_file}'..."
          echo "  The following command-line instruction is being invoked by the system:"
          echo "    `ajv validate -s \"${JSON_SCHEMA_META_SCHEMA_URL}\" -d \"$schema_file\"`"
          echo "  Detailed explanation of command arguments:"
          echo "    -s (schema): This argument specifies the *meta-schema* (the JSON Schema Draft 2020-12 URL)"
          echo "                 that defines the very structure and rules for what a valid JSON Schema looks like."
          echo "    -d (data): This argument specifies our application-defined *schema file* ('${schema_file}')"
          echo "               which is the document that needs to be validated against the meta-schema."
          echo "  The direct output generated by AJV-CLI, including any specific validation errors or success messages,"
          echo "  will be displayed immediately below this line for transparent auditing and debugging."
          echo "  --------------------------------------------------------------------------------"

          # Execute the `ajv` command. The `if ! command; then ... else ... fi` construct
          # robustly captures the exit status of `ajv` (0 for success, non-zero for failure).
          if ! ajv validate -s "${JSON_SCHEMA_META_SCHEMA_URL}" -d "$schema_file"; then
            echo "  --------------------------------------------------------------------------------"
            echo "  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            echo "  !!! CRITICAL INTEGRITY FAILURE DETECTED: Validation FAILED for '${schema_file}' !!!"
            echo "  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            echo "  Failure Details: The JSON Schema file '${schema_file}' is NOT a valid JSON Schema itself."
            echo "  This unequivocally indicates that its internal structure, the usage of its keywords,"
            echo "  the data types assigned to specific properties, or its overall formatting and syntax"
            echo "  deviates from the rigorous requirements stipulated by the JSON Schema Draft 2020-12 specification."
            echo ""
            echo "  [Developer Action Required]: Immediate and thorough review of the specific error messages"
            echo "  provided by AJV directly above this failure summary is absolutely necessary. These messages"
            echo "  are highly diagnostic and will pinpoint the exact location and nature of the syntax or logic error."
            echo "  Common reasons for such failures include, but are not limited to:"
            echo "  -   Typos in standard JSON Schema keywords (e.g., 'requierd' instead of 'required', 'patter' instead of 'pattern')."
            echo "  -   Incorrect data types assigned to specific schema properties (e.g., providing an array where a string is expected)."
            echo "  -   Violations of fundamental JSON syntax rules (e.g., missing commas, unclosed braces or brackets)."
            echo "  -   Misunderstanding or incorrect implementation of complex schema constructs or conditional keywords."
            echo "  This critical failure will contribute directly to the overall workflow failure status."
            VALIDATION_FAILED=1 # Crucially, set the global failure flag to '1'.
            echo "  ####################################################################################################"
          else
            echo "  --------------------------------------------------------------------------------"
            echo "  #####################################################################################################"
            echo "  ### INTEGRITY CHECK PASSED: Validation SUCCESS for '${schema_file}'         ###"
            echo "  #####################################################################################################"
            echo "  Success Details: The JSON Schema file '${schema_file}' has been meticulously confirmed to be a"
            echo "  perfectly well-formed and fully compliant JSON Schema definition, adhering without any errors"
            echo "  to the stringent requirements of the JSON Schema Draft 2020-12 specification."
            echo ""
            echo "  [Outcome]: This schema is robust, reliable, and entirely ready for use in all subsequent data"
            echo "  validation, documentation generation, and code generation tasks. It meets the highest standards"
            echo "  of schema integrity and can be trusted as a valid data contract."
            echo "  ####################################################################################################"
          fi
          echo "" # Visual separator for clear distinction between schema results.
        done # End of the main iteration loop over all discovered schema files.

        echo "----------------------------------------------------------------------------------------------------"
        echo "  Phase 4: Comprehensive Workflow Status Finalization and Reporting."
        echo "  All identified '.schema.json' files within the repository have now successfully undergone"
        echo "  the rigorous integrity validation process. The overall success or failure of this"
        echo "  `Schema Integrity Checker` workflow is being definitively determined based on aggregated results."
        echo "----------------------------------------------------------------------------------------------------"
        echo "" # Visual separator for log readability.

        # Final evaluation of the 'VALIDATION_FAILED' flag to determine the ultimate workflow status.
        if [ "$VALIDATION_FAILED" -eq 1 ]; then
          echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
          echo "!!!                       WORKFLOW CRITICAL FAILURE REPORT: SCHEMA INTEGRITY COMPROMISED         !!!"
          echo "!!!----------------------------------------------------------------------------------------------!!!"
          echo "!!!  STATUS: ONE OR MORE JSON SCHEMA DEFINITION FILES FAILED INTEGRITY VALIDATION.               !!!"
          echo "!!!                                                                                              !!!"
          echo "!!!  SUMMARY: At least one of the '.schema.json' files meticulously scanned within this          !!!"
          echo "!!!           repository has been found to be non-compliant with the official JSON Schema        !!!"
          echo "!!!           Draft 2020-12 specification. This represents a critical issue, as invalid schemas  !!!"
          echo "!!!           can severely jeopardize runtime data validation processes, lead to unpredictable   !!!"
          echo "!!!           application behavior, and fundamentally undermine the reliability of our data      !!!"
          echo "!!!           contracts and API definitions.                                                     !!!"
          echo "!!!                                                                                              !!!"
          echo "!!!  IMMEDIATE REMEDIATION IS REQUIRED TO MAINTAIN CODEBASE QUALITY:                             !!!"
          echo "!!!  1.  **Review Full Workflow Logs Thoroughly:** Scrutinize the GitHub Actions log for this    !!!"
          echo "!!!      specific run with utmost attention, focusing on the output from 'Step 4'.               !!!"
          echo "!!!      Specifically search for detailed 'CRITICAL INTEGRITY FAILURE' messages.                 !!!"
          echo "!!!  2.  **Identify & Analyze Errors:** Pinpoint the exact schema file(s) that failed validation !!!"
          echo "!!!      and carefully read the AJV-CLI error reports for precise diagnostic information.        !!!"
          echo "!!!  3.  **Local Debugging:** Correct the identified issues in your local development environment.!!!"
          echo "!!!      Utilize powerful IDE features (e.g., VS Code's built-in JSON Schema validation, linters)!!!"
          echo "!!!      for real-time feedback and assistance in rectifying the schema errors.                  !!!"
          echo "!!!  4.  **Re-validate:** Commit your corrected schema files and push them to your branch        !!!"
          echo "!!!      to automatically trigger a new workflow run for re-validation. Repeat until all schemas pass.!!!"
          echo "!!!                                                                                              !!!"
          echo "!!!  The workflow is now terminating with a non-zero exit code (1) to unequivocally signal this failure. !!!"
          echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
          exit 1 # Exit with an error code (1) to definitively fail the GitHub Action.
        else
          echo "####################################################################################################"
          echo "###                       WORKFLOW SUCCESS REPORT: SCHEMA INTEGRITY CONFIRMED                  ###"
          echo "###----------------------------------------------------------------------------------------------###"
          echo "###  STATUS: ALL JSON SCHEMA DEFINITION FILES PASSED INTEGRITY VALIDATION.                     ###"
          echo "###                                                                                              ###"
          echo "###  SUMMARY: Every single '.schema.json' file discovered within this repository has been        ###"
          echo "###           meticulously verified and confirmed to be impeccably well-formed and fully         ###"
          echo "###           compliant with the JSON Schema Draft 2020-12 specification. This is an             ###"
          echo "###           exceptional outcome, validating the robustness, reliability, and high quality      ###"
          echo "###           of all your schema definitions across the entire codebase.                         ###"
          echo "###                                                                                              ###"
          echo "###  CONTINUE WITH CONFIDENCE:                                                                   ###"
          echo "###  The repository's schema definitions are currently in an optimal and fully validated state.  ###"
          echo "###  You can now confidently proceed with further development, data validation, API              ###"
          echo "###  implementations, and deployment activities with complete assurance in the integrity         ###"
          echo "###  and correctness of your underlying data contracts. Your hard work in maintaining            ###
          echo "###  high-quality schemas is appreciated!                                                        ###"
          echo "###                                                                                              ###"
          echo "###  The workflow will now terminate with a zero exit code (0) to unequivocally signal complete success.###"
          echo "####################################################################################################"
          exit 0 # Exit with a success code (0) to indicate successful completion of the GitHub Action.
        fi
        echo "" # Final blank line for log cleanliness and visual separation.
        echo "----------------------------------------------------------------------------------------------------"
        echo "  End of GitHub Actions Workflow Execution: Schema Integrity Checker."
        echo "  Thank you for maintaining high quality schema definitions in your project!"
        echo "----------------------------------------------------------------------------------------------------"