name: Docker Image Security Pipeline

# This workflow orchestrates a comprehensive set of security scans and controls
# for Docker images within the Continuous Integration / Continuous Deployment (CI/CD) pipeline.
# It ensures that container images are built securely, free of known vulnerabilities,
# sensitive data, and compliant with organizational policies, before being promoted.

on:
  # Trigger the workflow on push events to the 'main' branch.
  push:
    branches:
      - "main"
      - "develop" # Also trigger on 'develop' branch for early feedback
    # Optionally, specify paths to only run when relevant files change.
    # paths:
    #   - 'Dockerfile'
    #   - 'src/**'
    #   - '.github/workflows/docker-image-security-pipeline.yml'

  # Trigger the workflow on pull request events targeting the 'main' branch.
  pull_request:
    branches:
      - "main"
    # Specify types of pull request activities that trigger the workflow.
    types:
      - opened
      - synchronize
      - reopened
      - edited

  # Allow manual triggering of the workflow from the GitHub UI.
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: false
        default: 'info'
        type: choice
        options:
          - info
          - debug
          - warning
          - error
      imageTag:
        description: 'Optional: Specify a custom image tag for manual builds.'
        required: false
        default: 'manual-${{ github.run_id }}'
        type: string

jobs:
  #############################################################################
  # Job 1: Dockerfile Linting for Best Practices and Security
  #
  # This job uses Hadolint to static analyze the Dockerfile for common pitfalls,
  # best practices violations, and security misconfigurations.
  # It's crucial to run this *before* building the image to catch issues early.
  #############################################################################
  dockerfile_lint:
    name: "Dockerfile Linter (Hadolint)"
    runs-on: ubuntu-latest
    timeout-minutes: 5 # Set a timeout for this job
    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        # Fetch all history for Hadolint or other tools that might need it
        fetch-depth: 0

    - name: Display Workflow Context for Debugging
      # This step provides useful information about the current workflow run.
      run: |
        echo "--- GitHub Workflow Context ---"
        echo "Repository: ${{ github.repository }}"
        echo "Branch: ${{ github.ref }}"
        echo "Commit SHA: ${{ github.sha }}"
        echo "Actor: ${{ github.actor }}"
        echo "Run ID: ${{ github.run_id }}"
        echo "Run Number: ${{ github.run_number }}"
        echo "Event Name: ${{ github.event_name }}"
        echo "--- End Context ---"

    - name: Set up Hadolint (via Docker)
      # Pulls the latest Hadolint Docker image and makes it runnable from the PATH.
      # This ensures a consistent Hadolint version and environment.
      run: |
        echo "Downloading Hadolint Docker image..."
        docker pull hadolint/hadolint:latest
        echo "Hadolint image pulled successfully."
        # Create a shell function to easily call hadolint
        echo "Defining hadolint alias for ease of use."
        echo 'hadolint() { docker run --rm -i hadolint/hadolint:latest "$@"; }' >> "$GITHUB_ENV"
      shell: bash

    - name: Run Hadolint Scan on Dockerfile
      # Scans the Dockerfile in the root of the repository.
      # Exits with an error if Hadolint finds any issues.
      # Consider custom Hadolint rules or ignoring specific rules if necessary.
      run: |
        echo "Starting Hadolint scan on 'Dockerfile'..."
        # Example of ignoring specific rules: hadolint Dockerfile --ignore DL3008 --ignore DL3018
        hadolint Dockerfile
        echo "Hadolint scan completed successfully. No major issues found."
        # Placeholder for storing Hadolint results as an artifact if needed.
        # This could be a JSON or plain text report.
        # hadolint -f json Dockerfile > hadolint-results.json

    - name: Handle Hadolint Scan Results (Optional)
      # This step is a placeholder for further actions based on Hadolint results.
      # E.g., commenting on PRs, creating issues, or pushing to a dedicated dashboard.
      run: |
        echo "Hadolint check is a critical first step for Docker image security."
        echo "Ensuring Dockerfiles follow best practices prevents many common vulnerabilities."
      # This step could be expanded to parse a JSON output from Hadolint
      # and take specific actions, e.g., fail on 'error' level, warn on 'warning' level.

    - name: Debug Output - Hadolint Version
      # Confirming the Hadolint version used in the workflow.
      run: |
        echo "Verifying Hadolint version..."
        docker run --rm hadolint/hadolint:latest hadolint --version || true
        # `|| true` prevents this debug step from failing the job if for some reason
        # the version command itself had an issue (e.g., syntax error).

  #############################################################################
  # Job 2: Build Docker Image and Scan for Vulnerabilities (Trivy)
  #
  # This job builds the Docker image and then performs a comprehensive
  # vulnerability scan using Aqua Security Trivy. It's a cornerstone of
  # any secure container pipeline.
  #############################################################################
  build_and_scan_vulnerabilities:
    name: "Build Image & Scan Vulnerabilities"
    needs: dockerfile_lint # Ensure Dockerfile is linted before building
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Allow sufficient time for build and scan
    # Define outputs that other jobs can consume, such as the built image name.
    outputs:
      docker_image: ${{ steps.build-image.outputs.docker_image }}

    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Full history might be needed for some tools, e.g., Git-aware scanners

    - name: Set up Docker BuildX (for multi-platform builds, optional)
      # BuildX provides enhanced build capabilities, including caching and multi-platform builds.
      uses: docker/setup-buildx-action@v3
      with:
        install: true
        driver-opts: image=moby/buildkit:latest # Ensure latest BuildKit features

    - name: Define Docker Image Name and Tag
      id: set-image-tag
      run: |
        # Use a consistent image name and tag strategy.
        # For PRs or non-main branches, use the branch name or commit SHA.
        # For main, use a unique identifier like the run number.
        IMAGE_BASE_NAME="my-secure-app-container"
        REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        IMAGE_NAME="${REPO_OWNER}/${IMAGE_BASE_NAME}"

        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          # For pull requests, tag with PR number and commit SHA.
          IMAGE_TAG="pr-${{ github.event.pull_request.number }}-${{ github.sha }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/develop" ]]; then
          # For main/develop branch pushes, use branch name and run number.
          # You might also consider semver tags for releases.
          BRANCH_NAME=$(echo "${{ github.ref }}" | sed 's/refs\/heads\///g')
          IMAGE_TAG="${BRANCH_NAME}-${{ github.run_number }}-${{ github.sha }}"
        else
          # Fallback for other branches or events, use commit SHA.
          IMAGE_TAG="untracked-${{ github.sha }}"
        fi

        # If a custom tag was provided via workflow_dispatch, override.
        if [[ -n "${{ github.event.inputs.imageTag }}" ]]; then
          IMAGE_TAG="${{ github.event.inputs.imageTag }}"
          echo "Using custom image tag from workflow_dispatch: ${IMAGE_TAG}"
        fi

        FULL_IMAGE_NAME="${IMAGE_NAME}:${IMAGE_TAG}"
        echo "Resolved full Docker image name: ${FULL_IMAGE_NAME}"
        echo "docker_image=${FULL_IMAGE_NAME}" >> "$GITHUB_OUTPUT"
        echo "docker_image_name_only=${IMAGE_NAME}" >> "$GITHUB_OUTPUT"
        echo "docker_image_tag_only=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

    - name: Cache Docker Layers
      # Optimize build times by caching Docker layers.
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-docker-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-docker-
      continue-on-error: true # Allow job to proceed if cache fails

    - name: Build Docker Image
      id: build-image # Set an ID to reference this step's outputs
      # Builds the Docker image from the Dockerfile in the root.
      # Uses BuildX for improved caching and potential multi-platform builds.
      run: |
        echo "Initiating Docker image build process..."
        docker build \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --tag "${{ steps.set-image-tag.outputs.docker_image }}" \
          --output type=docker \
          .
        echo "Docker image '${{ steps.set-image-tag.outputs.docker_image }}' built successfully."
        # Output the full image name for consumption by subsequent jobs.
        echo "docker_image=${{ steps.set-image-tag.outputs.docker_image }}" >> "$GITHUB_OUTPUT"
      env:
        DOCKER_BUILDKIT: 1 # Ensure BuildKit is enabled
        # Example of build arguments:
        # BUILD_ENVIRONMENT: "ci"
        # APP_VERSION: "${{ github.sha }}"

    - name: Login to Container Registry (Optional but Recommended)
      # Log in to GitHub Container Registry (GHCR) or Docker Hub.
      # This is necessary for pushing images and often for pulling base images
      # from private registries. Credentials should be stored as GitHub Secrets.
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io # Or docker.io for Docker Hub
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }} # Use GITHUB_TOKEN for GHCR
      continue-on-error: true # Don't fail the job if login fails (e.g., wrong secrets)

    - name: Push Docker Image to Registry (Optional)
      # Push the built image to a container registry for later use or deployment.
      # This step should typically be conditional, e.g., only on successful main branch builds.
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        echo "Pushing Docker image '${{ steps.build-image.outputs.docker_image }}' to registry..."
        docker push "${{ steps.build-image.outputs.docker_image }}"
        echo "Image push complete."

    - name: Scan Docker Image for Vulnerabilities with Trivy
      # Uses the Aqua Security Trivy action to scan the built Docker image.
      # This step identifies known CVEs in OS packages and application dependencies.
      uses: aquasecurity/trivy-action@v0.20.0 # Pin to a specific version
      with:
        image-ref: '${{ steps.build-image.outputs.docker_image }}'
        format: 'sarif' # Output results in SARIF format for GitHub Security tab
        output: 'trivy-vulnerabilities.sarif'
        # Define severity levels that should cause the job to fail.
        # CRITICAL, HIGH, MEDIUM are commonly used for blocking builds.
        severity: 'CRITICAL,HIGH,MEDIUM'
        # Exit code 1 if vulnerabilities of specified severity are found,
        # otherwise exit code 0. This makes the job fail on high-severity findings.
        exit-code: '1'
        # Set a reasonable timeout for the scan to prevent indefinite hangs.
        scan-timeout: '5m'
        # Additional Trivy configurations:
        ignore-unfixed: true # Only report vulnerabilities with available fixes
        # template: '@contrib/html.tpl' # Example: Generate an HTML report
        # sca-params: --skip-files /etc/path/to/specific/file.txt # Skip specific paths from SCA
      env:
        # Suppress progress bars in logs for cleaner output in CI.
        TRIVY_NO_PROGRESS: 'true'
        # TRIVY_CACHE_DIR: '/tmp/trivy-cache' # Customize cache location

    - name: Upload Trivy Vulnerability SARIF results to GitHub Security tab
      # This step uploads the SARIF report to the GitHub Security tab,
      # making vulnerabilities visible directly in the repository's security alerts.
      # 'if: always()' ensures results are uploaded even if the previous scan step failed.
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-vulnerabilities.sarif'
        category: 'Trivy Image Vulnerability Scan' # Helps categorize alerts in GitHub UI
        # The upload automatically links to the correct commit/PR context.

    - name: Perform Trivy Misconfiguration Scan
      # Scans the Docker image for common misconfigurations, exposed secrets (limited),
      # and other security best practice violations beyond CVEs.
      uses: aquasecurity/trivy-action@v0.20.0
      with:
        image-ref: '${{ steps.build-image.outputs.docker_image }}'
        # Specify 'config' scanner to focus on configuration issues.
        scanners: 'config'
        format: 'sarif'
        output: 'trivy-misconfigurations.sarif'
        severity: 'CRITICAL,HIGH' # Fail on critical/high misconfigurations
        exit-code: '1'
        scan-timeout: '3m'
        # config-scanners-ignore-policy: 'AVD-ID-0001' # Ignore specific configuration policies
      env:
        TRIVY_NO_PROGRESS: 'true'

    - name: Upload Trivy Misconfiguration SARIF results to GitHub Security tab
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-misconfigurations.sarif'
        category: 'Trivy Image Misconfiguration Scan'

    - name: Post-scan Cleanup (Optional)
      run: |
        echo "Cleaning up local Docker image and Trivy cache to free up space."
        docker rmi -f "${{ steps.build-image.outputs.docker_image }}" || true
        # Clean Trivy cache if it was stored locally
        # docker run --rm aquasecurity/trivy:latest cache --clear || true

  #############################################################################
  # Job 3: Secret Detection in Docker Image Layers
  #
  # This job scans the built Docker image for hardcoded secrets, API keys,
  # and other sensitive credentials that might have accidentally been embedded
  # during the build process. It leverages TruffleHog for deep scanning.
  #############################################################################
  secret_detection_in_image:
    name: "Secret Scanner (TruffleHog)"
    needs: build_and_scan_vulnerabilities # Depends on image being successfully built
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set DOCKER_IMAGE_TO_SCAN Environment Variable
      # Retrieves the full Docker image name from the output of the previous job.
      run: |
        echo "DOCKER_IMAGE_TO_SCAN=${{ needs.build_and_scan_vulnerabilities.outputs.docker_image }}" >> "$GITHUB_ENV"
      shell: bash

    - name: Verify Target Image for Secret Scan
      run: |
        if [ -z "${{ env.DOCKER_IMAGE_TO_SCAN }}" ]; then
          echo "::error::DOCKER_IMAGE_TO_SCAN environment variable is not set. Cannot proceed with secret scanning."
          exit 1
        fi
        echo "Target Docker image for secret scan: ${{ env.DOCKER_IMAGE_TO_SCAN }}"

    - name: Install TruffleHog (via Docker)
      # Pulls the TruffleHog Docker image. This is a robust way to run CLI tools.
      run: |
        echo "Downloading TruffleHog Docker image..."
        docker pull trufflesecurity/trufflehog:latest
        echo "TruffleHog image pulled successfully."
        # Create a shell function/alias for trufflehog to simplify commands.
        echo 'trufflehog() { docker run --rm -i -v "$(pwd):/code" trufflesecurity/trufflehog:latest "$@"; }' >> "$GITHUB_ENV"
      shell: bash

    - name: Scan Docker Image for Secrets with TruffleHog
      id: trufflehog_scan
      # TruffleHog directly supports scanning Docker images by prefixing with 'docker://'.
      # The output is directed to a JSON file. `|| true` prevents immediate job failure,
      # allowing the SARIF conversion/upload step to run even if secrets are found.
      run: |
        echo "Initiating TruffleHog scan on Docker image: ${{ env.DOCKER_IMAGE_TO_SCAN }}"
        trufflehog "docker://${{ env.DOCKER_IMAGE_TO_SCAN }}" \
          --json \
          --output trufflehog-results.json \
          --fail-on-detector-group 'High,Medium' \
          --exit-code 0 \
          --max-depth 10 \
          --only-verified \
          || true
        echo "TruffleHog scan command executed. Results in trufflehog-results.json."
        # The --exit-code 0 is important to let the next step check the JSON for actual findings.
      env:
        # TRUFFLEHOG_API_KEY: ${{ secrets.TRUFFLEHOG_API_KEY }} # If using enterprise features
        # TRUFFLEHOG_GIT_AUTH: ${{ secrets.GH_PAT_FOR_TRUFFLEHOG }} # For scanning git history if needed
        TRUFFLEHOG_DEBUG: 'false' # Set to 'true' for verbose logging during debugging

    - name: Convert TruffleHog JSON to SARIF Format
      id: convert_to_sarif
      # TruffleHog might not always output SARIF directly depending on version/config.
      # This step assumes a conversion script or a direct JSON-to-SARIF capability.
      # For now, we'll use a simple placeholder if a direct converter isn't available.
      run: |
        echo "Attempting to convert TruffleHog JSON results to SARIF..."
        if [ -f trufflehog-results.json ] && [ "$(jq '.[] | length' trufflehog-results.json)" -gt 0 ]; then
            # If the JSON file exists and has actual findings, generate a dummy SARIF.
            # In a real scenario, you'd use a proper converter tool or script.
            echo '{ "runs": [ { "tool": { "driver": { "name": "TruffleHog", "version": "latest" } }, "results": [] } ] }' > trufflehog-results.sarif
            # Parse trufflehog-results.json and populate the SARIF results array.
            # This requires a more complex `jq` command or a Python/Node.js script.
            # Example placeholder: jq -s '[.[] | { message: { text: .Redacted }, locations: [ { physicalLocation: { artifactLocation: { uri: .SourceMetadata.Data.Git.file } } } ] }]' trufflehog-results.json | jq '.[] | { ruleId: "trufflehog-secret", message: .message, locations: .locations }' | jq -s '{ "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json", "version": "2.1.0", "runs": [ { "tool": { "driver": { "name": "TruffleHog" } }, "results": . } ] }' > trufflehog-results.sarif
            echo "Dummy SARIF file 'trufflehog-results.sarif' created for upload."
            echo "sarif_generated=true" >> "$GITHUB_OUTPUT"
        else
            echo "No secrets detected or trufflehog-results.json is empty/missing. Skipping SARIF conversion."
            echo "sarif_generated=false" >> "$GITHUB_OUTPUT"
        fi
      shell: bash

    - name: Check TruffleHog Scan Results and Fail Job if Secrets Found
      # This step explicitly fails the job if secrets were detected by TruffleHog.
      # It parses the JSON output to determine the presence of findings.
      if: always() # Always run to check results
      run: |
        if [ -f trufflehog-results.json ]; then
            SECRET_COUNT=$(jq '.[] | length' trufflehog-results.json || echo 0)
            if [ "$SECRET_COUNT" -gt 0 ]; then
                echo "::error::TruffleHog detected $SECRET_COUNT secrets in the Docker image! Review 'trufflehog-results.json'."
                # Print first few findings for immediate visibility
                echo "First 5 secret findings:"
                jq '.[0:5]' trufflehog-results.json
                exit 1
            else
                echo "TruffleHog scan completed. No secrets detected."
            fi
        else
            echo "TruffleHog results file 'trufflehog-results.json' not found. This might indicate a problem with the scan itself."
            # Optionally, uncomment the next line to fail the job if results are expected but missing.
            # exit 1
        fi
      shell: bash

    - name: Upload TruffleHog SARIF results to GitHub Security tab
      # Only upload SARIF if it was successfully generated and findings were present.
      if: always() && steps.convert_to_sarif.outputs.sarif_generated == 'true'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trufflehog-results.sarif'
        category: 'TruffleHog Docker Image Secret Scan'

  #############################################################################
  # Job 4: Software Bill of Materials (SBOM) Generation
  #
  # This job generates an SBOM for the built Docker image using Syft.
  # An SBOM provides a comprehensive list of all components, dependencies,
  # and their licenses within the image, which is crucial for supply chain
  # security and compliance.
  #############################################################################
  sbom_generation:
    name: "SBOM Generator (Syft)"
    needs: build_and_scan_vulnerabilities # Requires the image to be built
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set DOCKER_IMAGE_FOR_SBOM Environment Variable
      # Retrieve the image name from the build job.
      run: |
        echo "DOCKER_IMAGE_FOR_SBOM=${{ needs.build_and_scan_vulnerabilities.outputs.docker_image }}" >> "$GITHUB_ENV"
      shell: bash

    - name: Verify Target Image for SBOM Generation
      run: |
        if [ -z "${{ env.DOCKER_IMAGE_FOR_SBOM }}" ]; then
          echo "::error::DOCKER_IMAGE_FOR_SBOM environment variable is not set. Cannot proceed with SBOM generation."
          exit 1
        fi
        echo "Target Docker image for SBOM generation: ${{ env.DOCKER_IMAGE_FOR_SBOM }}"

    - name: Install Syft for SBOM Generation
      # Uses the Anchore Syft action to install the tool.
      uses: anchore/syft-action@v0.6.0
      with:
        version: 'latest' # Ensure the latest Syft version for best results
        syft-args: '' # Add custom Syft arguments if needed, e.g., '--scope all-layers'

    - name: Generate SPDX SBOM in JSON Format
      # Generates a Software Bill of Materials in SPDX JSON format.
      # SPDX is a widely adopted standard for communicating SBOM information.
      run: |
        echo "Generating SPDX JSON SBOM for ${{ env.DOCKER_IMAGE_FOR_SBOM }}..."
        # syft supports various formats like cyclonedx-json, cyclonedx-xml, spdx-tag-value.
        # SPDX JSON is often preferred for machine readability and compatibility.
        syft "${{ env.DOCKER_IMAGE_FOR_SBOM }}" -o spdx-json > sbom.spdx.json
        echo "SBOM 'sbom.spdx.json' generated successfully."
      env:
        # Example: Exclude specific paths or file types from the SBOM.
        SYFT_EXCLUDE: "/dev/*, /proc/*, /sys/*"
        # SYFT_ONLY_FILES: "*.jar,*.gem" # Include only specific file types

    - name: Generate CycloneDX SBOM in JSON Format (Optional)
      # Some tools or platforms prefer CycloneDX format. Generating both provides flexibility.
      run: |
        echo "Generating CycloneDX JSON SBOM for ${{ env.DOCKER_IMAGE_FOR_SBOM }}..."
        syft "${{ env.DOCKER_IMAGE_FOR_SBOM }}" -o cyclonedx-json > sbom.cyclonedx.json
        echo "SBOM 'sbom.cyclonedx.json' generated successfully."
      continue-on-error: true # Allow pipeline to continue even if this optional format fails

    - name: Upload SBOM as Workflow Artifact
      # Uploads the generated SBOM files as a GitHub Actions artifact.
      # This makes the SBOM accessible for auditing, further processing, or later download.
      uses: actions/upload-artifact@v4
      with:
        name: sbom-artifacts # Name of the artifact bundle
        path: |
          sbom.spdx.json
          sbom.cyclonedx.json
        retention-days: 90 # Keep the SBOM artifact for 90 days
        if-no-files-found: error # Fail the job if expected SBOM files are not found

    - name: Display SBOM Content Preview (for verification)
      # Prints the first few lines of the SPDX SBOM to the job log for quick review.
      run: |
        echo "--- SPDX SBOM Content Preview (First 20 lines) ---"
        head -n 20 sbom.spdx.json || true
        echo "--- End of SBOM Preview ---"
        echo "Full SBOM files are available as 'sbom-artifacts' in the workflow run artifacts."

  #############################################################################
  # Job 5: License Compliance Scan
  #
  # This job utilizes the generated SBOM to perform license compliance checks.
  # It identifies components with problematic or disallowed licenses based on
  # predefined policies.
  #############################################################################
  license_compliance_scan:
    name: "License Compliance Checker"
    needs: sbom_generation # Requires SBOM to be generated and uploaded
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download SBOM Artifacts
      # Downloads the SBOM files generated in the previous 'sbom_generation' job.
      uses: actions/download-artifact@v4
      with:
        name: sbom-artifacts # Must match the name used in upload-artifact
        path: . # Download to the current working directory

    - name: Verify SBOM Files Exist
      # Ensures that the required SBOM file is present before proceeding.
      run: |
        ls -l sbom.spdx.json || { echo "::error::SPDX SBOM file not found!"; exit 1; }
        ls -l sbom.cyclonedx.json || { echo "CycloneDX SBOM file not found!"; exit 1; }

    - name: Perform License Compliance Check using SPDX SBOM
      # This step parses the SPDX SBOM to extract license information
      # and compares it against a predefined deny-list of problematic licenses.
      run: |
        echo "Analyzing licenses from sbom.spdx.json for compliance..."

        # Define a comma-separated list of licenses that are not allowed.
        # This list should reflect your organization's legal and open-source policies.
        DENY_LIST_LICENSES="AGPL-3.0,GPL-3.0-only,LGPL-3.0,SSPL-1.0,Commons Clause"
        echo "Configured Denied Licenses: ${DENY_LIST_LICENSES}"

        # Use 'jq' to extract unique licenses from the SPDX SBOM.
        # It looks for licenses in 'licenseInfoFromFiles', 'licenseConcluded', and 'licenseDeclared'.
        LICENSES=$(jq -r '[.packages[]?.licenseInfoFromFiles[]?, .packages[]?.licenseConcluded?, .packages[]?.licenseDeclared? | select(. != null and . != "NOASSERTION" and . != "NONE")] | unique | .[]' sbom.spdx.json)

        echo "--- Detected Unique Licenses in SBOM ---"
        if [ -z "$LICENSES" ]; then
          echo "No specific licenses detected or all are 'NOASSERTION'/'NONE'."
        else
          echo "$LICENSES"
        fi
        echo "----------------------------------------"

        VIOLATIONS=0
        if [ -n "$LICENSES" ]; then
          for license in $LICENSES; do
              # Check if the detected license is in the deny-list.
              if echo "$DENY_LIST_LICENSES" | grep -qE "(^|,)${license}(,|$)"; then
                  echo "::error::LICENSE VIOLATION: Detected denied license '$license' in a component."
                  VIOLATIONS=$((VIOLATIONS+1))
              else
                  echo "License '$license' is permitted."
              fi
          done
        fi

        if [ "$VIOLATIONS" -gt 0 ]; then
            echo "::error::License compliance check FAILED: $VIOLATIONS denied licenses found."
            echo "Review the 'sbom.spdx.json' artifact for details."
            exit 1
        else
            echo "License compliance check PASSED. No denied licenses found."
        fi
        # Advanced checks could involve:
        # - Ensuring all components have *any* declared license (not "NOASSERTION").
        # - Checking for specific license combinations or compatibility issues.
        # - Integration with a commercial License Compliance Management tool (e.g., FOSSA, Black Duck).
      shell: bash # Ensure bash is used for robust scripting

    - name: Generate License Report (Optional)
      # Creates a simple markdown report of all detected licenses.
      run: |
        echo "## Docker Image License Report" > license_report.md
        echo "" >> license_report.md
        echo "This report lists all unique licenses identified in the Docker image components." >> license_report.md
        echo "" >> license_report.md
        echo "| License | Status |" >> license_report.md
        echo "|---------|--------|" >> license_report.md

        DENY_LIST_LICENSES="AGPL-3.0,GPL-3.0-only,LGPL-3.0,SSPL-1.0,Commons Clause"
        LICENSES=$(jq -r '[.packages[]?.licenseInfoFromFiles[]?, .packages[]?.licenseConcluded?, .packages[]?.licenseDeclared? | select(. != null and . != "NOASSERTION" and . != "NONE")] | unique | .[]' sbom.spdx.json)

        if [ -n "$LICENSES" ]; then
          for license in $LICENSES; do
              if echo "$DENY_LIST_LICENSES" | grep -qE "(^|,)${license}(,|$)"; then
                  echo "| $license | ❌ DENIED |" >> license_report.md
              else
                  echo "| $license | ✅ PERMITTED |" >> license_report.md
              fi
          done
        else
          echo "| No Licenses | N/A |" >> license_report.md
        fi
        echo "License report 'license_report.md' generated."

    - name: Upload License Report as Workflow Artifact
      uses: actions/upload-artifact@v4
      with:
        name: license-report
        path: license_report.md
        retention-days: 30
      if: always() # Always upload the report even if license check fails

  #############################################################################
  # Job 6: Artifact Attestation and Signing
  #
  # This job uses Sigstore Cosign to sign the Docker image and attach its SBOM
  # as an attestation. This provides tamper-evidence and supply chain transparency.
  # Keyless signing is used, leveraging the OIDC identity of the GitHub Actions runner.
  #############################################################################
  artifact_attestation:
    name: "Image Attestation (Cosign)"
    needs: [build_and_scan_vulnerabilities, sbom_generation] # Requires image & SBOM
    runs-on: ubuntu-latest
    timeout-minutes: 8
    # Permissions required for Sigstore's keyless signing with OIDC.
    permissions:
      id-token: write # Allows fetching OIDC ID token
      contents: read # Required to checkout the repository code
      packages: write # Required to push signatures/attestations to GHCR

    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set DOCKER_IMAGE_FOR_SIGNING Environment Variable
      # Retrieves the full Docker image name from the output of the build job.
      run: |
        echo "DOCKER_IMAGE_FOR_SIGNING=${{ needs.build_and_scan_vulnerabilities.outputs.docker_image }}" >> "$GITHUB_ENV"
      shell: bash

    - name: Verify Target Image for Signing
      run: |
        if [ -z "${{ env.DOCKER_IMAGE_FOR_SIGNING }}" ]; then
          echo "::error::DOCKER_IMAGE_FOR_SIGNING environment variable is not set. Cannot proceed with signing."
          exit 1
        fi
        echo "Target Docker image for signing: ${{ env.DOCKER_IMAGE_FOR_SIGNING }}"

    - name: Install Cosign
      # Installs the Cosign CLI tool, part of the Sigstore project.
      uses: sigstore/cosign-installer@v3.4.0
      with:
        cosign-release: 'v2.2.0' # Pin to a specific, stable Cosign version

    - name: Configure Sigstore Identity for Keyless Signing
      # Sets up the environment variables required for Cosign's keyless signing.
      # It uses the OIDC identity of the GitHub Actions workflow.
      run: |
        # Set the OIDC issuer URL for GitHub Actions.
        echo "SIGSTORE_OIDC_ISSUER=https://token.actions.githubusercontent.com" >> "$GITHUB_ENV"
        # Set the OIDC subject (identity) that will be recorded in the signature.
        # This typically includes the repository, workflow, and commit.
        echo "SIGSTORE_OIDC_SUBJECT=repository:${{ github.repository }}:ref:${{ github.ref }}" >> "$GITHUB_ENV"
        echo "Sigstore OIDC identity configured for keyless signing."
      shell: bash

    - name: Download SBOM Artifacts for Attestation
      # The SBOM generated previously is attached as an attestation.
      uses: actions/download-artifact@v4
      with:
        name: sbom-artifacts
        path: .

    - name: Sign Docker Image (Keyless)
      # Uses Cosign to sign the Docker image.
      # Keyless signing sends the signature to the Rekor transparency log.
      run: |
        echo "Starting keyless signing of Docker image: ${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        # The '--yes' flag bypasses interactive prompts.
        cosign sign --yes "${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        echo "Docker image signed successfully."
      env:
        # COSIGN_EXPERIMENTAL: "true" # Enable experimental features if needed

    - name: Attest SBOM to Docker Image
      # Attaches the SPDX SBOM as a software supply chain attestation to the signed image.
      # This provides an immutable record of the image's components.
      run: |
        echo "Attaching SPDX SBOM as an attestation to ${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        cosign attest --yes \
          --predicate sbom.spdx.json \
          --type spdxjson \
          "${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        echo "SBOM attestation complete."

    - name: Verify Signed Image (Optional, for auditing)
      # Verifies the digital signature of the Docker image.
      # This step should pass if the image was signed correctly.
      run: |
        echo "Verifying signature of Docker image: ${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        # A full verification would include checking the OIDC issuer and subject.
        # cosign verify --key-oidc-issuer "${{ env.SIGSTORE_OIDC_ISSUER }}" \
        #   --key-rekor-url https://rekor.sigstore.dev \
        #   "${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        cosign verify "${{ env.DOCKER_IMAGE_FOR_SIGNING }}" || { echo "::error::Image signature verification FAILED!"; exit 1; }
        echo "Image signature verification successful."

    - name: Verify SBOM Attestation (Optional)
      # Verifies that the SBOM attestation is correctly linked and valid for the image.
      run: |
        echo "Verifying SBOM attestation for Docker image: ${{ env.DOCKER_IMAGE_FOR_SIGNING }}"
        cosign verify-attestation \
          --type spdxjson \
          "${{ env.DOCKER_IMAGE_FOR_SIGNING }}" || { echo "::error::SBOM attestation verification FAILED!"; exit 1; }
        echo "SBOM attestation verification successful."

  #############################################################################
  # Job 7: Final Release / Deployment Gate (Placeholder)
  #
  # This job acts as a placeholder for final release or deployment actions.
  # It depends on all previous security checks passing, ensuring that only
  # securely vetted images proceed further in the CI/CD pipeline.
  #############################################################################
  final_release_gate:
    name: "Deployment Gate / Release Candidate"
    # This job only runs if ALL previous security jobs have succeeded.
    needs:
      - build_and_scan_vulnerabilities
      - secret_detection_in_image
      - sbom_generation
      - license_compliance_scan
      - artifact_attestation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Only run this job for successful merges to main branch.
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4

    - name: Set DOCKER_IMAGE_FOR_RELEASE Environment Variable
      run: |
        echo "DOCKER_IMAGE_FOR_RELEASE=${{ needs.build_and_scan_vulnerabilities.outputs.docker_image }}" >> "$GITHUB_ENV"
      shell: bash

    - name: Final Security Review Confirmation
      run: |
        echo "--------------------------------------------------------"
        echo "All critical security checks passed for Docker Image:"
        echo "  -> ${{ env.DOCKER_IMAGE_FOR_RELEASE }}"
        echo "This image is now considered a RELEASE CANDIDATE."
        echo "--------------------------------------------------------"
        echo "Further actions could include:"
        echo "  - Tagging the image with a production-ready version (e.g., v1.0.0)"
        echo "  - Pushing the image to a production container registry."
        echo "  - Triggering a deployment pipeline (e.g., Kubernetes, ECS)."
        echo "  - Archiving all security reports for long-term audit."
        echo "  - Notifying relevant teams (e.g., security, operations) of readiness."

    - name: Create Release Tag (Optional)
      # Example of creating a GitHub Release or version tag for the image.
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        RELEASE_TAG="v$(date +%Y%m%d%H%M)-${{ github.run_number }}"
        echo "Creating release tag: ${RELEASE_TAG}"
        # git tag ${RELEASE_TAG}
        # git push origin ${RELEASE_TAG}
        echo "For demonstration, skipping actual git tag push."
        echo "The image '${{ env.DOCKER_IMAGE_FOR_RELEASE }}' is ready for deployment under this release identifier."

    - name: Dummy Deployment Step (Placeholder)
      # This step simulates the deployment of the validated Docker image.
      run: |
        echo "Simulating deployment of ${{ env.DOCKER_IMAGE_FOR_RELEASE }} to production environment..."
        # Example: helm upgrade my-app my-chart --set image.tag=${{ env.DOCKER_IMAGE_FOR_RELEASE }}
        # Example: kubectl apply -f deployment.yaml
        sleep 10 # Simulate deployment time
        echo "Deployment simulation complete."
        echo "The Docker image has successfully passed all security gates and is deployed."