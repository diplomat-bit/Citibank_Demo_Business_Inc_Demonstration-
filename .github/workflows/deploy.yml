name: Deploy Application

on:
  push:
    branches:
      - "main" # This workflow is triggered on pushes to the 'main' branch.
               # This strategy assumes that any code merged into 'main' has already
               # passed necessary build and test checks (e.g., by a preceding CI workflow).
               # For more precise control, 'workflow_run' can be used to trigger
               # this workflow specifically after another build/test workflow completes successfully.
               # However, adhering to the seed file's pattern, 'push' is utilized here.

jobs:
  # --------------------------------------------------------------------------------------------------
  # Job: deploy-staging
  # Description: This job is dedicated to deploying the application to the staging environment.
  #              The staging environment acts as a near-production replica, crucial for final
  #              testing, user acceptance testing (UAT), and validation before a public release.
  #              It helps catch environment-specific issues that might not appear in development.
  # --------------------------------------------------------------------------------------------------
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest # Specifies the type of virtual machine to execute the job on.
                           # 'ubuntu-latest' offers a robust and up-to-date Linux environment.
                           # Other options include 'windows-latest', 'macos-latest', or self-hosted runners
                           # for specialized environments or hardware.
    environment:           # Declares a GitHub environment for this deployment.
                           # Environments provide features like deployment protection rules (e.g., manual approval),
                           # environment-specific secrets, and deployment history tracking in GitHub.
      name: Staging        # The logical name for this deployment environment.
      url: https://staging.example.com # An optional URL to link directly to the deployed application.

    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4 # This action retrieves the repository's code to the runner.
                                # It's a foundational step, ensuring the latest version of the code
                                # targeted by the 'push' event is available for deployment.
      with:
        fetch-depth: 0 # Configures the checkout action to fetch the entire Git history.
                       # This can be beneficial for tasks such as creating release tags
                       # or performing operations that require full commit history.

    - name: Set up Node.js Environment
      uses: actions/setup-node@v4 # Configures a Node.js environment on the runner.
                                  # Essential if your application or deployment tools are Node.js-based.
      with:
        node-version: 22          # Specifies the exact Node.js version to install.
                                  # It's critical to match this with the version used during your local
                                  # development and CI build processes to prevent inconsistencies.
        cache: 'npm'              # Enables caching for npm dependencies. This significantly
                                  # reduces job execution time by reusing previously installed packages.
        cache-dependency-path: 'package-lock.json' # Defines the lock file used by npm for caching.

    - name: Install Project Dependencies (if necessary for deployment scripts)
      run: |
        echo "Attempting to install npm project dependencies."
        echo "This step is required if your deployment scripts or assets rely on Node.js packages"
        echo "that are not part of the final build artifact (e.g., if you re-build here, or use deploy tools)."
        # npm ci # 'npm ci' ensures a clean install from 'package-lock.json', ideal for CI.
                 # Add '--omit=dev' if development dependencies are not needed for deployment.
        echo "npm dependencies installation check/completion."

    - name: Download Build Artifacts (Highly Recommended for Consistent Deployments)
      # This step is crucial for deploying the *exact* output of a previous build workflow.
      # It ensures consistency between what was tested and what is deployed, preventing
      # potential "works on my machine" or "works in CI but not deploy" issues due to re-building.
      # Uncomment and configure this if your build workflow (e.g., 'npm-grunt.yml') uses
      # 'actions/upload-artifact' to save compiled assets (e.g., 'dist' folder).
      # uses: actions/download-artifact@v4
      # with:
      #   name: my-application-build-output # Replace with the actual artifact name from your build workflow.
      #   path: ./build-dist                # The directory where the artifact will be downloaded.
      echo "--- Artifact Download Placeholder ---"
      echo "In a production-grade CI/CD pipeline, the build (compilation, bundling, etc.)"
      echo "should happen only once in a dedicated build job."
      echo "The resulting deployable artifacts (e.g., a 'dist' folder, a Docker image, a JAR file)"
      echo "should then be uploaded as GitHub Actions artifacts."
      echo "This step would then download those artifacts to ensure the build that passed CI tests"
      echo "is precisely what gets deployed. This avoids any re-building on the deploy runner"
      echo "which could introduce inconsistencies."
      echo "Example usage for downloading: "
      echo "  uses: actions/download-artifact@v4"
      echo "  with:"
      echo "    name: 'web-app-build-assets'"
      echo "    path: './app-build/'"
      echo "--- End Artifact Download Placeholder ---"

    - name: Execute Staging Deployment Strategy
      run: |
        echo "--- Initiating Application Deployment to Staging Environment ---"
        echo "This crucial section contains the specific commands and logic required to push"
        echo "your application to the staging server or cloud service."
        echo "The implementation here is highly dependent on your chosen deployment method and infrastructure."
        echo ""
        echo "Common deployment patterns and examples for staging:"
        echo ""
        echo "1.  **Static Site / SPA Deployment (e.g., Netlify, Vercel, AWS S3, Azure Static Web Apps):**"
        echo "    If deploying a client-side application or static assets:"
        echo "    - **Netlify CLI:**"
        echo "      npm install -g netlify-cli"
        echo "      netlify deploy --dir=./build-dist --alias=staging-branch-preview.netlify.app --message \"Staging deploy via GA #${GITHUB_RUN_NUMBER}\""
        echo "      (Requires NETLIFY_AUTH_TOKEN in GitHub Secrets)"
        echo "    - **AWS S3 Sync:**"
        echo "      aws s3 sync ./build-dist/ s3://your-staging-s3-bucket --delete --region us-east-1"
        echo "      (Requires AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION in GitHub Secrets)"
        echo "    - **Azure Static Web Apps CLI:**"
        echo "      npm install -g @azure/static-web-apps-cli"
        echo "      swa deploy --app-location ./build-dist --token ${{ secrets.AZURE_STATIC_WEB_APPS_TOKEN }}"
        echo ""
        echo "2.  **Server-Side Application Deployment (e.g., SSH/Rsync to VM, Docker Image Deployment):**"
        echo "    If deploying to a virtual machine or a container orchestration platform:"
        echo "    - **SSH & Rsync:**"
        echo "      # Use actions/add-ssh-key@v6 to set up SSH access"
        echo "      # (Requires STAGING_SSH_PRIVATE_KEY in GitHub Secrets)"
        echo "      echo \"${{ secrets.STAGING_SSH_PRIVATE_KEY }}\" | ssh-add -"
        echo "      rsync -avz --delete --exclude='.git' ./build-dist/ user@staging.your-domain.com:/var/www/html/app/"
        echo "      ssh user@staging.your-domain.com 'sudo systemctl restart your-app-service'"
        echo "    - **Docker Image Push:**"
        echo "      docker build -t your-org/your-app:staging-${GITHUB_RUN_NUMBER} ."
        echo "      echo \"${{ secrets.DOCKER_PASSWORD }}\" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin"
        echo "      docker push your-org/your-app:staging-${GITHUB_RUN_NUMBER}"
        echo "      # Then, use a tool like 'kubectl' or 'aws ecs update-service' to deploy to K8s/ECS."
        echo ""
        echo "3.  **Platform-as-a-Service (PaaS) Deployments (e.g., Heroku, Azure App Service, Google App Engine):**"
        echo "    - **Heroku CLI:**"
        echo "      npm install -g heroku"
        echo "      heroku container:login"
        echo "      heroku container:push web --app your-staging-app-name"
        echo "      heroku container:release web --app your-staging-app-name"
        echo "      (Requires HEROKU_API_KEY in GitHub Secrets)"
        echo ""
        echo "--- Staging Deployment Process Completed ---"
        echo "Please verify the deployment at ${{ environment.url }}"

  # --------------------------------------------------------------------------------------------------
  # Job: deploy-production
  # Description: This job is responsible for deploying the application to the production environment.
  #              Production deployments are the final step in the CI/CD pipeline and require
  #              the highest level of scrutiny, often including manual approvals and robust error handling.
  # --------------------------------------------------------------------------------------------------
  deploy-production:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest # Specifies the runner environment, typically consistent across deploy jobs.
    needs: deploy-staging  # This crucial dependency ensures that the production deployment
                           # will ONLY commence if the 'deploy-staging' job has successfully completed.
                           # This creates a safe, sequential deployment flow, guaranteeing that staging
                           # validation occurs before any production changes.
    environment:           # Defines the production GitHub environment.
      name: Production     # The logical name for the production environment.
      url: https://www.example.com # The live URL of the deployed production application.
      # Production environments often benefit from additional protection rules:
      # required_reviewers:  # Uncomment to require specific GitHub users/teams to approve deployment.
      #   - your-github-username
      #   - your-team-name

    steps:
    - name: Checkout Repository Code
      uses: actions/checkout@v4 # Fetches the repository code, identical to the staging job.
      with:
        fetch-depth: 0 # Essential for operations like creating release tags.

    - name: Set up Node.js Environment
      uses: actions/setup-node@v4 # Configures Node.js, ensuring consistent versions.
      with:
        node-version: 22
        cache: 'npm'
        cache-dependency-path: 'package-lock.json'

    - name: Install Project Dependencies (if necessary)
      run: |
        echo "Checking/installing npm dependencies required for production deployment."
        # npm ci --omit=dev # For production, ensure only essential runtime dependencies are installed.
        echo "Production dependencies installation check/completion."

    - name: Download Build Artifacts (Mandatory for Production Consistency)
      # For production, it is absolutely critical to deploy the identical artifacts
      # that were built and successfully validated in the staging environment.
      # This prevents any potential discrepancies that could arise from re-building.
      # uses: actions/download-artifact@v4
      # with:
      #   name: my-application-build-output # Must match the artifact name from the build workflow.
      #   path: ./build-dist                # Target directory for the downloaded artifacts.
      echo "--- Production Artifact Download Placeholder ---"
      echo "This step is paramount for production deployments. It ensures that the exact"
      echo "build artifacts (e.g., compiled code, static assets) that were generated by"
      echo "the CI build workflow and subsequently validated in staging, are deployed to production."
      echo "This eliminates any build-time variability that could lead to production issues."
      echo "Example: "
      echo "  uses: actions/download-artifact@v4"
      echo "  with:"
      echo "    name: 'web-app-build-assets'"
      echo "    path: './app-build/'"
      echo "--- End Production Artifact Download Placeholder ---"

    - name: Execute Production Deployment Strategy
      run: |
        echo "--- Initiating CRITICAL Production Application Deployment ---"
        echo "This section contains the highly sensitive and impactful commands for deploying to production."
        echo "Every command here must be carefully considered and tested."
        echo ""
        echo "Key considerations and examples for production deployments:"
        echo ""
        echo "1.  **Release Tagging and Versioning:**"
        echo "    Tagging releases is a best practice for traceability, hotfixes, and rollbacks."
        echo "    - git config user.name \"GitHub Actions Bot\""
        echo "    - git config user.email \"actions@github.com\""
        echo "    - RELEASE_TAG=\"v$(date +'%Y.%m.%d')-${GITHUB_RUN_NUMBER}\""
        echo "    - git tag -a \"${RELEASE_TAG}\" -m \"Production Release ${RELEASE_TAG} via GitHub Actions\""
        echo "    - git push origin \"${RELEASE_TAG}\""
        echo ""
        echo "2.  **Zero-Downtime Deployment Strategies (Highly Recommended):**"
        echo "    Minimize or eliminate service interruptions during deployment."
        echo "    - **Blue/Green Deployment:** Deploy to an entirely new, idle environment (green), then switch traffic from old (blue) to new. Requires careful infrastructure setup."
        echo "    - **Canary Deployment:** Gradually roll out the new version to a small subset of users/servers, monitor, and then progressively expand. Ideal for risk mitigation."
        echo "    - **Rolling Updates:** Update instances one by one, allowing traffic to be handled by remaining healthy instances (common in Kubernetes, ECS)."
        echo "    - The commands for these strategies depend heavily on your cloud provider's services (e.g., AWS CodeDeploy, Azure Deployment Slots, Kubernetes rolling updates)."
        echo ""
        echo "3.  **Database Migrations (Handle with Extreme Caution):**"
        echo "    If your application involves database schema changes:"
        echo "    - **Always ensure migrations are backward-compatible** with the currently running application version before deployment."
        echo "    - Run migrations *before* switching traffic to the new application version, or as part of an atomic deployment process."
        echo "    - Example (Node.js/TypeORM): npm run typeorm migration:run"
        echo "    - Example (Manual SSH): ssh user@prod.your-domain.com 'cd /app && npm run db:migrate:prod'"
        echo ""
        echo "4.  **Cache Invalidation (CDN, Application Cache):**"
        echo "    Clear or invalidate caches to ensure users receive the latest content."
        echo "    - **CDN (e.g., Cloudflare, CloudFront):**"
        echo "      curl -X POST \"https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache\" \\"
        echo "        -H \"Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}\" \\"
        echo "        -H \"Content-Type: application/json\" \\"
        echo "        --data '{\"purge_everything\":true}'"
        echo "    - **Application Cache (Redis, Memcached):** Implement a script to flush relevant keys."
        echo ""
        echo "5.  **Environment Variables and Secrets Management:**"
        echo "    Verify that all production-specific environment variables and secrets are correctly"
        echo "    configured in the 'Production' GitHub Environment and securely accessed."
        echo "    Example: ${{ secrets.PROD_API_KEY }}, ${{ secrets.PROD_DB_CONNECTION_STRING }}, ${{ secrets.SENTRY_DSN }}"
        echo ""
        echo "6.  **Post-Deployment Verification and Monitoring:**"
        echo "    After deployment, trigger automated smoke tests or health checks."
        echo "    Ensure integration with monitoring (e.g., Prometheus, Grafana, Datadog) and alerting systems."
        echo "    (A separate 'post-deployment-tests' job might be beneficial here, with 'needs: deploy-production')"
        echo ""
        echo "--- Production Deployment Process Completed ---"
        echo "Immediately verify application health and functionality at ${{ environment.url }}"
        echo "Monitor logs and metrics closely for any anomalies."