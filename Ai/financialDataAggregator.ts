// Copyright James Burvel O’Callaghan III
// President Citibank Demo Business Inc.

// No external library imports are permitted for this file, as per the architectural blueprint.
// All logic must be self-contained within this file, utilizing only native JavaScript/TypeScript features.

/**
 * The base URL for all API routes owned by Citibank Demo Business Inc.
 * This URL is used for internal API calls such as categorization, fraud detection,
 * or updating internal transaction statuses, reinforcing ownership and domain context.
 */
const CITIBANK_DEMO_BUSINESS_BASE_URL = "https://citibankdemobusiness.dev";

/**
 * Enumerates the possible financial data sources integrated with the platform.
 * This helps in tracking the origin of aggregated data and routing source-specific logic.
 */
enum FinancialDataSource {
  Stripe = "Stripe",
  Plaid = "Plaid",
  ModernTreasury = "ModernTreasury",
  CitibankDemoBusiness = "CitibankDemoBusiness", // Represents data originating from internal systems
}

/**
 * Represents a standardized, globally unique identifier for an entity (account or transaction)
 * across all integrated financial data sources. This ID is generated by the aggregation service
 * to ensure consistency and enable unified data management, even if source IDs overlap or differ.
 */
type UnifiedId = string;

/**
 * Represents common status types for financial transactions across all sources.
 * This enum provides a normalized view of transaction states, simplifying UI rendering
 * and business logic that depends on transaction lifecycle.
 */
enum TransactionStatus {
  Pending = "PENDING",
  Completed = "COMPLETED",
  Failed = "FAILED",
  Canceled = "CANCELED",
  Refunded = "REFUNDED",
  Disputed = "DISPUTED",
  Void = "VOID",
}

/**
 * Represents common types for financial transactions, categorized for unified analysis.
 * This normalization allows for consistent reporting and filtering regardless of the
 * original source's specific transaction type definitions.
 */
enum TransactionType {
  Deposit = "DEPOSIT",
  Withdrawal = "WITHDRAWAL",
  Transfer = "TRANSFER",
  Payment = "PAYMENT",
  Refund = "REFUND",
  Fee = "FEE",
  Adjustment = "ADJUSTMENT",
  Charge = "CHARGE",
  Payout = "PAYOUT",
  Credit = "CREDIT",
  Debit = "DEBIT",
  Interest = "INTEREST",
  Tax = "TAX",
}

/**
 * Represents common types for financial accounts, standardized across different providers.
 * This abstraction enables uniform handling of diverse account types (e.g., bank accounts,
 * credit cards, digital wallets) from various financial institutions.
 */
enum AccountType {
  Checking = "CHECKING",
  Savings = "SAVINGS",
  CreditCard = "CREDIT_CARD",
  Loan = "LOAN",
  Investment = "INVESTMENT",
  Wallet = "WALLET", // Represents digital payment accounts like Stripe
  MoneyMarket = "MONEY_MARKET",
  LineOfCredit = "LINE_OF_CREDIT",
  Other = "OTHER",
}

/**
 * Represents a standardized financial account structure, normalized from various external data sources.
 * This interface defines the core attributes expected for any account managed by the Citibank Demo Business platform.
 */
interface NormalizedAccount {
  /**
   * A unique identifier generated by the aggregation service for this account.
   * Ensures global uniqueness across all integrated financial data sources.
   */
  unifiedId: UnifiedId;
  /**
   * The original, unique identifier for the account within its source system (e.g., Stripe's 'acct_...', Plaid's 'account_id').
   */
  sourceId: string;
  /**
   * The original data source from which this account information was retrieved (e.g., Stripe, Plaid, ModernTreasury).
   */
  source: FinancialDataSource;
  /**
   * A human-readable name for the account, typically provided by the user or the source system.
   */
  name: string;
  /**
   * The financial institution name associated with the account, if applicable (e.g., "Bank of America", "Citibank").
   * Not all sources provide this (e.g., Stripe accounts might just be "Stripe").
   */
  institutionName?: string;
  /**
   * The last four digits of the account number, primarily for display and identification while maintaining privacy.
   */
  accountNumberLast4?: string;
  /**
   * The full account number, if available and authorized for access.
   * Should be handled with strict security protocols.
   */
  fullAccountNumber?: string;
  /**
   * The ISO 4217 currency code of the account (e.g., 'USD', 'EUR', 'GBP').
   * All balances and transaction amounts within this account should adhere to this currency.
   */
  currency: string;
  /**
   * The current available balance of the account, representing funds that can be immediately withdrawn or transacted.
   * Expressed in the smallest currency unit (e.g., cents for USD).
   */
  availableBalance: number;
  /**
   * The current ledger balance of the account, representing all posted transactions, including those not yet available.
   * Expressed in the smallest currency unit (e.g., cents for USD).
   */
  currentBalance: number;
  /**
   * The type of account (e.g., checking, savings, credit card) based on a normalized enum.
   */
  type: AccountType;
  /**
   * Date when the account was opened, if available from the source system.
   * Formatted as an ISO 8601 date string (e.g., "YYYY-MM-DDTHH:mm:ssZ").
   */
  openedDate?: string;
  /**
   * Any additional, un-normalized metadata or custom fields from the source system.
   * Stored as a generic key-value pair object to preserve source-specific details.
   */
  metadata: Record<string, unknown>;
  /**
   * Timestamp when this account record was last updated by the aggregation service.
   * Formatted as an ISO 8601 date string.
   */
  lastUpdated: string;
}

/**
 * Represents a standardized financial transaction structure, normalized from various external data sources.
 * This interface defines the core attributes for any transaction managed by the Citibank Demo Business platform.
 */
interface NormalizedTransaction {
  /**
   * A unique identifier generated by the aggregation service for this transaction.
   * Ensures global uniqueness across all integrated financial data sources.
   */
  unifiedId: UnifiedId;
  /**
   * The original, unique identifier for the transaction within its source system.
   */
  sourceId: string;
  /**
   * The original data source from which this transaction information was retrieved.
   */
  source: FinancialDataSource;
  /**
   * The unified ID of the account associated with this transaction.
   * This links the transaction to a specific `NormalizedAccount`.
   */
  accountId: UnifiedId;
  /**
   * A descriptive text for the transaction, often including merchant name or payment purpose.
   */
  description: string;
  /**
   * The amount of the transaction. Negative for debits (outflows), positive for credits (inflows).
   * Expressed in the smallest currency unit (e.g., cents for USD) for consistency.
   */
  amount: number;
  /**
   * The ISO 4217 currency code of the transaction. Should match the associated account's currency.
   */
  currency: string;
  /**
   * The date and time the transaction officially posted or settled in the account.
   * Formatted as an ISO 8601 date string.
   */
  date: string;
  /**
   * The date and time the transaction was authorized, if different from the posted date.
   * Formatted as an ISO 8601 date string.
   */
  authorizedDate?: string;
  /**
   * The current status of the transaction based on a normalized enum.
   */
  status: TransactionStatus;
  /**
   * The type of transaction based on a normalized enum (e.g., deposit, withdrawal, payment).
   */
  type: TransactionType;
  /**
   * The name of the counterparty (e.g., merchant, sender, recipient) involved in the transaction, if available.
   */
  counterpartyName?: string;
  /**
   * A categorization of the transaction, either from the source or enriched by internal logic.
   * Can be a simple string or a hierarchical path (e.g., "Food > Restaurants").
   */
  category?: string;
  /**
   * Any additional, un-normalized metadata or custom fields from the source system.
   */
  metadata: Record<string, unknown>;
  /**
   * Timestamp when this transaction record was last updated by the aggregation service.
   * Formatted as an ISO 8601 date string.
   */
  lastUpdated: string;
}

/**
 * Type representing a basic structure for API responses, including potential errors.
 * This is used for internal simulation of external API calls.
 */
interface ApiResponse<T> {
  data: T | null;
  error?: string;
}

/**
 * --- SIMULATED STRIPE DATA STRUCTURES ---
 * These interfaces represent a simplified subset of Stripe's API responses
 * for accounts and transactions, used for demonstration purposes.
 * In a real application, these would be defined by the Stripe SDK.
 */
interface StripeBalanceDetails {
  object: "balance";
  available: Array<{ amount: number; currency: string }>; // In cents
  pending: Array<{ amount: number; currency: string }>; // In cents
  livemode: boolean;
}

interface StripeAccountDetails {
  id: string; // e.g., 'acct_...'
  object: "account";
  business_profile?: { name?: string };
  email?: string;
  type: "standard" | "express" | "custom";
  country: string; // ISO 3166-1 alpha-2 country code
  currency: string; // Default currency, e.g., 'usd'
  charges_enabled: boolean;
  payouts_enabled: boolean;
  created: number; // Unix timestamp
  metadata: Record<string, string>;
  capabilities?: Record<string, "active" | "inactive" | "pending" | "restricted">;
  settings?: {
    payouts?: {
      schedule?: {
        interval: "manual" | "daily" | "weekly" | "monthly";
        delay_days?: number;
      };
    };
  };
}

interface StripeChargeDetails {
  id: string; // e.g., 'ch_...'
  object: "charge";
  amount: number; // In cents
  currency: string;
  created: number; // Unix timestamp
  description: string | null;
  status: "succeeded" | "pending" | "failed";
  paid: boolean;
  refunded: boolean;
  captured: boolean;
  balance_transaction: string | null; // ID of the balance transaction
  customer: string | null; // ID of the customer
  metadata: Record<string, string>;
  amount_captured: number; // In cents
  amount_refunded: number; // In cents
  payment_intent: string | null; // ID of the payment intent
  receipt_email: string | null;
  receipt_number: string | null;
}

interface StripePayoutDetails {
  id: string; // e.g., 'po_...'
  object: "payout";
  amount: number; // In cents
  currency: string;
  created: number; // Unix timestamp
  status: "pending" | "in_transit" | "paid" | "failed" | "canceled";
  description: string | null;
  type: "bank_account" | "card";
  destination: string | null; // ID of bank account or card
  balance_transaction: string;
  statement_descriptor: string | null;
}

/**
 * --- SIMULATED PLAID DATA STRUCTURES ---
 * These interfaces represent a simplified subset of Plaid's API responses
 * for accounts and transactions, used for demonstration purposes.
 * In a real application, these would be defined by the Plaid SDK.
 */
interface PlaidBalanceDetails {
  available: number | null; // In base units (e.g., dollars)
  current: number | null; // In base units
  limit: number | null; // For credit cards, e.g., in base units
  iso_currency_code: string | null;
  unofficial_currency_code: string | null;
  last_updated_datetime: string | null; // ISO 8601
}

interface PlaidAccountDetails {
  account_id: string;
  balances: PlaidBalanceDetails;
  mask: string | null; // Last 4 digits of the account number
  name: string;
  official_name: string | null;
  subtype: string | null; // e.g., "checking", "savings", "credit card"
  type: "depository" | "credit" | "loan" | "investment" | "brokerage" | "other";
  verification_status: string | null; // e.g., "pending_verification", "automatically_verified"
  persistent_account_id: string | null;
}

interface PlaidTransactionDetails {
  account_id: string;
  amount: number; // Positive value for debits, negative for credits (from account holder's perspective) in base units
  iso_currency_code: string | null;
  unofficial_currency_code: string | null;
  transaction_id: string;
  date: string; // YYYY-MM-DD
  authorized_date: string | null; // YYYY-MM-DD
  name: string; // Original description from the financial institution
  merchant_name: string | null;
  pending: boolean;
  payment_channel: string; // e.g., "in store", "online", "other"
  category: string[] | null; // Plaid-provided categories
  category_id: string | null;
  transaction_type: "digital" | "place" | "special" | "unresolved";
  personal_finance_category?: {
    primary: string; // e.g., "Food and Drink"
    detailed: string; // e.g., "Fast Food"
  };
  check_number: string | null;
  pending_transaction_id: string | null;
  location?: {
    address: string | null;
    city: string | null;
    region: string | null;
    postal_code: string | null;
    country: string | null;
    lat: number | null;
    lon: number | null;
    store_number: string | null;
  };
}

interface PlaidInstitutionDetails {
  name: string;
  institution_id: string;
  url: string;
  logo: string | null;
  primary_color: string | null;
  products: string[]; // e.g., "transactions", "auth"
}

/**
 * --- SIMULATED MODERN TREASURY DATA STRUCTURES ---
 * These interfaces represent a simplified subset of Modern Treasury's API responses
 * for accounts and transactions, used for demonstration purposes.
 * In a real application, these would be defined by the Modern Treasury SDK.
 */
interface ModernTreasuryAccountDetails {
  id: string; // e.g., 'acc_...' or 'ex_acc_...'
  object: "internal_account" | "external_account";
  name: string;
  account_type: "cash" | "checking" | "savings" | "credit_card" | "money_market" | "loan" | "other";
  account_number: string;
  currency: string;
  balance: number; // In cents
  live_mode: boolean;
  created_at: string; // ISO 8601
  updated_at: string; // ISO 8601
  metadata: Record<string, string>;
  bank_name: string; // e.g., "Citibank"
  party_name: string | null; // The name of the account holder
  parent_account_id: string | null; // For nested accounts
}

interface ModernTreasuryTransactionDetails {
  id: string; // e.g., 'txn_...'
  object: "transaction";
  amount: number; // In cents
  currency: string;
  description: string;
  status: "pending" | "posted" | "void";
  direction: "credit" | "debit";
  type: "ach" | "wire" | "book" | "rtp" | "sepa" | "check" | "other"; // More types exist
  posted_at: string; // ISO 8601
  transactable_type: "expected_payment" | "payment_order" | "return" | "other";
  vendor_name: string | null;
  internal_account_id: string; // The MT internal account ID this transaction affects
  metadata: Record<string, string>;
  accounting_category_id: string | null;
  statement_descriptor: string | null;
  details?: Record<string, unknown>; // Specific details based on type (e.g., wire info)
}

/**
 * Helper function to generate a consistent unified ID.
 * This ensures that IDs are unique across different sources for the same logical entity.
 * A simple hash-like function based on source and sourceId is used for demonstration.
 * In production, a UUID v5 (name-based) or a more robust collision-resistant mechanism
 * would be employed to guarantee uniqueness and consistency.
 *
 * @param source The financial data source.
 * @param sourceId The original ID from the source system.
 * @returns A generated UnifiedId string.
 */
function generateUnifiedId(source: FinancialDataSource, sourceId: string): UnifiedId {
  // A robust implementation would use a cryptographic hash or a UUID generator (e.g., uuid/v5).
  // For this exercise, a simple concatenation and basic sanitization will serve to represent
  // the concept of a unified, unique identifier that is deterministic given source and sourceId.
  const sanitizedSourceId = sourceId.replace(/[^a-zA-Z0-9]/g, "");
  return `${source.toLowerCase()}_${sanitizedSourceId}`;
}

/**
 * Simple utility to perform a shallow clone of an object.
 * This is a basic implementation to avoid external library dependencies like `lodash.cloneDeep`,
 * adhering to the "no imports" constraint for this file.
 * It handles primitive types, arrays (recursively), and plain objects.
 *
 * @param obj The object or array to clone.
 * @returns A deep clone of the object.
 */
function cloneDeep<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(item => cloneDeep(item)) as T;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as T;
  }
  // Handle other built-in objects if necessary (e.g., RegExp, Map, Set)
  // For generic plain objects:
  const cloned = {} as T;
  for (const key in obj) {
    // eslint-disable-next-line no-prototype-builtins
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloned[key] = cloneDeep(obj[key]);
    }
  }
  return cloned;
}

/**
 * Simple utility to compare two objects for deep equality.
 * This is a basic implementation to avoid external library dependencies like `lodash.isEqual`,
 * adhering to the "no imports" constraint. It supports primitives, arrays, and plain objects.
 * It does not handle circular references, functions, Symbols, or complex built-in objects
 * (like `Map`, `Set`, `Date` instances correctly beyond value comparison).
 *
 * @param a The first object to compare.
 * @param b The second object to compare.
 * @returns True if objects are deeply equal, false otherwise.
 */
function deepIsEqual(a: any, b: any): boolean {
  if (a === b) return true; // Strict equality for primitives, and same object references

  // If both are objects (and not null)
  if (a && typeof a === 'object' && b && typeof b === 'object') {
    // Compare dates
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }

    // Compare arrays
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (!deepIsEqual(a[i], b[i])) return false;
      }
      return true;
    }

    // If one is an array and other isn't, they are not equal
    if (Array.isArray(a) !== Array.isArray(b)) return false;

    // Compare plain objects
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);

    if (keysA.length !== keysB.length) return false;

    for (const key of keysA) {
      // eslint-disable-next-line no-prototype-builtins
      if (!Object.prototype.hasOwnProperty.call(b, key) || !deepIsEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }

  return false;
}

/**
 * Normalizes a Stripe account object and its corresponding balance into a UnifiedAccount structure.
 * This function handles the mapping of Stripe's specific data model to the platform's generic account interface.
 *
 * @param account The raw Stripe account details.
 * @param balance The raw Stripe balance details for the account's primary currency.
 * @returns A `NormalizedAccount` object.
 */
function normalizeStripeAccount(
  account: StripeAccountDetails,
  balance: StripeBalanceDetails,
): NormalizedAccount {
  const unifiedId = generateUnifiedId(FinancialDataSource.Stripe, account.id);
  const now = new Date().toISOString();

  // Stripe balances are global per currency, not per connected account directly in some views.
  // We'll find the balance for the account's specified currency.
  const availableBalanceAmount =
    balance.available.find((b) => b.currency.toUpperCase() === account.currency.toUpperCase())
      ?.amount || 0;
  const pendingBalanceAmount =
    balance.pending.find((b) => b.currency.toUpperCase() === account.currency.toUpperCase())
      ?.amount || 0;

  let accountType: AccountType = AccountType.Wallet; // Stripe accounts often function as digital wallets for platform funds.
  // Further refinement could be made based on capabilities or specific use cases.

  return {
    unifiedId: unifiedId,
    sourceId: account.id,
    source: FinancialDataSource.Stripe,
    name: account.business_profile?.name || `Stripe Account ${account.id.substring(4)}`,
    institutionName: "Stripe",
    currency: account.currency.toUpperCase(),
    availableBalance: availableBalanceAmount, // Stripe amounts are in cents
    currentBalance: availableBalanceAmount + pendingBalanceAmount,
    type: accountType,
    openedDate: new Date(account.created * 1000).toISOString(),
    metadata: { ...account.metadata, type: account.type, country: account.country },
    lastUpdated: now,
  };
}

/**
 * Normalizes a Stripe charge or payout transaction object into a UnifiedTransaction structure.
 * This function maps Stripe's transaction details (e.g., charges, payouts) to the platform's
 * generic transaction interface, handling status and type conversions.
 *
 * @param transaction The raw Stripe transaction details (can be a Charge or Payout).
 * @param accountUnifiedId The unified ID of the account associated with this transaction.
 * @returns A `NormalizedTransaction` object.
 */
function normalizeStripeTransaction(
  transaction: StripeChargeDetails | StripePayoutDetails,
  accountUnifiedId: UnifiedId,
): NormalizedTransaction {
  const now = new Date().toISOString();
  let transactionStatus: TransactionStatus;
  let transactionType: TransactionType;
  let amount: number; // In cents, negative for debits, positive for credits

  if ((transaction as StripeChargeDetails).object === "charge") {
    const charge = transaction as StripeChargeDetails;
    if (charge.status === "succeeded" && charge.paid && !charge.refunded) {
      transactionStatus = TransactionStatus.Completed;
    } else if (charge.status === "failed") {
      transactionStatus = TransactionStatus.Failed;
    } else if (charge.refunded) {
      transactionStatus = TransactionStatus.Refunded;
    } else if (charge.status === "pending") {
      transactionStatus = TransactionStatus.Pending;
    } else {
      transactionStatus = TransactionStatus.Other; // Default if not explicitly handled
    }

    transactionType = charge.refunded ? TransactionType.Refund : TransactionType.Charge;
    amount = charge.amount; // A charge is typically an inflow (credit) to the merchant's Stripe account.
    if (charge.refunded) {
      // If the charge was refunded, it's an outflow from the merchant account.
      amount = -charge.amount_refunded; // Use amount_refunded for the refund value
    }

    return {
      unifiedId: generateUnifiedId(FinancialDataSource.Stripe, charge.id),
      sourceId: charge.id,
      source: FinancialDataSource.Stripe,
      accountId: accountUnifiedId,
      description: charge.description || `Stripe Charge ${charge.id}`,
      amount: amount,
      currency: charge.currency.toUpperCase(),
      date: new Date(charge.created * 1000).toISOString(),
      status: transactionStatus,
      type: transactionType,
      counterpartyName: charge.customer || "Unknown Customer",
      metadata: { ...charge.metadata, paymentIntent: charge.payment_intent },
      lastUpdated: now,
    };
  } else if ((transaction as StripePayoutDetails).object === "payout") {
    const payout = transaction as StripePayoutDetails;
    if (payout.status === "paid" || payout.status === "in_transit") {
      transactionStatus = TransactionStatus.Completed; // Or 'Pending' for 'in_transit'
    } else if (payout.status === "failed") {
      transactionStatus = TransactionStatus.Failed;
    } else if (payout.status === "pending") {
      transactionStatus = TransactionStatus.Pending;
    } else if (payout.status === "canceled") {
      transactionStatus = TransactionStatus.Canceled;
    } else {
      transactionStatus = TransactionStatus.Other;
    }
    transactionType = TransactionType.Payout;
    amount = -payout.amount; // Payouts are outflows (debits) from the Stripe account

    return {
      unifiedId: generateUnifiedId(FinancialDataSource.Stripe, payout.id),
      sourceId: payout.id,
      source: FinancialDataSource.Stripe,
      accountId: accountUnifiedId,
      description: payout.description || `Stripe Payout ${payout.id}`,
      amount: amount,
      currency: payout.currency.toUpperCase(),
      date: new Date(payout.created * 1000).toISOString(),
      status: transactionStatus,
      type: transactionType,
      counterpartyName: payout.destination || "Bank Account", // Can be expanded with destination details
      metadata: { ...payout.statement_descriptor && { statementDescriptor: payout.statement_descriptor } },
      lastUpdated: now,
    };
  } else {
    // Fallback for unexpected Stripe object types
    console.warn("Unknown Stripe transaction object type encountered during normalization:", transaction);
    return {
      unifiedId: generateUnifiedId(FinancialDataSource.Stripe, transaction.id),
      sourceId: transaction.id,
      source: FinancialDataSource.Stripe,
      accountId: accountUnifiedId,
      description: `Unknown Stripe Event ${transaction.id}`,
      amount: 0,
      currency: (transaction as any).currency?.toUpperCase() || "USD", // Attempt to infer currency
      date: new Date((transaction as any).created * 1000).toISOString(),
      status: TransactionStatus.Other,
      type: TransactionType.Other,
      metadata: {},
      lastUpdated: now,
    };
  }
}

/**
 * Normalizes a Plaid account object into a UnifiedAccount structure.
 * This function translates Plaid's account details and balance information into
 * the platform's standardized account interface.
 *
 * @param account The raw Plaid account details.
 * @param institution The raw Plaid institution details associated with the account.
 * @returns A `NormalizedAccount` object.
 */
function normalizePlaidAccount(
  account: PlaidAccountDetails,
  institution: PlaidInstitutionDetails,
): NormalizedAccount {
  const unifiedId = generateUnifiedId(FinancialDataSource.Plaid, account.account_id);
  const now = new Date().toISOString();

  let accountType: AccountType = AccountType.Other;
  switch (account.type) {
    case "depository":
      if (account.subtype === "checking") accountType = AccountType.Checking;
      else if (account.subtype === "savings") accountType = AccountType.Savings;
      else if (account.subtype === "money market") accountType = AccountType.MoneyMarket;
      break;
    case "credit":
      if (account.subtype === "credit card") accountType = AccountType.CreditCard;
      else if (account.subtype === "line of credit") accountType = AccountType.LineOfCredit;
      break;
    case "loan":
      accountType = AccountType.Loan;
      break;
    case "investment":
      accountType = AccountType.Investment;
      break;
    default:
      accountType = AccountType.Other;
      break;
  }

  // Plaid amounts are in base units (e.g., dollars), convert to cents for consistency
  const availableBalanceCents = (account.balances.available ?? 0) * 100;
  const currentBalanceCents = (account.balances.current ?? 0) * 100;

  return {
    unifiedId: unifiedId,
    sourceId: account.account_id,
    source: FinancialDataSource.Plaid,
    name: account.official_name || account.name,
    institutionName: institution.name,
    accountNumberLast4: account.mask || undefined,
    currency: (account.balances.iso_currency_code || "USD").toUpperCase(),
    availableBalance: availableBalanceCents,
    currentBalance: currentBalanceCents,
    type: accountType,
    metadata: {
      plaidSubtype: account.subtype,
      plaidType: account.type,
      verificationStatus: account.verification_status,
      persistentAccountId: account.persistent_account_id,
      lastUpdatedDateTime: account.balances.last_updated_datetime,
    },
    lastUpdated: now,
  };
}

/**
 * Normalizes a Plaid transaction object into a UnifiedTransaction structure.
 * This function translates Plaid's transaction details into the platform's
 * standardized transaction interface, handling amount inversion (Plaid's convention
 * differs from the platform's) and category mapping.
 *
 * @param transaction The raw Plaid transaction details.
 * @param accountUnifiedId The unified ID of the account related to this transaction.
 * @returns A `NormalizedTransaction` object.
 */
function normalizePlaidTransaction(
  transaction: PlaidTransactionDetails,
  accountUnifiedId: UnifiedId,
): NormalizedTransaction {
  const now = new Date().toISOString();
  let transactionStatus: TransactionStatus = TransactionStatus.Completed;
  if (transaction.pending) {
    transactionStatus = TransactionStatus.Pending;
  }

  // Plaid transaction amounts are positive for debits (outflows) and negative for credits (inflows)
  // from the account holder's perspective. Our NormalizedTransaction interface expects:
  // Negative for debits, positive for credits. So, we invert the sign.
  const amount = -transaction.amount; // In base units

  let transactionType: TransactionType = TransactionType.Payment; // Default for general payments
  const primaryCategory = transaction.personal_finance_category?.primary;
  const detailedCategory = transaction.personal_finance_category?.detailed;

  // Map Plaid's primary categories to our `TransactionType` enum
  if (primaryCategory) {
    switch (primaryCategory) {
      case "Transfer":
        transactionType = TransactionType.Transfer;
        break;
      case "Income":
        transactionType = TransactionType.Deposit;
        break;
      case "Loans and Cash Advances":
        transactionType = TransactionType.Withdrawal;
        break;
      case "Bank Fees":
        transactionType = TransactionType.Fee;
        break;
      case "Payment": // Plaid's `Payment` means credit card payments typically
        transactionType = amount > 0 ? TransactionType.Payment : TransactionType.Deposit;
        break;
      case "Food and Drink":
      case "Shopping":
      case "Bills and Utilities":
      case "Travel":
      case "Healthcare":
        transactionType = TransactionType.Payment; // General spending
        break;
      // ... more mappings as needed
      default:
        transactionType = TransactionType.Other;
    }
  }

  return {
    unifiedId: generateUnifiedId(FinancialDataSource.Plaid, transaction.transaction_id),
    sourceId: transaction.transaction_id,
    source: FinancialDataSource.Plaid,
    accountId: accountUnifiedId,
    description: transaction.name || transaction.merchant_name || `Plaid Transaction ${transaction.transaction_id}`,
    amount: amount * 100, // Plaid amounts are in base units, convert to cents for consistency
    currency: (transaction.iso_currency_code || "USD").toUpperCase(),
    date: new Date(transaction.date).toISOString(),
    authorizedDate: transaction.authorized_date ? new Date(transaction.authorized_date).toISOString() : undefined,
    status: transactionStatus,
    type: transactionType,
    counterpartyName: transaction.merchant_name || undefined,
    category: detailedCategory || (transaction.category ? transaction.category.join(" > ") : undefined),
    metadata: {
      checkNumber: transaction.check_number,
      paymentChannel: transaction.payment_channel,
      transactionType: transaction.transaction_type,
      plaidCategoryId: transaction.category_id,
      location: transaction.location,
    },
    lastUpdated: now,
  };
}

/**
 * Normalizes a Modern Treasury account object into a UnifiedAccount structure.
 * This function translates Modern Treasury's account details into the platform's
 * standardized account interface, converting types and preserving metadata.
 *
 * @param account The raw Modern Treasury account details.
 * @returns A `NormalizedAccount` object.
 */
function normalizeModernTreasuryAccount(
  account: ModernTreasuryAccountDetails,
): NormalizedAccount {
  const unifiedId = generateUnifiedId(FinancialDataSource.ModernTreasury, account.id);
  const now = new Date().toISOString();

  let accountType: AccountType = AccountType.Other;
  switch (account.account_type) {
    case "checking":
      accountType = AccountType.Checking;
      break;
    case "savings":
      accountType = AccountType.Savings;
      break;
    case "credit_card":
      accountType = AccountType.CreditCard;
      break;
    case "loan":
      accountType = AccountType.Loan;
      break;
    case "money_market":
      accountType = AccountType.MoneyMarket;
      break;
    case "cash": // Modern Treasury's "cash" type can be ambiguous, treat as other or a specific internal type
    case "other":
    default:
      accountType = AccountType.Other;
      break;
  }

  return {
    unifiedId: unifiedId,
    sourceId: account.id,
    source: FinancialDataSource.ModernTreasury,
    name: account.name,
    institutionName: account.bank_name,
    fullAccountNumber: account.account_number,
    accountNumberLast4: account.account_number.slice(-4),
    currency: account.currency.toUpperCase(),
    availableBalance: account.balance, // MT amounts are in cents
    currentBalance: account.balance, // MT often provides ledger balance
    type: accountType,
    openedDate: account.created_at,
    metadata: { ...account.metadata, objectType: account.object, partyName: account.party_name, parentAccountId: account.parent_account_id },
    lastUpdated: now,
  };
}

/**
 * Normalizes a Modern Treasury transaction object into a UnifiedTransaction structure.
 * This function translates Modern Treasury's transaction details into the platform's
 * standardized transaction interface, correctly applying the amount sign based on direction
 * and mapping transaction types.
 *
 * @param transaction The raw Modern Treasury transaction details.
 * @param accountUnifiedId The unified ID of the account related to this transaction.
 * @returns A `NormalizedTransaction` object.
 */
function normalizeModernTreasuryTransaction(
  transaction: ModernTreasuryTransactionDetails,
  accountUnifiedId: UnifiedId,
): NormalizedTransaction {
  const now = new Date().toISOString();
  let transactionStatus: TransactionStatus = TransactionStatus.Pending;
  if (transaction.status === "posted") {
    transactionStatus = TransactionStatus.Completed;
  } else if (transaction.status === "void") {
    transactionStatus = TransactionStatus.Void; // Use specific VOID status
  } else if (transaction.status === "pending") {
    transactionStatus = TransactionStatus.Pending;
  }

  // MT amount is in cents. Direction indicates debit/credit.
  // We want negative for debit (outflow), positive for credit (inflow).
  const amount = transaction.direction === "credit" ? transaction.amount : -transaction.amount;

  let transactionType: TransactionType = TransactionType.Other; // Default fallback
  switch (transaction.type) {
    case "ach":
    case "wire":
    case "rtp":
    case "sepa":
      transactionType = transaction.direction === "credit" ? TransactionType.Deposit : TransactionType.Withdrawal;
      break;
    case "check":
      transactionType = transaction.direction === "credit" ? TransactionType.Deposit : TransactionType.Payment;
      break;
    case "book":
      transactionType = TransactionType.Transfer;
      break;
    default:
      transactionType = TransactionType.Other;
      break;
  }

  return {
    unifiedId: generateUnifiedId(FinancialDataSource.ModernTreasury, transaction.id),
    sourceId: transaction.id,
    source: FinancialDataSource.ModernTreasury,
    accountId: accountUnifiedId,
    description: transaction.description || `MT Transaction ${transaction.id}`,
    amount: amount,
    currency: transaction.currency.toUpperCase(),
    date: transaction.posted_at,
    status: transactionStatus,
    type: transactionType,
    counterpartyName: transaction.vendor_name || undefined,
    metadata: {
      ...transaction.metadata,
      objectType: transaction.object,
      transactableType: transaction.transactable_type,
      statementDescriptor: transaction.statement_descriptor,
      accountingCategoryId: transaction.accounting_category_id,
      details: transaction.details,
    },
    lastUpdated: now,
  };
}

/**
 * Stores mock data to simulate API responses from various financial services.
 * In a real application, these would be actual network calls to SDKs or custom HTTP clients.
 * This structure allows for easily defining and manipulating test data.
 */
interface MockDataStore {
  stripeAccounts: StripeAccountDetails[];
  stripeBalances: StripeBalanceDetails[];
  stripeCharges: StripeChargeDetails[];
  stripePayouts: StripePayoutDetails[];
  plaidAccounts: PlaidAccountDetails[];
  plaidInstitutions: PlaidInstitutionDetails[];
  plaidTransactions: PlaidTransactionDetails[];
  modernTreasuryAccounts: ModernTreasuryAccountDetails[];
  modernTreasuryTransactions: ModernTreasuryTransactionDetails[];
}

/**
 * Generates a comprehensive set of mock financial data for demonstration and testing purposes.
 * This data simulates responses from Stripe, Plaid, and Modern Treasury APIs.
 * It's structured to provide diverse scenarios for account types, transaction statuses,
 * and data points, ensuring thorough testing of the normalization and aggregation logic.
 * The data includes multiple accounts and transactions for each source.
 */
function generateMockFinancialData(): MockDataStore {
  // Define stable mock IDs for consistency
  const stripeAccountIdUSD = "acct_stripe_usd_001";
  const stripeAccountIdEUR = "acct_stripe_eur_002";
  const plaidAccountIdChecking = "plaid_acc_chk_1234";
  const plaidAccountIdCredit = "plaid_acc_cc_5678";
  const modernTreasuryAccountIdMain = "mt_acc_main_9012";
  const modernTreasuryAccountIdSecondary = "mt_acc_sec_3456";

  const plaidInstitutionBoA = { name: "Bank of America", institution_id: "ins_boa", url: "https://bankofamerica.com", logo: null, primary_color: "#E52128", products: ["transactions", "auth", "accounts"] };
  const plaidInstitutionWF = { name: "Wells Fargo", institution_id: "ins_wf", url: "https://wellsfargo.com", logo: null, primary_color: "#C42533", products: ["transactions", "auth", "accounts"] };


  const stripeAccounts: StripeAccountDetails[] = [
    {
      id: stripeAccountIdUSD,
      object: "account",
      business_profile: { name: "Citibank Demo Business US Operations" },
      email: "us_ops@citibankdemobusiness.dev",
      type: "standard",
      country: "US",
      currency: "usd",
      charges_enabled: true,
      payouts_enabled: true,
      created: 1609459200, // Jan 1, 2021, 00:00:00 UTC
      metadata: { department: "sales", region: "north_america" },
      capabilities: { card_payments: "active", transfers: "active" },
      settings: { payouts: { schedule: { interval: "daily", delay_days: 2 } } },
    },
    {
      id: stripeAccountIdEUR,
      object: "account",
      business_profile: { name: "Citibank Demo Business EU Operations" },
      email: "eu_ops@citibankdemobusiness.dev",
      type: "standard",
      country: "DE",
      currency: "eur",
      charges_enabled: true,
      payouts_enabled: true,
      created: 1614556800, // Mar 1, 2021, 00:00:00 UTC
      metadata: { department: "international", region: "europe" },
      capabilities: { card_payments: "active", transfers: "active" },
      settings: { payouts: { schedule: { interval: "weekly", delay_days: 7 } } },
    },
  ];

  const stripeBalances: StripeBalanceDetails[] = [
    {
      object: "balance",
      available: [{ amount: 15000000, currency: "usd" }], // $150,000.00
      pending: [{ amount: 2000000, currency: "usd" }], // $20,000.00
      livemode: true,
    },
    {
      object: "balance",
      available: [{ amount: 5000000, currency: "eur" }], // €50,000.00
      pending: [{ amount: 1000000, currency: "eur" }], // €10,000.00
      livemode: true,
    },
  ];

  const stripeCharges: StripeChargeDetails[] = [
    {
      id: "ch_stripe_usd_001",
      object: "charge",
      amount: 10000, // $100.00
      currency: "usd",
      created: 1672531200, // Jan 1, 2023
      description: "Payment for Enterprise SaaS License",
      status: "succeeded",
      paid: true,
      refunded: false,
      captured: true,
      balance_transaction: "bt_001",
      customer: "cust_stripe_001",
      metadata: { orderId: "STRIPE-ORD-001" },
      amount_captured: 10000,
      amount_refunded: 0,
      payment_intent: "pi_001",
      receipt_email: "customer1@example.com",
      receipt_number: "RCPT0001",
    },
    {
      id: "ch_stripe_usd_002",
      object: "charge",
      amount: 5000, // $50.00
      currency: "usd",
      created: 1672617600, // Jan 2, 2023
      description: "Monthly Software Subscription",
      status: "succeeded",
      paid: true,
      refunded: false,
      captured: true,
      balance_transaction: "bt_002",
      customer: "cust_stripe_002",
      metadata: { plan: "standard_monthly" },
      amount_captured: 5000,
      amount_refunded: 0,
      payment_intent: "pi_002",
      receipt_email: "customer2@example.com",
      receipt_number: "RCPT0002",
    },
    {
      id: "ch_stripe_usd_003_failed",
      object: "charge",
      amount: 2500, // $25.00
      currency: "usd",
      created: 1672704000, // Jan 3, 2023
      description: "Failed Payment Attempt for Consulting",
      status: "failed",
      paid: false,
      refunded: false,
      captured: false,
      balance_transaction: null,
      customer: "cust_stripe_003",
      metadata: { reason: "card_declined" },
      amount_captured: 0,
      amount_refunded: 0,
      payment_intent: "pi_003",
      receipt_email: null,
      receipt_number: null,
    },
    {
      id: "ch_stripe_eur_004",
      object: "charge",
      amount: 7500, // €75.00
      currency: "eur",
      created: 1672963200, // Jan 6, 2023
      description: "EU Region Payment for SaaS",
      status: "succeeded",
      paid: true,
      refunded: false,
      captured: true,
      balance_transaction: "bt_004",
      customer: "cust_stripe_004",
      metadata: { country: "DE" },
      amount_captured: 7500,
      amount_refunded: 0,
      payment_intent: "pi_004",
      receipt_email: "customer4@example.com",
      receipt_number: "RCPT0004",
    },
  ];

  const stripePayouts: StripePayoutDetails[] = [
    {
      id: "po_stripe_usd_001",
      object: "payout",
      amount: 500000, // $5,000.00
      currency: "usd",
      created: 1673049600, // Jan 7, 2023
      status: "paid",
      description: "Weekly Payout to Bank Account",
      type: "bank_account",
      destination: "ba_001",
      balance_transaction: "bt_payout_001",
      statement_descriptor: "CTBDEMO PAYOUT",
    },
    {
      id: "po_stripe_eur_002_pending",
      object: "payout",
      amount: 100000, // €1,000.00
      currency: "eur",
      created: 1673136000, // Jan 8, 2023
      status: "pending",
      description: "Pending EU Payout",
      type: "bank_account",
      destination: "ba_002",
      balance_transaction: "bt_payout_002",
      statement_descriptor: "CTBDEMO EUPAY",
    },
  ];

  const plaidInstitutions: PlaidInstitutionDetails[] = [
    plaidInstitutionBoA,
    plaidInstitutionWF,
  ];

  const plaidAccounts: PlaidAccountDetails[] = [
    {
      account_id: plaidAccountIdChecking,
      balances: { available: 5000.50, current: 5200.75, iso_currency_code: "USD", unofficial_currency_code: null, limit: null, last_updated_datetime: "2023-11-01T10:30:00Z" },
      mask: "1111",
      name: "Business Checking",
      official_name: "My Biz Checking",
      subtype: "checking",
      type: "depository",
      verification_status: "automatically_verified",
      persistent_account_id: "pa_plaid_chk_abc",
    },
    {
      account_id: plaidAccountIdCredit,
      balances: { available: 1200.00, current: 1500.00, iso_currency_code: "USD", unofficial_currency_code: null, limit: 10000.00, last_updated_datetime: "2023-11-01T10:31:00Z" },
      mask: "2222",
      name: "Company Credit Card",
      official_name: "Business Rewards Visa",
      subtype: "credit card",
      type: "credit",
      verification_status: "automatically_verified",
      persistent_account_id: "pa_plaid_cc_def",
    },
  ];

  const plaidTransactions: PlaidTransactionDetails[] = [
    {
      account_id: plaidAccountIdChecking,
      amount: 25.00, // Outflow (debit)
      iso_currency_code: "USD",
      unofficial_currency_code: null,
      transaction_id: "pt_plaid_chk_001",
      date: "2023-01-01",
      authorized_date: "2023-01-01",
      name: "Starbucks Coffee",
      merchant_name: "Starbucks",
      pending: false,
      payment_channel: "in store",
      category: ["Food and Drink", "Coffee Shop"],
      category_id: "13005032",
      transaction_type: "place",
      personal_finance_category: { primary: "Food and Drink", detailed: "Coffee Shop" },
      check_number: null,
      pending_transaction_id: null,
      location: { city: "New York", country: "US", lat: 40.7128, lon: -74.0060, address: "123 Main St", postal_code: "10001", region: "NY", store_number: "1234" },
    },
    {
      account_id: plaidAccountIdChecking,
      amount: -500.00, // Inflow (credit)
      iso_currency_code: "USD",
      unofficial_currency_code: null,
      transaction_id: "pt_plaid_chk_002",
      date: "2023-01-02",
      authorized_date: "2023-01-02",
      name: "Payroll Deposit - Citibank Demo Business",
      merchant_name: "Citibank Demo Business Inc.",
      pending: false,
      payment_channel: "online",
      category: ["Transfer", "Deposit"],
      category_id: "21007000",
      transaction_type: "digital",
      personal_finance_category: { primary: "Income", detailed: "Payroll" },
      check_number: null,
      pending_transaction_id: null,
    },
    {
      account_id: plaidAccountIdChecking,
      amount: 120.00, // Outflow (debit)
      iso_currency_code: "USD",
      unofficial_currency_code: null,
      transaction_id: "pt_plaid_chk_003_pending",
      date: "2023-01-03",
      authorized_date: null,
      name: "Amazon.com pending",
      merchant_name: "Amazon",
      pending: true,
      payment_channel: "online",
      category: ["Shopping"],
      category_id: "19047000",
      transaction_type: "digital",
      personal_finance_category: { primary: "Shopping", detailed: "Online Retail" },
      check_number: null,
      pending_transaction_id: "pt_plaid_chk_003_temp",
    },
    {
      account_id: plaidAccountIdCredit,
      amount: 75.50, // Outflow (debit) from credit card
      iso_currency_code: "USD",
      unofficial_currency_code: null,
      transaction_id: "pt_plaid_cc_004",
      date: "2023-01-04",
      authorized_date: "2023-01-03",
      name: "The Fancy Fork Restaurant",
      merchant_name: "The Fancy Fork",
      pending: false,
      payment_channel: "in store",
      category: ["Food and Drink", "Restaurants"],
      category_id: "13005043",
      transaction_type: "place",
      personal_finance_category: { primary: "Food and Drink", detailed: "Restaurants" },
      check_number: null,
      pending_transaction_id: null,
    },
    {
      account_id: plaidAccountIdChecking,
      amount: 15.00, // Outflow (debit)
      iso_currency_code: "USD",
      unofficial_currency_code: null,
      transaction_id: "pt_plaid_chk_005_fee",
      date: "2023-01-05",
      authorized_date: "2023-01-05",
      name: "Monthly Service Fee",
      merchant_name: "Bank of America",
      pending: false,
      payment_channel: "other",
      category: ["Bank Fees"],
      category_id: "16001000",
      transaction_type: "special",
      personal_finance_category: { primary: "Bank Fees", detailed: "Service Fee" },
      check_number: null,
      pending_transaction_id: null,
    },
  ];

  const modernTreasuryAccounts: ModernTreasuryAccountDetails[] = [
    {
      id: modernTreasuryAccountIdMain,
      object: "internal_account",
      name: "Main Operating Account (USD)",
      account_type: "checking",
      account_number: "1234567890",
      currency: "USD",
      balance: 100000000, // $1,000,000.00
      live_mode: true,
      created_at: "2022-01-15T10:00:00Z",
      updated_at: "2023-11-01T10:00:00Z",
      metadata: { team: "finance", purpose: "primary_operations" },
      bank_name: "Citibank",
      party_name: "Citibank Demo Business Inc.",
      parent_account_id: null,
    },
    {
      id: modernTreasuryAccountIdSecondary,
      object: "internal_account",
      name: "Treasury Investment Account (USD)",
      account_type: "investment",
      account_number: "0987654321",
      currency: "USD",
      balance: 250000000, // $2,500,000.00
      live_mode: true,
      created_at: "2022-03-01T12:00:00Z",
      updated_at: "2023-11-01T10:00:00Z",
      metadata: { team: "treasury", purpose: "investment_holdings" },
      bank_name: "Citibank",
      party_name: "Citibank Demo Business Inc.",
      parent_account_id: modernTreasuryAccountIdMain,
    },
  ];

  const modernTreasuryTransactions: ModernTreasuryTransactionDetails[] = [
    {
      id: "mt_tx_001_wire_in",
      object: "transaction",
      amount: 500000, // $5,000.00
      currency: "USD",
      description: "Incoming Wire Payment from Client A for Project X",
      status: "posted",
      direction: "credit",
      type: "wire",
      posted_at: "2023-01-05T11:30:00Z",
      transactable_type: "expected_payment",
      vendor_name: "Client A Corporation",
      internal_account_id: modernTreasuryAccountIdMain,
      metadata: { invoiceId: "INV-2023-001", projectId: "PX-789" },
      accounting_category_id: "revenue_software",
      statement_descriptor: "CLIEN A PMT",
    },
    {
      id: "mt_tx_002_ach_out",
      object: "transaction",
      amount: 25000, // $250.00
      currency: "USD",
      description: "ACH Payment to Vendor B for Office Supplies",
      status: "pending",
      direction: "debit",
      type: "ach",
      posted_at: "2023-01-06T09:00:00Z",
      transactable_type: "payment_order",
      vendor_name: "Vendor B LLC",
      internal_account_id: modernTreasuryAccountIdMain,
      metadata: { poNumber: "PO-12345", costCenter: "admin" },
      accounting_category_id: "expense_office_supplies",
      statement_descriptor: "VENDOR B ACH",
    },
    {
      id: "mt_tx_003_check_void",
      object: "transaction",
      amount: 15000, // $150.00
      currency: "USD",
      description: "Voided Check Payment to Vendor C (Mistake)",
      status: "void",
      direction: "debit",
      type: "check",
      posted_at: "2023-01-07T14:15:00Z",
      transactable_type: "payment_order",
      vendor_name: "Vendor C Corp",
      internal_account_id: modernTreasuryAccountIdMain,
      metadata: { checkNumber: "CK-9876", reason: "incorrect_amount" },
      accounting_category_id: "expense_consulting",
      statement_descriptor: null,
    },
    {
      id: "mt_tx_004_book_transfer",
      object: "transaction",
      amount: 10000000, // $100,000.00
      currency: "USD",
      description: "Internal Fund Transfer to Investment Account",
      status: "posted",
      direction: "debit",
      type: "book",
      posted_at: "2023-01-08T16:00:00Z",
      transactable_type: "payment_order",
      vendor_name: "Internal Transfer",
      internal_account_id: modernTreasuryAccountIdMain,
      metadata: { targetAccountId: modernTreasuryAccountIdSecondary, purpose: "capital_allocation" },
      accounting_category_id: "intercompany_transfer",
      statement_descriptor: "INTERNAL TRANSFER",
    },
    {
      id: "mt_tx_005_book_transfer_credit",
      object: "transaction",
      amount: 10000000, // $100,000.00
      currency: "USD",
      description: "Internal Fund Transfer from Main Account",
      status: "posted",
      direction: "credit",
      type: "book",
      posted_at: "2023-01-08T16:00:00Z",
      transactable_type: "expected_payment",
      vendor_name: "Internal Transfer",
      internal_account_id: modernTreasuryAccountIdSecondary,
      metadata: { sourceAccountId: modernTreasuryAccountIdMain, purpose: "capital_allocation" },
      accounting_category_id: "intercompany_transfer",
      statement_descriptor: "INTERNAL TRANSFER",
    },
    {
      id: "mt_tx_006_interest_credit",
      object: "transaction",
      amount: 12500, // $125.00
      currency: "USD",
      description: "Monthly Interest Earned",
      status: "posted",
      direction: "credit",
      type: "other", // Assuming 'other' for interest
      posted_at: "2023-01-31T23:59:59Z",
      transactable_type: "expected_payment",
      vendor_name: "Citibank",
      internal_account_id: modernTreasuryAccountIdSecondary,
      metadata: {},
      accounting_category_id: "interest_income",
      statement_descriptor: "INTEREST EARNED",
      details: { interest_rate: "0.005", period: "Jan 2023" },
    },
  ];

  return {
    stripeAccounts,
    stripeBalances,
    stripeCharges,
    stripePayouts,
    plaidAccounts,
    plaidInstitutions,
    plaidTransactions,
    modernTreasuryAccounts,
    modernTreasuryTransactions,
  };
}

/**
 * The core FinancialDataAggregator service.
 * This service is responsible for orchestrating the retrieval, normalization,
 * and aggregation of financial data from various third-party sources (Stripe, Plaid, Modern Treasury).
 * It ensures a unified data model (`NormalizedAccount`, `NormalizedTransaction`) for consistent
 * consumption across the Citibank Demo Business platform. It also provides functionalities for
 * data enrichment, de-duplication, and interaction with internal systems.
 */
class FinancialDataAggregator {
  private mockData: MockDataStore;
  // Caches to store normalized data for quick retrieval and to manage state.
  private readonly accountsCache: Map<UnifiedId, NormalizedAccount> = new Map();
  private readonly transactionsCache: Map<UnifiedId, NormalizedTransaction> = new Map();

  /**
   * Initializes the FinancialDataAggregator.
   * In a production environment, this constructor would typically receive configured
   * API clients or SDK instances for Stripe, Plaid, and Modern Treasury.
   * For this simulated environment, it initializes with comprehensive mock data.
   */
  constructor() {
    this.mockData = generateMockFinancialData();
  }

  /**
   * Simulates fetching Stripe account and balance data.
   * In a real scenario, this would involve calling the Stripe API (e.g., `stripe.accounts.retrieve`, `stripe.balance.retrieve`).
   * This mock method filters by account ID if provided and returns a shallow clone of the mock data.
   *
   * @param accountId Optional: Fetch a specific Stripe account by its Stripe ID.
   * @returns A promise resolving to an `ApiResponse` containing an array of Stripe account details and their associated balances.
   */
  private async fetchStripeAccounts(
    accountId?: string,
  ): Promise<ApiResponse<{ accounts: StripeAccountDetails[]; balances: StripeBalanceDetails[] }>> {
    const filteredAccounts = accountId
      ? this.mockData.stripeAccounts.filter((a) => a.id === accountId)
      : this.mockData.stripeAccounts;

    const balances = this.mockData.stripeBalances; // For simplicity, assume balance objects are globally available per currency, not tied to a specific connected account ID in the mock.

    if (filteredAccounts.length === 0 && accountId) {
      return { data: null, error: `Stripe account ${accountId} not found in mock data.` };
    }

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: { accounts: cloneDeep(filteredAccounts), balances: cloneDeep(balances) } };
  }

  /**
   * Simulates fetching Stripe transaction data (charges and payouts).
   * In a real scenario, this would involve calling the Stripe API (e.g., `stripe.charges.list`, `stripe.payouts.list`).
   * This mock method filters transactions based on account ID (conceptually) and date range.
   *
   * @param accountId The Stripe ID of the account for which to fetch transactions.
   * @param params Optional filters for transactions (e.g., `startDate`, `endDate`, `limit`).
   * @returns A promise resolving to an `ApiResponse` containing an array of raw Stripe transaction details.
   */
  private async fetchStripeTransactions(
    accountId: string,
    params?: { startDate?: string; endDate?: string; limit?: number },
  ): Promise<ApiResponse<(StripeChargeDetails | StripePayoutDetails)[]>> {
    // For simplicity in mock, we consider charges/payouts related to the account currency
    // or directly if they had an associated account_id field.
    // In Stripe, balance transactions would link charges/payouts to the account.
    const allStripeTransactions: (StripeChargeDetails | StripePayoutDetails)[] = [
      ...this.mockData.stripeCharges,
      ...this.mockData.stripePayouts,
    ];

    let filteredTransactions = allStripeTransactions;

    // Simulate filtering by account - based on currency or implicit association for mock
    const targetAccount = this.mockData.stripeAccounts.find(a => a.id === accountId);
    if (targetAccount) {
        filteredTransactions = filteredTransactions.filter(tx => tx.currency.toUpperCase() === targetAccount.currency.toUpperCase());
    } else {
        // If account not found, return empty set for transactions
        return { data: [] };
    }


    // Apply basic date filtering for mock data
    if (params?.startDate) {
      const startTimestamp = new Date(params.startDate).getTime() / 1000;
      filteredTransactions = filteredTransactions.filter((tx) => tx.created >= startTimestamp);
    }
    if (params?.endDate) {
      const endTimestamp = new Date(params.endDate).getTime() / 1000;
      filteredTransactions = filteredTransactions.filter((tx) => tx.created <= endTimestamp);
    }

    if (params?.limit) {
      filteredTransactions = filteredTransactions.slice(0, params.limit);
    }

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: cloneDeep(filteredTransactions) };
  }

  /**
   * Simulates fetching Plaid account and institution data.
   * In a real scenario, this would involve calling the Plaid API (e.g., `client.accountsGet`, `client.institutionsGetById`).
   * This mock method filters by account ID if provided and ensures institution data is available.
   *
   * @param accountId Optional: Fetch a specific Plaid account by its Plaid `account_id`.
   * @returns A promise resolving to an `ApiResponse` containing an array of Plaid account details and their associated institutions.
   */
  private async fetchPlaidAccounts(
    accountId?: string,
  ): Promise<ApiResponse<{ accounts: PlaidAccountDetails[]; institutions: PlaidInstitutionDetails[] }>> {
    const filteredAccounts = accountId
      ? this.mockData.plaidAccounts.filter((a) => a.account_id === accountId)
      : this.mockData.plaidAccounts;

    if (filteredAccounts.length === 0 && accountId) {
      return { data: null, error: `Plaid account ${accountId} not found in mock data.` };
    }

    // For simplicity, assume all plaid accounts in mock data belong to known institutions.
    // A real implementation would fetch institution details for each linked item.
    const institutions = this.mockData.plaidInstitutions;

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: { accounts: cloneDeep(filteredAccounts), institutions: cloneDeep(institutions) } };
  }

  /**
   * Simulates fetching Plaid transaction data.
   * In a real scenario, this would involve calling the Plaid API (e.g., `client.transactionsGet`).
   * This mock method filters transactions by the given Plaid `account_id` and date range.
   *
   * @param accountId The Plaid `account_id` to fetch transactions for.
   * @param params Optional filters for transactions (e.g., `startDate`, `endDate`, `limit`).
   * @returns A promise resolving to an `ApiResponse` containing an array of raw Plaid transaction details.
   */
  private async fetchPlaidTransactions(
    accountId: string,
    params?: { startDate?: string; endDate?: string; limit?: number },
  ): Promise<ApiResponse<PlaidTransactionDetails[]>> {
    let transactions = this.mockData.plaidTransactions.filter(
      (tx) => tx.account_id === accountId,
    );

    // Apply basic date filtering for mock data
    if (params?.startDate) {
      transactions = transactions.filter((tx) => new Date(tx.date) >= new Date(params.startDate!));
    }
    if (params?.endDate) {
      transactions = transactions.filter((tx) => new Date(tx.date) <= new Date(params.endDate!));
    }

    if (params?.limit) {
      transactions = transactions.slice(0, params.limit);
    }

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: cloneDeep(transactions) };
  }

  /**
   * Simulates fetching Modern Treasury account data.
   * In a real scenario, this would involve calling the Modern Treasury API (e.g., `client.internalAccounts.list`, `client.externalAccounts.list`).
   * This mock method filters by account ID if provided.
   *
   * @param accountId Optional: Fetch a specific Modern Treasury account by its Modern Treasury ID.
   * @returns A promise resolving to an `ApiResponse` containing an array of raw Modern Treasury account details.
   */
  private async fetchModernTreasuryAccounts(
    accountId?: string,
  ): Promise<ApiResponse<ModernTreasuryAccountDetails[]>> {
    const filteredAccounts = accountId
      ? this.mockData.modernTreasuryAccounts.filter((a) => a.id === accountId)
      : this.mockData.modernTreasuryAccounts;

    if (filteredAccounts.length === 0 && accountId) {
      return { data: null, error: `Modern Treasury account ${accountId} not found in mock data.` };
    }

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: cloneDeep(filteredAccounts) };
  }

  /**
   * Simulates fetching Modern Treasury transaction data.
   * In a real scenario, this would involve calling the Modern Treasury API (e.g., `client.transactions.list`).
   * This mock method filters transactions by the given Modern Treasury `internal_account_id` and date range.
   *
   * @param accountId The Modern Treasury `internal_account_id` to fetch transactions for.
   * @param params Optional filters for transactions (e.g., `startDate`, `endDate`, `limit`).
   * @returns A promise resolving to an `ApiResponse` containing an array of raw Modern Treasury transaction details.
   */
  private async fetchModernTreasuryTransactions(
    accountId: string,
    params?: { startDate?: string; endDate?: string; limit?: number },
  ): Promise<ApiResponse<ModernTreasuryTransactionDetails[]>> {
    let transactions = this.mockData.modernTreasuryTransactions.filter(
      (tx) => tx.internal_account_id === accountId,
    );

    // Apply basic date filtering for mock data
    if (params?.startDate) {
      transactions = transactions.filter(
        (tx) => new Date(tx.posted_at) >= new Date(params.startDate!),
      );
    }
    if (params?.endDate) {
      transactions = transactions.filter(
        (tx) => new Date(tx.posted_at) <= new Date(params.endDate!),
      );
    }

    if (params?.limit) {
      transactions = transactions.slice(0, params.limit);
    }

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 50));
    return { data: cloneDeep(transactions) };
  }

  /**
   * Fetches and normalizes all accounts from all integrated sources (Stripe, Plaid, Modern Treasury).
   * It aggregates them into a single list of `NormalizedAccount` objects and populates an internal cache.
   * This method performs initial data retrieval and transformation, making accounts ready for consumption.
   *
   * @returns A promise resolving to an array of all `NormalizedAccount` objects.
   */
  public async getAggregatedAccounts(): Promise<NormalizedAccount[]> {
    const allNormalizedAccounts: NormalizedAccount[] = [];
    const newAccountsCache = new Map<UnifiedId, NormalizedAccount>();

    // 1. Fetch and normalize Stripe accounts
    try {
      const stripeAccountsResponse = await this.fetchStripeAccounts();
      if (stripeAccountsResponse.data) {
        stripeAccountsResponse.data.accounts.forEach((stripeAccount) => {
          // Find the balance for the specific account's currency from the global balance object.
          const relevantBalance = stripeAccountsResponse.data!.balances.find(
            (b) =>
              b.available.some(
                (a) => a.currency.toUpperCase() === stripeAccount.currency.toUpperCase(),
              ),
          );
          if (relevantBalance) {
            const normalized = normalizeStripeAccount(stripeAccount, relevantBalance);
            allNormalizedAccounts.push(normalized);
            newAccountsCache.set(normalized.unifiedId, normalized);
          } else {
            console.warn(`No relevant Stripe balance found for account ${stripeAccount.id} in currency ${stripeAccount.currency}. Skipping normalization.`);
          }
        });
      } else if (stripeAccountsResponse.error) {
        console.error(`Error fetching Stripe accounts: ${stripeAccountsResponse.error}`);
      }
    } catch (e) {
      console.error("Failed to fetch or normalize Stripe accounts:", e);
    }


    // 2. Fetch and normalize Plaid accounts
    try {
      const plaidAccountsResponse = await this.fetchPlaidAccounts();
      if (plaidAccountsResponse.data) {
        plaidAccountsResponse.data.accounts.forEach((plaidAccount) => {
          // For mock, we simply pick a known institution. In real life, Plaid links
          // accounts to items, and items to institutions.
          const institution = plaidAccountsResponse.data!.institutions[0]; // Simplification for mock
          if (institution) {
            const normalized = normalizePlaidAccount(plaidAccount, institution);
            allNormalizedAccounts.push(normalized);
            newAccountsCache.set(normalized.unifiedId, normalized);
          } else {
            console.warn(`No Plaid institution found for account ${plaidAccount.account_id}. Skipping normalization.`);
          }
        });
      } else if (plaidAccountsResponse.error) {
        console.error(`Error fetching Plaid accounts: ${plaidAccountsResponse.error}`);
      }
    } catch (e) {
      console.error("Failed to fetch or normalize Plaid accounts:", e);
    }

    // 3. Fetch and normalize Modern Treasury accounts
    try {
      const mtAccountsResponse = await this.fetchModernTreasuryAccounts();
      if (mtAccountsResponse.data) {
        mtAccountsResponse.data.forEach((mtAccount) => {
          const normalized = normalizeModernTreasuryAccount(mtAccount);
          allNormalizedAccounts.push(normalized);
          newAccountsCache.set(normalized.unifiedId, normalized);
        });
      } else if (mtAccountsResponse.error) {
        console.error(`Error fetching Modern Treasury accounts: ${mtAccountsResponse.error}`);
      }
    } catch (e) {
      console.error("Failed to fetch or normalize Modern Treasury accounts:", e);
    }

    // Update the internal accounts cache after successful aggregation of all sources.
    // This ensures consistency and avoids partial updates.
    this.accountsCache.clear();
    newAccountsCache.forEach((account) => this.accountsCache.set(account.unifiedId, account));

    return allNormalizedAccounts;
  }

  /**
   * Fetches and normalizes transactions for a given unified account ID.
   * If the account is not found in the cache, it attempts to refresh the account list.
   *
   * @param unifiedAccountId The unified ID of the account to fetch transactions for.
   * @param params Optional filters for transactions (e.g., `startDate`, `endDate`, `limit`).
   * @returns A promise resolving to an array of `NormalizedTransaction` objects.
   */
  public async getAggregatedTransactions(
    unifiedAccountId: UnifiedId,
    params?: { startDate?: string; endDate?: string; limit?: number },
  ): Promise<NormalizedTransaction[]> {
    let account = this.accountsCache.get(unifiedAccountId);
    if (!account) {
      console.warn(`Account with unified ID ${unifiedAccountId} not found in cache. Attempting to refresh accounts.`);
      await this.getAggregatedAccounts(); // Attempt to refresh accounts cache
      account = this.accountsCache.get(unifiedAccountId);
      if (!account) {
        console.error(`Account with unified ID ${unifiedAccountId} still not found after refresh. Cannot fetch transactions.`);
        return [];
      }
    }

    return this.fetchTransactionsFromSource(account, params);
  }

  /**
   * Internal helper to fetch raw transactions from the original source based on the normalized account's source,
   * then normalizes them into `NormalizedTransaction` objects.
   *
   * @param account The `NormalizedAccount` object indicating the source and source ID.
   * @param params Optional filters.
   * @returns A promise resolving to an array of `NormalizedTransaction` objects.
   */
  private async fetchTransactionsFromSource(
    account: NormalizedAccount,
    params?: { startDate?: string; endDate?: string; limit?: number },
  ): Promise<NormalizedTransaction[]> {
    let rawTransactions:
      | (StripeChargeDetails | StripePayoutDetails)[]
      | PlaidTransactionDetails[]
      | ModernTreasuryTransactionDetails[]
      | null = null;
    let error: string | undefined;

    // Route the request to the appropriate source-specific fetcher.
    switch (account.source) {
      case FinancialDataSource.Stripe:
        const stripeTxResponse = await this.fetchStripeTransactions(account.sourceId, params);
        rawTransactions = stripeTxResponse.data;
        error = stripeTxResponse.error;
        break;
      case FinancialDataSource.Plaid:
        const plaidTxResponse = await this.fetchPlaidTransactions(account.sourceId, params);
        rawTransactions = plaidTxResponse.data;
        error = plaidTxResponse.error;
        break;
      case FinancialDataSource.ModernTreasury:
        const mtTxResponse = await this.fetchModernTreasuryTransactions(account.sourceId, params);
        rawTransactions = mtTxResponse.data;
        error = mtTxResponse.error;
        break;
      default:
        console.warn(`Unsupported financial data source for transaction fetching: ${account.source}.`);
        return [];
    }

    if (error) {
      console.error(`Error fetching transactions from ${account.source} for account ${account.sourceId}: ${error}`);
      return [];
    }

    if (!rawTransactions || rawTransactions.length === 0) {
      return [];
    }

    const normalizedTransactions: NormalizedTransaction[] = [];
    rawTransactions.forEach((rawTx) => {
      let normalized: NormalizedTransaction | null = null;
      try {
        // Cast `rawTx` to the correct type before passing to the normalization function.
        if (account.source === FinancialDataSource.Stripe) {
          normalized = normalizeStripeTransaction(rawTx as (StripeChargeDetails | StripePayoutDetails), account.unifiedId);
        } else if (account.source === FinancialDataSource.Plaid) {
          normalized = normalizePlaidTransaction(rawTx as PlaidTransactionDetails, account.unifiedId);
        } else if (account.source === FinancialDataSource.ModernTreasury) {
          normalized = normalizeModernTreasuryTransaction(rawTx as ModernTreasuryTransactionDetails, account.unifiedId);
        }

        if (normalized) {
          normalizedTransactions.push(normalized);
          this.transactionsCache.set(normalized.unifiedId, normalized); // Cache individual transactions
        }
      } catch (e) {
        console.error(`Failed to normalize transaction ${JSON.stringify(rawTx)} from ${account.source}:`, e);
      }
    });

    return normalizedTransactions;
  }

  /**
   * Retrieves a single normalized account by its unified ID from the internal cache.
   *
   * @param unifiedId The unified ID of the account.
   * @returns The `NormalizedAccount` object, or `undefined` if not found.
   */
  public getAccountByUnifiedId(unifiedId: UnifiedId): NormalizedAccount | undefined {
    return this.accountsCache.get(unifiedId);
  }

  /**
   * Retrieves a single normalized transaction by its unified ID from the internal cache.
   *
   * @param unifiedId The unified ID of the transaction.
   * @returns The `NormalizedTransaction` object, or `undefined` if not found.
   */
  public getTransactionByUnifiedId(unifiedId: UnifiedId): NormalizedTransaction | undefined {
    return this.transactionsCache.get(unifiedId);
  }

  /**
   * Performs an enrichment process on a given normalized transaction.
   * This method simulates adding more details (e.g., internal categorization, fraud risk score)
   * to a transaction by interacting with internal Citibank Demo Business services.
   * It returns a *new* transaction object with the enriched data, leaving the original unchanged.
   *
   * @param transaction The `NormalizedTransaction` object to enrich.
   * @returns A promise resolving to a new `NormalizedTransaction` object with enriched data.
   */
  public async enrichTransaction(
    transaction: NormalizedTransaction,
  ): Promise<NormalizedTransaction> {
    const enrichedTransaction = cloneDeep(transaction); // Start with a deep copy to avoid modifying original

    // Simulate calling an internal categorization service
    const internalCategory = await this.fetchInternalCategorization(transaction.description);
    if (internalCategory) {
      enrichedTransaction.category = internalCategory;
    }

    // Simulate calling a fraud detection service
    const riskScore = await this.calculateTransactionRisk(transaction);
    enrichedTransaction.metadata = {
      ...enrichedTransaction.metadata,
      riskScore: riskScore,
      enrichedAt: new Date().toISOString(),
    };

    return enrichedTransaction;
  }

  /**
   * Simulates an internal call to a categorization service hosted at `citibankdemobusiness.dev`.
   * This service would typically employ machine learning models or a complex rule-based system
   * to assign granular categories to transactions based on their descriptions and other attributes.
   *
   * @param description The transaction description to categorize.
   * @returns A promise resolving to a categorized string (e.g., "Business Expenses > Software") or `null` if no category is found.
   */
  private async fetchInternalCategorization(description: string): Promise<string | null> {
    // In a real scenario, this would be an HTTP call to:
    // `${CITIBANK_DEMO_BUSINESS_BASE_URL}/api/categorization?description=${encodeURIComponent(description)}`
    // For now, simulate based on keywords in the description.
    await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate API latency

    const lowerDescription = description.toLowerCase();
    if (lowerDescription.includes("starbucks") || lowerDescription.includes("coffee")) {
      return "Business Expenses > Food & Beverage > Coffee";
    }
    if (lowerDescription.includes("amazon") || lowerDescription.includes("online purchase")) {
      return "Business Expenses > Supplies > Online Retail";
    }
    if (lowerDescription.includes("payroll") || lowerDescription.includes("salary")) {
      return "Income > Payroll";
    }
    if (lowerDescription.includes("license") || lowerDescription.includes("software")) {
      return "Income > Software Sales";
    }
    if (lowerDescription.includes("wire") || lowerDescription.includes("client payment")) {
      return "Income > Client Payments";
    }
    if (lowerDescription.includes("office supplies") || lowerDescription.includes("staples")) {
      return "Business Expenses > Office Supplies";
    }
    if (lowerDescription.includes("consulting fee") || lowerDescription.includes("professional services")) {
      return "Business Expenses > Professional Services";
    }
    return null; // No specific category found
  }

  /**
   * Simulates an internal call to a fraud detection or risk scoring service hosted at `citibankdemobusiness.dev`.
   * This service would analyze various transaction attributes (amount, counterparty, frequency, location, status)
   * to assign a numerical risk score, indicating the likelihood of fraudulent or suspicious activity.
   *
   * @param transaction The `NormalizedTransaction` object to assess risk for.
   * @returns A promise resolving to a numerical risk score (0.0 to 1.0, where 1.0 is highest risk).
   */
  private async calculateTransactionRisk(transaction: NormalizedTransaction): Promise<number> {
    // In a real scenario, this would be an HTTP call to:
    // `${CITIBANK_DEMO_BUSINESS_BASE_URL}/api/fraud-detection` with transaction payload
    // For now, simulate based on simple heuristic rules.
    await new Promise((resolve) => setTimeout(resolve, 150)); // Simulate API latency

    let risk = 0.0;

    // Rule 1: High transaction amount
    if (transaction.amount >= 1000000) { // $10,000+
      risk += 0.3;
    } else if (transaction.amount >= 500000) { // $5,000+
      risk += 0.15;
    }

    // Rule 2: Failed or disputed transactions
    if (transaction.status === TransactionStatus.Failed || transaction.status === TransactionStatus.Disputed) {
      risk += 0.5;
    } else if (transaction.status === TransactionStatus.Pending) {
        risk += 0.1; // Pending might have a slight elevated risk until settled
    }

    // Rule 3: Transaction description keywords
    const lowerDescription = transaction.description.toLowerCase();
    if (lowerDescription.includes("refunded") && transaction.type !== TransactionType.Refund) {
        // Suspicious if description says refund but type is not
        risk += 0.2;
    }
    if (lowerDescription.includes("unusual activity") || lowerDescription.includes("fraud")) {
      risk += 0.8;
    }

    // Rule 4: New or unknown counterparty (simplified check against cached transactions)
    // A more sophisticated check would involve a dedicated counterparty management system.
    const isNewCounterparty = Array.from(this.transactionsCache.values()).every(
      (t) => t.counterpartyName !== transaction.counterpartyName || t.unifiedId === transaction.unifiedId
    );
    if (isNewCounterparty && transaction.counterpartyName && transaction.amount >= 10000) { // Only if a counterparty is actually named
      risk += 0.2;
    }

    // Cap the risk score at 1.0 and round to two decimal places
    return Math.min(1.0, Math.round(risk * 100) / 100);
  }

  /**
   * Attempts to de-duplicate transactions from different sources that refer to the same real-world event.
   * This is a complex problem in financial data aggregation, often requiring sophisticated matching algorithms.
   * This implementation provides a basic heuristic based on key transaction attributes (account, amount, date, description prefix).
   *
   * @param transactions An array of `NormalizedTransaction` objects potentially containing duplicates.
   * @returns A new array with identified duplicates removed, prioritizing the first transaction encountered for a given hash.
   */
  public deDuplicateTransactions(transactions: NormalizedTransaction[]): NormalizedTransaction[] {
    if (transactions.length <= 1) {
      return transactions;
    }

    const uniqueTransactions: NormalizedTransaction[] = [];
    const seenHashes = new Set<string>();

    for (const transaction of transactions) {
      // Create a hash based on key identifying fields. This hash serves as a heuristic for potential duplicates.
      // Factors considered: account, amount, currency, transaction date (day-level), and a truncated description.
      // A truly robust de-duplication would consider a fuzzy matching, time windows, and source priority.
      const transactionHash = [
        transaction.accountId,
        transaction.amount,
        transaction.currency,
        transaction.date.substring(0, 10), // Date part only (YYYY-MM-DD)
        transaction.description.substring(0, 50).toLowerCase().replace(/[^a-z0-9]/g, ""), // First 50 chars, alphanumeric only
      ].join("_");

      if (seenHashes.has(transactionHash)) {
        // If a transaction with the same heuristic hash has already been seen,
        // we consider this a duplicate and skip it. This implicitly prioritizes
        // the first transaction encountered, which might not always be the desired behavior
        // (e.g., you might want to prioritize 'posted' over 'pending', or a specific source).
        console.log(`Skipping potential duplicate transaction (unifiedId: ${transaction.unifiedId}, hash: ${transactionHash}).`);
        continue;
      }

      uniqueTransactions.push(transaction);
      seenHashes.add(transactionHash);
    }

    return uniqueTransactions;
  }

  /**
   * Calculates and returns a summary of financial data across all aggregated accounts.
   * This includes total available and current balances per currency, and a total transaction count.
   * It demonstrates how aggregated data can be used to generate high-level insights.
   *
   * @returns A promise resolving to an object containing summary statistics.
   */
  public async getFinancialSummary(): Promise<{
    totalAvailableBalance: { [currency: string]: number };
    totalCurrentBalance: { [currency: string]: number };
    totalTransactionCount: number;
    lastUpdated: string;
  }> {
    const accounts = await this.getAggregatedAccounts();
    const totalAvailableBalance: { [currency: string]: number } = {};
    const totalCurrentBalance: { [currency: string]: number } = {};
    let totalTransactionCount = 0;

    for (const account of accounts) {
      // Aggregate balances per currency
      if (!totalAvailableBalance[account.currency]) {
        totalAvailableBalance[account.currency] = 0;
      }
      totalAvailableBalance[account.currency] += account.availableBalance;

      if (!totalCurrentBalance[account.currency]) {
        totalCurrentBalance[account.currency] = 0;
      }
      totalCurrentBalance[account.currency] += account.currentBalance;

      // Fetch transactions for each account and add to the total count.
      // This could be optimized by using a cached count or a more efficient transaction retrieval if available.
      const transactions = await this.getAggregatedTransactions(account.unifiedId);
      totalTransactionCount += transactions.length;
    }

    return {
      totalAvailableBalance,
      totalCurrentBalance,
      totalTransactionCount,
      lastUpdated: new Date().toISOString(),
    };
  }

  /**
   * Resets the internal caches for accounts and transactions, and reloads the mock data.
   * This is primarily useful for testing scenarios where a clean slate is required.
   */
  public resetCaches(): void {
    this.accountsCache.clear();
    this.transactionsCache.clear();
    this.mockData = generateMockFinancialData(); // Reset mock data to its initial state
    console.log("FinancialDataAggregator caches and mock data reset.");
  }

  /**
   * Simulates an operation that might require direct interaction with Citibank Demo Business internal systems,
   * for example, updating a ledger or marking a transaction as reconciled in the internal database.
   * This method demonstrates a potential write-back capability to internal systems.
   *
   * @param unifiedTransactionId The unified ID of the transaction to update.
   * @param status The new `TransactionStatus` to set for the transaction.
   * @param notes Optional: additional notes for the update.
   * @returns A promise indicating the success or failure of the operation with an `ApiResponse`.
   */
  public async updateInternalTransactionStatus(
    unifiedTransactionId: UnifiedId,
    status: TransactionStatus,
    notes?: string,
  ): Promise<ApiResponse<boolean>> {
    const transaction = this.transactionsCache.get(unifiedTransactionId);
    if (!transaction) {
      return { data: false, error: "Transaction not found in cache. Cannot update status." };
    }

    // Simulate an API call to an internal Citibank Demo Business endpoint.
    // In a real system, this would involve proper authentication, data validation,
    // and an actual API request to `${CITIBANK_DEMO_BUSINESS_BASE_URL}/api/transactions/...`.
    const url = `${CITIBANK_DEMO_BUSINESS_BASE_URL}/api/transactions/${unifiedTransactionId}/status`;
    console.log(`Simulating PUT request to ${url} with new status: ${status}. Notes: ${notes || 'N/A'}`);

    // Optimistically update internal cache immediately for responsive UI feedback.
    const updatedTransaction = { ...transaction, status: status, lastUpdated: new Date().toISOString(),
      metadata: { ...transaction.metadata, internalNotes: notes || transaction.metadata.internalNotes }
    };
    this.transactionsCache.set(unifiedTransactionId, updatedTransaction);

    // Simulate network delay and potential backend error.
    await new Promise((resolve) => setTimeout(resolve, 500)); // Simulate async operation

    if (Math.random() > 0.9) { // Simulate a 10% chance of backend failure
      console.error(`Simulated backend failure for updating transaction ${unifiedTransactionId}. Reverting cache.`);
      // Revert cache if simulated failure occurs
      this.transactionsCache.set(unifiedTransactionId, transaction); // Revert to old state
      return { data: false, error: "Simulated backend update failure. Please try again." };
    }

    console.log(`Transaction ${unifiedTransactionId} status successfully updated to ${status} in internal cache.`);
    return { data: true };
  }

  /**
   * Retrieves a comprehensive audit log for a specific unified entity (account or transaction).
   * This would typically involve querying an internal audit service at `citibankdemobusiness.dev`
   * that tracks all changes and access events for financial entities.
   *
   * @param unifiedEntityId The unified ID of the account or transaction for which to retrieve the audit log.
   * @returns A promise resolving to an `ApiResponse` containing an array of audit log entries (strings).
   */
  public async getAuditLogForEntity(unifiedEntityId: UnifiedId): Promise<ApiResponse<string[]>> {
    // Simulate an API call to an internal Citibank Demo Business endpoint.
    const url = `${CITIBANK_DEMO_BUSINESS_BASE_URL}/api/audit-logs/${unifiedEntityId}`;
    console.log(`Simulating GET request to ${url} for audit log.`);

    // Simulate data retrieval delay.
    await new Promise((resolve) => setTimeout(resolve, 300));

    if (Math.random() > 0.8) { // Simulate a 20% chance of failure to retrieve logs
      return { data: null, error: `Failed to retrieve audit log for entity ${unifiedEntityId} from backend.` };
    }

    // Generate mock audit log entries.
    const now = new Date().toISOString();
    return {
      data: [
        `[${now}] Entity ${unifiedEntityId} created by system.`,
        `[${now}] Data fetched from source ${unifiedEntityId.split("_")[0]} and normalized.`,
        `[${now}] Last accessed by user 'admin_analyst' from IP '192.168.1.100'.`,
        `[${now}] Metadata field 'riskScore' updated by 'enrichment_service'.`,
        `[${now}] Status changed to 'COMPLETED' (if transaction).`,
        `[${now}] Exported for reporting by 'reporting_service'.`,
      ],
    };
  }
}

// Export a singleton instance of the aggregator to ensure a single source of truth for financial data
// throughout the application. This pattern is common for service layers that manage shared state
// or coordinate operations across multiple components.
const financialDataAggregator = new FinancialDataAggregator();
export default financialDataAggregator;