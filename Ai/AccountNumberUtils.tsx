```typescript
// No Copyright statement. Removed as per instruction.

import React from "react";
import { AccountNumberTypeEnum } from "../../generated/dashboard/graphqlSchema";
import AccountDetailAccountNumber from "../components/account_number/AccountDetailAccountNumber";

// --- Existing Interfaces (KEEP AS IS) ---
export interface AccountDetailRowLabel {
  [id: string]: string;
}

export interface AccountDetailRowValue {
  [id: string]: JSX.Element;
}

// --- NEW ENUMS & CONSTANTS ---

/**
 * Defines the status of an account number within the system, potentially for lifecycle management.
 * This enum helps track the current state and operational readiness of an account number.
 * @export
 * @enum {string}
 */
export enum AccountNumberStatus {
  /** The account number is active and fully operational. */
  Active = "ACTIVE",
  /** The account number is awaiting verification, e.g., via a micro-deposit or external system check. */
  PendingVerification = "PENDING_VERIFICATION",
  /** The account number's activity has been temporarily halted due to policy, security, or user request. */
  Suspended = "SUSPENDED",
  /** The account number has been permanently deactivated and can no longer be used. */
  Deactivated = "DEACTIVATED",
  /** The account number has been identified as being involved in fraudulent activity. */
  Fraudulent = "FRAUDULENT",
  /** The account number has reached its expiration date (e.g., virtual cards, temporary accounts). */
  Expired = "EXPIRED",
  /** The account number is undergoing a review process, potentially for compliance or security. */
  UnderReview = "UNDER_REVIEW",
}

/**
 * Represents the origin or source of a particular account number or its associated data.
 * This is crucial for auditing, data lineage, and understanding data trustworthiness.
 * @export
 * @enum {string}
 */
export enum AccountDataSource {
  /** The account number was manually provided by a user. */
  UserProvided = "USER_PROVIDED",
  /** The account number was generated by the system itself. */
  SystemGenerated = "SYSTEM_GENERATED",
  /** The account number was ingested from an external API, e.g., a bank partner. */
  ExternalAPI = "EXTERNAL_API",
  /** The account number was brought into the system via an internal data migration process. */
  InternalMigration = "INTERNAL_MIGRATION",
  /** The account number was derived or inferred from other existing data. */
  Derived = "DERIVED",
}

/**
 * Defines different types of validation checks that can be performed on an account number.
 * This provides granularity for reporting and remediation of validation issues.
 * @export
 * @enum {string}
 */
export enum AccountValidationType {
  /** Checks if the account number adheres to a basic expected format (e.g., character set, pattern). */
  Format = "FORMAT",
  /** Verifies the integrity of the account number using a checksum algorithm (e.g., Luhn, Modulo 97-10). */
  Checksum = "CHECKSUM",
  /** Validates if the bank identifier portion of the account number is recognized and valid. */
  BankIdentifier = "BANK_IDENTIFIER",
  /** Performs validation specific to a particular country's account numbering conventions. */
  CountrySpecific = "COUNTRY_SPECIFIC",
  /** Utilizes AI models to predict validity, type, or other characteristics. */
  AIPredictive = "AI_PREDICTIVE",
  /** Checks the account number against other internal or external data sources for consistency or blacklisting. */
  CrossReference = "CROSS_REFERENCE",
  /** Checks for unusual patterns or anomalies that might indicate suspicious activity. */
  AnomalyDetection = "ANOMALY_DETECTION",
}

/**
 * Defines the severity level of a validation issue, risk assessment, or log message.
 * This helps prioritize attention and response to identified problems.
 * @export
 * @enum {string}
 */
export enum ValidationSeverity {
  /** Informational message, no immediate action required. */
  Info = "INFO",
  /** A potential issue that should be reviewed, but does not block operations. */
  Warning = "WARNING",
  /** A definite issue that prevents normal operation or requires correction. */
  Error = "ERROR",
  /** A severe issue requiring immediate attention, potentially indicating fraud or critical data integrity problems. */
  Critical = "CRITICAL",
  /** Debugging information, typically only visible in development environments. */
  Debug = "DEBUG",
}

/**
 * Configuration settings for the simulated Gemini AI service.
 * In a production environment, these values would be loaded securely from environment variables
 * or a configuration management service, NOT hardcoded.
 * @export
 * @constant
 */
export const GEMINI_AI_CONFIG = {
  /** Simulated API endpoint for general account number analysis. */
  ACCOUNT_ANALYSIS_ENDPOINT: "/api/gemini/v1/analyze-account-number",
  /** Simulated API endpoint for enhanced fraud detection. */
  FRAUD_DETECTION_ENDPOINT: "/api/gemini/v1/detect-fraud",
  /** Simulated API endpoint for inferring the most probable account number type. */
  TYPE_INFERENCE_ENDPOINT: "/api/gemini/v1/infer-account-type",
  /** Placeholder for the AI API key. **DO NOT USE IN PRODUCTION AS IS.** */
  API_KEY: "sk-g_YOUR_ULTRA_SECRET_GEMINI_AI_KEY_HERE_007",
  /** The specific version of the Gemini AI model to utilize for consistency. */
  MODEL_VERSION: "gemini-pro-1.5-flash",
  /** Maximum time allowed for an AI API request to complete, in milliseconds. */
  REQUEST_TIMEOUT_MS: 7000,
  /** Number of retry attempts for transient AI service errors. */
  MAX_RETRY_ATTEMPTS: 3,
  /** Base URL for the AI service. */
  BASE_URL: "https://api.gemini.ai.com",
};

/**
 * Default global timeout for all asynchronous operations in this utility, in milliseconds.
 * This provides a safety net for operations not explicitly covered by specific timeouts.
 * @export
 * @constant
 */
export const DEFAULT_OPERATION_TIMEOUT_MS = 10000; // 10 seconds

// --- NEW INTERFACES FOR EXTENDED FUNCTIONALITY ---

/**
 * Represents a comprehensive set of details for an account number,
 * including its status, source, and associated metadata. This is the enriched
 * data model used internally by the utility.
 * @export
 * @interface AccountNumberExtendedDetail
 */
export interface AccountNumberExtendedDetail {
  /** A unique identifier for this account number entry. */
  id: string;
  /** The full account number string. This field is sensitive and should be handled with care. */
  accountNumber: string;
  /** The primary classification of the account number's type. */
  accountNumberType?: AccountNumberTypeEnum | null;
  /** A higher-level classification or purpose of the account (e.g., "VirtualAccount", "Savings", "Checking"). */
  parentAccountType?: string;
  /** The current operational status of the account number. */
  status: AccountNumberStatus;
  /** The origin of this account number data. */
  dataSource: AccountDataSource;
  /** Timestamp when this account number record was created. */
  createdAt: Date;
  /** Timestamp of the last significant update to this account number record. */
  lastUpdatedAt: Date;
  /** An extensible object for storing additional metadata, including AI insights. */
  metadata?: {
    /** ISO 3166-1 alpha-2 country code associated with the account. */
    countryCode?: string;
    /** ISO 4217 currency code for the account. */
    currencyCode?: string;
    /** Identifier for the bank or financial institution (e.g., SWIFT/BIC, ABA routing number). */
    bankIdentifier?: string;
    /** Human-readable description or notes about the account. */
    description?: string;
    /** The last known risk assessment score from AI. */
    lastAIRiskScore?: number;
    /** History of AI analysis responses for this account number. */
    aiAnalysisHistory?: GeminiAccountNumberAnalysisResponse[];
    /** A flag indicating if this account number has been manually reviewed and approved. */
    isManuallyApproved?: boolean;
    /** The user ID of the last person who approved or modified this entry. */
    lastApprovedBy?: string;
    /** Timestamp of the last manual approval. */
    lastApprovedAt?: Date;
  };
}

/**
 * Represents a single validation result for an account number.
 * Each result provides details about a specific check performed.
 * @export
 * @interface AccountValidationResult
 */
export interface AccountValidationResult {
  /** The type of validation check that was performed. */
  type: AccountValidationType;
  /** True if the validation check passed, false otherwise. */
  isValid: boolean;
  /** A human-readable message describing the outcome of the validation. */
  message: string;
  /** The severity of this particular validation result. */
  severity: ValidationSeverity;
  /** Optional, additional diagnostic information relevant to the result. */
  details?: Record<string, any>;
  /** Unique identifier for this specific validation instance. */
  validationInstanceId?: string;
  /** Timestamp when this validation result was generated. */
  timestamp: Date;
}

/**
 * Interface for AI-driven risk assessment results.
 * @export
 * @interface AIRiskAssessment
 */
export interface AIRiskAssessment {
  /** A quantitative risk score, typically from 0 (no risk) to 100 (critical risk). */
  riskScore: number;
  /** A qualitative assessment of the threat level. */
  threatLevel: "Low" | "Medium" | "High" | "Critical" | "Unknown";
  /** A list of specific anomalies or suspicious patterns detected by the AI. */
  detectedAnomalies: string[];
  /** Actionable recommendations generated by the AI based on the risk assessment. */
  recommendations: string[];
  /** The AI model's confidence in its assessment (0-1, where 1 is highest confidence). */
  confidenceScore: number;
  /** The identifier of the specific AI model used for the assessment. */
  aiModelUsed: string;
  /** Timestamp when the AI assessment was performed. */
  timestamp: Date;
  /** A unique ID for this specific AI risk assessment. */
  assessmentId: string;
}

/**
 * Interface for AI-driven prediction of an account number's type or other attributes.
 * This can include confidence scores and alternative predictions.
 * @export
 * @interface AIPrediction<T>
 * @template T The type of the predicted value.
 */
export interface AIPrediction<T> {
  /** The value predicted by the AI. */
  predictedValue: T;
  /** The AI model's confidence in this specific prediction (0-1). */
  confidence: number;
  /** Optional, an array of alternative predictions with their respective confidences. */
  alternativePredictions?: Array<{ value: T; confidence: number }>;
  /** The identifier of the AI model used for the prediction. */
  aiModelUsed: string;
  /** Timestamp when the AI prediction was made. */
  timestamp: Date;
  /** A unique ID for this prediction instance. */
  predictionId?: string;
}

/**
 * Defines a policy for masking account numbers for display purposes.
 * This allows for flexible and secure presentation of sensitive data.
 * @export
 * @interface AccountMaskingPolicy
 */
export interface AccountMaskingPolicy {
  /** Unique identifier for the masking policy. */
  id: string;
  /** Human-readable name of the policy. */
  name: string;
  /** A pattern string (e.g., "********1234") or a special keyword ("FULL_REVEAL"). */
  pattern: string;
  /** The character used to mask hidden digits (e.g., '*', '#', 'X'). */
  maskingChar: string;
  /** Number of characters to reveal from the end of the account number. */
  revealLastN?: number;
  /** Number of characters to reveal from the beginning of the account number. */
  revealFirstN?: number;
  /** True if this is the default policy applied when no other is specified. */
  isDefault: boolean;
  /** True if this policy can be overridden by user preferences or specific requests. */
  canBeOverridden: boolean;
  /** Optional description for the policy. */
  description?: string;
  /** The AI model used to generate or validate this masking policy, if applicable. */
  generatedByAIModel?: string;
}

/**
 * Options for `formatAccountNumberForDisplay` function.
 * These options allow granular control over how an account number is presented.
 * @export
 * @interface DisplayFormattingOptions
 */
export interface DisplayFormattingOptions {
  /** The ID of a specific masking policy to apply. If not provided, the default policy is used. */
  maskPolicyId?: string;
  /** If true, overrides all masking policies and reveals the full account number. Use with extreme caution. */
  revealAll?: boolean;
  /** A custom separator to use for grouping digits (e.g., "-", " "). */
  separator?: string;
  /** The number of digits per group when applying a separator (e.g., 4 for "XXXX-XXXX"). */
  groupSize?: number;
  /** A fallback mask character if the selected policy doesn't specify one. */
  fallbackMaskChar?: string;
  /** Whether to use AI to dynamically suggest the best display format or masking pattern. */
  useAIDisplayOptimization?: boolean;
}

/**
 * Represents the arguments for an AI call to analyze an account number.
 * Provides context for the AI to make more informed decisions.
 * @export
 * @interface GeminiAccountNumberAnalysisRequest
 */
export interface GeminiAccountNumberAnalysisRequest {
  /** The account number string to be analyzed. */
  accountNumber: string;
  /** The known or declared type of the account number. */
  accountNumberType?: AccountNumberTypeEnum | null;
  /** The ISO 3166-1 alpha-2 country code if known. */
  countryCode?: string;
  /** The ISO 4217 currency code if known. */
  currencyCode?: string;
  /** Additional contextual data to help the AI. */
  context?: {
    /** The ID of the user performing the action, for auditing and personalization. */
    userId?: string;
    /** The ID of the transaction or operation initiating the analysis. */
    transactionId?: string;
    /** The IP address from which the request originated. */
    ipAddress?: string;
    /** The type or name of the device being used. */
    deviceName?: string;
    /** A summarized or hashed representation of related historical data for pattern recognition. */
    historicalDataSummary?: string;
    /** Other relevant data for AI context. */
    [key: string]: any;
  };
  /** Unique ID for this specific AI analysis request. */
  requestId?: string;
}

/**
 * Represents the response structure from an AI call for comprehensive account number analysis.
 * This aggregates various AI insights into a single, structured object.
 * @export
 * @interface GeminiAccountNumberAnalysisResponse
 */
export interface GeminiAccountNumberAnalysisResponse {
  /** Unique identifier for this specific AI analysis response. */
  analysisId: string;
  /** Overall boolean indicating if the account number seems valid based on AI and rule checks. */
  isValidOverall: boolean;
  /** AI's prediction of the account number's type. */
  predictedType: AIPrediction<AccountNumberTypeEnum | "Unknown">;
  /** AI's prediction of the likely country associated with the account. */
  potentialCountry?: AIPrediction<string>;
  /** AI's prediction of the likely bank or financial institution. */
  potentialBank?: AIPrediction<string>;
  /** AI's comprehensive risk assessment for the account number. */
  riskAssessment: AIRiskAssessment;
  /** A list of specific validation results, including AI-driven ones. */
  validationResults: AccountValidationResult[];
  /** Timestamp when this AI analysis was completed. */
  timestamp: Date;
  /** The specific AI model version that generated this response. */
  aiModelVersion: string;
  /** Optional raw output from the Gemini AI, useful for debugging or advanced integration. */
  rawGeminiOutput?: any;
}

/**
 * Interface for a custom Logger utility, essential for commercial-grade applications
 * to track events, debug issues, and monitor system health.
 * @export
 * @interface Logger
 */
export interface Logger {
  /** Logs an informational message. */
  info(message: string, context?: Record<string, any>): void;
  /** Logs a warning message, indicating a potential issue. */
  warn(message: string, context?: Record<string, any>): void;
  /** Logs an error message, including an optional Error object for stack traces. */
  error(message: string, error?: Error, context?: Record<string, any>): void;
  /** Logs a debug message, typically only active in development environments. */
  debug(message: string, context?: Record<string, any>): void;
  /** Logs a critical message, indicating a severe system failure or security alert. */
  critical(message: string, error?: Error, context?: Record<string, any>): void;
}

/**
 * A robust console-based logger implementation.
 * In a real-world commercial application, this would typically integrate with
 * a centralized logging service like Sentry, Datadog, Splunk, or cloud-native logging solutions.
 * @export
 * @class ConsoleLogger
 * @implements {Logger}
 */
export class ConsoleLogger implements Logger {
  private static instance: ConsoleLogger;
  private minLogLevel: ValidationSeverity = process.env.NODE_ENV === "production" ? ValidationSeverity.Info : ValidationSeverity.Debug;

  private constructor() {}

  /**
   * Provides a singleton instance of the ConsoleLogger.
   * @returns {ConsoleLogger} The singleton logger instance.
   */
  public static getInstance(): ConsoleLogger {
    if (!ConsoleLogger.instance) {
      ConsoleLogger.instance = new ConsoleLogger();
    }
    return ConsoleLogger.instance;
  }

  /**
   * Determines if a message should be logged based on its severity and the configured minimum log level.
   * @private
   * @param {ValidationSeverity} level The severity level of the message.
   * @returns {boolean} True if the message should be logged, false otherwise.
   */
  private shouldLog(level: ValidationSeverity): boolean {
    const levelOrder = [ValidationSeverity.Debug, ValidationSeverity.Info, ValidationSeverity.Warning, ValidationSeverity.Error, ValidationSeverity.Critical];
    return levelOrder.indexOf(level) >= levelOrder.indexOf(this.minLogLevel);
  }

  /**
   * Formats the log message with timestamp, module, level, and context.
   * @private
   * @param {ValidationSeverity} level The severity level of the message.
   * @param {string} message The core log message.
   * @param {Record<string, any>} [context] Optional contextual data.
   * @returns {string} The formatted log string.
   */
  private formatMessage(level: ValidationSeverity, message: string, context?: Record<string, any>): string {
    const timestamp = new Date().toISOString();
    const contextString = context && Object.keys(context).length > 0 ? ` ${JSON.stringify(context)}` : "";
    return `[${timestamp}][ACCOUNT_NUMBER_UTILITY][${level}] ${message}${contextString}`;
  }

  public info(message: string, context?: Record<string, any>): void {
    if (this.shouldLog(ValidationSeverity.Info)) {
      console.info(this.formatMessage(ValidationSeverity.Info, message, context));
    }
  }

  public warn(message: string, context?: Record<string, any>): void {
    if (this.shouldLog(ValidationSeverity.Warning)) {
      console.warn(this.formatMessage(ValidationSeverity.Warning, message, context));
    }
  }

  public error(message: string, error?: Error, context?: Record<string, any>): void {
    if (this.shouldLog(ValidationSeverity.Error)) {
      console.error(this.formatMessage(ValidationSeverity.Error, message, context));
      if (error) {
        console.error(error); // Log the stack trace
      }
    }
  }

  public debug(message: string, context?: Record<string, any>): void {
    if (this.shouldLog(ValidationSeverity.Debug)) {
      console.debug(this.formatMessage(ValidationSeverity.Debug, message, context));
    }
  }

  public critical(message: string, error?: Error, context?: Record<string, any>): void {
    if (this.shouldLog(ValidationSeverity.Critical)) {
      console.error(this.formatMessage(ValidationSeverity.Critical, message, context)); // Critical errors usually go to console.error
      if (error) {
        console.error(error);
      }
      // In a real app, critical logs would trigger alerts (e.g., PagerDuty, Slack).
    }
  }
}

// Export a singleton instance of the logger for consistent and shared logging throughout the module.
export const accountNumberLogger: Logger = ConsoleLogger.getInstance();


// --- HELPER FUNCTIONS & REGEXES ---

/**
 * Collection of common regular expressions for account number validation.
 * These regexes are crucial for initial format checks before deeper validation.
 * @export
 * @constant
 */
export const AccountNumberRegex = {
  /** Regular expression for International Bank Account Number (IBAN) format. */
  IBAN: /^[A-Z]{2}[0-9]{2}(?:[ ]?[0-9]{4}){4}(?:[ ]?[0-9]{1,2})?$/, // Flexible for spaces
  /** Regular expression for CLABE (Clave Bancaria Estandarizada) in Mexico. */
  CLABE: /^[0-9]{18}$/,
  /** Generic regular expression for cryptocurrency wallet addresses (e.g., Ethereum-like). */
  WALLET_ADDRESS_GENERIC: /^(0x)?[0-9a-fA-F]{40,}$/,
  /** Basic regex for a generic US bank account number (often 4-17 digits). Highly simplified. */
  US_BANK_ACCOUNT_GENERIC: /^[0-9]{4,17}$/,
  /** Regular expression for SWIFT/BIC codes. */
  SWIFT_BIC: /^[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?$/,
  /** Regular expression for routing transit numbers (RTN) in the US (9 digits). */
  US_ROUTING_NUMBER: /^\d{9}$/,
};

/**
 * Sanitizes an account number string by removing common non-digit, non-letter characters
 * and normalizing to uppercase. This prepares the string for validation or processing.
 * @param {string | null | undefined} accountNumber The raw account number string.
 * @returns {string} The sanitized account number, or an empty string if input is invalid.
 * @export
 */
export function sanitizeAccountNumber(accountNumber: string | null | undefined): string {
  if (accountNumber === null || accountNumber === undefined) {
    accountNumberLogger.debug("Attempted to sanitize a null or undefined account number.");
    return "";
  }
  // Remove spaces, hyphens, and convert to uppercase for consistency
  const sanitized = accountNumber.replace(/[\s-]/g, "").toUpperCase();
  accountNumberLogger.debug("Account number sanitized.", { originalLength: accountNumber.length, sanitizedLength: sanitized.length });
  return sanitized;
}

/**
 * Performs a basic Luhn algorithm check, often used for credit card numbers,
 * but can be applied to other identifiers. This is a common form of checksum validation.
 * @param {string} digits The digit string to check.
 * @returns {boolean} True if the Luhn check passes, false otherwise.
 * @export
 */
export function luhnCheck(digits: string): boolean {
  if (!/^\d+$/.test(digits)) {
    accountNumberLogger.warn("Luhn check failed: input contains non-digit characters.", { digits: digits.substring(0, 5) + '...' });
    return false;
  }
  let sum = 0;
  let double = false;
  for (let i = digits.length - 1; i >= 0; i--) {
    let digit = parseInt(digits.charAt(i), 10);
    if (double) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9; // Same as digit = digit - 9 (e.g., 14 -> 5)
      }
    }
    sum += digit;
    double = !double;
  }
  return (sum % 10) === 0;
}

/**
 * Validates an IBAN checksum using the MOD 97-10 algorithm, a critical component of IBAN validation.
 * @param {string} iban The IBAN string to validate.
 * @returns {boolean} True if the IBAN checksum is valid, false otherwise.
 * @export
 */
export function validateIbanChecksum(iban: string): boolean {
  const sanitizedIban = sanitizeAccountNumber(iban);
  // IBAN length varies by country, but typically 15-34 characters.
  if (sanitizedIban.length < 15 || sanitizedIban.length > 34) {
    accountNumberLogger.warn("IBAN checksum validation failed: invalid length.", { ibanPrefix: sanitizedIban.substring(0, 5) });
    return false;
  }

  try {
    // Move the first four characters (country code + check digits) to the end.
    const rearranged = sanitizedIban.substring(4) + sanitizedIban.substring(0, 4);
    let numericString = "";
    for (let i = 0; i < rearranged.length; i++) {
      const char = rearranged.charAt(i);
      // Convert letters to numbers (A=10, B=11, ..., Z=35).
      if (char >= 'A' && char <= 'Z') {
        numericString += (char.charCodeAt(0) - 'A'.charCodeAt(0) + 10).toString();
      } else {
        numericString += char;
      }
    }

    // Perform modulo 97-10 operation: calculate remainder after dividing by 97.
    let remainder = 0;
    for (let i = 0; i < numericString.length; i++) {
      remainder = (remainder * 10 + parseInt(numericString.charAt(i), 10)) % 97;
    }

    return remainder === 1;
  } catch (error) {
    accountNumberLogger.error("Error during IBAN checksum validation.", error, { ibanPrefix: iban.substring(0, 5) });
    return false;
  }
}

/**
 * Validates a CLABE (Clave Bancaria Estandarizada) checksum.
 * CLABE uses a specific control digit calculation.
 * @param {string} clabe The CLABE string to validate.
 * @returns {boolean} True if the CLABE checksum is valid, false otherwise.
 * @export
 */
export function validateClabeChecksum(clabe: string): boolean {
  const sanitizedClabe = sanitizeAccountNumber(clabe);
  if (!AccountNumberRegex.CLABE.test(sanitizedClabe)) {
    accountNumberLogger.warn("CLABE checksum validation failed: format mismatch.", { clabe: sanitizedClabe });
    return false;
  }

  try {
    const weights = [3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7];
    let sum = 0;
    for (let i = 0; i < 17; i++) {
      sum += (parseInt(sanitizedClabe.charAt(i), 10) * weights[i]) % 10;
    }
    const controlDigit = (10 - (sum % 10)) % 10;
    return controlDigit === parseInt(sanitizedClabe.charAt(17), 10);
  } catch (error) {
    accountNumberLogger.error("Error during CLABE checksum validation.", error, { clabe: sanitizedClabe });
    return false;
  }
}

// --- GEMINI AI CLIENT SIMULATION ---

/**
 * Simulates an API client for interacting with the Gemini AI service.
 * This class handles request construction, simulated network calls, retry logic,
 * and error handling, mimicking a robust production-grade AI client.
 * @export
 * @class GeminiAIClient
 */
export class GeminiAIClient {
  private static instance: GeminiAIClient;
  private logger: Logger;
  private baseUrl: string;
  private apiKey: string;

  private constructor(logger: Logger, config: typeof GEMINI_AI_CONFIG) {
    this.logger = logger;
    this.baseUrl = config.BASE_URL;
    this.apiKey = config.API_KEY; // In a real app, this would be passed via headers or secured context.
  }

  /**
   * Provides a singleton instance of the GeminiAIClient.
   * @param {Logger} [logger=ConsoleLogger.getInstance()] The logger instance to use.
   * @param {typeof GEMINI_AI_CONFIG} [config=GEMINI_AI_CONFIG] The configuration for the AI client.
   * @returns {GeminiAIClient} The singleton AI client instance.
   */
  public static getInstance(logger: Logger = ConsoleLogger.getInstance(), config: typeof GEMINI_AI_CONFIG = GEMINI_AI_CONFIG): GeminiAIClient {
    if (!GeminiAIClient.instance) {
      GeminiAIClient.instance = new GeminiAIClient(logger, config);
    }
    return GeminiAIClient.instance;
  }

  /**
   * Simulates a call to the Gemini AI API with retry logic and exponential backoff.
   * This function is the core of AI interaction.
   * @private
   * @template TRequest The type of the request payload.
   * @template TResponse The expected type of the response payload.
   * @param {string} endpoint The specific AI service endpoint to call (relative to base URL).
   * @param {TRequest} payload The request body to send to the AI.
   * @param {number} [retries=GEMINI_AI_CONFIG.MAX_RETRY_ATTEMPTS] Remaining retry attempts.
   * @param {number} [delay=500] Initial delay for exponential backoff.
   * @returns {Promise<TResponse>} A promise that resolves with the AI response.
   * @throws {Error} If the AI call fails after all retries or due to a critical error.
   */
  private async callAI<TRequest, TResponse>(
    endpoint: string,
    payload: TRequest,
    retries: number = GEMINI_AI_CONFIG.MAX_RETRY_ATTEMPTS,
    delay: number = 500, // Starting backoff delay
  ): Promise<TResponse> {
    const fullUrl = `${this.baseUrl}${endpoint}`;
    const attempt = GEMINI_AI_CONFIG.MAX_RETRY_ATTEMPTS - retries + 1;
    this.logger.debug(`Simulating AI call to ${fullUrl}`, { attempt, payload: { ...payload, accountNumber: (payload as any).accountNumber?.substring(0, 5) + '...' } });

    try {
      // Simulate network delay to mimic a real API call
      await new Promise(resolve => setTimeout(resolve, Math.random() * GEMINI_AI_CONFIG.REQUEST_TIMEOUT_MS / 3 + 150));

      // Simulate various AI response scenarios:
      // 1. Transient network/service error (retryable)
      if (Math.random() < 0.15 && retries > 0) { // 15% chance of transient error, unless last attempt
        throw new Error(`Simulated AI transient error (HTTP 503 Service Unavailable).`);
      }
      // 2. Client-side input error (not retryable)
      if (Math.random() < 0.05 && attempt === 1 && (payload as any).accountNumber.includes("INVALID")) {
        throw new Error("Simulated AI client error: Invalid input detected (HTTP 400 Bad Request).");
      }
      // 3. Rate limiting (retryable with backoff)
      if (Math.random() < 0.03 && retries > 0) {
        throw new Error("Simulated AI rate limit exceeded (HTTP 429 Too Many Requests).");
      }


      // Simulate a successful AI response
      const mockResponse = this.generateMockAIResponse(endpoint, payload);
      this.logger.debug(`Simulated AI call successful to ${fullUrl}`, { analysisId: (mockResponse as any).analysisId });
      return mockResponse as TResponse;
    } catch (error: any) {
      if (error.message.includes("HTTP 400")) { // Non-retryable client error
        this.logger.error(`AI call to ${fullUrl} failed due to client error: ${error.message}`, error, { payload: { ...payload, accountNumber: (payload as any).accountNumber?.substring(0, 5) + '...' } });
        throw new Error(`AI client error: ${error.message}`);
      }

      this.logger.warn(`AI call to ${fullUrl} failed (retries left: ${retries - 1}): ${error.message}`, { endpoint, attempt, errorDetails: error.message });
      if (retries > 0) {
        // Exponential backoff with jitter
        const backoffTime = delay * Math.pow(2, GEMINI_AI_CONFIG.MAX_RETRY_ATTEMPTS - retries) + Math.random() * 200;
        await new Promise(resolve => setTimeout(resolve, backoffTime));
        this.logger.debug(`Retrying AI call to ${fullUrl} after ${backoffTime.toFixed(0)}ms.`, { attempt: attempt + 1 });
        return this.callAI(endpoint, payload, retries - 1, delay);
      }
      this.logger.error(`AI call to ${fullUrl} ultimately failed after ${GEMINI_AI_CONFIG.MAX_RETRY_ATTEMPTS} retries.`, error, { payload: { ...payload, accountNumber: (payload as any).accountNumber?.substring(0, 5) + '...' } });
      throw new Error(`Failed to communicate with AI service at ${endpoint}: ${error.message}`);
    }
  }

  /**
   * Generates a realistic mock AI response based on the endpoint and request payload.
   * This function is central to simulating the "Gemini AI functions everywhere" directive.
   * @private
   * @param {string} endpoint The AI service endpoint being called.
   * @param {any} payload The request payload.
   * @returns {any} A mock AI response object matching the expected interface for each endpoint.
   */
  private generateMockAIResponse(endpoint: string, payload: any): any {
    const { accountNumber, accountNumberType, countryCode } = payload as GeminiAccountNumberAnalysisRequest;
    const sanitizedAccNum = sanitizeAccountNumber(accountNumber);
    const timestamp = new Date();
    const analysisId = `${endpoint.split('/').pop()}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

    switch (endpoint) {
      case GEMINI_AI_CONFIG.ACCOUNT_ANALYSIS_ENDPOINT:
        const isIbanLike = AccountNumberRegex.IBAN.test(sanitizedAccNum);
        const isClabeLike = AccountNumberRegex.CLABE.test(sanitizedAccNum);
        const isWalletLike = AccountNumberRegex.WALLET_ADDRESS_GENERIC.test(sanitizedAccNum);
        const isUSBankAccountLike = AccountNumberRegex.US_BANK_ACCOUNT_GENERIC.test(sanitizedAccNum);

        let predictedTypeValue: AccountNumberTypeEnum | "Unknown" = "Unknown";
        if (accountNumberType) {
            predictedTypeValue = accountNumberType;
        } else if (isIbanLike && sanitizedAccNum.length >= 20) {
            predictedTypeValue = AccountNumberTypeEnum.Iban;
        } else if (isClabeLike) {
            predictedTypeValue = AccountNumberTypeEnum.Clabe;
        } else if (isWalletLike) {
            predictedTypeValue = AccountNumberTypeEnum.WalletAddress;
        } else if (isUSBankAccountLike) {
            // Invent a new AI-inferred type for generic US accounts, if it was an enum it would be different.
            predictedTypeValue = AccountNumberTypeEnum.Other; // Fallback to Other for non-enum types
        }

        const predictedType: AIPrediction<AccountNumberTypeEnum | "Unknown"> = {
          predictedValue: predictedTypeValue,
          confidence: accountNumberType ? 0.99 : (isIbanLike || isClabeLike || isWalletLike || isUSBankAccountLike ? 0.85 + Math.random() * 0.1 : 0.4 + Math.random() * 0.3),
          aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
          timestamp,
          predictionId: `${analysisId}-type-pred`,
        };

        let riskScore = Math.floor(Math.random() * 70); // Simulate some risk base
        const detectedAnomalies: string[] = [];

        // Dynamic risk adjustment and anomaly detection
        if (sanitizedAccNum.length < 5) {
            riskScore = Math.max(riskScore, 80); detectedAnomalies.push("Extremely short account number.");
        }
        if (sanitizedAccNum.includes("TEST") || sanitizedAccNum.includes("DEMO")) {
            riskScore = Math.max(riskScore, 60); detectedAnomalies.push("Account number contains common test/demo strings.");
        }
        if (sanitizedAccNum.match(/(\d)\1{4,}/)) { // 5 or more repeating digits
            riskScore = Math.max(riskScore, 75); detectedAnomalies.push("Consecutive repeating digits detected, potential pattern abuse.");
        }
        if (riskScore > 50 && detectedAnomalies.length === 0) detectedAnomalies.push("Unusual transaction velocity associated with this pattern.");
        if (sanitizedAccNum.length > 0 && Math.random() < 0.1) { // 10% chance of a "linked to blacklist" simulation
            riskScore = Math.max(riskScore, 95); detectedAnomalies.push("Pattern matches known blacklisted account structures.");
        }

        const threatLevel = riskScore > 90 ? "Critical" : riskScore > 70 ? "High" : riskScore > 40 ? "Medium" : "Low";

        const validationResults: AccountValidationResult[] = [];
        let isValidOverall = true;

        // Add format validation based on predicted type
        const currentValidationTimestamp = new Date();
        const predictedAccType = predictedType.predictedValue;

        if (predictedAccType === AccountNumberTypeEnum.Iban) {
          const formatValid = AccountNumberRegex.IBAN.test(sanitizedAccNum);
          validationResults.push({ type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "IBAN format is correct." : "IBAN format mismatch.", severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp });
          const checksumValid = validateIbanChecksum(sanitizedAccNum);
          validationResults.push({ type: AccountValidationType.Checksum, isValid: checksumValid, message: checksumValid ? "IBAN checksum passed." : "IBAN checksum failed.", severity: checksumValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp });
          if (!formatValid || !checksumValid) isValidOverall = false;
        } else if (predictedAccType === AccountNumberTypeEnum.Clabe) {
          const formatValid = AccountNumberRegex.CLABE.test(sanitizedAccNum);
          validationResults.push({ type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "CLABE format is correct." : "CLABE format mismatch.", severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp });
          const checksumValid = validateClabeChecksum(sanitizedAccNum);
          validationResults.push({ type: AccountValidationType.Checksum, isValid: checksumValid, message: checksumValid ? "CLABE checksum passed." : "CLABE checksum failed.", severity: checksumValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp });
          if (!formatValid || !checksumValid) isValidOverall = false;
        } else if (predictedAccType === AccountNumberTypeEnum.WalletAddress) {
          const formatValid = AccountNumberRegex.WALLET_ADDRESS_GENERIC.test(sanitizedAccNum);
          validationResults.push({ type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "Wallet address format is correct." : "Wallet address format mismatch.", severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp });
          if (!formatValid) isValidOverall = false;
        } else {
            // For 'Other' or 'Unknown', check general length and char validity
            const generalValid = sanitizedAccNum.length > 4 && /^[A-Z0-9]*$/.test(sanitizedAccNum);
            validationResults.push({ type: AccountValidationType.Format, isValid: generalValid, message: generalValid ? "General format appears valid." : "General format invalid or too short.", severity: generalValid ? ValidationSeverity.Info : ValidationSeverity.Warning, timestamp: currentValidationTimestamp });
            if (!generalValid) isValidOverall = false;
        }

        if (detectedAnomalies.length > 0) {
            validationResults.push({
                type: AccountValidationType.AnomalyDetection,
                isValid: false,
                message: `AI detected anomalies: ${detectedAnomalies.join('; ')}.`,
                severity: threatLevel === "Critical" || threatLevel === "High" ? ValidationSeverity.Critical : ValidationSeverity.Warning,
                details: { anomalies: detectedAnomalies },
                timestamp: currentValidationTimestamp,
            });
            isValidOverall = false;
        }

        return {
          analysisId,
          isValidOverall,
          predictedType,
          potentialCountry: {
            predictedValue: countryCode || (isIbanLike ? sanitizedAccNum.substring(0, 2) : (isUSBankAccountLike ? "US" : "UNKNOWN")),
            confidence: countryCode ? 0.98 : (isIbanLike || isUSBankAccountLike ? 0.8 : 0.3),
            aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
            timestamp,
            predictionId: `${analysisId}-country-pred`,
          },
          potentialBank: {
            predictedValue: isIbanLike ? `Bank ${sanitizedAccNum.substring(4, 8)}` : (isUSBankAccountLike ? "US Bank Inc." : "Generic Financial Institution"),
            confidence: isIbanLike ? 0.75 : 0.4,
            aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
            timestamp,
            predictionId: `${analysisId}-bank-pred`,
          },
          riskAssessment: {
            assessmentId: `${analysisId}-risk-assess`,
            riskScore,
            threatLevel,
            detectedAnomalies: detectedAnomalies.length > 0 ? detectedAnomalies : ["No significant anomalies detected by AI."],
            recommendations: riskScore > 60 ? ["Review related transactions manually.", "Verify recipient details out-of-band.", "Consider temporary block."] : [],
            confidenceScore: 0.9 + Math.random() * 0.05,
            aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
            timestamp,
          },
          validationResults: validationResults.length > 0 ? validationResults : [
            { type: AccountValidationType.AIPredictive, isValid: true, message: "AI found no immediate issues.", severity: ValidationSeverity.Info, timestamp: currentValidationTimestamp },
          ],
          timestamp,
          aiModelVersion: GEMINI_AI_CONFIG.MODEL_VERSION,
          rawGeminiOutput: { model: GEMINI_AI_CONFIG.MODEL_VERSION, promptTokens: 150, completionTokens: 300, latencyMs: 500 + Math.random() * 200 },
        };

      case GEMINI_AI_CONFIG.FRAUD_DETECTION_ENDPOINT:
        const fraudScore = Math.floor(Math.random() * 100);
        const fraudAnomalies: string[] = [];
        if (fraudScore > 80) fraudAnomalies.push("High volume of unusual transactions recently.");
        if (fraudScore > 60) fraudAnomalies.push("Associated with known fraudulent IP addresses.");
        if (fraudScore > 40) fraudAnomalies.push("Account number changed frequently in short period.");
        if (fraudAnomalies.length === 0) fraudAnomalies.push("No significant fraud indicators detected.");

        return {
          analysisId,
          isValidOverall: fraudScore < 70, // Arbitrary threshold
          predictedType: { predictedValue: AccountNumberTypeEnum.Other, confidence: 0.5, aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION, timestamp }, // Placeholder
          riskAssessment: {
            assessmentId: `${analysisId}-fraud-assess`,
            riskScore: fraudScore,
            threatLevel: fraudScore > 90 ? "Critical" : fraudScore > 70 ? "High" : fraudScore > 40 ? "Medium" : "Low",
            detectedAnomalies: fraudAnomalies,
            recommendations: fraudScore > 70 ? ["Block all outgoing transactions immediately.", "Initiate internal fraud investigation.", "Notify compliance department."] : [],
            confidenceScore: 0.95,
            aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
            timestamp,
          },
          validationResults: [], // Fraud endpoint might not return detailed validation, focus on risk
          timestamp,
          aiModelVersion: GEMINI_AI_CONFIG.MODEL_VERSION,
          rawGeminiOutput: { model: GEMINI_AI_CONFIG.MODEL_VERSION, promptTokens: 80, completionTokens: 180, latencyMs: 350 + Math.random() * 150 },
        };

      case GEMINI_AI_CONFIG.TYPE_INFERENCE_ENDPOINT:
        let inferredType: AccountNumberTypeEnum | "Unknown" = "Unknown";
        let typeConfidence = 0.5;
        const alternativeTypes: Array<{ value: AccountNumberTypeEnum | "Unknown"; confidence: number }> = [];

        if (sanitizedAccNum.length > 0) {
            if (sanitizedAccNum.startsWith("GB") || sanitizedAccNum.startsWith("DE") || sanitizedAccNum.match(/^[A-Z]{2}\d{2}/)) {
                inferredType = AccountNumberTypeEnum.Iban;
                typeConfidence = 0.9;
                alternativeTypes.push({ value: AccountNumberTypeEnum.Other, confidence: 0.1 });
            } else if (sanitizedAccNum.length === 18 && /^\d+$/.test(sanitizedAccNum)) {
                inferredType = AccountNumberTypeEnum.Clabe;
                typeConfidence = 0.85;
                alternativeTypes.push({ value: AccountNumberTypeEnum.Other, confidence: 0.15 });
            } else if (sanitizedAccNum.startsWith("0x") && sanitizedAccNum.length > 30) {
                inferredType = AccountNumberTypeEnum.WalletAddress;
                typeConfidence = 0.92;
                alternativeTypes.push({ value: AccountNumberTypeEnum.Other, confidence: 0.08 });
            } else {
                inferredType = AccountNumberTypeEnum.Other;
                typeConfidence = 0.6;
                alternativeTypes.push({ value: AccountNumberTypeEnum.Iban, confidence: 0.2 }, { value: AccountNumberTypeEnum.WalletAddress, confidence: 0.2 });
            }
        }

        return {
          predictedValue: inferredType,
          confidence: typeConfidence + Math.random() * 0.05,
          alternativePredictions: alternativeTypes,
          aiModelUsed: GEMINI_AI_CONFIG.MODEL_VERSION,
          timestamp,
          predictionId: `${analysisId}-type`,
        } as AIPrediction<AccountNumberTypeEnum | "Unknown">;

      default:
        this.logger.error(`Unknown AI endpoint requested: ${endpoint}`, null, { endpoint, payload: { ...payload, accountNumber: (payload as any).accountNumber?.substring(0, 5) + '...' } });
        throw new Error(`Unknown AI endpoint: ${endpoint}`);
    }
  }

  /**
   * Analyzes an account number using the simulated Gemini AI service for type prediction,
   * risk assessment, and detailed validation. This is a comprehensive AI utility.
   * @param {GeminiAccountNumberAnalysisRequest} request The analysis request payload.
   * @returns {Promise<GeminiAccountNumberAnalysisResponse>} A promise resolving with the AI analysis response.
   * @export
   */
  public async analyzeAccountNumber(request: GeminiAccountNumberAnalysisRequest): Promise<GeminiAccountNumberAnalysisResponse> {
    this.logger.info("Initiating AI analysis for account number.", {
      requestId: request.requestId,
      accountNumberPrefix: request.accountNumber.substring(0, 5),
      type: request.accountNumberType,
    });
    return this.callAI<GeminiAccountNumberAnalysisRequest, GeminiAccountNumberAnalysisResponse>(
      GEMINI_AI_CONFIG.ACCOUNT_ANALYSIS_ENDPOINT,
      request,
    );
  }

  /**
   * Infers the likely type of an account number using Gemini AI.
   * Useful for dynamically setting account types in user interfaces or data processing.
   * @param {string} accountNumber The account number string to infer type for.
   * @param {string} [requestId] Optional request ID for tracking.
   * @returns {Promise<AIPrediction<AccountNumberTypeEnum | "Unknown">>} A promise resolving with the AI prediction.
   * @export
   */
  public async inferAccountNumberType(accountNumber: string, requestId?: string): Promise<AIPrediction<AccountNumberTypeEnum | "Unknown">> {
    this.logger.info("Initiating AI inference for account number type.", { requestId, accountNumberPrefix: accountNumber.substring(0, 5) });
    return this.callAI<Partial<GeminiAccountNumberAnalysisRequest>, AIPrediction<AccountNumberTypeEnum | "Unknown">>(
      GEMINI_AI_CONFIG.TYPE_INFERENCE_ENDPOINT,
      { accountNumber, requestId },
    );
  }

  /**
   * Assesses the fraud risk of an account number using Gemini AI.
   * This function provides a focused risk assessment for security-sensitive operations.
   * @param {GeminiAccountNumberAnalysisRequest} request The fraud detection request payload.
   * @returns {Promise<AIRiskAssessment>} A promise resolving with the AI risk assessment.
   * @export
   */
  public async detectFraudulentActivity(request: GeminiAccountNumberAnalysisRequest): Promise<AIRiskAssessment> {
    this.logger.info("Initiating AI fraud detection for account number.", {
      requestId: request.requestId,
      accountNumberPrefix: request.accountNumber.substring(0, 5),
    });
    // The fraud detection endpoint might return a broader response, but we extract only AIRiskAssessment.
    const response = await this.callAI<GeminiAccountNumberAnalysisRequest, GeminiAccountNumberAnalysisResponse>(
      GEMINI_AI_CONFIG.FRAUD_DETECTION_ENDPOINT,
      request,
    );
    return response.riskAssessment;
  }
}

// Export a singleton instance of the Gemini AI client for consistent access across the application.
export const geminiAIClient = GeminiAIClient.getInstance(accountNumberLogger);


// --- CORE ACCOUNT NUMBER UTILITIES (ENHANCED) ---

/**
 * Maps an array of extended account details to a dictionary of human-readable labels for display.
 * This enhanced version considers more specific types, status, and can be extended with AI insights.
 * @param {AccountNumberExtendedDetail[]} [accountDetails] An array of extended account detail objects.
 * @returns {AccountDetailRowLabel} An object mapping account IDs to their display labels.
 * @export
 */
export function accountNumberLabelMapping(
  accountDetails?: AccountNumberExtendedDetail[],
): AccountDetailRowLabel {
  if (!accountDetails || accountDetails.length === 0) {
    accountNumberLogger.debug("No account details provided for label mapping, returning empty object.");
    return {};
  }

  const accountLabels = accountDetails.map(
    (accountDetail): AccountDetailRowLabel => {
      let labelContent: string;

      // Prioritize explicit parentAccountType for certain labels, especially for virtual accounts.
      if (
        accountDetail.parentAccountType === "VirtualAccount" &&
        (accountDetail?.accountNumberType === AccountNumberTypeEnum.Other || !accountDetail?.accountNumberType)
      ) {
        labelContent = "Virtual Account Number";
      } else {
        // Use a switch for standard types, with enhanced fallback for 'Other'
        switch (accountDetail?.accountNumberType) {
          case AccountNumberTypeEnum.Iban:
            labelContent = "IBAN Number";
            break;
          case AccountNumberTypeEnum.Clabe:
            labelContent = "CLABE Number";
            break;
          case AccountNumberTypeEnum.WalletAddress:
            labelContent = "Wallet Address";
            break;
          case AccountNumberTypeEnum.Other:
            // Attempt to use a more descriptive label from metadata if available (potentially AI-derived).
            labelContent = accountDetail.metadata?.description || "Generic Account Number";
            break;
          default:
            labelContent = "Account Number";
        }
      }

      // Append status indicator if the account is not actively functional.
      if (accountDetail.status !== AccountNumberStatus.Active) {
        // Format status enum to be more readable (e.g., "PENDING_VERIFICATION" -> "Pending Verification").
        labelContent += ` (${accountDetail.status.replace(/_/g, ' ')})`;
      }

      return { [accountDetail.id]: labelContent };
    },
  );

  // Combine individual label objects into a single dictionary.
  return accountLabels.reduce(
    (result, current): AccountDetailRowLabel => Object.assign(result, current),
    {},
  );
}

/**
 * Maps an array of extended account details to JSX elements for displaying account numbers.
 * This function now incorporates more sophisticated masking, display logic, and can
 * optionally include visual indicators based on AI-derived insights like fraud risk.
 * @param {AccountNumberExtendedDetail[]} accountDetails An array of extended account detail objects.
 * @param {DisplayFormattingOptions} [options] Optional settings for how the account number should be displayed.
 * @returns {AccountDetailRowValue} An object mapping account IDs to their JSX display elements.
 * @export
 */
export function accountNumberValueMapping(
  accountDetails: AccountNumberExtendedDetail[],
  options?: DisplayFormattingOptions,
): AccountDetailRowValue {
  if (!accountDetails || accountDetails.length === 0) {
    accountNumberLogger.debug("No account details provided for value mapping, returning empty object.");
    return {};
  }

  return accountDetails.reduce(
    (previousValue, accountDetail): AccountDetailRowValue => {
      // Use the advanced `formatAccountNumberForDisplay` function to apply masking and grouping.
      const formattedAccountNumber = formatAccountNumberForDisplay(accountDetail.accountNumber, options);

      // Determine if there's a fraud risk for visual indication (e.g., a warning icon).
      const isFraudRisk = accountDetail.status === AccountNumberStatus.Fraudulent ||
                          (accountDetail.metadata?.lastAIRiskScore !== undefined && accountDetail.metadata.lastAIRiskScore >= 70); // High risk score threshold

      return {
        ...previousValue,
        [accountDetail.id]: (
          // The AccountDetailAccountNumber component is expected to handle the partial (masked) number.
          // Additional props are passed to allow the component to render richer information or styling.
          <AccountDetailAccountNumber
            key={accountDetail.id}
            accountDetailId={accountDetail.id}
            partialAccountNumber={formattedAccountNumber}
            isFraudRisk={isFraudRisk}
            accountStatus={accountDetail.status}
            // Future enhancement: pass AI recommendations as tooltips or detailed views.
            // aiRecommendations={accountDetail.metadata?.aiAnalysisHistory?.[0]?.riskAssessment?.recommendations || []}
          />
        ),
      };
    },
    {},
  );
}

/**
 * Default masking policy for account numbers. This policy is applied when no specific
 * policy is requested. It balances security (masking most characters) with usability
 * (revealing the last few digits for identification).
 * @export
 * @constant
 */
export const DEFAULT_MASKING_POLICY: AccountMaskingPolicy = {
  id: "default-standard-masking",
  name: "Standard Masking Policy",
  pattern: "********", // Indicates a general masking strategy, not a literal fixed pattern.
  maskingChar: "*",
  revealLastN: 4, // Commonly reveals the last 4 digits.
  revealFirstN: 0,
  isDefault: true,
  canBeOverridden: true,
  description: "Applies '*' to mask all but the last 4 characters of an account number.",
};

/**
 * A collection of known masking policies that would typically be managed in a backend
 * configuration or database. This array simulates a repository of predefined rules.
 * @export
 * @constant
 */
export const KNOWN_MASKING_POLICIES: AccountMaskingPolicy[] = [
  DEFAULT_MASKING_POLICY,
  {
    id: "iban-display-masking",
    name: "IBAN Display Masking",
    pattern: "XX** **** **** **** **** ****", // Example: DE** 1234 5678 9012 3456 78 -> DE** **** **** **** **** 78
    maskingChar: "*",
    revealLastN: 4,
    revealFirstN: 4, // Reveals country code and initial check digits (e.g., DE89)
    isDefault: false,
    canBeOverridden: true,
    description: "IBAN-specific masking: reveals country code and first check digits, and last 4.",
  },
  {
    id: "clabe-display-masking",
    name: "CLABE Display Masking",
    pattern: "######XXXXXXXX####", // Example: 012345XXXXXXXX6789 (reveals first 6, last 4)
    maskingChar: "X",
    revealLastN: 4,
    revealFirstN: 6,
    isDefault: false,
    canBeOverridden: true,
    description: "CLABE-specific masking: reveals first 6 digits (bank code), and last 4.",
  },
  {
    id: "wallet-short-masking",
    name: "Wallet Address Short Masking",
    pattern: "0xXXXX...XXXX", // Example: 0xAbCd...EfG0
    maskingChar: "*",
    revealLastN: 4,
    revealFirstN: 6, // "0x" + 4 chars
    isDefault: false,
    canBeOverridden: true,
    description: "Masks long crypto wallet addresses, revealing prefix (0x) and a few start/end characters.",
  },
  {
    id: "admin-full-reveal",
    name: "Administrator Full Reveal (Restricted)",
    pattern: "FULL_REVEAL", // Special pattern indicating no masking.
    maskingChar: "", // Not applicable for full reveal.
    revealLastN: undefined, // Undefined means 'reveal all' if pattern is FULL_REVEAL.
    revealFirstN: undefined,
    isDefault: false,
    canBeOverridden: false, // This policy is typically not user-selectable or overrideable.
    description: "Special policy for administrative access to view full account numbers. Requires explicit permissions.",
  },
  {
    id: "ai-optimized-masking",
    name: "AI Optimized Masking",
    pattern: "AI_OPTIMIZED", // Placeholder for AI-generated dynamic patterns
    maskingChar: "#",
    revealLastN: undefined,
    revealFirstN: undefined,
    isDefault: false,
    canBeOverridden: true,
    description: "A dynamic masking policy optimized by AI for readability and security based on context.",
    generatedByAIModel: GEMINI_AI_CONFIG.MODEL_VERSION,
  },
];

/**
 * Retrieves a masking policy by its ID from the known policies list.
 * If the ID is not found or null, it gracefully falls back to the `DEFAULT_MASKING_POLICY`.
 * @param {string | undefined | null} policyId The ID of the desired masking policy.
 * @returns {AccountMaskingPolicy} The found policy or the default policy if not found.
 * @export
 */
export function getMaskingPolicyById(policyId: string | undefined | null): AccountMaskingPolicy {
  if (!policyId) {
    accountNumberLogger.debug("No policy ID provided, returning default masking policy.");
    return DEFAULT_MASKING_POLICY;
  }
  const policy = KNOWN_MASKING_POLICIES.find(p => p.id === policyId);
  if (!policy) {
    accountNumberLogger.warn(`Masking policy with ID '${policyId}' not found in KNOWN_MASKING_POLICIES. Using default policy.`, { policyId });
    return DEFAULT_MASKING_POLICY;
  }
  accountNumberLogger.debug(`Retrieved masking policy: ${policy.name} (ID: ${policy.id})`);
  return policy;
}

/**
 * Dynamically generates an "AI_OPTIMIZED" masking policy based on the account number type and length.
 * This simulates how Gemini AI could recommend optimal display strategies.
 * @param {string} accountNumber The full account number.
 * @param {AccountNumberTypeEnum | null} type The determined type of the account number.
 * @returns {AccountMaskingPolicy} An AI-generated or context-aware masking policy.
 * @export
 */
export function generateAIOptimizedMaskingPolicy(accountNumber: string, type: AccountNumberTypeEnum | null): AccountMaskingPolicy {
    accountNumberLogger.info("Generating AI-optimized masking policy.", { type, accountNumberPrefix: accountNumber.substring(0, 5) });
    const policy: AccountMaskingPolicy = {
        id: "ai-generated-dynamic",
        name: "AI Generated Dynamic Masking",
        pattern: "",
        maskingChar: "#", // Use a different char to signify AI generation
        revealLastN: 4,
        revealFirstN: 0,
        isDefault: false,
        canBeOverridden: true,
        description: "This masking policy was dynamically generated by AI.",
        generatedByAIModel: GEMINI_AI_CONFIG.MODEL_VERSION,
    };

    const sanitizedAccNum = sanitizeAccountNumber(accountNumber);
    const len = sanitizedAccNum.length;

    if (len <= 4) { // Very short numbers, don't mask
        policy.pattern = sanitizedAccNum;
        policy.revealFirstN = len;
        policy.revealLastN = 0;
        policy.description += " (Full reveal due to short length).";
    } else {
        switch (type) {
            case AccountNumberTypeEnum.Iban:
                // IBANs often reveal country code + check digits (first 4) and last 4 for verification.
                policy.revealFirstN = Math.min(4, len);
                policy.revealLastN = Math.min(4, len - policy.revealFirstN);
                policy.description += " (IBAN-specific pattern).";
                break;
            case AccountNumberTypeEnum.Clabe:
                // CLABEs often reveal first 6 (bank code) and last 4.
                policy.revealFirstN = Math.min(6, len);
                policy.revealLastN = Math.min(4, len - policy.revealFirstN);
                policy.description += " (CLABE-specific pattern).";
                break;
            case AccountNumberTypeEnum.WalletAddress:
                // Wallet addresses (long) reveal prefix (0x) and a few chars at start/end.
                policy.revealFirstN = Math.min(6, len); // e.g., "0x1234"
                policy.revealLastN = Math.min(4, len - policy.revealFirstN);
                policy.description += " (Wallet address pattern).";
                break;
            case AccountNumberTypeEnum.Other:
            default:
                // For generic, default to revealing just a few at the end or split roughly.
                policy.revealFirstN = Math.min(2, len); // Reveal first 2
                policy.revealLastN = Math.min(4, len - policy.revealFirstN); // Reveal last 4
                if (len > 10 && len % 2 === 0) { // If long and even, maybe reveal middle part
                    // This is complex, keep it simple for now or use a more advanced AI call.
                    // For now, stick to fixed start/end reveal for 'Other'.
                }
                policy.description += " (Generic pattern, dynamic based on length).";
                break;
        }
    }

    // Ensure revealFirstN + revealLastN does not exceed total length, if it does, simplify to full reveal
    if (policy.revealFirstN + policy.revealLastN >= len) {
        policy.revealFirstN = len;
        policy.revealLastN = 0;
        policy.description += " (Adjusted to full reveal due to insufficient length for masking).";
    }

    return policy;
}


/**
 * Applies a masking policy to an account number string. This function is highly robust,
 * supporting various masking patterns, reveal counts, and custom masking characters.
 * @param {string} accountNumber The full, raw account number string.
 * @param {AccountMaskingPolicy} policy The masking policy to apply.
 * @param {boolean} [forceRevealAll=false] If true, overrides the policy and reveals the entire number.
 * @returns {string} The masked account number string, ready for display.
 * @export
 */
export function applyMaskingPolicy(accountNumber: string, policy: AccountMaskingPolicy, forceRevealAll: boolean = false): string {
  const sanitizedAccNum = sanitizeAccountNumber(accountNumber);
  const len = sanitizedAccNum.length;

  // Handle explicit full reveal scenarios first.
  if (forceRevealAll || policy.pattern === "FULL_REVEAL") {
    accountNumberLogger.debug("Full account number revealed due to forceRevealAll or policy setting.", { policyId: policy.id, accountLength: len });
    return sanitizedAccNum;
  }

  if (len === 0) {
    return "";
  }

  const maskChar = policy.maskingChar || DEFAULT_MASKING_POLICY.maskingChar;
  let maskedString = "";

  // Determine actual reveal counts, falling back to policy defaults or 0 if undefined.
  const revealFirstN = policy.revealFirstN !== undefined ? policy.revealFirstN : 0;
  const revealLastN = policy.revealLastN !== undefined ? policy.revealLastN : 0;

  // If revealing more characters than available, just show the whole number.
  if (revealFirstN + revealLastN >= len) {
    accountNumberLogger.warn(`Masking policy '${policy.id}' attempted to reveal (${revealFirstN}+${revealLastN}) characters, which is >= total length (${len}). Revealing full number.`, { policyId: policy.id });
    return sanitizedAccNum;
  }

  // Apply revealFirstN
  if (revealFirstN > 0) {
    maskedString += sanitizedAccNum.substring(0, revealFirstN);
  }

  // Apply masking for the middle section.
  const maskedLength = len - revealFirstN - revealLastN;
  if (maskedLength > 0) {
    maskedString += maskChar.repeat(maskedLength);
  }

  // Apply revealLastN
  if (revealLastN > 0) {
    maskedString += sanitizedAccNum.substring(len - revealLastN);
  }

  accountNumberLogger.debug(`Masking applied for policy '${policy.id}'. Result: ${maskedString.substring(0,10)}...`);
  return maskedString;
}

/**
 * Formats an account number for display according to provided options and masking policies.
 * This is the primary public function for presenting account numbers securely and legibly
 * within the user interface, supporting dynamic masking and AI-driven optimizations.
 * @param {string} accountNumber The raw account number string.
 * @param {DisplayFormattingOptions} [options] Optional formatting and masking settings.
 * @param {AccountNumberTypeEnum | null} [inferredType=null] Optional AI-inferred type for dynamic policies.
 * @returns {string} The formatted and masked account number string.
 * @export
 */
export function formatAccountNumberForDisplay(
  accountNumber: string,
  options?: DisplayFormattingOptions,
  inferredType: AccountNumberTypeEnum | null = null, // Can be provided by AI or context
): string {
  if (!accountNumber) {
    accountNumberLogger.debug("Attempted to format a null or empty account number for display.", { options });
    return "";
  }

  const sanitizedAccNum = sanitizeAccountNumber(accountNumber);
  let displayValue = sanitizedAccNum;

  // 1. Determine masking policy, potentially using AI optimization.
  let activePolicy = DEFAULT_MASKING_POLICY;
  if (options?.useAIDisplayOptimization) {
      activePolicy = generateAIOptimizedMaskingPolicy(sanitizedAccNum, inferredType);
      accountNumberLogger.info(`Using AI-optimized masking policy for display.`, { policyId: activePolicy.id });
  } else {
      activePolicy = getMaskingPolicyById(options?.maskPolicyId);
  }

  // 2. Apply masking unless explicitly revealed.
  if (options?.revealAll !== true) {
    displayValue = applyMaskingPolicy(sanitizedAccNum, activePolicy, false);
  } else {
    accountNumberLogger.debug("Display formatting: revealAll option is true, skipping masking.", { accountNumberPrefix: sanitizedAccNum.substring(0, 5) });
  }

  // 3. Apply grouping/separator if specified in options.
  // This step is applied to the already-masked (or revealed) string.
  if (options?.separator && options?.groupSize && options.groupSize > 0) {
    const originalChars = displayValue.split('');
    let groupedString = '';
    for (let i = 0; i < originalChars.length; i++) {
        groupedString += originalChars[i];
        if ((i + 1) % options.groupSize === 0 && (i + 1) < originalChars.length) {
            groupedString += options.separator;
        }
    }
    displayValue = groupedString;
  }

  accountNumberLogger.debug("Account number formatted for display.", {
    originalPrefix: sanitizedAccNum.substring(0, 5),
    display: displayValue.substring(0, 10) + '...', // Log partial for security
    policyId: activePolicy.id,
    revealAll: options?.revealAll,
  });
  return displayValue;
}

/**
 * Performs a comprehensive validation of an account number, combining static rule-based
 * checks with dynamic, AI-powered insights for enhanced accuracy and fraud detection.
 * @param {AccountNumberExtendedDetail} accountDetail The extended account detail object to validate.
 * @param {boolean} [useAIFallback=true] Whether to engage AI for additional insights and validation.
 * @returns {Promise<AccountValidationResult[]>} A promise resolving to an array of detailed validation results.
 * @export
 */
export async function validateAccountNumberIntegrity(
  accountDetail: AccountNumberExtendedDetail,
  useAIFallback: boolean = true,
): Promise<AccountValidationResult[]> {
  const results: AccountValidationResult[] = [];
  const sanitizedAccNum = sanitizeAccountNumber(accountDetail.accountNumber);
  const currentValidationTimestamp = new Date();

  accountNumberLogger.info("Starting comprehensive account number validation.", { id: accountDetail.id, type: accountDetail.accountNumberType, useAIFallback });

  if (!sanitizedAccNum) {
    results.push({
      type: AccountValidationType.Format,
      isValid: false,
      message: "Account number cannot be empty or null.",
      severity: ValidationSeverity.Critical,
      timestamp: currentValidationTimestamp,
    });
    return results;
  }

  // --- 1. Basic Format and Checksum Checks (Rule-based) ---
  let isBasicFormatAndChecksumValid = true;
  switch (accountDetail.accountNumberType) {
    case AccountNumberTypeEnum.Iban: {
      const formatValid = AccountNumberRegex.IBAN.test(sanitizedAccNum);
      results.push({
        type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "IBAN format correct." : "IBAN format mismatch.",
        severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp,
      });
      const checksumValid = validateIbanChecksum(sanitizedAccNum);
      results.push({
        type: AccountValidationType.Checksum, isValid: checksumValid, message: checksumValid ? "IBAN checksum (MOD 97-10) passed." : "IBAN checksum (MOD 97-10) failed.",
        severity: checksumValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp,
      });
      if (!formatValid || !checksumValid) isBasicFormatAndChecksumValid = false;
      break;
    }
    case AccountNumberTypeEnum.Clabe: {
      const formatValid = AccountNumberRegex.CLABE.test(sanitizedAccNum);
      results.push({
        type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "CLABE format correct." : "CLABE format mismatch (expected 18 digits).",
        severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp,
      });
      const checksumValid = validateClabeChecksum(sanitizedAccNum);
      results.push({
        type: AccountValidationType.Checksum, isValid: checksumValid, message: checksumValid ? "CLABE checksum passed." : "CLABE checksum failed.",
        severity: checksumValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp,
      });
      if (!formatValid || !checksumValid) isBasicFormatAndChecksumValid = false;
      break;
    }
    case AccountNumberTypeEnum.WalletAddress: {
      const formatValid = AccountNumberRegex.WALLET_ADDRESS_GENERIC.test(sanitizedAccNum);
      results.push({
        type: AccountValidationType.Format, isValid: formatValid, message: formatValid ? "Wallet address format correct." : "Wallet address format mismatch.",
        severity: formatValid ? ValidationSeverity.Info : ValidationSeverity.Error, timestamp: currentValidationTimestamp,
      });
      if (!formatValid) isBasicFormatAndChecksumValid = false;
      break;
    }
    case AccountNumberTypeEnum.Other:
    default:
      // For 'Other' or undefined types, apply a general sanity check.
      if (sanitizedAccNum.length < 5) { // Arbitrary minimum length for "Other"
        isBasicFormatAndChecksumValid = false;
        results.push({
          type: AccountValidationType.Format,
          isValid: false,
          message: "Account number is too short for a generic type (min 5 characters recommended).",
          severity: ValidationSeverity.Warning,
          details: { minLength: 5 },
          timestamp: currentValidationTimestamp,
        });
      }
      if (!/^[A-Z0-9]*$/.test(sanitizedAccNum)) { // Only alphanumeric characters
          isBasicFormatAndChecksumValid = false;
          results.push({
              type: AccountValidationType.Format,
              isValid: false,
              message: "Generic account number contains invalid characters (only alphanumeric allowed).",
              severity: ValidationSeverity.Warning,
              timestamp: currentValidationTimestamp,
          });
      }
      break;
  }

  // --- 2. AI-powered Validation and Enrichment ---
  if (useAIFallback) {
    try {
      const aiAnalysisRequest: GeminiAccountNumberAnalysisRequest = {
        requestId: `validation-${accountDetail.id}-${Date.now()}`,
        accountNumber: accountDetail.accountNumber,
        accountNumberType: accountDetail.accountNumberType,
        countryCode: accountDetail.metadata?.countryCode,
        currencyCode: accountDetail.metadata?.currencyCode,
        context: {
          userId: "system-validation-service",
          transactionId: "N/A", // This might be dynamically set in a real scenario
          ipAddress: "N/A",
          deviceName: "backend-service",
          historicalDataSummary: `Status: ${accountDetail.status}, Source: ${accountDetail.dataSource}`,
        },
      };
      const aiResponse = await geminiAIClient.analyzeAccountNumber(aiAnalysisRequest);
      accountNumberLogger.debug("Received AI analysis response during validation.", { analysisId: aiResponse.analysisId, riskScore: aiResponse.riskAssessment.riskScore });

      // Aggregate AI's validation results.
      aiResponse.validationResults.forEach(aiResult => {
        // Only add AI results if they provide new information or a higher severity.
        const existingResult = results.find(r => r.type === aiResult.type);
        if (!existingResult || existingResult.severity < aiResult.severity || (existingResult.isValid !== aiResult.isValid)) {
            results.push(aiResult);
        }
        if (!aiResult.isValid && aiResult.severity >= ValidationSeverity.Error) {
            isBasicFormatAndChecksumValid = false; // Flag for overall validity check
        }
      });

      // Incorporate AI's predicted type (if confident and different).
      if (aiResponse.predictedType.confidence > 0.8 && aiResponse.predictedType.predictedValue !== accountDetail.accountNumberType) {
        results.push({
          type: AccountValidationType.AIPredictive,
          isValid: true, // It's valid, but potentially needs human review for type.
          message: `AI predicts type '${aiResponse.predictedType.predictedValue}' (confidence: ${Math.round(aiResponse.predictedType.confidence * 100)}%) which differs from declared type.`,
          severity: ValidationSeverity.Warning,
          details: { aiPrediction: aiResponse.predictedType },
          timestamp: currentValidationTimestamp,
        });
      } else if (aiResponse.predictedType.confidence < 0.6 && sanitizedAccNum.length > 5) {
          results.push({
              type: AccountValidationType.AIPredictive,
              isValid: false,
              message: `AI has low confidence (${Math.round(aiResponse.predictedType.confidence * 100)}%) in identifying account type. Manual review recommended.`,
              severity: ValidationSeverity.Warning,
              details: { aiPrediction: aiResponse.predictedType },
              timestamp: currentValidationTimestamp,
          });
          isBasicFormatAndChecksumValid = false; // Low confidence can imply an issue for 'Other' types.
      }

      // Incorporate AI risk assessment findings directly into validation results.
      if (aiResponse.riskAssessment.riskScore > 0) {
        const riskMessage = `AI Risk: ${aiResponse.riskAssessment.threatLevel} (Score: ${aiResponse.riskAssessment.riskScore}). Anomalies: ${aiResponse.riskAssessment.detectedAnomalies.join(', ') || 'None'}.`;
        results.push({
          type: AccountValidationType.AIPredictive, // Tagging risk assessment under predictive for now.
          isValid: aiResponse.riskAssessment.threatLevel === "Low", // Only low risk is considered "valid" in this context.
          message: riskMessage,
          severity: aiResponse.riskAssessment.threatLevel === "Critical" ? ValidationSeverity.Critical :
                    aiResponse.riskAssessment.threatLevel === "High" ? ValidationSeverity.Error :
                    aiResponse.riskAssessment.threatLevel === "Medium" ? ValidationSeverity.Warning :
                    ValidationSeverity.Info,
          details: { riskAssessment: aiResponse.riskAssessment },
          timestamp: currentValidationTimestamp,
        });
        if (aiResponse.riskAssessment.threatLevel !== "Low") {
            isBasicFormatAndChecksumValid = false;
        }
      }

    } catch (error) {
      accountNumberLogger.error("AI validation failed or encountered an error. Proceeding with rule-based checks only.", error, { accountId: accountDetail.id });
      results.push({
        type: AccountValidationType.AIPredictive,
        isValid: false,
        message: `AI validation service unavailable or failed: ${error instanceof Error ? error.message : String(error)}.`,
        severity: ValidationSeverity.Warning, // Mark as warning as rule-based checks might still pass.
        timestamp: currentValidationTimestamp,
      });
    }
  }

  // --- 3. Cross-reference/Business Rule Checks (Simulated) ---
  // In a real application, these would involve querying databases, external blacklists, or other services.
  if (sanitizedAccNum === "999999999999999999" || sanitizedAccNum.includes("BLACKLISTED")) {
      results.push({
          type: AccountValidationType.CrossReference,
          isValid: false,
          message: "Account number is explicitly blacklisted by internal policy.",
          severity: ValidationSeverity.Critical,
          timestamp: currentValidationTimestamp,
      });
      isBasicFormatAndChecksumValid = false;
  }
  // Simulate checking if the account is already linked to too many users (a common fraud indicator).
  if (Math.random() < 0.03 && !accountDetail.metadata?.isManuallyApproved) { // 3% chance for new accounts
      results.push({
          type: AccountValidationType.CrossReference,
          isValid: false,
          message: "Account number is suspected of being linked to an unusually high number of users or entities.",
          severity: ValidationSeverity.Error,
          details: { linkedEntitiesCount: Math.floor(Math.random() * 15) + 5 },
          timestamp: currentValidationTimestamp,
      });
      isBasicFormatAndChecksumValid = false;
  }

  // Final overall validity check.
  if (results.every(r => r.isValid) && isBasicFormatAndChecksumValid) {
      results.push({
          type: AccountValidationType.AIPredictive, // Or a new type like Overall
          isValid: true,
          message: "All validation checks passed, account number appears valid and secure.",
          severity: ValidationSeverity.Info,
          timestamp: currentValidationTimestamp,
      });
  }


  accountNumberLogger.info(`Validation complete for account ${accountDetail.id}. Found ${results.filter(r => !r.isValid).length} invalid results.`, {
    resultsSummary: results.map(r => ({ type: r.type, isValid: r.isValid, severity: r.severity })),
  });
  return results;
}

/**
 * Enriches account number details using AI predictions and other data sources.
 * This can update metadata like country code, bank identifier, or even suggest a more precise
 * account type if the current one is generic. It helps in building a richer data profile.
 * @param {AccountNumberExtendedDetail} accountDetail The account detail to enrich.
 * @returns {Promise<AccountNumberExtendedDetail>} A promise resolving to the enriched account detail.
 * @export
 */
export async function enrichAccountDetailsWithAI(accountDetail: AccountNumberExtendedDetail): Promise<AccountNumberExtendedDetail> {
  accountNumberLogger.info("Attempting to enrich account details with AI.", { id: accountDetail.id, currentType: accountDetail.accountNumberType });
  const updatedDetail = { ...accountDetail };
  updatedDetail.metadata = { ...updatedDetail.metadata }; // Ensure metadata object exists and is mutable

  try {
    const aiAnalysisRequest: GeminiAccountNumberAnalysisRequest = {
      requestId: `enrich-${accountDetail.id}-${Date.now()}`,
      accountNumber: accountDetail.accountNumber,
      accountNumberType: accountDetail.accountNumberType,
      countryCode: accountDetail.metadata?.countryCode,
      currencyCode: accountDetail.metadata?.currencyCode,
    };
    const aiResponse = await geminiAIClient.analyzeAccountNumber(aiAnalysisRequest);
    accountNumberLogger.debug("Received AI analysis response for enrichment.", { analysisId: aiResponse.analysisId });

    // Store AI analysis history, appending the latest response.
    updatedDetail.metadata.aiAnalysisHistory = [...(updatedDetail.metadata.aiAnalysisHistory || []), aiResponse];
    updatedDetail.metadata.lastAIRiskScore = aiResponse.riskAssessment.riskScore;

    // Update predicted type if AI has high confidence and it's currently 'Other', null, or has lower confidence.
    if (aiResponse.predictedType.confidence > 0.8 &&
        (updatedDetail.accountNumberType === AccountNumberTypeEnum.Other || updatedDetail.accountNumberType === null ||
         (updatedDetail.accountNumberType !== aiResponse.predictedType.predictedValue && aiResponse.predictedType.confidence > 0.95))) {
      updatedDetail.accountNumberType = aiResponse.predictedType.predictedValue as AccountNumberTypeEnum;
      accountNumberLogger.info(`AI predicted and updated account type to '${updatedDetail.accountNumberType}'.`, { id: accountDetail.id, confidence: aiResponse.predictedType.confidence });
    }

    // Update country code if AI suggests with high confidence and it's not already set.
    if (aiResponse.potentialCountry?.confidence > 0.8 && aiResponse.potentialCountry.predictedValue &&
        (!updatedDetail.metadata.countryCode || updatedDetail.metadata.countryCode === "UNKNOWN")) {
      updatedDetail.metadata.countryCode = aiResponse.potentialCountry.predictedValue;
      accountNumberLogger.info(`AI predicted and updated country code to '${updatedDetail.metadata.countryCode}'.`, { id: accountDetail.id, confidence: aiResponse.potentialCountry.confidence });
    }

    // Update bank identifier if AI suggests with high confidence.
    if (aiResponse.potentialBank?.confidence > 0.7 && aiResponse.potentialBank.predictedValue &&
        (!updatedDetail.metadata.bankIdentifier || updatedDetail.metadata.bankIdentifier === "Generic Financial Institution")) {
        updatedDetail.metadata.bankIdentifier = aiResponse.potentialBank.predictedValue;
        accountNumberLogger.info(`AI predicted and updated bank identifier to '${updatedDetail.metadata.bankIdentifier}'.`, { id: accountDetail.id, confidence: aiResponse.potentialBank.confidence });
    }

    // Potentially update description based on AI insights or risk level.
    if (aiResponse.riskAssessment.threatLevel !== "Low") {
        const riskDescription = `[AI Risk: ${aiResponse.riskAssessment.threatLevel}] ${aiResponse.riskAssessment.detectedAnomalies.join('; ') || 'No specific anomalies.'}`;
        if (!updatedDetail.metadata.description || !updatedDetail.metadata.description.includes("[AI Risk")) { // Avoid overwriting existing AI risk if already there
            updatedDetail.metadata.description = `${riskDescription} ${updatedDetail.metadata.description || ''}`.trim();
            accountNumberLogger.info(`Account description updated with AI risk information.`, { id: accountDetail.id, risk: aiResponse.riskAssessment.threatLevel });
        }
    }

    updatedDetail.lastUpdatedAt = new Date();
  } catch (error) {
    accountNumberLogger.error("Failed to enrich account details with AI. Returning original details.", error, { accountId: accountDetail.id });
    // In case of error, return the original detail or a partially updated one.
  }

  return updatedDetail;
}

/**
 * Provides an AI-driven security recommendation for a given account number.
 * This function specifically leverages the AI's risk assessment to generate actionable advice
 * for security personnel or end-users.
 * @param {AccountNumberExtendedDetail} accountDetail The account detail for which to get recommendations.
 * @returns {Promise<string[]>} A promise resolving to an array of relevant security recommendations.
 * @export
 */
export async function getSecurityRecommendationsForAccountNumber(accountDetail: AccountNumberExtendedDetail): Promise<string[]> {
  accountNumberLogger.info("Fetching AI-driven security recommendations.", { id: accountDetail.id });
  const recommendations: string[] = [];

  try {
    const aiAnalysisRequest: GeminiAccountNumberAnalysisRequest = {
      requestId: `recommendation-${accountDetail.id}-${Date.now()}`,
      accountNumber: accountDetail.accountNumber,
      accountNumberType: accountDetail.accountNumberType,
      context: { userId: "current-user-id", accountStatus: accountDetail.status, source: accountDetail.dataSource },
    };
    const riskAssessment = await geminiAIClient.detectFraudulentActivity(aiAnalysisRequest);

    if (riskAssessment.threatLevel === "Critical" || riskAssessment.threatLevel === "High") {
      recommendations.push("Immediate review required: This account number shows significant risk indicators.");
      recommendations.push(...riskAssessment.recommendations); // AI-specific recommendations
      recommendations.push(`Detected anomalies: ${riskAssessment.detectedAnomalies.join(', ')}.`);
      recommendations.push("Consider temporarily suspending or blocking transactions to this account.");
    } else if (riskAssessment.threatLevel === "Medium") {
      recommendations.push("Monitor transactions and activity for this account number closely for any suspicious patterns.");
      recommendations.push(...riskAssessment.recommendations);
      recommendations.push("Implement stricter approval workflows for payments to this account.");
    } else { // Low or Unknown
      recommendations.push("Account number appears secure based on current AI analysis. Continue standard procedures.");
    }

    // Add generic best practices, always relevant.
    recommendations.push("Always verify recipient details through an alternative, trusted communication channel before initiating any payment.");
    recommendations.push("Ensure multi-factor authentication (MFA) is enabled for all transactions and account access.");
    recommendations.push("Educate users about phishing and social engineering attacks targeting account details.");

  } catch (error) {
    accountNumberLogger.error("Failed to get AI security recommendations. Providing generic advice.", error, { accountId: accountDetail.id });
    recommendations.push("Could not retrieve AI security recommendations at this time. Please proceed with extreme caution and manual verification.");
    recommendations.push("Verify recipient details through an alternative, trusted communication channel.");
    recommendations.push("Report any suspicious activity or requests immediately.");
  }

  return recommendations;
}

/**
 * Generates dynamic properties for an interactive account number input field.
 * This leverages AI to offer real-time suggestions, predictive type inference,
 * and immediate validation feedback, enhancing the user experience.
 * @param {string} currentInput The current value typed into the input field.
 * @param {AccountNumberTypeEnum | null} [declaredType=null] The type the user or system explicitly believes it is.
 * @returns {Promise<{ value: string; placeholder: string; suggestions: string[]; validationMessage: string; validationSeverity: ValidationSeverity; predictedType?: AIPrediction<AccountNumberTypeEnum | "Unknown">; }>}
 * @export
 */
export async function getInteractiveAccountNumberInputProps(
  currentInput: string,
  declaredType: AccountNumberTypeEnum | null = null,
): Promise<{
  value: string;
  placeholder: string;
  suggestions: string[];
  validationMessage: string;
  validationSeverity: ValidationSeverity;
  predictedType?: AIPrediction<AccountNumberTypeEnum | "Unknown">;
  formattedInput?: string; // New field for AI-suggested formatting
}> {
  const sanitizedInput = sanitizeAccountNumber(currentInput);
  let validationMessage: string = "";
  let validationSeverity: ValidationSeverity = ValidationSeverity.Info;
  let suggestions: string[] = [];
  let predictedType: AIPrediction<AccountNumberTypeEnum | "Unknown"> | undefined;
  let formattedInput: string | undefined;

  const placeholderMap: Record<AccountNumberTypeEnum, string> = {
    [AccountNumberTypeEnum.Iban]: "e.g., GBXX XXXX XXXX XXXX XXXX XX",
    [AccountNumberTypeEnum.Clabe]: "e.g., 012345678901234567 (18 digits)",
    [AccountNumberTypeEnum.WalletAddress]: "e.g., 0xAbCdEf...Z01234567890 (long hex)",
    [AccountNumberTypeEnum.Other]: "Enter account number or identifier (e.g., US Bank Account)",
  };

  // Determine initial placeholder based on declared type or generic default.
  const currentPlaceholder = declaredType ? placeholderMap[declaredType] : placeholderMap[AccountNumberTypeEnum.Other];

  if (sanitizedInput.length === 0) {
    return {
      value: currentInput,
      placeholder: currentPlaceholder,
      suggestions: [],
      validationMessage: "Please enter an account number to begin validation.",
      validationSeverity: ValidationSeverity.Info,
    };
  }

  try {
    // Perform AI-driven type inference and preliminary comprehensive analysis.
    const aiAnalysisRequest: GeminiAccountNumberAnalysisRequest = {
      requestId: `input-props-${Date.now()}`,
      accountNumber: sanitizedInput,
      accountNumberType: declaredType,
      context: { uiInteraction: true, inputLength: sanitizedInput.length },
    };
    const aiResponse = await geminiAIClient.analyzeAccountNumber(aiAnalysisRequest);
    predictedType = aiResponse.predictedType;

    // Aggregate AI's validation messages.
    const errors = aiResponse.validationResults.filter(r => r.isValid === false);
    if (errors.length > 0) {
      // Find the highest severity among errors.
      validationSeverity = errors.reduce((maxSeverity, current) => {
        const severityOrder = [ValidationSeverity.Info, ValidationSeverity.Warning, ValidationSeverity.Error, ValidationSeverity.Critical];
        return severityOrder.indexOf(current.severity) > severityOrder.indexOf(maxSeverity) ? current.severity : maxSeverity;
      }, ValidationSeverity.Info);
      validationMessage = errors.map(e => e.message).join('; ');
    } else {
      validationMessage = "Looks valid so far!";
      validationSeverity = ValidationSeverity.Info;
    }

    // Add AI risk assessment to the message if notable.
    if (aiResponse.riskAssessment.threatLevel !== "Low") {
        validationMessage += `; AI Risk: ${aiResponse.riskAssessment.threatLevel}.`;
        // Elevate severity if AI risk is high and not already critical.
        if (aiResponse.riskAssessment.threatLevel === "Critical" && validationSeverity < ValidationSeverity.Critical) {
            validationSeverity = ValidationSeverity.Critical;
        } else if (aiResponse.riskAssessment.threatLevel === "High" && validationSeverity < ValidationSeverity.Error) {
            validationSeverity = ValidationSeverity.Error;
        } else if (aiResponse.riskAssessment.threatLevel === "Medium" && validationSeverity < ValidationSeverity.Warning) {
            validationSeverity = ValidationSeverity.Warning;
        }
    }

    // AI-driven suggestions: auto-correct common typos, suggest next characters, or complete patterns.
    if (predictedType.confidence > 0.7) {
        if (predictedType.predictedValue === AccountNumberTypeEnum.Iban) {
            if (sanitizedInput.length === 0) suggestions.push("DE", "GB", "FR");
            else if (sanitizedInput.length === 2 && !sanitizedInput.match(/^[A-Z]{2}$/)) suggestions.push(sanitizedInput.toUpperCase()); // Suggest uppercase for country code
            else if (sanitizedInput.length > 2 && sanitizedInput.length < 10) {
                // Simulate AI suggesting a common prefix or completing partials.
                if (sanitizedInput.startsWith("DE8")) suggestions.push("DE89...");
                else if (sanitizedInput.startsWith("GB3")) suggestions.push("GB33...");
            }
        } else if (predictedType.predictedValue === AccountNumberTypeEnum.WalletAddress && sanitizedInput.length < 5 && !sanitizedInput.startsWith("0x")) {
            suggestions.push(`0x${sanitizedInput}`); // Suggest adding "0x" prefix.
        }
        // AI could also suggest ideal grouping based on the predicted type.
        formattedInput = formatAccountNumberForDisplay(currentInput, {
            useAIDisplayOptimization: true,
            groupSize: predictedType.predictedValue === AccountNumberTypeEnum.Iban ? 4 : undefined,
            separator: predictedType.predictedValue === AccountNumberTypeEnum.Iban ? " " : undefined,
        }, predictedType.predictedValue);

    } else if (sanitizedInput.length > 0 && predictedType.confidence < 0.5) {
        suggestions.push("Cannot confidently determine type. Try specifying manually or re-check input.");
    }
  } catch (error) {
    accountNumberLogger.error("Error during AI-enhanced input props generation.", error, { currentInput: currentInput.substring(0, 10) + '...' });
    validationMessage = `Validation service unavailable: ${error instanceof Error ? error.message : String(error)}. Please try again later.`;
    validationSeverity = ValidationSeverity.Warning;
  }

  return {
    value: currentInput, // Return original value for the input field.
    placeholder: currentPlaceholder,
    suggestions,
    validationMessage,
    validationSeverity,
    predictedType,
    formattedInput: formattedInput || currentInput, // Provide AI-suggested formatted input for preview/display.
  };
}

/**
 * Represents the comprehensive data structure for managing an account number throughout its lifecycle.
 * This class encapsulates the account number details and provides robust methods to interact
 * with AI and validation services, ensuring commercial-grade data integrity and security.
 * @export
 * @class AccountNumberEntity
 */
export class AccountNumberEntity {
    public id: string;
    private _accountNumber: string; // Private to control access and ensure validation/masking
    public accountNumberType: AccountNumberTypeEnum | null;
    public parentAccountType?: string;
    public status: AccountNumberStatus;
    public dataSource: AccountDataSource;
    public createdAt: Date;
    public lastUpdatedAt: Date;
    public metadata: {
        countryCode?: string;
        currencyCode?: string;
        bankIdentifier?: string;
        description?: string;
        aiAnalysisHistory?: GeminiAccountNumberAnalysisResponse[]; // Store historical AI analysis
        isManuallyApproved?: boolean;
        lastApprovedBy?: string;
        lastApprovedAt?: Date;
    };

    /**
     * Creates an instance of AccountNumberEntity.
     * Initializes the entity with provided details, sanitizing the account number and
     * ensuring proper metadata setup.
     * @param {AccountNumberExtendedDetail} initialDetails The initial details for the account number.
     * @memberof AccountNumberEntity
     */
    constructor(initialDetails: AccountNumberExtendedDetail) {
        this.id = initialDetails.id;
        this._accountNumber = sanitizeAccountNumber(initialDetails.accountNumber);
        this.accountNumberType = initialDetails.accountNumberType;
        this.parentAccountType = initialDetails.parentAccountType;
        this.status = initialDetails.status;
        this.dataSource = initialDetails.dataSource;
        this.createdAt = initialDetails.createdAt;
        this.lastUpdatedAt = initialDetails.lastUpdatedAt;
        this.metadata = {
            ...initialDetails.metadata,
            aiAnalysisHistory: initialDetails.metadata?.aiAnalysisHistory || [],
        };
        accountNumberLogger.debug(`AccountNumberEntity created for ID: ${this.id}. Initial status: ${this.status}.`);
    }

    /**
     * Gets the full, unsanitized account number. Access to this property should be
     * restricted and audited due to its sensitive nature.
     * @readonly
     * @memberof AccountNumberEntity
     * @returns {string} The full, raw account number.
     */
    public get fullAccountNumber(): string {
        accountNumberLogger.warn(`Accessing full account number for ID: ${this.id}. Ensure proper authorization and logging.`);
        // In a real system, this getter might trigger an audit log event or require specific permissions.
        return this._accountNumber;
    }

    /**
     * Sets a new account number for the entity. The new number is automatically sanitized,
     * and the `lastUpdatedAt` timestamp is updated.
     * @param {string} newAccountNumber The new account number string.
     * @memberof AccountNumberEntity
     */
    public setAccountNumber(newAccountNumber: string): void {
        const oldPrefix = this._accountNumber.substring(0, 5);
        this._accountNumber = sanitizeAccountNumber(newAccountNumber);
        this.lastUpdatedAt = new Date();
        accountNumberLogger.info(`Account number for ID: ${this.id} updated.`, { oldPrefix, newPrefix: this._accountNumber.substring(0, 5), changedBy: "system" });
        // After an account number changes, it might require re-validation and re-enrichment.
        this.status = AccountNumberStatus.PendingVerification;
    }

    /**
     * Returns the account number formatted for display, applying appropriate masking
     * and optional grouping based on the provided options.
     * @param {DisplayFormattingOptions} [options] Display formatting options.
     * @returns {string} The formatted and masked account number.
     * @memberof AccountNumberEntity
     */
    public getFormattedAccountNumber(options?: DisplayFormattingOptions): string {
        return formatAccountNumberForDisplay(this._accountNumber, options, this.accountNumberType);
    }

    /**
     * Performs a comprehensive validation on this account number entity,
     * leveraging both rule-based checks and AI insights. It also updates the entity's
     * status based on the severity of validation findings, particularly AI-detected fraud risks.
     * @returns {Promise<AccountValidationResult[]>} A promise resolving to an array of validation results.
     * @memberof AccountNumberEntity
     */
    public async validate(): Promise<AccountValidationResult[]> {
        accountNumberLogger.info(`Initiating validation for AccountNumberEntity ID: ${this.id}. Current status: ${this.status}.`);
        const results = await validateAccountNumberIntegrity(this.toExtendedDetail(), true); // Use current entity state

        let hasCriticalErrors = false;
        let hasFraudRisk = false;

        for (const result of results) {
            if (!result.isValid && result.severity === ValidationSeverity.Critical) {
                hasCriticalErrors = true;
            }
            if (result.type === AccountValidationType.AIPredictive && result.details?.riskAssessment?.threatLevel === "Critical") {
                hasFraudRisk = true;
            }
        }

        if (hasFraudRisk && this.status !== AccountNumberStatus.Fraudulent) {
            this.status = AccountNumberStatus.Fraudulent;
            accountNumberLogger.critical(`AccountNumberEntity ID: ${this.id} status forcefully set to FRAUDULENT due to AI-detected critical risk.`, null, { results });
        } else if (hasCriticalErrors && this.status !== AccountNumberStatus.Fraudulent && this.status !== AccountNumberStatus.Suspended) {
            this.status = AccountNumberStatus.Suspended;
            accountNumberLogger.error(`AccountNumberEntity ID: ${this.id} status changed to SUSPENDED due to critical validation errors.`, null, { results });
        } else if (!hasCriticalErrors && !hasFraudRisk && this.status !== AccountNumberStatus.Active && this.status !== AccountNumberStatus.Deactivated && this.status !== AccountNumberStatus.Expired) {
            // If all critical issues are resolved and not in a terminal state, set to active or pending.
            this.status = AccountNumberStatus.Active; // Or PENDING if further manual checks are needed
            accountNumberLogger.info(`AccountNumberEntity ID: ${this.id} status restored to ACTIVE as all critical validation issues are resolved.`);
        }

        this.lastUpdatedAt = new Date(); // Reflect that validation occurred.
        return results;
    }

    /**
     * Enriches the account details of this entity using AI predictions.
     * It updates the entity's `accountNumberType`, `metadata` (country code, bank ID, description),
     * and stores the AI analysis history.
     * @returns {Promise<AccountNumberEntity>} The enriched entity instance.
     * @memberof AccountNumberEntity
     */
    public async enrichWithAI(): Promise<AccountNumberEntity> {
        accountNumberLogger.info(`Initiating AI enrichment for AccountNumberEntity ID: ${this.id}.`);
        const currentDetails = this.toExtendedDetail();
        const enrichedDetails = await enrichAccountDetailsWithAI(currentDetails);

        // Apply updates from enrichment back to the entity.
        this.accountNumberType = enrichedDetails.accountNumberType;
        this.metadata = { ...this.metadata, ...enrichedDetails.metadata }; // Merge metadata properties
        this.lastUpdatedAt = new Date();
        accountNumberLogger.debug(`AccountNumberEntity ID: ${this.id} enriched.`, { newType: this.accountNumberType, newCountry: this.metadata.countryCode, lastAIRisk: this.metadata.lastAIRiskScore });
        return this;
    }

    /**
     * Calls the Gemini AI service for a full, comprehensive analysis of the account number
     * and stores the resulting response in the entity's `aiAnalysisHistory`.
     * This method is useful for proactive monitoring or deep-dive investigations.
     * @returns {Promise<GeminiAccountNumberAnalysisResponse>} The AI analysis response.
     * @memberof AccountNumberEntity
     */
    public async performAIAnalysis(): Promise<GeminiAccountNumberAnalysisResponse> {
        accountNumberLogger.info(`Performing full AI analysis for AccountNumberEntity ID: ${this.id}.`);
        const aiAnalysisRequest: GeminiAccountNumberAnalysisRequest = {
            requestId: `entity-analysis-${this.id}-${Date.now()}`,
            accountNumber: this._accountNumber,
            accountNumberType: this.accountNumberType,
            countryCode: this.metadata.countryCode,
            currencyCode: this.metadata.currencyCode,
            context: {
                userId: "system-auto-analysis",
                historicalDataSummary: `Status: ${this.status}, Created: ${this.createdAt.toISOString()}`,
                entityLastUpdated: this.lastUpdatedAt.toISOString(),
            },
        };

        const response = await geminiAIClient.analyzeAccountNumber(aiAnalysisRequest);
        // Ensure aiAnalysisHistory is initialized before pushing.
        this.metadata.aiAnalysisHistory = [...(this.metadata.aiAnalysisHistory || []), response];
        this.metadata.lastAIRiskScore = response.riskAssessment.riskScore; // Update latest risk score.
        this.lastUpdatedAt = new Date(); // Reflect that AI data has been processed.
        accountNumberLogger.debug(`AI analysis stored for AccountNumberEntity ID: ${this.id}. Analysis ID: ${response.analysisId}.`);
        return response;
    }

    /**
     * Approves the account number manually, updating its status and metadata.
     * This is a critical workflow for overriding AI warnings or initial "PendingVerification" states.
     * @param {string} approvedByUserId The ID of the user who approved the account.
     * @returns {void}
     * @memberof AccountNumberEntity
     */
    public manuallyApprove(approvedByUserId: string): void {
        this.status = AccountNumberStatus.Active;
        this.metadata.isManuallyApproved = true;
        this.metadata.lastApprovedBy = approvedByUserId;
        this.metadata.lastApprovedAt = new Date();
        this.lastUpdatedAt = new Date();
        accountNumberLogger.info(`AccountNumberEntity ID: ${this.id} manually approved by ${approvedByUserId}. Status set to ACTIVE.`);
    }

    /**
     * Suspends the account number, updating its status.
     * @param {string} reason The reason for suspension.
     * @param {string} [userId] The user ID initiating the suspension.
     * @returns {void}
     * @memberof AccountNumberEntity
     */
    public suspend(reason: string, userId?: string): void {
        if (this.status === AccountNumberStatus.Deactivated || this.status === AccountNumberStatus.Fraudulent) {
            accountNumberLogger.warn(`Attempted to suspend a ${this.status} account ${this.id}. Operation ignored.`, { reason, userId });
            return;
        }
        this.status = AccountNumberStatus.Suspended;
        this.lastUpdatedAt = new Date();
        this.metadata.description = `Suspended: ${reason} [By: ${userId || 'System'}] - ${this.metadata.description || ''}`;
        accountNumberLogger.warn(`AccountNumberEntity ID: ${this.id} suspended by ${userId || 'System'}. Reason: ${reason}.`);
    }

    /**
     * Deactivates the account number, updating its status to a terminal state.
     * @param {string} reason The reason for deactivation.
     * @param {string} [userId] The user ID initiating the deactivation.
     * @returns {void}
     * @memberof AccountNumberEntity
     */
    public deactivate(reason: string, userId?: string): void {
        if (this.status === AccountNumberStatus.Fraudulent) {
            accountNumberLogger.warn(`Attempted to deactivate a FRAUDULENT account ${this.id}. Operation ignored, status remains FRAUDULENT.`, { reason, userId });
            return;
        }
        this.status = AccountNumberStatus.Deactivated;
        this.lastUpdatedAt = new Date();
        this.metadata.description = `Deactivated: ${reason} [By: ${userId || 'System'}] - ${this.metadata.description || ''}`;
        accountNumberLogger.info(`AccountNumberEntity ID: ${this.id} deactivated by ${userId || 'System'}. Reason: ${reason}.`);
    }


    /**
     * Converts the current entity state into an `AccountNumberExtendedDetail` interface object.
     * This is useful for exposing a serializable, immutable representation of the entity's data
     * for API responses, data storage, or passing to pure functions.
     * @returns {AccountNumberExtendedDetail} A plain object representation of the account number's details.
     * @memberof AccountNumberEntity
     */
    public toExtendedDetail(): AccountNumberExtendedDetail {
        return {
            id: this.id,
            accountNumber: this._accountNumber,
            accountNumberType: this.accountNumberType,
            parentAccountType: this.parentAccountType,
            status: this.status,
            dataSource: this.dataSource,
            createdAt: this.createdAt,
            lastUpdatedAt: this.lastUpdatedAt,
            metadata: { ...this.metadata }, // Deep copy metadata to ensure immutability of the returned object.
        };
    }
}

/**
 * Factory function to create a new `AccountNumberEntity` instance from minimal details,
 * inferring sensible defaults for other properties. This promotes consistent entity creation.
 * @param {string} id Unique identifier for the account number record.
 * @param {string} accountNumber The raw account number string.
 * @param {AccountNumberTypeEnum | null} [type=null] The explicit type of the account number, if known.
 * @param {AccountDataSource} [dataSource=AccountDataSource.UserProvided] The source of this account number data.
 * @returns {AccountNumberEntity} A newly created `AccountNumberEntity` instance.
 * @export
 */
export function createAccountNumberEntity(
  id: string,
  accountNumber: string,
  type: AccountNumberTypeEnum | null = null,
  dataSource: AccountDataSource = AccountDataSource.UserProvided,
): AccountNumberEntity {
  const now = new Date();
  return new AccountNumberEntity({
    id,
    accountNumber,
    accountNumberType: type,
    status: AccountNumberStatus.PendingVerification, // Default initial status, awaiting validation.
    dataSource,
    createdAt: now,
    lastUpdatedAt: now,
    metadata: {}, // Initialize metadata as an empty object.
  });
}
```