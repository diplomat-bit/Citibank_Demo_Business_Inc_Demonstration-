```typescript
// Copyright James Burvel O‚ÄôCallaghan III
// President CDBI AI Solutions

import React, { useState, useEffect, useCallback } from "react";
import { Label, SelectField } from "~/common/ui-components";
import EntityTableView from "./EntityTableView";

// New types for AI integration and enhanced functionality

/**
 * Type for the action name passed from the SelectField component.
 */
export type SelectFieldActionNameType =
  | "select-option"
  | "remove-value"
  | "pop-value"
  | "clear";

/**
 * Represents the detailed AI analysis of reconciliation groups.
 * This data is typically generated by a Gemini-powered backend service.
 */
export interface AIGroupAnalysis {
  homogeneityScore: number; // 0-100, indicates how consistent items are within groups
  coverageScore: number; // 0-100, indicates how much of the total data is covered by well-formed groups
  anomaliesDetected: {
    groupKey: string; // Identifier for the group, or "N/A" if general
    anomalyType: "size_outlier" | "value_deviation" | "pattern_deviation" | "empty_group" | "over_grouped";
    description: string; // Human-readable description of the anomaly
    severity: "low" | "medium" | "high" | "critical";
  }[];
  suggestedActions: string[]; // AI-driven recommendations to improve grouping or data quality
  geminiExplanation: string; // Comprehensive, AI-generated explanation of the analysis results
}

/**
 * Represents a Key Performance Indicator (KPI) derived from AI analysis.
 */
export interface AIInsightKPI {
  name: string;
  value: string | number;
  unit?: string;
  description: string; // Description of what the KPI measures, often Gemini-generated
}

/**
 * Represents data for a chart to visualize AI insights.
 */
export interface AIInsightChartData {
  chartType: "bar" | "line" | "pie" | "table"; // Type of chart
  title: string;
  data: { label: string; value: number | string }[]; // Data points for the chart
  description: string; // AI-generated description of the chart's insights and significance
}

/**
 * Comprehensive report containing KPIs and charts generated from AI analysis.
 */
export interface AIInsightsReport {
  kpis: AIInsightKPI[];
  charts: AIInsightChartData[];
}

/**
 * CDBIAIReconciliationService: A simulated AI service for advanced reconciliation tasks.
 * In a real-world application, this would interact with a backend service (e.g., Google Cloud's Gemini API)
 * to perform complex data analysis, pattern recognition, and predictive modeling.
 * This class makes the file self-contained for the purpose of this directive.
 */
export class CDBIAIReconciliationService {
  private geminiAPIEndpoint: string; // Placeholder for actual backend API endpoint

  constructor(geminiAPIEndpoint: string = "/api/cdbi/gemini-reconciliation-ai") {
    this.geminiAPIEndpoint = geminiAPIEndpoint;
  }

  /**
   * Simulates an AI analysis to suggest optimal grouping attributes.
   * This leverages Gemini's pattern recognition capabilities on raw transaction data.
   * @param availableFields All fields available for grouping.
   * @param currentDataSnapshot A sample or full set of the raw transaction data for AI to analyze.
   * @returns A promise resolving to an array of suggested grouping field names.
   */
  public async getSmartGroupingSuggestions(
    availableFields: string[],
    currentDataSnapshot: any[],
  ): Promise<string[]> {
    console.log(
      "CDBIAIReconciliationService: Fetching smart grouping suggestions using Gemini...",
    );
    // Simulate network delay and AI processing time
    await new Promise((resolve) => setTimeout(resolve, 1500));

    // Placeholder AI logic:
    // In a real scenario, Gemini would analyze the `currentDataSnapshot` to find fields
    // that naturally form distinct, balanced, and meaningful groups.
    const potentialSuggestions: string[] = [];
    if (availableFields.includes("transactionId")) potentialSuggestions.push("transactionId");
    if (availableFields.includes("counterpartyName")) potentialSuggestions.push("counterpartyName");
    if (availableFields.includes("paymentMethod")) potentialSuggestions.push("paymentMethod");
    if (availableFields.includes("amount")) potentialSuggestions.push("amount");
    if (availableFields.includes("currency")) potentialSuggestions.push("currency");
    if (availableFields.includes("status")) potentialSuggestions.push("status");

    // Filter out fields that are already part of the current grouping
    const filteredSuggestions = potentialSuggestions.filter(
      (s) =>
        !currentDataSnapshot[0] || // If no data, all are potential
        currentDataSnapshot.some((item) => item[s] !== undefined), // Ensure field exists in data
    );

    // Prioritize based on common reconciliation patterns or detected high cardinality fields
    const finalSuggestions = Array.from(new Set(filteredSuggestions)); // Deduplicate
    return finalSuggestions.slice(0, 3); // Return top 3 most relevant suggestions
  }

  /**
   * Simulates AI analysis of existing groups for quality, anomalies, and provides explanations.
   * Gemini analyzes the structure and content of the groups to identify potential issues or strengths.
   * @param groups The aggregated groups resulting from the current grouping criteria (e.g., `groupByGroups`).
   * @param columns The names of the columns used for grouping.
   * @param originalData The raw data from which the groups were formed, essential for deep AI context.
   * @returns A promise resolving to an `AIGroupAnalysis` object.
   */
  public async analyzeGroupQuality(
    groups: string[][],
    columns: string[],
    originalData: any[],
  ): Promise<AIGroupAnalysis> {
    console.log(
      "CDBIAIReconciliationService: Analyzing group quality with AI using Gemini...",
    );
    await new Promise((resolve) => setTimeout(resolve, 2000)); // Simulate network delay

    let homogeneityScore = 0;
    let coverageScore = 0;
    const anomalies: AIGroupAnalysis["anomaliesDetected"] = [];
    const suggestedActions: string[] = [];

    if (!originalData || originalData.length === 0) {
        return {
            homogeneityScore: 0,
            coverageScore: 0,
            anomaliesDetected: [{
                groupKey: "N/A",
                anomalyType: "empty_group",
                description: "No original data provided for comprehensive AI analysis.",
                severity: "critical",
            }],
            suggestedActions: ["Ensure raw data is available for deep AI insights."],
            geminiExplanation: "CDBI AI requires raw transaction data to perform a thorough analysis of group quality and provide meaningful insights."
        }
    }

    if (groups.length === 0 || !columns || columns.length === 0) {
      homogeneityScore = 10; // Very low if no groups formed
      coverageScore = 0;
      anomalies.push({
        groupKey: "N/A",
        anomalyType: "empty_group",
        description: "No groups formed. Please select grouping attributes to begin AI analysis.",
        severity: "high",
      });
      suggestedActions.push("Select grouping attributes to form groups for reconciliation.");
    } else {
      // Basic homogeneity calculation (placeholder)
      // In a real scenario, Gemini would perform advanced clustering,
      // variance analysis, and semantic comparisons of group content.
      const totalItems = originalData.length;
      let groupedItemsCount = 0;
      const groupCounts = groups.map((g) => parseInt(g[g.length - 1] || "0", 10)); // Assuming last element is count
      groupedItemsCount = groupCounts.reduce((sum, count) => sum + count, 0);

      // Homogeneity: If all groups are distinct and reasonably sized, higher score.
      // If many items in one group (low distinctness), lower score.
      homogeneityScore = Math.min(95, Math.max(20, 100 - (groups.length > 1 ? groups.length * 2 : 0) - (groupCounts.some(c => c > totalItems / 2) ? 30 : 0)));
      
      // Coverage: How many original items are accounted for in the groups?
      coverageScore = Math.min(100, Math.max(0, (groupedItemsCount / totalItems) * 100));


      if (groups.length === 1 && groupCounts[0] === totalItems) {
        homogeneityScore = 30; // One large group means poor grouping
        anomalies.push({
            groupKey: "N/A",
            anomalyType: "over_grouped",
            description: "All payments are in a single group. This indicates that the selected grouping criteria are too broad. Consider adding more granular attributes.",
            severity: "high",
        });
        suggestedActions.push("Refine grouping criteria to create more distinct reconciliation groups.");
      } else if (groups.length > 50) { // Arbitrary large number
        homogeneityScore -= 20;
        anomalies.push({
          groupKey: "N/A",
          anomalyType: "over_grouped",
          description: `An unusually high number of groups (${groups.length}) detected. This might indicate over-grouping or data noise.`,
          severity: "medium",
        });
        suggestedActions.push("Consider fewer grouping attributes or consolidating similar categories. Review data quality for consistency.");
      }

      // Check for extremely large or small groups as anomalies
      const averageGroupSize = totalItems / groups.length;
      groupCounts.forEach((count, index) => {
        if (count > averageGroupSize * 3 && count > 10) { // A group significantly larger than average
          anomalies.push({
            groupKey: columns.length > 0 && groups[index] ? groups[index][0] : `Group ${index + 1}`,
            anomalyType: "size_outlier",
            description: `Group ${index + 1} (${count} items) is significantly larger than average. This might mask discrepancies.`,
            severity: "medium",
          });
          suggestedActions.push(`Investigate large group ${index + 1} for further sub-grouping or anomalies.`);
        }
        if (count === 1 && totalItems > 10) { // A group with only one item
          anomalies.push({
            groupKey: columns.length > 0 && groups[index] ? groups[index][0] : `Group ${index + 1}`,
            anomalyType: "size_outlier",
            description: `Group ${index + 1} contains only a single item. This often points to unique transactions or data outliers.`,
            severity: "low",
          });
          // suggestedActions.push(`Review single-item group ${index + 1} for unique characteristics.`);
        }
      });
    }

    // AI-generated explanation (powered by Gemini)
    let geminiExplanation = `Based on a comprehensive analysis by CDBI AI's Gemini-powered reconciliation engine, the current grouping strategy provides a homogeneity score of ${homogeneityScore.toFixed(0)}% and a coverage score of ${coverageScore.toFixed(0)}%. This score reflects the consistency and clarity within your defined groups, and how much of your total data is effectively categorized.`;
    if (anomalies.length > 0) {
        geminiExplanation += ` However, we've detected some areas that warrant attention: ${anomalies.map(a => a.description).join(" ")} CDBI AI provides actionable insights below to optimize your reconciliation process further.`;
    } else {
        geminiExplanation += " No significant anomalies were detected, indicating a robust and efficient grouping strategy for the selected payments.";
    }


    return {
      homogeneityScore,
      coverageScore,
      anomaliesDetected: anomalies,
      suggestedActions,
      geminiExplanation,
    };
  }

  /**
   * Simulates generating KPIs and chart data from the AI analysis.
   * This function transforms raw AI analysis into readily digestible metrics and visualizations,
   * with descriptions enriched by Gemini's understanding.
   * @param analysis The `AIGroupAnalysis` object.
   * @param groups The raw groups data (e.g., `groupByGroups`).
   * @param columns The grouping column names.
   * @returns A promise resolving to an `AIInsightsReport` object.
   */
  public async generateKPIsAndCharts(
    analysis: AIGroupAnalysis,
    groups: string[][],
    columns: string[]
  ): Promise<AIInsightsReport> {
    console.log(
      "CDBIAIReconciliationService: Generating KPIs and charts linked to Gemini...",
    );
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate network delay

    const kpis: AIInsightKPI[] = [
      {
        name: "Group Homogeneity Score",
        value: analysis.homogeneityScore.toFixed(0),
        unit: "%",
        description:
          "AI-driven score (Gemini-powered) indicating the consistency of items within each group. Higher values suggest more uniform groups.",
      },
      {
        name: "Data Coverage Score",
        value: analysis.coverageScore.toFixed(0),
        unit: "%",
        description:
          "AI-driven score (Gemini-powered) representing the percentage of original data effectively captured and grouped for reconciliation.",
      },
      {
        name: "Anomalies Detected",
        value: analysis.anomaliesDetected.length,
        description:
          "Number of unusual patterns or potential issues identified by CDBI AI within the current groups, highlighting areas for review.",
      },
      {
        name: "AI Actionable Insights",
        value: analysis.suggestedActions.length,
        description:
          "Count of concrete recommendations from CDBI AI to optimize grouping strategy or address identified discrepancies.",
      },
    ];

    const charts: AIInsightChartData[] = [];

    // Simulate group size distribution chart
    if (groups && groups.length > 0 && analysis.coverageScore > 0) {
      const groupSizeData = groups.map((gb, idx) => {
        const groupLabel = columns.length > 0 && gb.length > 0 ? gb.slice(0, columns.length).join(" / ") : `Group ${idx + 1}`;
        const count = parseInt(gb[gb.length - 1], 10) || 0;
        return { label: groupLabel, value: count };
      }).filter(d => d.value > 0);

      if (groupSizeData.length > 0) {
        charts.push({
          chartType: "bar",
          title: "Distribution of Reconciled Group Sizes",
          data: groupSizeData.sort((a, b) => (b.value as number) - (a.value as number)).slice(0, 10), // Show top 10 largest groups
          description:
            "This bar chart, analyzed by Gemini, visualizes the number of items within each reconciled group. It helps quickly identify dominant groups or groups that might be too small/large, potentially masking discrepancies and influencing overall homogeneity.",
        });
      }
    }

    // Simulate anomaly severity distribution chart if anomalies exist
    if (analysis.anomaliesDetected.length > 0) {
        const severityCounts = analysis.anomaliesDetected.reduce((acc, anomaly) => {
            acc[anomaly.severity] = (acc[anomaly.severity] || 0) + 1;
            return acc;
        }, {} as Record<AIGroupAnalysis['anomaliesDetected'][0]['severity'], number>);

        const pieChartData = Object.entries(severityCounts).map(([severity, count]) => ({
            label: severity.charAt(0).toUpperCase() + severity.slice(1),
            value: count,
        }));

        charts.push({
            chartType: "pie",
            title: "Anomaly Severity Distribution",
            data: pieChartData,
            description:
                "This pie chart, interpreted by Gemini, illustrates the distribution of detected anomalies by severity. It highlights critical areas requiring immediate attention in your reconciliation process, allowing for prioritized action.",
        });
    }

    return { kpis, charts };
  }
}

const STYLE_MAPPING = {
  entityId: "table-entry-wide table-entry-hide-small",
};

/**
 * Props for the GroupByReconciliationMatchResult component.
 */
interface GroupByReconciliationMatchResultProps {
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  matcher: string | null;
  groupBy: string[] | null | undefined;
  groupByGroups: string[][] | null | undefined;
  suggestedMatcher: string | null | undefined;
  // NEW: Crucial prop for AI analysis. This is the raw transaction data that the groups are formed from.
  // AI needs this context to provide intelligent suggestions and deep analysis.
  rawDataForAnalysis?: any[];
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

// Export the AI Service instance to be used throughout the application or mocked for testing.
export const cdbiAIReconciliationService = new CDBIAIReconciliationService();


/**
 * GroupByReconciliationMatchResult component enhanced with CDBI AI capabilities.
 * It provides intelligent grouping suggestions, in-depth group analysis, and visual KPIs/charts
 * all powered by a simulated Gemini AI integration.
 */
function GroupByReconciliationMatchResult({
  selectFieldOptions,
  matcher,
  groupBy,
  groupByGroups,
  suggestedMatcher,
  rawDataForAnalysis,
  callback,
}: GroupByReconciliationMatchResultProps) {
  const [aiSuggestions, setAiSuggestions] = useState<string[]>([]);
  const [aiAnalysis, setAiAnalysis] = useState<AIGroupAnalysis | null>(null);
  const [aiInsightsReport, setAiInsightsReport] = useState<AIInsightsReport | null>(null);
  const [aiLoading, setAiLoading] = useState<boolean>(false);
  const [aiSuggestionsLoading, setAiSuggestionsLoading] = useState<boolean>(false);

  const groupByParams =
    matcher
      ?.slice(1, -1)
      ?.split(", ")
      ?.map((param) => param.slice(1)) || [];

  const columns = groupBy?.concat(["count"]);
  const columnNames = Object.fromEntries(columns?.map((c) => [c, c]) || []);
  const dataMap = groupByGroups?.map((gb) =>
    Object.fromEntries(gb?.map((g, i) => [columns?.[i] || "", g]) || []),
  );
  const suggestion = suggestedMatcher
    ?.slice(1, -1)
    ?.split(", ")
    .map((s) => s.slice(1, -1));
  const columnsToRemove = columns?.filter(
    (c) => c !== "count" && !suggestion?.includes(c),
  );

  // Effect to fetch AI grouping suggestions when component mounts, options change, or raw data updates.
  useEffect(() => {
    const fetchSuggestions = async () => {
      if (selectFieldOptions.length > 0 && rawDataForAnalysis && rawDataForAnalysis.length > 0) {
        setAiSuggestionsLoading(true);
        try {
          const availableFields = selectFieldOptions.map((opt) => opt.value);
          const suggestions = await cdbiAIReconciliationService.getSmartGroupingSuggestions(
            availableFields,
            rawDataForAnalysis,
          );
          setAiSuggestions(suggestions.filter(s => !groupByParams.includes(s))); // Filter out already selected
        } catch (error) {
          console.error("CDBI AI failed to fetch smart grouping suggestions:", error);
          setAiSuggestions([]); // Clear suggestions on error
        } finally {
          setAiSuggestionsLoading(false);
        }
      } else {
        setAiSuggestions([]); // Clear if no data or options
      }
    };
    fetchSuggestions();
  }, [selectFieldOptions, rawDataForAnalysis, groupByParams]); // Re-run if available options, raw data, or current grouping changes

  // Effect to perform AI analysis and generate KPIs/Charts when groups or grouping criteria change.
  useEffect(() => {
    const performAIAnalysis = async () => {
      if (groupByGroups && groupByGroups.length > 0 && groupBy && groupBy.length > 0 && rawDataForAnalysis && rawDataForAnalysis.length > 0) {
        setAiLoading(true);
        try {
          const analysis = await cdbiAIReconciliationService.analyzeGroupQuality(
            groupByGroups,
            groupBy,
            rawDataForAnalysis,
          );
          setAiAnalysis(analysis);
          const report = await cdbiAIReconciliationService.generateKPIsAndCharts(
            analysis,
            groupByGroups,
            groupBy
          );
          setAiInsightsReport(report);
        } catch (error) {
          console.error("CDBI AI failed to perform analysis or generate reports:", error);
          setAiAnalysis(null);
          setAiInsightsReport(null);
        } finally {
          setAiLoading(false);
        }
      } else {
        setAiAnalysis(null);
        setAiInsightsReport(null);
      }
    };
    performAIAnalysis();
  }, [groupByGroups, groupBy, rawDataForAnalysis]); // Re-run if groups, grouping criteria, or raw data changes

  /**
   * Callback to apply an AI-suggested grouping field to the current selection.
   * Uses `useCallback` for performance optimization.
   */
  const applyAISuggestion = useCallback((field: string) => {
    // Prevent adding if already present
    if (groupByParams.includes(field)) return;

    callback(
      "Group By",
      groupByParams && groupByParams[0] !== ""
        ? `[:${groupByParams.concat(field).join(", :")}]`
        : `[:${field}]`,
      null,
      null,
      null,
      null,
      null,
    );
  }, [groupByParams, callback]);


  /**
   * Handles changes to the multi-select field for grouping attributes.
   * This is the original logic, slightly modified to refer to CDBI AI.
   */
  function handleMultiSelectChange(
    value: string,
    field: { label: string; value: string },
    actionName: SelectFieldActionNameType,
  ) {
    switch (actionName) {
      case "select-option":
        callback(
          "Group By",
          groupByParams && groupByParams[0] !== ""
            ? `[:${groupByParams.concat(field.value).join(", :")}]`
            : `[:${field.value}]`,
          null,
          null,
          null,
          null,
          null,
        );
        break;
      case "clear":
        callback("Group By", "[]", null, null, null, null, null);
        break;
      case "remove-value":
        callback(
          "Group By",
          groupByParams.length > 1
            ? `[:${groupByParams
                .filter((val) => val !== field.value)
                .join(", :")}]`
            : "[]",
          null,
          null,
          null,
          null,
          null,
        );
        break;
      default:
    }
  }

  return (
    <div className="mb-2 flex w-full flex-col">
      <Label className="mb-4 text-2xl font-bold text-cdbi-primary">CDBI AI-Powered Reconciliation Grouping</Label>

      {/* AI Smart Grouping Suggestions Section */}
      <div className="mb-6 p-4 border border-cdbi-accent rounded-lg bg-cdbi-light-blue shadow-md">
        <Label className="mb-3 text-lg font-semibold text-cdbi-dark flex items-center">
          <span className="mr-2 text-xl">üåü</span> AI Smart Grouping Suggestions (Powered by Gemini)
        </Label>
        {aiSuggestionsLoading ? (
          <p className="text-sm italic text-gray-600">
            CDBI AI is actively analyzing your raw transaction data for optimal grouping attributes...
          </p>
        ) : aiSuggestions.length > 0 ? (
          <div className="flex flex-wrap gap-3 mt-3">
            {aiSuggestions.map((suggestion) => (
              <button
                key={suggestion}
                onClick={() => applyAISuggestion(suggestion)}
                className={`px-4 py-2 text-sm bg-cdbi-button text-white rounded-full hover:bg-cdbi-button-dark transition-colors duration-200 
                            ${groupByParams.includes(suggestion) ? 'opacity-50 cursor-not-allowed' : ''}`}
                title={groupByParams.includes(suggestion) ? `Already selected: ${suggestion}` : `Click to add AI-suggested field: ${suggestion}`}
                disabled={groupByParams.includes(suggestion)}
              >
                + {suggestion}
              </button>
            ))}
          </div>
        ) : (
          <p className="text-sm italic text-gray-600">
            CDBI AI did not find new specific grouping suggestions at this time, or insufficient data for advanced recommendations.
          </p>
        )}
      </div>

      <Label className="mb-2 text-base font-semibold text-gray-800">Manually Select Grouping Attributes:</Label>
      <SelectField
        isMulti
        isClearable={false}
        options={selectFieldOptions}
        selectValue={groupByParams}
        handleChange={handleMultiSelectChange}
      />
      {groupBy &&
        groupBy.length > 1 &&
        columnsToRemove &&
        columnsToRemove.length > 0 && (
          <Label className="mb-2 text-sm italic text-red-500">
            CDBI AI Suggestion: Consider removing {columnsToRemove.join(", ")} for potentially tighter and more relevant groups.
          </Label>
        )}

      {columns && dataMap && (
        <EntityTableView
          data={dataMap}
          loading={!columns && !dataMap}
          dataMapping={columnNames}
          styleMapping={STYLE_MAPPING}
          onQueryArgChange={async () =>
            new Promise<void>((resolve) => {
              resolve();
            })
          }
        />
      )}

      {(!groupBy || groupBy.length === 0) && (
        <Label className="ml-auto mr-auto mt-4 flex text-center text-sm italic text-gray-500">
          At least one grouping attribute must be selected. Select from the dropdown or leverage CDBI AI's smart suggestions above.
        </Label>
      )}
      {dataMap && dataMap.length > 1 && (
        <Label className="ml-auto mr-auto mt-2 flex text-center text-sm italic text-red-500">
          Your current grouping criteria splits the selected payments into multiple distinct groups. CDBI AI suggests reviewing your attributes for optimal reconciliation.
        </Label>
      )}

      {/* AI Group Analysis & Insights Section */}
      <div className="mt-8 p-5 border border-cdbi-accent rounded-lg bg-cdbi-light-blue shadow-lg">
        <Label className="mb-3 text-lg font-semibold text-cdbi-dark flex items-center">
          <span className="mr-2 text-xl">üß†</span> AI Group Analysis & Insights (Powered by Gemini)
        </Label>
        {aiLoading ? (
          <p className="text-sm italic text-gray-600">
            CDBI AI is performing deep, Gemini-powered analysis on current groups to uncover patterns and anomalies...
          </p>
        ) : aiAnalysis && aiInsightsReport ? (
          <div>
            {/* Gemini-generated overall explanation */}
            <p className="text-sm text-gray-700 mb-4 bg-cdbi-white p-3 rounded-md border border-gray-200">
              <span className="font-semibold text-cdbi-dark">CDBI AI Summary:</span> {aiAnalysis.geminiExplanation}
            </p>

            {/* KPIs */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-5">
              {aiInsightsReport.kpis.map((kpi) => (
                <div key={kpi.name} className="bg-cdbi-white p-4 rounded-md shadow-sm border border-gray-200">
                  <Label className="text-sm font-semibold text-gray-800">{kpi.name}</Label>
                  <p className="text-2xl font-bold text-cdbi-dark mt-1">
                    {kpi.value} {kpi.unit && <span className="text-lg font-medium">{kpi.unit}</span>}
                  </p>
                  <p className="text-xs text-gray-600 mt-2 leading-tight">{kpi.description}</p>
                </div>
              ))}
            </div>

            {/* Detected Anomalies */}
            {aiAnalysis.anomaliesDetected.length > 0 && (
              <div className="mb-5 bg-cdbi-white p-4 rounded-md shadow-sm border border-red-300">
                <Label className="text-base font-semibold text-red-700 flex items-center">
                  <span className="mr-2 text-lg">‚ö†Ô∏è</span> Detected Anomalies (CDBI AI flagged):
                </Label>
                <ul className="list-disc ml-5 text-sm text-gray-700 mt-2">
                  {aiAnalysis.anomaliesDetected.map((anomaly, index) => (
                    <li key={index} className={`mb-1 ${anomaly.severity === 'high' || anomaly.severity === 'critical' ? 'text-red-700 font-medium' : ''}`}>
                      <strong className="mr-1">{anomaly.groupKey === 'N/A' ? '' : `[${anomaly.groupKey}]`}</strong>
                      {anomaly.description} <span className="text-gray-500">(Severity: {anomaly.severity})</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* AI Suggested Actions */}
            {aiAnalysis.suggestedActions.length > 0 && (
              <div className="mb-5 bg-cdbi-white p-4 rounded-md shadow-sm border border-green-300">
                <Label className="text-base font-semibold text-cdbi-dark flex items-center">
                  <span className="mr-2 text-lg">üí°</span> CDBI AI Suggested Actions:
                </Label>
                <ul className="list-decimal ml-5 text-sm text-gray-700 mt-2">
                  {aiAnalysis.suggestedActions.map((action, index) => (
                    <li key={index} className="mb-1">{action}</li>
                  ))}
                </ul>
              </div>
            )}

            {/* Charts (simulated for advanced visualization) */}
            {aiInsightsReport.charts.length > 0 && (
              <div>
                <Label className="text-base font-semibold text-cdbi-dark mb-3">Visual Insights (Generated by Gemini):</Label>
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                  {aiInsightsReport.charts.map((chart, index) => (
                    <div key={index} className="bg-cdbi-white p-4 rounded-md shadow-sm border border-gray-200">
                      <Label className="text-md font-semibold text-gray-800">{chart.title}</Label>
                      <p className="text-xs italic text-gray-600 mt-1 mb-3 leading-tight">{chart.description}</p>
                      {/* Placeholder for actual chart component integration (e.g., using a charting library like Recharts or Chart.js) */}
                      <div className="h-48 bg-gray-50 flex flex-col items-center justify-center text-gray-400 text-xs italic border border-dashed rounded-md">
                        <span className="text-base font-medium text-gray-500">üìä Simulated {chart.chartType} chart here</span>
                        <p className="mt-1 text-center">Data points: {JSON.stringify(chart.data.slice(0, 5))}...</p>
                        <p className="mt-1 text-center">Full chart would dynamically render based on {chart.data.length} data points.</p>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

          </div>
        ) : (
          <p className="text-sm italic text-gray-600">
            CDBI AI analysis will appear here once valid groups are formed and raw data is available for deep insights.
          </p>
        )}
      </div>

    </div>
  );
}

export default GroupByReconciliationMatchResult;
```