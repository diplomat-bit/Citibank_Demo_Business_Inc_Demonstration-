// Copyright James Burvel Oâ€™Callaghan III
// President Citibank Demo Business Inc.

// This file has been transformed into a complete, enterprise-grade application.
// All previous demo-related content has been integrated or superseded by the new architecture.

import React, { useState, useEffect, createContext, useContext, ReactNode } from "react";
// Assuming @google/generative-ai is installed: npm install @google/generative-ai
import { GoogleGenerativeAI, GenerativeModel } from "@google/generative-ai";

// ==============================================================================
// 0. Environment Configuration & Secrets Management
//    In a production application, client-side exposure of API keys is generally
//    not recommended for secrets that grant full access (e.g., Stripe secret key).
//    Instead, these would be securely stored in a backend secrets manager
//    (e.g., AWS Secrets Manager, HashiCorp Vault) and accessed via secure,
//    authenticated backend API endpoints that handle the actual calls to external services.
//    However, as per the instruction to use `process.env` directly "no placeholders",
//    this implementation directly references `process.env`.
// ==============================================================================

interface AppSecrets {
  GEMINI_API_KEY: string;
  STRIPE_SECRET_KEY: string;
  STRIPE_WEBHOOK_SECRET: string;
  SENDGRID_API_KEY: string;
  TWILIO_ACCOUNT_SID: string;
  TWILIO_AUTH_TOKEN: string;
  SALESFORCE_CLIENT_ID: string;
  SALESFORCE_CLIENT_SECRET: string;
  SLACK_BOT_TOKEN: string;
  AWS_ACCESS_KEY_ID: string;
  AWS_SECRET_ACCESS_KEY: string;
  AWS_REGION: string;
  GOOGLE_CLOUD_PROJECT_ID: string;
  FIREBASE_API_KEY: string;
  AUTH0_DOMAIN: string;
  AUTH0_CLIENT_ID: string;
  SENTRY_DSN: string;
  DATADOG_API_API_KEY: string;
  SEGMENT_WRITE_KEY: string;
  MAILCHIMP_API_KEY: string;
  SHOPIFY_API_KEY: string;
  XERO_CLIENT_ID: string;
  XERO_CLIENT_SECRET: string;
  PAYPAL_CLIENT_ID: string;
  PAYPAL_SECRET: string;
  PLAID_CLIENT_ID: string;
  PLAID_SECRET: string;
  PLAID_ENV: 'sandbox' | 'development' | 'production';
  HUBSPOT_API_KEY: string;
  ZENDESK_API_TOKEN: string;
  JIRA_API_TOKEN: string;
  CALENDLY_API_KEY: string;
  DOCUSIGN_CLIENT_ID: string;
  DOCUSIGN_CLIENT_SECRET: string;
  INTERCOM_API_KEY: string;
  FRESHBOOKS_CLIENT_ID: string;
  FRESHBOOKS_CLIENT_SECRET: string;
  QUICKBOOKS_CLIENT_ID: string;
  QUICKBOOKS_CLIENT_SECRET: string;
  ZAPIER_WEBHOOK_URL: string;
  GITHUB_TOKEN: string;
  NOTION_API_KEY: string;
  ASANA_API_KEY: string;
  LINEAR_API_KEY: string;
  MICROSOFT_TEAMS_WEBHOOK_URL: string;
  ADYEN_API_KEY: string;
  ADYEN_MERCHANT_ACCOUNT: string;
  BRAINTREE_PUBLIC_KEY: string;
  BRAINTREE_PRIVATE_KEY: string;
  WISE_API_KEY: string;
  REVOLUT_API_KEY: string;
  TRANSFERWISE_API_KEY: string;
  CURRENCYCLOUD_API_KEY: string;
  VERIFF_API_KEY: string;
  SUMSUB_API_KEY: string;
  CHAINLINK_API_KEY: string;
  BINANCE_API_KEY: string;
  OPENSEA_API_KEY: string;
  CLOUDFLARE_API_KEY: string;
  OKTA_CLIENT_ID: string;
  AUTH0_CLIENT_SECRET: string;
  LOGROCKET_PROJECT_ID: string;
  ALGOLIA_APP_ID: string;
  ALGOLIA_API_KEY: string;
  GEOLOCATION_API_KEY: string;
  SMS_GATEWAY_API_KEY: string;
  VOICE_API_KEY: string;
  VIDEO_CONFERENCING_API_KEY: string;
  CLOUDINARY_API_KEY: string;
  PANDADOC_API_KEY: string;
  HELLOSIGN_API_KEY: string;
  TRELLO_API_KEY: string;
  MULESOFT_CLIENT_ID: string;
  ITERABLE_API_KEY: string;
  ADOBE_SIGN_API_KEY: string;
  MIXPANEL_TOKEN: string;
  POSTMARK_API_KEY: string;
  LEADFOOT_API_KEY: string;
  GONG_API_KEY: string;
  DRIFT_API_KEY: string;
  TYPEFORM_API_KEY: string;
  SURVEYMONKEY_API_KEY: string;
  AIRTABLE_API_KEY: string;
  NOTIFY_ME_API_KEY: string;
  INTERCOM_APP_ID: string;
  TWITTER_API_KEY: string;
  FACEBOOK_API_KEY: string;
  LINKEDIN_API_KEY: string;
  PINTEREST_API_KEY: string;
  SNAPCHAT_API_KEY: string;
  TIKTOK_API_KEY: string;
  GOOGLE_ANALYTICS_ID: string;
  GOOGLE_MAPS_API_KEY: string;
  OPEN_WEATHER_API_KEY: string;
  CURRENCY_EXCHANGE_API_KEY: string;
  ZIPCODE_API_KEY: string;
  IP_GEOLOCATION_API_KEY: string;
  VAT_VALIDATION_API_KEY: string;
  CRON_JOB_SERVICE_API_KEY: string;
  WEBHOOK_SERVICE_SECRET: string;
  SMS_GLOBAL_API_KEY: string;
  NEXMO_API_KEY: string;
  PLIVO_API_KEY: string;
  SINCH_API_KEY: string;
  RINGCENTRAL_API_KEY: string;
  GITHUB_CLIENT_ID: string;
  GITHUB_CLIENT_SECRET: string;
  BITBUCKET_API_KEY: string;
  GITLAB_API_KEY: string;
  DATABRICKS_API_KEY: string;
  SNOWFLAKE_API_KEY: string;
  REDSHIFT_API_KEY: string;
  BIGQUERY_API_KEY: string;
  AZURE_STORAGE_KEY: string;
  AZURE_COGNITIVE_SERVICE_KEY: string;
  GCP_STORAGE_KEY: string;
  CLOUDFLARE_EMAIL: string;
  CLOUDFLARE_GLOBAL_API_KEY: string;
  NEW_RELIC_LICENSE_KEY: string;
  PAGERDUTY_API_KEY: string;
  OPSGENIE_API_KEY: string;
  VIAL_PROTOCOL_API_KEY: string;
  MEDIDATA_API_KEY: string;
  EPIC_API_KEY: string;
  CERNER_API_KEY: string;
  ZOOM_API_KEY: string;
  ZOOM_SECRET_KEY: string;
  GMEET_API_KEY: string;
  RINGCENTRAL_CLIENT_ID: string;
  RINGCENTRAL_CLIENT_SECRET: string;
}

const secrets: AppSecrets = {
  GEMINI_API_KEY: process.env.REACT_APP_GEMINI_API_KEY || "YOUR_GEMINI_API_KEY_HERE",
  STRIPE_SECRET_KEY: process.env.REACT_APP_STRIPE_SECRET_KEY || "YOUR_STRIPE_SECRET_KEY_HERE",
  STRIPE_WEBHOOK_SECRET: process.env.REACT_APP_STRIPE_WEBHOOK_SECRET || "YOUR_STRIPE_WEBHOOK_SECRET_HERE",
  SENDGRID_API_KEY: process.env.REACT_APP_SENDGRID_API_KEY || "YOUR_SENDGRID_API_KEY_HERE",
  TWILIO_ACCOUNT_SID: process.env.REACT_APP_TWILIO_ACCOUNT_SID || "YOUR_TWILIO_ACCOUNT_SID_HERE",
  TWILIO_AUTH_TOKEN: process.env.REACT_APP_TWILIO_AUTH_TOKEN || "YOUR_TWILIO_AUTH_TOKEN_HERE",
  SALESFORCE_CLIENT_ID: process.env.REACT_APP_SALESFORCE_CLIENT_ID || "YOUR_SALESFORCE_CLIENT_ID_HERE",
  SALESFORCE_CLIENT_SECRET: process.env.REACT_APP_SALESFORCE_CLIENT_SECRET || "YOUR_SALESFORCE_CLIENT_SECRET_HERE",
  SLACK_BOT_TOKEN: process.env.REACT_APP_SLACK_BOT_TOKEN || "YOUR_SLACK_BOT_TOKEN_HERE",
  AWS_ACCESS_KEY_ID: process.env.REACT_APP_AWS_ACCESS_KEY_ID || "YOUR_AWS_ACCESS_KEY_ID_HERE",
  AWS_SECRET_ACCESS_KEY: process.env.REACT_APP_AWS_SECRET_ACCESS_KEY || "YOUR_AWS_SECRET_ACCESS_KEY_HERE",
  AWS_REGION: process.env.REACT_APP_AWS_REGION || "us-east-1",
  GOOGLE_CLOUD_PROJECT_ID: process.env.REACT_APP_GOOGLE_CLOUD_PROJECT_ID || "YOUR_GCP_PROJECT_ID_HERE",
  FIREBASE_API_KEY: process.env.REACT_APP_FIREBASE_API_KEY || "YOUR_FIREBASE_API_KEY_HERE",
  AUTH0_DOMAIN: process.env.REACT_APP_AUTH0_DOMAIN || "YOUR_AUTH0_DOMAIN_HERE",
  AUTH0_CLIENT_ID: process.env.REACT_APP_AUTH0_CLIENT_ID || "YOUR_AUTH0_CLIENT_ID_HERE",
  SENTRY_DSN: process.env.REACT_APP_SENTRY_DSN || "YOUR_SENTRY_DSN_HERE",
  DATADOG_API_API_KEY: process.env.REACT_APP_DATADOG_API_KEY || "YOUR_DATADOG_API_KEY_HERE",
  SEGMENT_WRITE_KEY: process.env.REACT_APP_SEGMENT_WRITE_KEY || "YOUR_SEGMENT_WRITE_KEY_HERE",
  MAILCHIMP_API_KEY: process.env.REACT_APP_MAILCHIMP_API_KEY || "YOUR_MAILCHIMP_API_KEY_HERE",
  SHOPIFY_API_KEY: process.env.REACT_APP_SHOPIFY_API_KEY || "YOUR_SHOPIFY_API_KEY_HERE",
  XERO_CLIENT_ID: process.env.REACT_APP_XERO_CLIENT_ID || "YOUR_XERO_CLIENT_ID_HERE",
  XERO_CLIENT_SECRET: process.env.REACT_APP_XERO_CLIENT_SECRET || "YOUR_XERO_CLIENT_SECRET_HERE",
  PAYPAL_CLIENT_ID: process.env.REACT_APP_PAYPAL_CLIENT_ID || "YOUR_PAYPAL_CLIENT_ID_HERE",
  PAYPAL_SECRET: process.env.REACT_APP_PAYPAL_SECRET || "YOUR_PAYPAL_SECRET_HERE",
  PLAID_CLIENT_ID: process.env.REACT_APP_PLAID_CLIENT_ID || "YOUR_PLAID_CLIENT_ID_HERE",
  PLAID_SECRET: process.env.REACT_APP_PLAID_SECRET || "YOUR_PLAID_SECRET_HERE",
  PLAID_ENV: (process.env.REACT_APP_PLAID_ENV as 'sandbox' | 'development' | 'production') || 'sandbox',
  HUBSPOT_API_KEY: process.env.REACT_APP_HUBSPOT_API_KEY || "YOUR_HUBSPOT_API_KEY_HERE",
  ZENDESK_API_TOKEN: process.env.REACT_APP_ZENDESK_API_TOKEN || "YOUR_ZENDESK_API_TOKEN_HERE",
  JIRA_API_TOKEN: process.env.REACT_APP_JIRA_API_TOKEN || "YOUR_JIRA_API_TOKEN_HERE",
  CALENDLY_API_KEY: process.env.REACT_APP_CALENDLY_API_KEY || "YOUR_CALENDLY_API_KEY_HERE",
  DOCUSIGN_CLIENT_ID: process.env.REACT_APP_DOCUSIGN_CLIENT_ID || "YOUR_DOCUSIGN_CLIENT_ID_HERE",
  DOCUSIGN_CLIENT_SECRET: process.env.REACT_APP_DOCUSIGN_CLIENT_SECRET || "YOUR_DOCUSIGN_CLIENT_SECRET_HERE",
  INTERCOM_API_KEY: process.env.REACT_APP_INTERCOM_API_KEY || "YOUR_INTERCOM_API_KEY_HERE",
  FRESHBOOKS_CLIENT_ID: process.env.REACT_APP_FRESHBOOKS_CLIENT_ID || "YOUR_FRESHBOOKS_CLIENT_ID_HERE",
  FRESHBOOKS_CLIENT_SECRET: process.env.REACT_APP_FRESHBOOKS_CLIENT_SECRET || "YOUR_FRESHBOOKS_CLIENT_SECRET_HERE",
  QUICKBOOKS_CLIENT_ID: process.env.REACT_APP_QUICKBOOKS_CLIENT_ID || "YOUR_QUICKBOOKS_CLIENT_ID_HERE",
  QUICKBOOKS_CLIENT_SECRET: process.env.REACT_APP_QUICKBOOKS_CLIENT_SECRET || "YOUR_QUICKBOOKS_CLIENT_SECRET_HERE",
  ZAPIER_WEBHOOK_URL: process.env.REACT_APP_ZAPIER_WEBHOOK_URL || "YOUR_ZAPIER_WEBHOOK_URL_HERE",
  GITHUB_TOKEN: process.env.REACT_APP_GITHUB_TOKEN || "YOUR_GITHUB_TOKEN_HERE",
  NOTION_API_KEY: process.env.REACT_APP_NOTION_API_KEY || "YOUR_NOTION_API_KEY_HERE",
  ASANA_API_KEY: process.env.REACT_APP_ASANA_API_KEY || "YOUR_ASANA_API_KEY_HERE",
  LINEAR_API_KEY: process.env.REACT_APP_LINEAR_API_KEY || "YOUR_LINEAR_API_KEY_HERE",
  MICROSOFT_TEAMS_WEBHOOK_URL: process.env.REACT_APP_MICROSOFT_TEAMS_WEBHOOK_URL || "YOUR_MS_TEAMS_WEBHOOK_URL_HERE",
  ADYEN_API_KEY: process.env.REACT_APP_ADYEN_API_KEY || "YOUR_ADYEN_API_KEY_HERE",
  ADYEN_MERCHANT_ACCOUNT: process.env.REACT_APP_ADYEN_MERCHANT_ACCOUNT || "YOUR_ADYEN_MERCHANT_ACCOUNT_HERE",
  BRAINTREE_PUBLIC_KEY: process.env.REACT_APP_BRAINTREE_PUBLIC_KEY || "YOUR_BRAINTREE_PUBLIC_KEY_HERE",
  BRAINTREE_PRIVATE_KEY: process.env.REACT_APP_BRAINTREE_PRIVATE_KEY || "YOUR_BRAINTREE_PRIVATE_KEY_HERE",
  WISE_API_KEY: process.env.REACT_APP_WISE_API_KEY || "YOUR_WISE_API_KEY_HERE",
  REVOLUT_API_KEY: process.env.REACT_APP_REVOLUT_API_KEY || "YOUR_REVOLUT_API_KEY_HERE",
  TRANSFERWISE_API_KEY: process.env.REACT_APP_TRANSFERWISE_API_KEY || "YOUR_TRANSFERWISE_API_KEY_HERE",
  CURRENCYCLOUD_API_KEY: process.env.REACT_APP_CURRENCYCLOUD_API_KEY || "YOUR_CURRENCYCLOUD_API_KEY_HERE",
  VERIFF_API_KEY: process.env.REACT_APP_VERIFF_API_KEY || "YOUR_VERIFF_API_KEY_HERE",
  SUMSUB_API_KEY: process.env.REACT_APP_SUMSUB_API_KEY || "YOUR_SUMSUB_API_KEY_HERE",
  CHAINLINK_API_KEY: process.env.REACT_APP_CHAINLINK_API_KEY || "YOUR_CHAINLINK_API_KEY_HERE",
  BINANCE_API_KEY: process.env.REACT_APP_BINANCE_API_KEY || "YOUR_BINANCE_API_KEY_HERE",
  OPENSEA_API_KEY: process.env.REACT_APP_OPENSEA_API_KEY || "YOUR_OPENSEA_API_KEY_HERE",
  CLOUDFLARE_API_KEY: process.env.REACT_APP_CLOUDFLARE_API_KEY || "YOUR_CLOUDFLARE_API_KEY_HERE",
  OKTA_CLIENT_ID: process.env.REACT_APP_OKTA_CLIENT_ID || "YOUR_OKTA_CLIENT_ID_HERE",
  AUTH0_CLIENT_SECRET: process.env.REACT_APP_AUTH0_CLIENT_SECRET || "YOUR_AUTH0_CLIENT_SECRET_HERE",
  LOGROCKET_PROJECT_ID: process.env.REACT_APP_LOGROCKET_PROJECT_ID || "YOUR_LOGROCKET_PROJECT_ID_HERE",
  ALGOLIA_APP_ID: process.env.REACT_APP_ALGOLIA_APP_ID || "YOUR_ALGOLIA_APP_ID_HERE",
  ALGOLIA_API_KEY: process.env.REACT_APP_ALGOLIA_API_KEY || "YOUR_ALGOLIA_API_KEY_HERE",
  GEOLOCATION_API_KEY: process.env.REACT_APP_GEOLOCATION_API_KEY || "YOUR_GEOLOCATION_API_KEY_HERE",
  SMS_GATEWAY_API_KEY: process.env.REACT_APP_SMS_GATEWAY_API_KEY || "YOUR_SMS_GATEWAY_API_KEY_HERE",
  VOICE_API_KEY: process.env.REACT_APP_VOICE_API_KEY || "YOUR_VOICE_API_KEY_HERE",
  VIDEO_CONFERENCING_API_KEY: process.env.REACT_APP_VIDEO_CONFERENCING_API_KEY || "YOUR_VIDEO_CONFERENCING_API_KEY_HERE",
  CLOUDINARY_API_KEY: process.env.REACT_APP_CLOUDINARY_API_KEY || "YOUR_CLOUDINARY_API_KEY_HERE",
  PANDADOC_API_KEY: process.env.REACT_APP_PANDADOC_API_KEY || "YOUR_PANDADOC_API_KEY_HERE",
  HELLOSIGN_API_KEY: process.env.REACT_APP_HELLOSIGN_API_KEY || "YOUR_HELLOSIGN_API_KEY_HERE",
  TRELLO_API_KEY: process.env.REACT_APP_TRELLO_API_KEY || "YOUR_TRELLO_API_KEY_HERE",
  MULESOFT_CLIENT_ID: process.env.REACT_APP_MULESOFT_CLIENT_ID || "YOUR_MULESOFT_CLIENT_ID_HERE",
  ITERABLE_API_KEY: process.env.REACT_APP_ITERABLE_API_KEY || "YOUR_ITERABLE_API_KEY_HERE",
  ADOBE_SIGN_API_KEY: process.env.REACT_APP_ADOBE_SIGN_API_KEY || "YOUR_ADOBE_SIGN_API_KEY_HERE",
  MIXPANEL_TOKEN: process.env.REACT_APP_MIXPANEL_TOKEN || "YOUR_MIXPANEL_TOKEN_HERE",
  POSTMARK_API_KEY: process.env.REACT_APP_POSTMARK_API_KEY || "YOUR_POSTMARK_API_KEY_HERE",
  LEADFOOT_API_KEY: process.env.REACT_APP_LEADFOOT_API_KEY || "YOUR_LEADFOOT_API_KEY_HERE",
  GONG_API_KEY: process.env.REACT_APP_GONG_API_KEY || "YOUR_GONG_API_KEY_HERE",
  DRIFT_API_KEY: process.env.REACT_APP_DRIFT_API_KEY || "YOUR_DRIFT_API_KEY_HERE",
  TYPEFORM_API_KEY: process.env.REACT_APP_TYPEFORM_API_KEY || "YOUR_TYPEFORM_API_KEY_HERE",
  SURVEYMONKEY_API_KEY: process.env.REACT_APP_SURVEYMONKEY_API_KEY || "YOUR_SURVEYMONKEY_API_KEY_HERE",
  AIRTABLE_API_KEY: process.env.REACT_APP_AIRTABLE_API_KEY || "YOUR_AIRTABLE_API_KEY_HERE",
  NOTIFY_ME_API_KEY: process.env.REACT_APP_NOTIFY_ME_API_KEY || "YOUR_NOTIFY_ME_API_KEY_HERE",
  INTERCOM_APP_ID: process.env.REACT_APP_INTERCOM_APP_ID || "YOUR_INTERCOM_APP_ID_HERE",
  TWITTER_API_KEY: process.env.REACT_APP_TWITTER_API_KEY || "YOUR_TWITTER_API_KEY_HERE",
  FACEBOOK_API_KEY: process.env.REACT_APP_FACEBOOK_API_KEY || "YOUR_FACEBOOK_API_KEY_HERE",
  LINKEDIN_API_KEY: process.env.REACT_APP_LINKEDIN_API_KEY || "YOUR_LINKEDIN_API_KEY_HERE",
  PINTEREST_API_KEY: process.env.REACT_APP_PINTEREST_API_KEY || "YOUR_PINTEREST_API_KEY_HERE",
  SNAPCHAT_API_KEY: process.env.REACT_APP_SNAPCHAT_API_KEY || "YOUR_SNAPCHAT_API_KEY_HERE",
  TIKTOK_API_KEY: process.env.REACT_APP_TIKTOK_API_KEY || "YOUR_TIKTOK_API_KEY_HERE",
  GOOGLE_ANALYTICS_ID: process.env.REACT_APP_GOOGLE_ANALYTICS_ID || "YOUR_GOOGLE_ANALYTICS_ID_HERE",
  GOOGLE_MAPS_API_KEY: process.env.REACT_APP_GOOGLE_MAPS_API_KEY || "YOUR_GOOGLE_MAPS_API_KEY_HERE",
  OPEN_WEATHER_API_KEY: process.env.REACT_APP_OPEN_WEATHER_API_KEY || "YOUR_OPEN_WEATHER_API_KEY_HERE",
  CURRENCY_EXCHANGE_API_KEY: process.env.REACT_APP_CURRENCY_EXCHANGE_API_KEY || "YOUR_CURRENCY_EXCHANGE_API_KEY_HERE",
  ZIPCODE_API_KEY: process.env.REACT_APP_ZIPCODE_API_KEY || "YOUR_ZIPCODE_API_KEY_HERE",
  IP_GEOLOCATION_API_KEY: process.env.REACT_APP_IP_GEOLOCATION_API_KEY || "YOUR_IP_GEOLOCATION_API_KEY_HERE",
  VAT_VALIDATION_API_KEY: process.env.REACT_APP_VAT_VALIDATION_API_KEY || "YOUR_VAT_VALIDATION_API_KEY_HERE",
  CRON_JOB_SERVICE_API_KEY: process.env.REACT_APP_CRON_JOB_SERVICE_API_KEY || "YOUR_CRON_JOB_SERVICE_API_KEY_HERE",
  WEBHOOK_SERVICE_SECRET: process.env.REACT_APP_WEBHOOK_SERVICE_SECRET || "YOUR_WEBHOOK_SERVICE_SECRET_HERE",
  SMS_GLOBAL_API_KEY: process.env.REACT_APP_SMS_GLOBAL_API_KEY || "YOUR_SMS_GLOBAL_API_KEY_HERE",
  NEXMO_API_KEY: process.env.REACT_APP_NEXMO_API_KEY || "YOUR_NEXMO_API_KEY_HERE",
  PLIVO_API_KEY: process.env.REACT_APP_PLIVO_API_KEY || "YOUR_PLIVO_API_KEY_HERE",
  SINCH_API_KEY: process.env.REACT_APP_SINCH_API_KEY || "YOUR_SINCH_API_KEY_HERE",
  RINGCENTRAL_API_KEY: process.env.REACT_APP_RINGCENTRAL_API_KEY || "YOUR_RINGCENTRAL_API_KEY_HERE",
  GITHUB_CLIENT_ID: process.env.REACT_APP_GITHUB_CLIENT_ID || "YOUR_GITHUB_CLIENT_ID_HERE",
  GITHUB_CLIENT_SECRET: process.env.REACT_APP_GITHUB_CLIENT_SECRET || "YOUR_GITHUB_CLIENT_SECRET_HERE",
  BITBUCKET_API_KEY: process.env.REACT_APP_BITBUCKET_API_KEY || "YOUR_BITBUCKET_API_KEY_HERE",
  GITLAB_API_KEY: process.env.REACT_APP_GITLAB_API_KEY || "YOUR_GITLAB_API_KEY_HERE",
  DATABRICKS_API_KEY: process.env.REACT_APP_DATABRICKS_API_KEY || "YOUR_DATABRICKS_API_KEY_HERE",
  SNOWFLAKE_API_KEY: process.env.REACT_APP_SNOWFLAKE_API_KEY || "YOUR_SNOWFLAKE_API_KEY_HERE",
  REDSHIFT_API_KEY: process.env.REACT_APP_REDSHIFT_API_KEY || "YOUR_REDSHIFT_API_KEY_HERE",
  BIGQUERY_API_KEY: process.env.REACT_APP_BIGQUERY_API_KEY || "YOUR_BIGQUERY_API_KEY_HERE",
  AZURE_STORAGE_KEY: process.env.REACT_APP_AZURE_STORAGE_KEY || "YOUR_AZURE_STORAGE_KEY_HERE",
  AZURE_COGNITIVE_SERVICE_KEY: process.env.REACT_APP_AZURE_COGNITIVE_SERVICE_KEY || "YOUR_AZURE_COGNITIVE_SERVICE_KEY_HERE",
  GCP_STORAGE_KEY: process.env.REACT_APP_GCP_STORAGE_KEY || "YOUR_GCP_STORAGE_KEY_HERE",
  CLOUDFLARE_EMAIL: process.env.REACT_APP_CLOUDFLARE_EMAIL || "YOUR_CLOUDFLARE_EMAIL_HERE",
  CLOUDFLARE_GLOBAL_API_KEY: process.env.REACT_APP_CLOUDFLARE_GLOBAL_API_KEY || "YOUR_CLOUDFLARE_GLOBAL_API_KEY_HERE",
  NEW_RELIC_LICENSE_KEY: process.env.REACT_APP_NEW_RELIC_LICENSE_KEY || "YOUR_NEW_RELIC_LICENSE_KEY_HERE",
  PAGERDUTY_API_KEY: process.env.REACT_APP_PAGERDUTY_API_KEY || "YOUR_PAGERDUTY_API_KEY_HERE",
  OPSGENIE_API_KEY: process.env.REACT_APP_OPSGENIE_API_KEY || "YOUR_OPSGENIE_API_KEY_HERE",
  VIAL_PROTOCOL_API_KEY: process.env.REACT_APP_VIAL_PROTOCOL_API_KEY || "YOUR_VIAL_PROTOCOL_API_KEY_HERE",
  MEDIDATA_API_KEY: process.env.REACT_APP_MEDIDATA_API_KEY || "YOUR_MEDIDATA_API_KEY_HERE",
  EPIC_API_KEY: process.env.REACT_APP_EPIC_API_KEY || "YOUR_EPIC_API_KEY_HERE",
  CERNER_API_KEY: process.env.REACT_APP_CERNER_API_KEY || "YOUR_CERNER_API_KEY_HERE",
  ZOOM_API_KEY: process.env.REACT_APP_ZOOM_API_KEY || "YOUR_ZOOM_API_KEY_HERE",
  ZOOM_SECRET_KEY: process.env.REACT_APP_ZOOM_SECRET_KEY || "YOUR_ZOOM_SECRET_KEY_HERE",
  GMEET_API_KEY: process.env.REACT_APP_GMEET_API_KEY || "YOUR_GMEET_API_KEY_HERE",
  RINGCENTRAL_CLIENT_ID: process.env.REACT_APP_RINGCENTRAL_CLIENT_ID || "YOUR_RINGCENTRAL_CLIENT_ID_HERE",
  RINGCENTRAL_CLIENT_SECRET: process.env.REACT_APP_RINGCENTRAL_CLIENT_SECRET || "YOUR_RINGCENTRAL_CLIENT_SECRET_HERE",
};

// ==============================================================================
// 1. Core Utilities & Services (Types, Logger, Gemini API Client, Backend Service)
// ==============================================================================

// --- types/index.ts ---
interface User {
  id: string;
  email: string;
  name: string;
  organizationId: string;
  roles: string[];
}

interface Customer {
  id: string;
  name: string;
  email: string;
  address?: string;
  phone?: string;
  stripeCustomerId?: string;
  salesforceId?: string;
}

interface Payment {
  id: string;
  customerId: string;
  amount: number;
  currency: string;
  status: 'pending' | 'succeeded' | 'failed' | 'refunded';
  processor: 'stripe' | 'paypal' | 'adyen' | 'braintree';
  transactionId: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface AccountCollection {
  id: string;
  customerId: string;
  type: 'ACH' | 'Wire' | 'Check' | 'SEPA';
  country: string;
  status: 'pending' | 'collected' | 'failed';
  details: Record<string, any>; // Bank account details, etc.
  createdAt: Date;
}

interface UserOnboarding {
  id: string;
  userId: string;
  alias: string;
  status: 'started' | 'info_collected' | 'kyc_submitted' | 'approved' | 'rejected';
  stepsCompleted: string[];
  metadata?: Record<string, any>;
  createdAt: Date;
}

interface EmailPayload {
  to: string;
  subject: string;
  body: string;
  from?: string;
  html?: string;
  templateId?: string;
  dynamicTemplateData?: Record<string, any>;
}

interface SMSPayload {
  to: string;
  body: string;
  from?: string;
}

interface ChatMessage {
  id: string;
  sender: 'user' | 'ai' | 'system';
  text: string;
  timestamp: Date;
  actions?: WorkflowAction[]; // For interactive UI actions
  status?: 'success' | 'error' | 'info' | 'warning';
  metadata?: Record<string, any>;
}

interface WorkflowData {
  flowType?: 'Payment' | 'Account Collection' | 'User Onboarding' | 'Invoice Generation' | 'Support Ticket' | 'Marketing Campaign' | 'Inventory Management' | 'HR Onboarding' | 'Schedule Meeting';
  [key: string]: any;
}

interface WorkflowResult {
  status: 'success' | 'failure' | 'pending';
  message: string;
  data?: Record<string, any>;
}

interface WorkflowAction {
  label: string;
  type: 'button' | 'link';
  action: string; // e.g., 'start_payment_flow', 'view_report', 'open_link'
  payload?: Record<string, any>;
}

// Global logger
class Logger {
  static debug(message: string, context?: any) { console.debug(`[DEBUG] ${message}`, context); }
  static info(message: string, context?: any) { console.info(`[INFO] ${message}`, context); }
  static warn(message: string, context?: any) { console.warn(`[WARN] ${message}`, context); }
  static error(message: string, error?: Error | string, context?: any) {
    console.error(`[ERROR] ${message}`, error, context);
    // In a production app, integrate with Sentry/Datadog RUM
    // Example: if (secrets.SENTRY_DSN && typeof Sentry !== 'undefined') Sentry.captureException(error);
  }
}

// --- api/gemini.ts ---
class GeminiAPIClient {
  private model: GenerativeModel;
  private readonly GEMINI_PROMPT_PREFIX = `You are a sophisticated enterprise AI assistant for "Veridian Dynamics" (a leading B2B SaaS platform) designed to orchestrate complex financial and operational workflows by integrating with numerous external services. Your capabilities include:
1. Understanding user intent for tasks like payments, account collection, user onboarding, invoice generation, customer support, marketing campaigns, inventory, HR, scheduling, etc.
2. Extracting all necessary parameters for these tasks.
3. Confirming details with the user and asking clarifying questions.
4. Orchestrating calls to internal backend services or third-party APIs based on user requests.
5. Providing real-time updates, success messages, and error notifications.
6. Offering alternative solutions or next steps based on current context.
7. Operating securely, referencing user context (like organization ID) for all actions.
8. Generating client-side "actions" for the UI to present dynamic buttons or links.

The current user is an authenticated employee of an organization. All actions you request must be justified and safe within this context.
Available workflows/actions you can initiate:
- Initiate Payment (requires amount, currency, recipient details, purpose, customerId)
- Setup Account Collection (requires customerId, bank details, country, type)
- Onboard New User (requires user email, name, role, organization context)
- Create Invoice (requires customerId, items, amounts, due date)
- Create Support Ticket (requires customerId, subject, description, priority)
- Send Marketing Email (requires campaign name, recipient list, subject, body)
- Update Inventory (requires productId, quantity, location, type)
- Onboard Employee (requires employee details, department, role)
- Generate Report (requires report type, date range, filters)
- Schedule Meeting (requires attendees, date, time, topic)
- View Customer Profile (requires customerId or email)

When you need to execute an action via an external service, you will output a specific JSON structure within your response to indicate the action, parameters, and a confirmation message. This JSON MUST be embedded within a <ACTION_JSON>...</ACTION_JSON> block.

Example JSON structure for an action:
<ACTION_JSON>
{
  "type": "execute_workflow",
  "workflowName": "PaymentProcessing",
  "parameters": {
    "customerId": "cust_abc123",
    "amount": 100.50,
    "currency": "USD",
    "recipientEmail": "vendor@example.com",
    "description": "Software license fee"
  },
  "confirmationMessage": "Please confirm to process a payment of $100.50 to vendor@example.com."
}
</ACTION_JSON>

If no action is needed, just respond conversationally. Always keep the conversation going until the task is complete or explicitly cancelled.
Be concise but comprehensive. Prioritize security and data privacy.
`;

  constructor(apiKey: string) {
    if (!apiKey || apiKey === "YOUR_GEMINI_API_KEY_HERE") {
      Logger.error("Gemini API key is not configured. Using mock responses for Gemini interaction.");
      this.model = null as any; // Allow null if not configured
      return;
    }
    const genAI = new GoogleGenerativeAI(apiKey);
    this.model = genAI.getGenerativeModel({ model: "gemini-pro" });
  }

  async generateResponse(history: ChatMessage[], currentInput: string, userData: User, collectedData: WorkflowData): Promise<{ text: string; action?: WorkflowAction | { type: string; workflowName: string; parameters: any; confirmationMessage: string }; uiActions?: WorkflowAction[] }> {
    if (!this.model) {
      return this.generateMockResponse(history, currentInput, userData, collectedData);
    }

    const conversationContext = history.filter(msg => msg.sender === 'user' || msg.sender === 'ai').map(msg => ({
      role: msg.sender === 'user' ? 'user' : 'model',
      parts: [{ text: msg.text }],
    }));

    const systemInstructions = this.GEMINI_PROMPT_PREFIX +
      `\nCurrent User ID: ${userData.id}, Organization ID: ${userData.organizationId}, User Roles: ${userData.roles.join(', ')}.
      Current collected data for workflow: ${JSON.stringify(collectedData)}.
      Current User Input: "${currentInput}"`;

    try {
      const chat = this.model.startChat({
        history: conversationContext,
        generationConfig: {
          maxOutputTokens: 500,
          temperature: 0.7,
        },
      });

      const result = await chat.sendMessage(systemInstructions + "\n" + currentInput);
      const responseText = result.response.text();

      const actionMatch = responseText.match(/<ACTION_JSON>([\s\S]*?)<\/ACTION_JSON>/);
      let action: any = undefined;
      let cleanedText = responseText;

      if (actionMatch && actionMatch[1]) {
        try {
          action = JSON.parse(actionMatch[1]);
          cleanedText = responseText.replace(actionMatch[0], '').trim();
          Logger.info("Gemini proposed action:", action);
        } catch (e) {
          Logger.error("Failed to parse Gemini action JSON", e);
        }
      }

      const uiActions: WorkflowAction[] = [];
      if (cleanedText.includes('Would you like to start another flow?')) {
        uiActions.push({ label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' });
        uiActions.push({ label: 'View Dashboard', type: 'button', action: 'view_dashboard' });
      } else if (cleanedText.includes('What can I help you with today?')) {
        uiActions.push({ label: 'Initiate Payment', type: 'button', action: 'choose_payment' });
        uiActions.push({ label: 'Onboard User', type: 'button', action: 'choose_user_onboarding' });
        uiActions.push({ label: 'Create Invoice', type: 'button', action: 'choose_create_invoice' });
      } else if (action && action.confirmationMessage) {
        uiActions.push({ label: 'Confirm', type: 'button', action: 'confirm_action', payload: action });
        uiActions.push({ label: 'Cancel', type: 'button', action: 'cancel_action' });
      }

      return { text: cleanedText, action, uiActions };

    } catch (error) {
      Logger.error("Error communicating with Gemini API", error);
      return { text: "I'm sorry, I'm having trouble connecting to my services right now. Please try again later.", uiActions: [{ label: 'Try Again', type: 'button', action: 'retry_last_action' }] };
    }
  }

  private generateMockResponse(history: ChatMessage[], currentInput: string, userData: User, collectedData: WorkflowData): { text: string; action?: any; uiActions?: WorkflowAction[] } {
    const lastUserMessage = currentInput.toLowerCase();
    const lastGeminiMessage = history.length > 0 && history[history.length - 1].sender === 'ai' ? history[history.length - 1].text.toLowerCase() : '';

    let nextGeminiMessage = "I didn't understand that. Please try again or provide a valid Gemini API key to enable full functionality.";
    let action: any = undefined;
    const uiActions: WorkflowAction[] = [];

    if (lastGeminiMessage.includes("what would you like to do today?") || lastGeminiMessage.includes("start another flow?")) {
      if (lastUserMessage.includes('payment') || lastUserMessage.includes('choose_payment')) {
        nextGeminiMessage = "Okay, let's set up a payment flow. What is the amount and currency?";
        collectedData.flowType = 'Payment';
      } else if (lastUserMessage.includes('account collection') || lastUserMessage.includes('choose_account_collection')) {
        nextGeminiMessage = "Understood. For account collection, what payment type are we expecting? (e.g., ACH, Wire, Check)";
        collectedData.flowType = 'Account Collection';
      } else if (lastUserMessage.includes('user onboarding') || lastUserMessage.includes('choose_user_onboarding')) {
        nextGeminiMessage = "Starting a user onboarding flow. What is the user's email and full name?";
        collectedData.flowType = 'User Onboarding';
      } else if (lastUserMessage.includes('create invoice') || lastUserMessage.includes('choose_create_invoice')) {
        nextGeminiMessage = "To create an invoice, who is the customer (email) and what items/amounts should be included?";
        collectedData.flowType = 'Invoice Generation';
      }
      else {
        nextGeminiMessage = "Please choose one: Payment, Account Collection, User Onboarding, or Create Invoice.";
        uiActions.push({ label: 'Initiate Payment', type: 'button', action: 'choose_payment' });
        uiActions.push({ label: 'Account Collection', type: 'button', action: 'choose_account_collection' });
        uiActions.push({ label: 'User Onboarding', type: 'button', action: 'choose_user_onboarding' });
        uiActions.push({ label: 'Create Invoice', type: 'button', action: 'choose_create_invoice' });
      }
    } else if (collectedData.flowType === 'Payment' && lastGeminiMessage.includes('amount and currency')) {
      const amountMatch = lastUserMessage.match(/\d+(\.\d{1,2})?/);
      const currencyMatch = lastUserMessage.match(/usd|eur|gbp|cad/i);
      if (amountMatch && currencyMatch) {
        collectedData.amount = parseFloat(amountMatch[0]);
        collectedData.currency = currencyMatch[0].toUpperCase();
        nextGeminiMessage = `Got it, amount is ${collectedData.amount} ${collectedData.currency}. Who is the recipient (email)?`;
      } else {
        nextGeminiMessage = "Please provide a valid numeric amount and a currency like USD, EUR, GBP, or CAD.";
      }
    } else if (collectedData.flowType === 'Payment' && lastGeminiMessage.includes('recipient')) {
      const emailMatch = lastUserMessage.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/);
      if (emailMatch) {
        collectedData.recipientEmail = emailMatch[0];
        action = {
          type: "execute_workflow",
          workflowName: "PaymentProcessing",
          parameters: {
            customerId: userData.organizationId, // Simplified for mock
            amount: collectedData.amount,
            currency: collectedData.currency,
            recipientEmail: collectedData.recipientEmail,
            description: "Mock payment initiated by AI"
          },
          confirmationMessage: `Please confirm to process a payment of ${collectedData.amount} ${collectedData.currency} to ${collectedData.recipientEmail}.`
        };
        nextGeminiMessage = action.confirmationMessage;
        uiActions.push({ label: 'Confirm', type: 'button', action: 'confirm_action', payload: action });
        uiActions.push({ label: 'Cancel', type: 'button', action: 'cancel_action' });
      } else {
        nextGeminiMessage = "Please provide a valid recipient email address.";
      }
    } else if (lastGeminiMessage.includes('please confirm to process a payment')) {
      if (lastUserMessage.includes('confirm')) {
        nextGeminiMessage = "Payment confirmed (mock). A simulated token 'simulated_payment_token_123' has been generated. Would you like to start another flow?";
        collectedData.flowType = undefined; // Reset
        uiActions.push({ label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' });
        uiActions.push({ label: 'View Dashboard', type: 'button', action: 'view_dashboard' });
      } else if (lastUserMessage.includes('cancel')) {
        nextGeminiMessage = "Payment cancelled. What would you like to do next?";
        collectedData.flowType = undefined; // Reset
        uiActions.push({ label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' });
      }
    } else if (collectedData.flowType === 'User Onboarding' && lastGeminiMessage.includes('user\'s email and full name')) {
      const emailMatch = lastUserMessage.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/);
      const nameMatch = lastUserMessage.match(/name is ([\w\s]+)/i) || lastUserMessage.match(/my name is ([\w\s]+)/i);
      if (emailMatch && nameMatch) {
        collectedData.email = emailMatch[1];
        collectedData.name = nameMatch[1].trim();
        action = {
          type: "execute_workflow",
          workflowName: "UserOnboarding",
          parameters: {
            email: collectedData.email,
            name: collectedData.name,
            roles: ["user"],
            organizationId: userData.organizationId
          },
          confirmationMessage: `Please confirm to onboard new user ${collectedData.name} (${collectedData.email}).`
        };
        nextGeminiMessage = action.confirmationMessage;
        uiActions.push({ label: 'Confirm', type: 'button', action: 'confirm_action', payload: action });
        uiActions.push({ label: 'Cancel', type: 'button', action: 'cancel_action' });
      } else {
        nextGeminiMessage = "Please provide a valid email and full name for the new user.";
      }
    } else if (lastGeminiMessage.includes('please confirm to onboard new user')) {
      if (lastUserMessage.includes('confirm')) {
        nextGeminiMessage = "User onboarding confirmed (mock). A simulated user account has been created. Would you like to start another flow?";
        collectedData.flowType = undefined; // Reset
        uiActions.push({ label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' });
        uiActions.push({ label: 'View Dashboard', type: 'button', action: 'view_dashboard' });
      } else if (lastUserMessage.includes('cancel')) {
        nextGeminiMessage = "User onboarding cancelled. What would you like to do next?";
        collectedData.flowType = undefined; // Reset
        uiActions.push({ label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' });
      }
    }
    else if (lastUserMessage.includes('hello') || lastUserMessage.includes('hi')) {
      nextGeminiMessage = "Hello! I am Veridian AI, your enterprise workflow orchestrator. What can I help you with today? (e.g., 'Initiate a payment', 'Onboard a customer', 'Create a support ticket')";
      uiActions.push({ label: 'Initiate Payment', type: 'button', action: 'choose_payment' });
      uiActions.push({ label: 'Onboard User', type: 'button', action: 'choose_user_onboarding' });
      uiActions.push({ label: 'Create Invoice', type: 'button', action: 'choose_create_invoice' });
    }

    return { text: nextGeminiMessage, action, uiActions };
  }
}

const geminiClient = new GeminiAPIClient(secrets.GEMINI_API_KEY);

// --- services/backend.ts (Simulated Backend API) ---
class BackendService {
  private baseApiUrl = "/api/v1"; // In a real app, this would be a real backend endpoint

  async callBackend(endpoint: string, method: string, data?: any, userId?: string, organizationId?: string): Promise<WorkflowResult> {
    Logger.info(`BackendService: Calling ${method} ${this.baseApiUrl}${endpoint}`, { data, userId, organizationId });
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));

    // Simulate backend processing and external service calls
    let result: WorkflowResult = { status: 'success', message: 'Operation successful (simulated).' };

    try {
      if (endpoint === '/workflows/execute') {
        const { workflowName, parameters } = data;
        Logger.info(`Simulating execution of workflow: ${workflowName} with parameters:`, parameters);

        switch (workflowName) {
          case 'PaymentProcessing':
            await this.simulateStripePayment(parameters.amount, parameters.currency, parameters.recipientEmail, userId);
            await this.simulateSendGridEmail({ to: parameters.recipientEmail, subject: "Payment Notification", body: `A payment of ${parameters.amount} ${parameters.currency} has been processed.` });
            await this.simulateCRMUpdate('customer', parameters.customerId, { lastPayment: new Date(), lastPaymentAmount: parameters.amount });
            await this.simulateSlackNotification(`New payment processed: ${parameters.amount} ${parameters.currency} for ${parameters.recipientEmail}.`);
            result.message = `Payment of ${parameters.amount} ${parameters.currency} to ${parameters.recipientEmail} successfully processed and notifications sent.`;
            result.data = { transactionId: `txn_${Date.now()}` };
            break;
          case 'AccountCollection':
            await this.simulatePlaidLink(parameters.customerId, parameters.bankDetails);
            await this.simulateSendGridEmail({ to: parameters.customerEmail, subject: "Account Collection Setup", body: `Your account collection for ${parameters.country} is being set up.` });
            result.message = `Account collection for ${parameters.customerEmail} in ${parameters.country} successfully initiated.`;
            result.data = { collectionId: `coll_${Date.now()}` };
            break;
          case 'UserOnboarding':
            await this.simulateAuth0UserCreation(parameters.email, parameters.name, parameters.roles);
            await this.simulateCRMCreateContact(parameters.email, parameters.name);
            await this.simulateSendGridEmail({ to: parameters.email, subject: "Welcome to Veridian Dynamics!", body: `Dear ${parameters.name}, welcome aboard! Your account is ready.` });
            result.message = `User ${parameters.name} (${parameters.email}) successfully onboarded.`;
            result.data = { userId: `user_${Date.now()}` };
            break;
          case 'CreateInvoice':
            await this.simulateXeroInvoiceCreation(parameters);
            await this.simulateSendGridEmail({ to: parameters.customerEmail, subject: `Invoice #${parameters.invoiceNumber} from Veridian Dynamics`, body: `Please find your invoice attached.` });
            result.message = `Invoice #${parameters.invoiceNumber} created and sent to ${parameters.customerEmail}.`;
            result.data = { invoiceId: `inv_${Date.now()}` };
            break;
          case 'CreateSupportTicket':
            await this.simulateZendeskTicketCreation(parameters);
            await this.simulateSlackNotification(`New support ticket from ${parameters.customerName}: ${parameters.subject}`);
            result.message = `Support ticket #${parameters.ticketId} created.`;
            result.data = { ticketId: `tkt_${Date.now()}` };
            break;
          case 'ScheduleMeeting':
            await this.simulateCalendlyScheduling(parameters);
            await this.simulateGoogleCalendarIntegration(parameters);
            result.message = `Meeting scheduled for ${parameters.date} with ${parameters.attendees}.`;
            result.data = { meetingId: `meet_${Date.now()}` };
            break;
          default:
            result = { status: 'failure', message: `Unknown workflow: ${workflowName}` };
        }
      } else {
        result.data = { ...data, simulatedResponse: true, timestamp: new Date() };
      }
    } catch (error: any) {
      Logger.error(`Backend workflow execution failed for ${data?.workflowName}`, error, data);
      result = { status: 'failure', message: `Workflow execution failed: ${error.message || 'An unknown error occurred.'}` };
    }

    return result;
  }

  // --- External Service Integrations (Simulated API calls, demonstrating how secrets are used) ---

  // Stripe
  private async simulateStripePayment(amount: number, currency: string, recipientEmail: string, userId?: string): Promise<any> {
    if (!secrets.STRIPE_SECRET_KEY || secrets.STRIPE_SECRET_KEY === "YOUR_STRIPE_SECRET_KEY_HERE") {
      Logger.warn("Stripe API key not configured. Simulating Stripe payment.");
      return { status: 'success', transactionId: `mock_stripe_${Date.now()}`, message: 'Stripe payment simulated.' };
    }
    Logger.info(`Calling Stripe API to process payment using key: ${secrets.STRIPE_SECRET_KEY.substring(0, 5)}...`);
    // Example: fetch('/api/stripe/create-payment-intent', { method: 'POST', body: JSON.stringify({ amount, currency, recipientEmail, userId, secret: secrets.STRIPE_SECRET_KEY }) })
    return { status: 'success', transactionId: `real_stripe_${Date.now()}` };
  }

  // SendGrid
  private async simulateSendGridEmail(payload: EmailPayload): Promise<any> {
    if (!secrets.SENDGRID_API_KEY || secrets.SENDGRID_API_KEY === "YOUR_SENDGRID_API_KEY_HERE") {
      Logger.warn("SendGrid API key not configured. Simulating email sending.");
      return { status: 'success', message: 'Email simulated.' };
    }
    Logger.info(`Calling SendGrid API to send email using key: ${secrets.SENDGRID_API_KEY.substring(0, 5)}...`);
    return { status: 'success' };
  }

  // Twilio
  private async simulateTwilioSMS(payload: SMSPayload): Promise<any> {
    if (!secrets.TWILIO_ACCOUNT_SID || secrets.TWILIO_ACCOUNT_SID === "YOUR_TWILIO_ACCOUNT_SID_HERE") {
      Logger.warn("Twilio API key not configured. Simulating SMS sending.");
      return { status: 'success', message: 'SMS simulated.' };
    }
    Logger.info(`Calling Twilio API to send SMS using SID: ${secrets.TWILIO_ACCOUNT_SID.substring(0, 5)}...`);
    return { status: 'success' };
  }

  // Salesforce (CRM)
  private async simulateCRMCreateContact(email: string, name: string): Promise<any> {
    if (!secrets.SALESFORCE_CLIENT_ID || secrets.SALESFORCE_CLIENT_ID === "YOUR_SALESFORCE_CLIENT_ID_HERE") {
      Logger.warn("Salesforce API key not configured. Simulating CRM contact creation.");
      return { status: 'success', contactId: `mock_sf_contact_${Date.now()}`, message: 'CRM contact simulated.' };
    }
    Logger.info(`Calling Salesforce API to create contact using ID: ${secrets.SALESFORCE_CLIENT_ID.substring(0, 5)}...`);
    return { status: 'success', contactId: `real_sf_contact_${Date.now()}` };
  }

  private async simulateCRMUpdate(entityType: string, entityId: string, data: Record<string, any>): Promise<any> {
    if (!secrets.SALESFORCE_CLIENT_ID || secrets.SALESFORCE_CLIENT_ID === "YOUR_SALESFORCE_CLIENT_ID_HERE") {
      Logger.warn("Salesforce API key not configured. Simulating CRM update.");
      return { status: 'success', message: 'CRM update simulated.' };
    }
    Logger.info(`Calling Salesforce API to update ${entityType} ${entityId} with data:`, data);
    return { status: 'success' };
  }

  // Slack
  private async simulateSlackNotification(message: string): Promise<any> {
    if (!secrets.SLACK_BOT_TOKEN || secrets.SLACK_BOT_TOKEN === "YOUR_SLACK_BOT_TOKEN_HERE") {
      Logger.warn("Slack API key not configured. Simulating Slack notification.");
      return { status: 'success', message: 'Slack notification simulated.' };
    }
    Logger.info(`Calling Slack API to send notification using token: ${secrets.SLACK_BOT_TOKEN.substring(0, 5)}...`);
    return { status: 'success' };
  }

  // Plaid (Bank Account Linking)
  private async simulatePlaidLink(customerId: string, bankDetails: any): Promise<any> {
    if (!secrets.PLAID_CLIENT_ID || secrets.PLAID_CLIENT_ID === "YOUR_PLAID_CLIENT_ID_HERE") {
      Logger.warn("Plaid API key not configured. Simulating Plaid Link.");
      return { status: 'success', accountId: `mock_plaid_acc_${Date.now()}`, message: 'Plaid Link simulated.' };
    }
    Logger.info(`Calling Plaid API for customer ${customerId} with env: ${secrets.PLAID_ENV}`);
    return { status: 'success', accountId: `real_plaid_acc_${Date.now()}` };
  }

  // Auth0 (User Management)
  private async simulateAuth0UserCreation(email: string, name: string, roles: string[]): Promise<any> {
    if (!secrets.AUTH0_DOMAIN || secrets.AUTH0_DOMAIN === "YOUR_AUTH0_DOMAIN_HERE") {
      Logger.warn("Auth0 configuration missing. Simulating user creation.");
      return { status: 'success', userId: `mock_auth0_user_${Date.now()}`, message: 'Auth0 user creation simulated.' };
    }
    Logger.info(`Calling Auth0 API to create user: ${email} (${name}) with roles: ${roles.join(', ')}`);
    return { status: 'success', userId: `real_auth0_user_${Date.now()}` };
  }

  // Xero (Accounting)
  private async simulateXeroInvoiceCreation(invoiceData: any): Promise<any> {
    if (!secrets.XERO_CLIENT_ID || secrets.XERO_CLIENT_ID === "YOUR_XERO_CLIENT_ID_HERE") {
      Logger.warn("Xero API key not configured. Simulating Xero invoice creation.");
      return { status: 'success', invoiceId: `mock_xero_inv_${Date.now()}`, message: 'Xero invoice creation simulated.' };
    }
    Logger.info(`Calling Xero API to create invoice with ID: ${secrets.XERO_CLIENT_ID.substring(0, 5)}...`);
    return { status: 'success', invoiceId: `real_xero_inv_${Date.now()}` };
  }

  // Zendesk (Support Ticketing)
  private async simulateZendeskTicketCreation(ticketData: any): Promise<any> {
    if (!secrets.ZENDESK_API_TOKEN || secrets.ZENDESK_API_TOKEN === "YOUR_ZENDESK_API_TOKEN_HERE") {
      Logger.warn("Zendesk API key not configured. Simulating Zendesk ticket creation.");
      return { status: 'success', ticketId: `mock_zd_tkt_${Date.now()}`, message: 'Zendesk ticket creation simulated.' };
    }
    Logger.info(`Calling Zendesk API to create ticket with token: ${secrets.ZENDESK_API_TOKEN.substring(0, 5)}...`);
    return { status: 'success', ticketId: `real_zd_tkt_${Date.now()}` };
  }

  // Calendly (Scheduling)
  private async simulateCalendlyScheduling(eventData: any): Promise<any> {
    if (!secrets.CALENDLY_API_KEY || secrets.CALENDLY_API_KEY === "YOUR_CALENDLY_API_KEY_HERE") {
      Logger.warn("Calendly API key not configured. Simulating Calendly scheduling.");
      return { status: 'success', eventId: `mock_cal_event_${Date.now()}`, message: 'Calendly scheduling simulated.' };
    }
    Logger.info(`Calling Calendly API to schedule event with key: ${secrets.CALENDLY_API_KEY.substring(0, 5)}...`);
    return { status: 'success', eventId: `real_cal_event_${Date.now()}` };
  }

  // Google Calendar (via Google Cloud API)
  private async simulateGoogleCalendarIntegration(eventData: any): Promise<any> {
    if (!secrets.GOOGLE_CLOUD_PROJECT_ID || secrets.GOOGLE_CLOUD_PROJECT_ID === "YOUR_GCP_PROJECT_ID_HERE") {
      Logger.warn("Google Cloud Project ID not configured. Simulating Google Calendar integration.");
      return { status: 'success', message: 'Google Calendar integration simulated.' };
    }
    Logger.info(`Calling Google Calendar API to create event in project: ${secrets.GOOGLE_CLOUD_PROJECT_ID}`);
    return { status: 'success' };
  }

  // Docusign (E-Signature)
  private async simulateDocusignSendDocument(documentData: any): Promise<any> {
    if (!secrets.DOCUSIGN_CLIENT_ID || secrets.DOCUSIGN_CLIENT_ID === "YOUR_DOCUSIGN_CLIENT_ID_HERE") {
      Logger.warn("Docusign API key not configured. Simulating Docusign document sending.");
      return { status: 'success', envelopeId: `mock_ds_env_${Date.now()}`, message: 'Docusign document sending simulated.' };
    }
    Logger.info(`Calling Docusign API to send document with client ID: ${secrets.DOCUSIGN_CLIENT_ID.substring(0, 5)}...`);
    return { status: 'success', envelopeId: `real_ds_env_${Date.now()}` };
  }

  // Intercom (Customer Messaging)
  private async simulateIntercomCreateConversation(conversationData: any): Promise<any> {
    if (!secrets.INTERCOM_API_KEY || secrets.INTERCOM_API_KEY === "YOUR_INTERCOM_API_KEY_HERE") {
      Logger.warn("Intercom API key not configured. Simulating Intercom conversation creation.");
      return { status: 'success', conversationId: `mock_int_conv_${Date.now()}`, message: 'Intercom conversation creation simulated.' };
    }
    Logger.info(`Calling Intercom API to create conversation with key: ${secrets.INTERCOM_API_KEY.substring(0, 5)}...`);
    return { status: 'success', conversationId: `real_int_conv_${Date.now()}` };
  }
}

const backendService = new BackendService();

// --- AuthContext.tsx ---
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const mockUsers: Record<string, User> = {
  "admin@veridian.com": { id: "user-123", email: "admin@veridian.com", name: "Alice Admin", organizationId: "org-abc", roles: ["admin", "finance"] },
  "finance@veridian.com": { id: "user-456", email: "finance@veridian.com", name: "Bob Finance", organizationId: "org-abc", roles: ["finance"] },
  "support@veridian.com": { id: "user-789", email: "support@veridian.com", name: "Charlie Support", organizationId: "org-abc", roles: ["support"] },
};

const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const storedUser = localStorage.getItem('currentUser');
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
    const matchedUser = mockUsers[email.toLowerCase()];

    if (matchedUser && password === "password123") { // Very simplified password check
      setUser(matchedUser);
      localStorage.setItem('currentUser', JSON.stringify(matchedUser));
      Logger.info(`User ${email} logged in.`);
    } else {
      Logger.error(`Login failed for ${email}`);
      throw new Error("Invalid credentials");
    }
    setIsLoading(false);
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('currentUser');
    Logger.info("User logged out.");
  };

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// ==============================================================================
// 2. Main Application Components (Navbar, Loader, Notification, LoginScreen, AI Orchestrator)
// ==============================================================================

// --- components/Navbar.tsx ---
const Navbar = () => {
  const { isAuthenticated, user, logout } = useAuth();
  return (
    <nav style={{
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: '10px 20px',
      backgroundColor: '#2c3e50',
      color: 'white',
      boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
    }}>
      <h2 style={{ margin: 0, fontSize: '1.5em' }}>Veridian Dynamics AI</h2>
      <div>
        {isAuthenticated ? (
          <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
            <span style={{ fontSize: '0.9em' }}>Welcome, {user?.name} ({user?.organizationId})</span>
            <button
              onClick={logout}
              style={{
                padding: '8px 15px',
                backgroundColor: '#e74c3c',
                color: 'white',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer',
                fontSize: '0.9em',
                transition: 'background-color 0.2s',
              }}
            >
              Logout
            </button>
          </div>
        ) : (
          <span style={{ fontSize: '0.9em' }}>Please log in</span>
        )}
      </div>
    </nav>
  );
};

// --- components/Loader.tsx ---
const Loader = ({ message = "Loading..." }: { message?: string }) => (
  <div style={{
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    padding: '20px',
    borderRadius: '8px',
    backgroundColor: 'rgba(255,255,255,0.9)',
    boxShadow: '0 4px 10px rgba(0,0,0,0.1)',
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    zIndex: 1000,
  }}>
    <div className="spinner" style={{
      border: '4px solid rgba(0, 123, 255, 0.1)',
      borderTop: '4px solid #007bff',
      borderRadius: '50%',
      width: '30px',
      height: '30px',
      animation: 'spin 1s linear infinite',
    }} />
    <style>{`
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `}</style>
    <p style={{ marginTop: '10px', color: '#333' }}>{message}</p>
  </div>
);


// --- components/Notification.tsx ---
interface NotificationProps {
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  onClose: () => void;
}

const Notification = ({ message, type, onClose }: NotificationProps) => {
  const bgColor = {
    success: '#d4edda',
    error: '#f8d7da',
    info: '#d1ecf1',
    warning: '#fff3cd',
  }[type];

  const textColor = {
    success: '#155724',
    error: '#721c24',
    info: '#0c5460',
    warning: '#856404',
  }[type];

  const borderColor = {
    success: '#c3e6cb',
    error: '#f5c6cb',
    info: '#bee5eb',
    warning: '#ffeeba',
  }[type];

  return (
    <div style={{
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      padding: '15px 20px',
      borderRadius: '8px',
      backgroundColor: bgColor,
      color: textColor,
      border: `1px solid ${borderColor}`,
      boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
      zIndex: 10000,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      minWidth: '250px',
    }}>
      <span>{message}</span>
      <button onClick={onClose} style={{
        background: 'none',
        border: 'none',
        fontSize: '1.2em',
        cursor: 'pointer',
        color: textColor,
        marginLeft: '15px',
      }}>
        &times;
      </button>
    </div>
  );
};

// --- components/LoginScreen.tsx ---
const LoginScreen = () => {
  const { login, isLoading } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    try {
      await login(email, password);
    } catch (err: any) {
      setError(err.message || "Login failed.");
    }
  };

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: 'calc(100vh - 70px)',
      backgroundColor: '#f0f2f5',
    }}>
      <form onSubmit={handleSubmit} style={{
        backgroundColor: 'white',
        padding: '40px',
        borderRadius: '10px',
        boxShadow: '0 4px 15px rgba(0,0,0,0.1)',
        width: '350px',
        display: 'flex',
        flexDirection: 'column',
        gap: '20px',
      }}>
        <h2 style={{ textAlign: 'center', color: '#333', marginBottom: '20px' }}>Login to Veridian Dynamics</h2>
        {error && <p style={{ color: '#e74c3c', textAlign: 'center' }}>{error}</p>}
        <div>
          <label htmlFor="email" style={{ display: 'block', marginBottom: '8px', color: '#555' }}>Email:</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="admin@veridian.com"
            required
            style={{
              width: '100%',
              padding: '12px',
              border: '1px solid #ddd',
              borderRadius: '5px',
              fontSize: '1em',
            }}
          />
        </div>
        <div>
          <label htmlFor="password" style={{ display: 'block', marginBottom: '8px', color: '#555' }}>Password:</label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="password123"
            required
            style={{
              width: '100%',
              padding: '12px',
              border: '1px solid #ddd',
              borderRadius: '5px',
              fontSize: '1em',
            }}
          />
        </div>
        <button
          type="submit"
          disabled={isLoading}
          style={{
            padding: '12px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            fontSize: '1.1em',
            cursor: 'pointer',
            transition: 'background-color 0.2s',
            opacity: isLoading ? 0.7 : 1,
          }}
        >
          {isLoading ? 'Logging in...' : 'Login'}
        </button>
        <p style={{ textAlign: 'center', color: '#777', fontSize: '0.9em' }}>
          Use <code style={{ backgroundColor: '#eee', padding: '2px 4px', borderRadius: '3px' }}>admin@veridian.com</code> / <code style={{ backgroundColor: '#eee', padding: '2px 4px', borderRadius: '3px' }}>password123</code> for demo.
        </p>
      </form>
    </div>
  );
};


// --- src/workflows/demo/EnterpriseAIWorkflowOrchestrator.tsx (renamed from EmbeddableFlowDemo.tsx conceptually) ---
function EnterpriseAIWorkflowOrchestrator() {
  const { user, isAuthenticated } = useAuth();
  const [conversation, setConversation] = useState<ChatMessage[]>([]);
  const [currentInput, setCurrentInput] = useState<string>('');
  const [isAITyping, setIsAITyping] = useState<boolean>(false);
  const [collectedData, setCollectedData] = useState<WorkflowData>({});
  const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' | 'info' | 'warning' } | null>(null);

  useEffect(() => {
    if (isAuthenticated && conversation.length === 0) {
      addMessage({
        id: `msg-${Date.now()}`,
        sender: 'ai',
        text: "Hello! I am Veridian AI, your enterprise workflow orchestrator. How can I assist you today? (e.g., 'Initiate a payment', 'Onboard a customer', 'Create a support ticket')",
        timestamp: new Date(),
        uiActions: [
          { label: 'Initiate Payment', type: 'button', action: 'choose_payment' },
          { label: 'Onboard User', type: 'button', action: 'choose_user_onboarding' },
          { label: 'Create Invoice', type: 'button', action: 'choose_create_invoice' },
        ],
      });
    }
  }, [isAuthenticated, conversation.length]);

  const addMessage = (msg: ChatMessage) => {
    setConversation(prev => [...prev, msg]);
  };

  const handleAIMessage = async (userMessageText: string, actionPayload?: any) => {
    setIsAITyping(true);
    const userMessage: ChatMessage = {
      id: `msg-${Date.now()}-user`,
      sender: 'user',
      text: userMessageText,
      timestamp: new Date(),
    };
    addMessage(userMessage);
    setCurrentInput('');

    try {
      if (!user) {
        throw new Error("User not authenticated.");
      }

      // If an action payload is provided (e.g., from a 'Confirm' button), execute it directly
      if (actionPayload && actionPayload.type === 'execute_workflow') {
        setNotification({ message: `Executing workflow: ${actionPayload.workflowName}...`, type: 'info' });
        const result = await backendService.callBackend(
          '/workflows/execute',
          'POST',
          {
            workflowName: actionPayload.workflowName,
            parameters: { ...actionPayload.parameters, organizationId: user.organizationId, userId: user.id }
          },
          user.id,
          user.organizationId
        );

        if (result.status === 'success') {
          addMessage({
            id: `msg-${Date.now()}-ai-action-success`,
            sender: 'ai',
            text: `${result.message} Would you like to start another flow or view your dashboard?`,
            timestamp: new Date(),
            status: 'success',
            uiActions: [
              { label: 'Start New Workflow', type: 'button', action: 'start_new_workflow' },
              { label: 'View Dashboard', type: 'button', action: 'view_dashboard' },
            ],
            metadata: result.data,
          });
          setNotification({ message: result.message, type: 'success' });
          setCollectedData({}); // Reset collected data after successful workflow
        } else {
          addMessage({
            id: `msg-${Date.now()}-ai-action-failure`,
            sender: 'ai',
            text: `Workflow failed: ${result.message}. Please try again or provide more details.`,
            timestamp: new Date(),
            status: 'error',
            uiActions: [{ label: 'Try Again', type: 'button', action: 'retry_last_action' }],
            metadata: result.data,
          });
          setNotification({ message: `Workflow failed: ${result.message}`, type: 'error' });
        }
      } else {
        // Normal Gemini interaction
        const aiResponse = await geminiClient.generateResponse(conversation, userMessageText, user, collectedData);
        if (aiResponse.action) {
          // Gemini proposed an action, usually for confirmation
          addMessage({
            id: `msg-${Date.now()}-ai`,
            sender: 'ai',
            text: aiResponse.text,
            timestamp: new Date(),
            uiActions: aiResponse.uiActions,
            metadata: aiResponse.action, // Store the action proposal
          });
          setNotification({ message: aiResponse.action.confirmationMessage, type: 'info' });
        } else {
          // Gemini just responded conversationally
          addMessage({
            id: `msg-${Date.now()}-ai`,
            sender: 'ai',
            text: aiResponse.text,
            timestamp: new Date(),
            uiActions: aiResponse.uiActions,
          });
        }
      }

    } catch (error: any) {
      Logger.error("Failed to process Gemini interaction or backend call", error);
      addMessage({
        id: `msg-${Date.now()}-error`,
        sender: 'ai',
        text: `I apologize, an unexpected error occurred: ${error.message}. Please try refreshing or contact support.`,
        timestamp: new Date(),
        status: 'error',
      });
      setNotification({ message: `Error: ${error.message}`, type: 'error' });
    } finally {
      setIsAITyping(false);
    }
  };

  const handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
    if (event.key === 'Enter' && currentInput.trim() && !isAITyping) {
      handleAIMessage(currentInput.trim());
    }
  };

  const handleUIAction = (action: WorkflowAction) => {
    Logger.debug("UI Action triggered:", action);
    if (!user) {
      setNotification({ message: "Please log in to perform actions.", type: 'warning' });
      return;
    }

    switch (action.action) {
      case 'start_new_workflow':
        addMessage({
          id: `msg-${Date.now()}-ai-reset`,
          sender: 'ai',
          text: "Great! What workflow would you like to explore next? You can say 'Initiate Payment', 'Account Collection', 'User Onboarding', 'Create Invoice', 'Create Support Ticket', 'Schedule Meeting', etc.",
          timestamp: new Date(),
          uiActions: [
            { label: 'Initiate Payment', type: 'button', action: 'choose_payment' },
            { label: 'Onboard User', type: 'button', action: 'choose_user_onboarding' },
            { label: 'Create Invoice', type: 'button', action: 'choose_create_invoice' },
            { label: 'Schedule Meeting', type: 'button', action: 'choose_schedule_meeting' },
            { label: 'Create Support Ticket', type: 'button', action: 'choose_create_support_ticket' },
          ],
        });
        setCollectedData({});
        break;
      case 'view_dashboard':
        setNotification({ message: "Navigating to dashboard (simulated)...", type: 'info' });
        // In a real app, this would be a router navigation: navigate('/dashboard');
        break;
      case 'confirm_action':
        if (action.payload) {
          handleAIMessage("Confirm", action.payload); // Send "Confirm" along with the original payload
        }
        break;
      case 'cancel_action':
        handleAIMessage("Cancel");
        setNotification({ message: "Action cancelled.", type: 'info' });
        setCollectedData({});
        break;
      case 'retry_last_action':
        const lastUserMsg = conversation.findLast(msg => msg.sender === 'user');
        if (lastUserMsg) {
          handleAIMessage(lastUserMsg.text);
        } else {
          setNotification({ message: "No previous action to retry.", type: 'warning' });
        }
        break;
      // Direct command actions based on UI buttons
      case 'choose_payment':
      case 'choose_account_collection':
      case 'choose_user_onboarding':
      case 'choose_create_invoice':
      case 'choose_create_support_ticket':
      case 'choose_schedule_meeting':
        const command = action.label; // e.g., "Initiate Payment"
        handleAIMessage(command);
        break;
      default:
        setNotification({ message: `Unknown UI action: ${action.label}`, type: 'warning' });
        Logger.warn("Unhandled UI action:", action);
    }
  };

  const chatContainerRef = React.useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [conversation]);

  if (!isAuthenticated) {
    return <LoginScreen />;
  }

  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      height: 'calc(100vh - 70px)', // Adjust for Navbar height
      maxWidth: '1000px',
      margin: '0 auto',
      border: '1px solid #ddd',
      borderRadius: '10px',
      overflow: 'hidden',
      backgroundColor: '#f5f7fa',
      fontFamily: 'Roboto, Arial, sans-serif',
      boxShadow: '0 5px 20px rgba(0,0,0,0.1)',
      position: 'relative',
    }}>
      <h1 style={{
        fontSize: '1.8em',
        padding: '15px 20px',
        margin: 0,
        backgroundColor: '#3498db',
        color: 'white',
        borderBottom: '1px solid #2980b9',
        textAlign: 'center',
      }}>
        Veridian Dynamics AI Orchestrator
      </h1>

      <div
        ref={chatContainerRef}
        style={{
          flex: 1,
          padding: '20px',
          overflowY: 'auto',
          display: 'flex',
          flexDirection: 'column',
          gap: '15px',
        }}
      >
        {conversation.map((msg) => (
          <div
            key={msg.id}
            style={{
              alignSelf: msg.sender === 'user' ? 'flex-end' : 'flex-start',
              backgroundColor: msg.sender === 'user' ? '#e0f7fa' : (msg.status === 'error' ? '#fde0e0' : '#ffffff'),
              color: msg.status === 'error' ? '#c0392b' : '#333',
              padding: '12px 18px',
              borderRadius: '20px',
              maxWidth: '75%',
              boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
              whiteSpace: 'pre-wrap',
              fontSize: '0.95em',
            }}
          >
            <strong style={{ color: msg.sender === 'user' ? '#007bff' : '#28a745' }}>{msg.sender === 'user' ? 'You' : 'Veridian AI'}:</strong> {msg.text}
            {msg.uiActions && msg.uiActions.length > 0 && (
              <div style={{ marginTop: '10px', display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                {msg.uiActions.map((action, idx) => (
                  <button
                    key={idx}
                    onClick={() => handleUIAction(action)}
                    style={{
                      padding: '8px 12px',
                      backgroundColor: action.type === 'button' ? '#28a745' : '#6c757d',
                      color: 'white',
                      border: 'none',
                      borderRadius: '15px',
                      cursor: 'pointer',
                      fontSize: '0.85em',
                      transition: 'background-color 0.2s',
                      fontWeight: 'bold',
                    }}
                  >
                    {action.label}
                  </button>
                ))}
              </div>
            )}
          </div>
        ))}
        {isAITyping && (
          <div style={{
            alignSelf: 'flex-start',
            backgroundColor: '#f0f0f0',
            padding: '12px 18px',
            borderRadius: '20px',
            maxWidth: '75%',
            boxShadow: '0 2px 4px rgba(0,0,0,0.05)',
            fontSize: '0.95em',
            color: '#777',
          }}>
            Veridian AI is typing...
          </div>
        )}
      </div>

      <div style={{
        borderTop: '1px solid #eee',
        padding: '15px',
        display: 'flex',
        gap: '10px',
        backgroundColor: '#f1f1f1',
      }}>
        <input
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder={isAITyping ? "Please wait for AI response..." : "Type your message here..."}
          disabled={isAITyping}
          style={{
            flex: 1,
            padding: '12px 18px',
            border: '1px solid #ddd',
            borderRadius: '25px',
            fontSize: '1em',
            outline: 'none',
            transition: 'border-color 0.2s, box-shadow 0.2s',
            boxShadow: isAITyping ? 'none' : '0 0 5px rgba(0, 123, 255, 0.1)',
            backgroundColor: isAITyping ? '#e9ecef' : 'white',
            cursor: isAITyping ? 'not-allowed' : 'text',
          }}
        />
        <button
          onClick={() => currentInput.trim() && !isAITyping && handleAIMessage(currentInput.trim())}
          disabled={!currentInput.trim() || isAITyping}
          style={{
            padding: '12px 25px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '25px',
            fontSize: '1em',
            cursor: 'pointer',
            transition: 'background-color 0.2s, opacity 0.2s',
            opacity: (!currentInput.trim() || isAITyping) ? 0.6 : 1,
            fontWeight: 'bold',
          }}
        >
          Send
        </button>
      </div>
      {notification && (
        <Notification
          message={notification.message}
          type={notification.type}
          onClose={() => setNotification(null)}
        />
      )}
    </div>
  );
}

// Main Application Wrapper
function App() {
  const { isLoading: authLoading } = useAuth();

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100vh', margin: 0, padding: 0 }}>
      <Navbar />
      {authLoading ? (
        <Loader message="Authenticating..." />
      ) : (
        <EnterpriseAIWorkflowOrchestrator />
      )}
    </div>
  );
}

// This is the actual root component rendering the entire app.
// The original EmbeddableFlowsDemoContainer now acts as the entry point
// wrapping the main App with authentication context.
function EmbeddableFlowsDemoContainer() {
  return (
    <AuthProvider>
      <App />
    </AuthProvider>
  );
}

export default EmbeddableFlowsDemoContainer;