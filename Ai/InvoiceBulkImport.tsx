// Copyright CDBI (Cognitive Data-driven Business Intelligence) Inc.
// President CDBI AI Powered Treasury

import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateInvoicesMutation,
  useBulkValidateInvoiceImportMutation,
} from "~/generated/dashboard/graphqlSchema";
import { BulkResourceType } from "./FlatfileBulkUploadButton";
import BulkImportHeader from "./BulkImportHeader";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import {
  invoiceBlueprint,
  invoiceBlueprintFields,
} from "./bulk_imports/blueprints/invoiceBlueprint";

// --- CDBI AI Powered Modules ---

/**
 * @interface CDBIInvoiceInsight
 * @description Represents a structured insight generated by the AI for a single invoice.
 */
export interface CDBIInvoiceInsight {
  invoiceId?: string; // Optional, might not exist pre-creation
  rowIdentifier: number; // Row index in the bulk import (1-based)
  type: "anomaly" | "fraud" | "prediction" | "categorization" | "compliance" | "warning" | "info";
  message: string;
  severity: "critical" | "high" | "medium" | "low" | "none" | "info";
  suggestedAction?: string;
  details?: Record<string, any>; // More specific data related to the insight
  kpisAffected?: string[]; // List of KPIs that this insight relates to
  chartRecommendations?: string[]; // Suggested charts for this insight
}

/**
 * @interface CDBIAIAnalysisResult
 * @description Aggregated result from the AI analysis of multiple invoices.
 */
export interface CDBIAIAnalysisResult {
  overallStatus: "success" | "warning" | "error";
  insights: CDBIInvoiceInsight[];
  summaryKpis: Record<string, number | string>;
  chartData: Record<string, any>; // Data structured for various charts
}

/**
 * @class CDBIAIInvoiceProcessor
 * @description Central AI engine for processing and analyzing invoice data.
 * This class simulates advanced AI capabilities like anomaly detection, fraud detection,
 * payment prediction, and intelligent categorization. It is designed to be self-contained
 * for its core AI logic.
 */
export class CDBIAIInvoiceProcessor {
  private invoices: Array<Record<string, CellValueUnion | null>>;

  constructor(invoices: Array<Record<string, CellValueUnion | null>>) {
    this.invoices = invoices;
  }

  /**
   * @method generateInvoiceId
   * @description Generates a deterministic, unique ID for an invoice based on its content hash.
   * This is crucial for linking AI insights to specific invoices before they are persisted in a DB.
   * In a real-world scenario, this might involve a more robust hashing algorithm or a temporary UUID.
   */
  private generateInvoiceId(invoiceData: Record<string, CellValueUnion | null>): string {
    const relevantFields = ["invoiceNumber", "vendorName", "amount", "dueDate"];
    const hashableString = relevantFields
      .map(field => String(invoiceData[field] || ""))
      .join("|");
    // Simple Base64 hash for demo purposes. Real AI would use a more robust ID generation.
    return btoa(hashableString).substring(0, 12);
  }

  /**
   * @method analyzeInvoices
   * @description Performs a comprehensive AI analysis of all invoices.
   * Combines anomaly detection, fraud detection, payment prediction, and categorization.
   * @returns {Promise<CDBIAIAnalysisResult>} An aggregated result of all AI insights.
   */
  public async analyzeInvoices(): Promise<CDBIAIAnalysisResult> {
    let overallStatus: "success" | "warning" | "error" = "success";
    const allInsights: CDBIInvoiceInsight[] = [];
    const summaryKpis: Record<string, number | string> = {
      totalInvoices: this.invoices.length,
      anomaliesDetected: 0,
      potentialFraudCases: 0,
      autoCategorized: 0,
      highRiskPayments: 0,
      complianceWarnings: 0,
    };
    const chartData: Record<string, any> = {
      anomalyTypeDistribution: {},
      fraudRiskScoreDistribution: {},
      paymentDelayDistribution: {},
      categoryDistribution: {},
      complianceSeverityDistribution: {},
      cashFlowProjection: {}, // Data for amount by due date
    };

    for (let i = 0; i < this.invoices.length; i++) {
      const invoice = this.invoices[i];
      const rowIdentifier = i + 1;
      const invoiceId = this.generateInvoiceId(invoice); // Generate a temporary ID

      // 1. Anomaly Detection
      const anomalies = this.detectAnomalies(invoice, rowIdentifier, invoiceId);
      if (anomalies.length > 0) {
        if (overallStatus === "success") overallStatus = "warning";
        anomalies.forEach(a => {
          allInsights.push(a);
          summaryKpis.anomaliesDetected = (summaryKpis.anomaliesDetected as number) + 1;
          const anomalyType = a.details?.type || "General";
          chartData.anomalyTypeDistribution[anomalyType] = (chartData.anomalyTypeDistribution[anomalyType] || 0) + 1;
        });
      }

      // 2. Fraud Detection
      const fraudAlerts = this.detectFraud(invoice, rowIdentifier, invoiceId);
      if (fraudAlerts.length > 0) {
        overallStatus = "error"; // Fraud is typically critical
        fraudAlerts.forEach(f => {
          allInsights.push(f);
          summaryKpis.potentialFraudCases = (summaryKpis.potentialFraudCases as number) + 1;
          const riskScore = f.details?.riskScore || 0;
          const bucket = riskScore >= 80 ? 'High' : riskScore >= 50 ? 'Medium' : 'Low';
          chartData.fraudRiskScoreDistribution[bucket] = (chartData.fraudRiskScoreDistribution[bucket] || 0) + 1;
        });
      }

      // 3. Payment Prediction & Cash Flow Impact
      const paymentPrediction = this.predictPayments(invoice, rowIdentifier, invoiceId);
      if (paymentPrediction) {
        allInsights.push(paymentPrediction);
        if (paymentPrediction.severity === "high") {
            summaryKpis.highRiskPayments = (summaryKpis.highRiskPayments as number) + 1;
        }
        if (paymentPrediction.details?.predictedDelayDays > 0) {
            chartData.paymentDelayDistribution[`${paymentPrediction.details.predictedDelayDays} days`] = (chartData.paymentDelayDistribution[`${paymentPrediction.details.predictedDelayDays} days`] || 0) + 1;
        }

        // Add to total amount by due date for cash flow forecast
        const dueDate = invoice.dueDate as string;
        const amount = typeof invoice.amount === 'number' ? invoice.amount : parseFloat(String(invoice.amount || 0));
        if (dueDate && !isNaN(amount)) {
            chartData.cashFlowProjection[dueDate] = (chartData.cashFlowProjection[dueDate] || 0) + amount;
        }
      }

      // 4. Automated Categorization
      const categorization = this.categorizeInvoice(invoice, rowIdentifier, invoiceId);
      if (categorization) {
        allInsights.push(categorization);
        summaryKpis.autoCategorized = (summaryKpis.autoCategorized as number) + 1;
        const category = categorization.details?.predictedCategory || 'Uncategorized';
        chartData.categoryDistribution[category] = (chartData.categoryDistribution[category] || 0) + 1;
      }

      // 5. Compliance Check
      const complianceChecks = this.checkCompliance(invoice, rowIdentifier, invoiceId);
      if (complianceChecks.length > 0) {
        if (overallStatus === "success") overallStatus = "warning"; // Upgrade status if not already error
        complianceChecks.forEach(c => {
          allInsights.push(c);
          summaryKpis.complianceWarnings = (summaryKpis.complianceWarnings as number) + 1;
          chartData.complianceSeverityDistribution[c.severity] = (chartData.complianceSeverityDistribution[c.severity] || 0) + 1;
        });
      }
    }

    // Sort insights by severity (critical > high > medium > low > none > info)
    const severityOrder = { "critical": 0, "high": 1, "medium": 2, "low": 3, "none": 4, "info": 5, "warning": 6 };
    allInsights.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

    return {
      overallStatus,
      insights: allInsights,
      summaryKpis,
      chartData,
    };
  }

  /**
   * @method detectAnomalies
   * @description AI-powered anomaly detection for invoice data.
   * This would typically involve machine learning models trained on historical invoice patterns.
   * For this demo, it's rule-based.
   */
  private detectAnomalies(
    invoice: Record<string, CellValueUnion | null>,
    rowIdentifier: number,
    invoiceId: string,
  ): CDBIInvoiceInsight[] {
    const anomalies: CDBIInvoiceInsight[] = [];
    const amount = typeof invoice.amount === 'number' ? invoice.amount : parseFloat(String(invoice.amount || 0));
    const dueDate = invoice.dueDate as string;
    const invoiceNumber = invoice.invoiceNumber as string;
    const vendorName = invoice.vendorName as string;

    // Rule 1: Very high or very low amounts
    if (amount > 100000) {
      anomalies.push({
        invoiceId, rowIdentifier,
        type: "anomaly",
        message: `Unusually high invoice amount detected ($${amount}). Review for potential errors.`,
        severity: "high",
        suggestedAction: "Verify invoice amount against contract/PO.",
        details: { field: "amount", value: amount, anomalyType: "HighValue" },
        kpisAffected: ["anomaliesDetected", "highValueInvoiceAnomalies"],
        chartRecommendations: ["AnomalyTrendChart", "HighValueInvoiceDistribution"],
      });
    } else if (amount < 10 && amount > 0) {
      anomalies.push({
        invoiceId, rowIdentifier,
        type: "anomaly",
        message: `Unusually low invoice amount detected ($${amount}). Confirm accuracy.`,
        severity: "medium",
        suggestedAction: "Check for missing line items or data entry errors.",
        details: { field: "amount", value: amount, anomalyType: "LowValue" },
        kpisAffected: ["anomaliesDetected", "lowValueInvoiceAnomalies"],
        chartRecommendations: ["AnomalyTrendChart", "LowValueInvoiceDistribution"],
      });
    }

    // Rule 2: Duplicate invoice numbers or suspicious patterns
    if (invoiceNumber && String(invoiceNumber).match(/(copy|duplicate|re-submit)/i)) {
      anomalies.push({
        invoiceId, rowIdentifier,
        type: "anomaly",
        message: `Invoice number "${invoiceNumber}" suggests a potential duplicate or re-submission.`,
        severity: "medium",
        suggestedAction: "Cross-reference with existing invoices for this vendor.",
        details: { field: "invoiceNumber", value: invoiceNumber, anomalyType: "DuplicatePattern" },
        kpisAffected: ["anomaliesDetected", "duplicateInvoiceNumbers"],
        chartRecommendations: ["InvoiceNumberPatternAnalysis"],
      });
    }

    // Rule 3: Due date significantly in the past or far in the future
    try {
      const parsedDueDate = new Date(dueDate);
      const now = new Date();
      const oneYearInFuture = new Date();
      oneYearInFuture.setFullYear(now.getFullYear() + 1);
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(now.getDate() - 90);

      if (parsedDueDate < ninetyDaysAgo) {
        anomalies.push({
          invoiceId, rowIdentifier,
          type: "anomaly",
          message: `Invoice due date (${dueDate}) is significantly in the past. Expedite payment or dispute.`,
          severity: "high",
          suggestedAction: "Investigate payment status and potential late fees.",
          details: { field: "dueDate", value: dueDate, anomalyType: "PastDueDate" },
          kpisAffected: ["anomaliesDetected", "overdueInvoices"],
          chartRecommendations: ["AgingReportChart"],
        });
      } else if (parsedDueDate > oneYearInFuture) {
        anomalies.push({
          invoiceId, rowIdentifier,
          type: "anomaly",
          message: `Invoice due date (${dueDate}) is unusually far in the future. Confirm payment terms.`,
          severity: "low",
          suggestedAction: "Verify payment terms with vendor.",
          details: { field: "dueDate", value: dueDate, anomalyType: "FutureDueDate" },
          kpisAffected: ["anomaliesDetected", "futureDatedInvoices"],
          chartRecommendations: ["FuturePaymentCommitment"],
        });
      }
    } catch (e: any) {
      anomalies.push({
        invoiceId, rowIdentifier,
        type: "warning",
        message: `Invalid due date format: "${dueDate}". Please correct.`,
        severity: "medium",
        suggestedAction: "Correct due date format to YYYY-MM-DD.",
        details: { field: "dueDate", value: dueDate, error: e.message, anomalyType: "DateFormat" },
        kpisAffected: ["dataQualityIssues"],
        chartRecommendations: ["DataQualityReport"],
      });
    }

    // Rule 4: Unusual vendor name length or character patterns
    if (vendorName && (vendorName.length < 3 || vendorName.length > 50)) { // Example heuristic
        anomalies.push({
            invoiceId, rowIdentifier,
            type: "anomaly",
            message: `Unusual vendor name length for "${vendorName}". Review for potential typos or suspicious entities.`,
            severity: "low",
            suggestedAction: "Verify vendor details.",
            details: { field: "vendorName", value: vendorName, anomalyType: "VendorNamePattern" },
            kpisAffected: ["anomaliesDetected", "vendorNameIrregularities"],
            chartRecommendations: ["VendorNameAnalytics"],
        });
    }

    return anomalies;
  }

  /**
   * @method detectFraud
   * @description AI-powered fraud detection.
   * This would involve sophisticated machine learning models, graph analytics (for vendor relationships),
   * and potentially external data sources. For this demo, it's rule-based and simplified.
   */
  private detectFraud(
    invoice: Record<string, CellValueUnion | null>,
    rowIdentifier: number,
    invoiceId: string,
  ): CDBIInvoiceInsight[] {
    const fraudAlerts: CDBIInvoiceInsight[] = [];
    const vendorName = invoice.vendorName as string;
    const amount = typeof invoice.amount === 'number' ? invoice.amount : parseFloat(String(invoice.amount || 0));
    const poNumber = invoice.poNumber as string;

    // Rule 1: High-risk vendor names
    if (vendorName && vendorName.toLowerCase().includes("solutions ltd") && amount > 5000) {
      fraudAlerts.push({
        invoiceId, rowIdentifier,
        type: "fraud",
        message: `Potential high-risk vendor name pattern combined with high amount. Investigate "${vendorName}".`,
        severity: "critical",
        suggestedAction: "Verify vendor legitimacy and bank details independently.",
        details: { field: "vendorName", value: vendorName, riskScore: 90, fraudType: "SuspiciousVendor" },
        kpisAffected: ["potentialFraudCases", "highRiskVendors"],
        chartRecommendations: ["FraudRiskHeatmap", "VendorRiskProfile"],
      });
    }

    // Rule 2: Invoices with large round numbers
    if (amount % 1000 === 0 && amount > 10000) {
        fraudAlerts.push({
            invoiceId, rowIdentifier,
            type: "fraud",
            message: `Invoice amount ($${amount}) is a large round number, sometimes indicative of fraudulent activity.`,
            severity: "medium",
            suggestedAction: "Request detailed breakdown of services/goods.",
            details: { field: "amount", value: amount, riskScore: 60, fraudType: "RoundNumber" },
            kpisAffected: ["potentialFraudCases", "roundNumberInvoices"],
            chartRecommendations: ["InvoiceAmountDistribution", "FraudPatternAnalysis"],
        });
    }

    // Rule 3: Missing key information for large amounts
    if (amount > 5000 && !poNumber) {
      fraudAlerts.push({
        invoiceId, rowIdentifier,
        type: "fraud",
        message: `High-value invoice ($${amount}) missing a Purchase Order (PO) number. This is a common fraud indicator.`,
        severity: "high",
        suggestedAction: "Reject invoice until valid PO is provided or confirm exemption.",
        details: { field: "poNumber", value: poNumber, riskScore: 85, fraudType: "MissingPO" },
        kpisAffected: ["potentialFraudCases", "missingPOForHighValue"],
        chartRecommendations: ["POComplianceRate", "FraudIndicatorTrend"],
      });
    }

    // Rule 4: Invoices from new, unvetted vendors with unusually high amounts (simulated)
    const isNewVendor = Math.random() < 0.1; // Simulate 10% chance of being a "new" vendor
    if (isNewVendor && amount > 20000) {
        fraudAlerts.push({
            invoiceId, rowIdentifier,
            type: "fraud",
            message: `New vendor "${vendorName}" with high-value invoice ($${amount}). Requires enhanced due diligence.`,
            severity: "high",
            suggestedAction: "Perform a comprehensive vendor background check.",
            details: { field: "vendorName", value: vendorName, riskScore: 75, fraudType: "NewVendorHighValue" },
            kpisAffected: ["potentialFraudCases", "newVendorRisk"],
            chartRecommendations: ["NewVendorRiskAssessment"],
        });
    }

    return fraudAlerts;
  }

  /**
   * @method predictPayments
   * @description AI-driven payment prediction for cash flow optimization.
   * Predicts optimal payment date, potential late payments, and early payment discount opportunities.
   * This would involve time series forecasting, historical payment behavior analysis.
   */
  private predictPayments(
    invoice: Record<string, CellValueUnion | null>,
    rowIdentifier: number,
    invoiceId: string,
  ): CDBIInvoiceInsight | null {
    const dueDateStr = invoice.dueDate as string;
    const terms = invoice.paymentTerms as string; // e.g., "Net 30", "Net 60"
    const amount = typeof invoice.amount === 'number' ? invoice.amount : parseFloat(String(invoice.amount || 0));

    try {
      const dueDate = new Date(dueDateStr);
      const now = new Date();

      if (isNaN(dueDate.getTime())) {
          return null; // Can't predict without a valid due date
      }

      // Simulate payment behavior prediction (e.g., based on historical vendor payment speed)
      let predictedPaymentDelayDays = 0; // Simulate AI predicting 0-5 days delay for some vendors
      if (invoice.vendorName && String(invoice.vendorName).includes("DelayCorp")) { // Example
        predictedPaymentDelayDays = 3;
      } else if (invoice.vendorName && String(invoice.vendorName).includes("FastPay Inc.")) {
        predictedPaymentDelayDays = -5; // Paid 5 days early
      }

      const predictedPaymentDate = new Date(dueDate);
      predictedPaymentDate.setDate(dueDate.getDate() + predictedPaymentDelayDays);

      let severity: "high" | "medium" | "low" | "none" | "info" = "info";
      let message = `Optimal payment expected by ${predictedPaymentDate.toISOString().split('T')[0]}.`;
      let suggestedAction = "Process for timely payment.";

      if (predictedPaymentDate < now && predictedPaymentDelayDays >= 0) { // If it's predicted overdue
        const daysOverdue = Math.abs(Math.ceil((now.getTime() - predictedPaymentDate.getTime()) / (1000 * 60 * 60 * 24)));
        message = `AI predicts this invoice is already overdue or will be paid late by ${daysOverdue} days.`;
        severity = "high";
        suggestedAction = "Expedite payment immediately to avoid late fees and impact on vendor relations.";
      } else if (predictedPaymentDelayDays > 0) { // If potential future delay
        message = `AI predicts potential ${predictedPaymentDelayDays} day payment delay for this invoice. Due: ${dueDateStr}, Predicted: ${predictedPaymentDate.toISOString().split('T')[0]}.`;
        severity = "medium";
        suggestedAction = "Monitor payment status closely or contact vendor to confirm.";
      }

      // Early payment discount prediction
      if (terms && terms.includes("2/10 Net 30") && amount > 1000 && predictedPaymentDelayDays <= 0) {
        message += ` Opportunity for 2% early payment discount if paid within 10 days.`;
        suggestedAction += " Consider early payment to capture discount.";
        if (severity === "info") severity = "info"; // Keep info if it's just an opportunity
      }

      return {
        invoiceId, rowIdentifier,
        type: "prediction",
        message,
        severity,
        suggestedAction,
        details: {
          dueDate: dueDateStr,
          predictedPaymentDate: predictedPaymentDate.toISOString().split('T')[0],
          paymentTerms: terms,
          predictedDelayDays: predictedPaymentDelayDays,
          amount: amount,
        },
        kpisAffected: ["paymentPredictionAccuracy", "cashFlowForecastImpact", "earlyPaymentDiscountOpportunities", "latePaymentRisk"],
        chartRecommendations: ["CashFlowProjection", "PaymentPerformanceByVendor", "EarlyPaymentDiscountCaptureRate"],
      };
    } catch (e: any) {
      return {
        invoiceId, rowIdentifier,
        type: "warning",
        message: `Could not predict payment for invoice due to invalid date/terms: ${e.message}`,
        severity: "low",
        suggestedAction: "Verify date and payment terms format.",
        details: { error: e.message, predictionType: "DataIssue" },
        kpisAffected: ["dataQualityIssues"],
        chartRecommendations: ["DataQualityReport"],
      };
    }
  }

  /**
   * @method categorizeInvoice
   * @description AI-powered invoice categorization/coding.
   * Uses historical data, vendor names, and line item descriptions to suggest or auto-assign G/L codes.
   */
  private categorizeInvoice(
    invoice: Record<string, CellValueUnion | null>,
    rowIdentifier: number,
    invoiceId: string,
  ): CDBIInvoiceInsight | null {
    const vendorName = String(invoice.vendorName || "").toLowerCase();
    const description = String(invoice.description || "").toLowerCase(); // Assuming a general description field

    let predictedCategory = "Uncategorized";
    let confidence = 0.6; // Simulate AI confidence score

    if (vendorName.includes("google") || description.includes("advertising") || description.includes("adwords")) {
      predictedCategory = "Marketing & Advertising";
      confidence = 0.95;
    } else if (vendorName.includes("aws") || vendorName.includes("azure") || description.includes("cloud services") || description.includes("server hosting")) {
      predictedCategory = "IT Infrastructure";
      confidence = 0.92;
    } else if (vendorName.includes("office supply") || description.includes("stationery") || description.includes("ink cartridges")) {
      predictedCategory = "Office Supplies";
      confidence = 0.88;
    } else if (vendorName.includes("consulting") || description.includes("advisory services")) {
      predictedCategory = "Professional Services";
      confidence = 0.80;
    } else if (description.includes("travel") || description.includes("flight") || description.includes("hotel") || description.includes("airline")) {
      predictedCategory = "Travel Expenses";
      confidence = 0.85;
    } else if (description.includes("rent") || description.includes("utilities") || description.includes("electricity") || description.includes("water bill")) {
        predictedCategory = "Facilities & Utilities";
        confidence = 0.75;
    } else if (description.includes("software license") || description.includes("subscription fee")) {
        predictedCategory = "Software Subscriptions";
        confidence = 0.90;
    }

    if (predictedCategory !== "Uncategorized") {
      return {
        invoiceId, rowIdentifier,
        type: "categorization",
        message: `AI suggests category: "${predictedCategory}" with ${Math.round(confidence * 100)}% confidence.`,
        severity: "info",
        suggestedAction: "Review and confirm AI-suggested category or manually re-assign.",
        details: { predictedCategory, confidence },
        kpisAffected: ["autoCategorizedRate", "categorizationAccuracy"],
        chartRecommendations: ["CategoryDistributionChart", "AIConfidenceScoreDistribution"],
      };
    }

    return null;
  }

  /**
   * @method checkCompliance
   * @description AI-assisted compliance checking.
   * Flags invoices that might violate internal policies, regulatory requirements, or tax rules.
   * This would involve a knowledge base of rules and NLP for understanding invoice content.
   */
  private checkCompliance(
    invoice: Record<string, CellValueUnion | null>,
    rowIdentifier: number,
    invoiceId: string,
  ): CDBIInvoiceInsight[] {
    const complianceIssues: CDBIInvoiceInsight[] = [];
    const amount = typeof invoice.amount === 'number' ? invoice.amount : parseFloat(String(invoice.amount || 0));
    const vendorCountry = String(invoice.vendorCountry || "").toLowerCase(); // Assuming a field for vendor country
    const invoiceCurrency = String(invoice.currency || "USD").toUpperCase();
    const invoiceDateStr = invoice.invoiceDate as string;

    // Rule 1: High-value invoices requiring special approval (e.g., >$25k)
    if (amount > 25000) {
      complianceIssues.push({
        invoiceId, rowIdentifier,
        type: "compliance",
        message: `High-value invoice ($${amount}) detected, requires special approval flow.`,
        severity: "medium",
        suggestedAction: "Route invoice for higher-level management approval.",
        details: { policy: "HighValueApproval", threshold: 25000, value: amount },
        kpisAffected: ["complianceWarnings", "highValueApprovalRate"],
        chartRecommendations: ["ApprovalWorkflowCompliance", "ComplianceIssueSeverity"],
      });
    }

    // Rule 2: Invoices from restricted countries (e.g., sanctions list)
    if (["iran", "north korea", "syria", "cuba"].includes(vendorCountry)) { // Example list
      complianceIssues.push({
        invoiceId, rowIdentifier,
        type: "compliance",
        message: `Invoice from a sanctioned country (${vendorCountry}). This is a critical compliance violation.`,
        severity: "critical",
        suggestedAction: "Immediately flag for legal review and block payment.",
        details: { policy: "SanctionsCompliance", country: vendorCountry },
        kpisAffected: ["complianceWarnings", "sanctionedCountryInvoices"],
        chartRecommendations: ["GeopoliticalRiskMap", "CriticalComplianceAlerts"],
      });
    }

    // Rule 3: Currency mismatch or unusual currency for vendor location
    if (vendorCountry === "canada" && invoiceCurrency !== "CAD" && invoiceCurrency !== "USD") { // Example
        complianceIssues.push({
            invoiceId, rowIdentifier,
            type: "compliance",
            message: `Currency mismatch: Vendor in Canada (${vendorCountry}) but invoice is in ${invoiceCurrency}.`,
            severity: "low",
            suggestedAction: "Verify correct currency and exchange rates.",
            details: { policy: "CurrencyVerification", expected: "CAD/USD", actual: invoiceCurrency },
            kpisAffected: ["complianceWarnings", "currencyMismatchIssues"],
            chartRecommendations: ["CurrencyErrorRate"],
        });
    }

    // Rule 4: Invoice date is in the future
    try {
        const invoiceDate = new Date(invoiceDateStr);
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Normalize today's date

        if (invoiceDate > today) {
            complianceIssues.push({
                invoiceId, rowIdentifier,
                type: "compliance",
                message: `Invoice date (${invoiceDateStr}) is in the future, which might indicate a data entry error or an invalid invoice.`,
                severity: "medium",
                suggestedAction: "Verify the invoice date with the vendor.",
                details: { policy: "FutureDatedInvoice", date: invoiceDateStr },
                kpisAffected: ["complianceWarnings", "futureDatedInvoiceCount"],
                chartRecommendations: ["InvoiceDateCompliance"],
            });
        }
    } catch (e: any) {
        complianceIssues.push({
            invoiceId, rowIdentifier,
            type: "warning",
            message: `Invalid invoice date format: "${invoiceDateStr}". Cannot perform date compliance check.`,
            severity: "low",
            suggestedAction: "Correct invoice date format to YYYY-MM-DD.",
            details: { field: "invoiceDate", value: invoiceDateStr, error: e.message },
            kpisAffected: ["dataQualityIssues"],
            chartRecommendations: ["DataQualityReport"],
        });
    }

    return complianceIssues;
  }
}

/**
 * @class CDBIAIGeminiAnalyticsService
 * @description A conceptual service to integrate with Google Gemini for advanced analytics and visualization.
 * This class simulates sending KPIs and chart data to a powerful AI analytics platform.
 */
export class CDBIAIGeminiAnalyticsService {
  private analyticsEndpoint: string; // This would be a real API endpoint

  constructor(endpoint: string = "https://api.gemini.ai/cdbi-analytics/v1") {
    this.analyticsEndpoint = endpoint;
  }

  /**
   * @method sendKPIsToGemini
   * @description Sends a set of Key Performance Indicators to Gemini for dashboarding and monitoring.
   * @param {Record<string, number | string>} kpis - A dictionary of KPI names and their values.
   * @param {string} context - A description of the data context (e.g., "Invoice Bulk Import Analysis").
   * @returns {Promise<boolean>} True if successful, false otherwise.
   */
  public async sendKPIsToGemini(kpis: Record<string, number | string>, context: string): Promise<boolean> {
    console.log(`CDBIAIGeminiAnalyticsService: Sending ${Object.keys(kpis).length} KPIs to Gemini for context: "${context}"`);
    console.log("KPIs:", kpis);
    // In a real application, this would involve an actual API call:
    // try {
    //   const response = await fetch(`${this.analyticsEndpoint}/kpis`, {
    //     method: 'POST',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify({ kpis, context, timestamp: new Date().toISOString() }),
    //   });
    //   return response.ok;
    // } catch (error) {
    //   console.error("Failed to send KPIs to Gemini:", error);
    //   return false;
    // }
    return true; // Simulate success
  }

  /**
   * @method generateAndSendChartDataToGemini
   * @description Sends data for chart generation and visualization to Gemini.
   * Gemini's AI could then interpret this data and suggest the best chart types.
   * @param {Record<string, any>} chartData - Structured data for various charts.
   * @param {string} chartTypeHint - An optional hint for Gemini about the preferred chart type.
   * @param {string} title - Title for the chart.
   * @param {CDBIInvoiceInsight[]} [insights] - Optional array of insights linked to this chart.
   * @returns {Promise<boolean>} True if successful, false otherwise.
   */
  public async generateAndSendChartDataToGemini(
    chartData: Record<string, any>,
    chartTypeHint: string,
    title: string,
    insights?: CDBIInvoiceInsight[],
  ): Promise<boolean> {
    console.log(`CDBIAIGeminiAnalyticsService: Sending chart data for "${title}" (Hint: ${chartTypeHint}) to Gemini.`);
    console.log("Chart Data:", chartData);
    if (insights && insights.length > 0) {
      console.log(`Associated Insights (${insights.length} total):`, insights.map(i => `${i.type} (${i.severity})`));
    }
    // In a real application, this would involve an actual API call:
    // try {
    //   const response = await fetch(`${this.analyticsEndpoint}/charts`, {
    //     method: 'POST',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify({ chartData, chartTypeHint, title, insights, timestamp: new Date().toISOString() }),
    //   });
    //   return response.ok;
    // } catch (error) {
    //   console.error("Failed to send chart data to Gemini:", error);
    //   return false;
    // }
    return true; // Simulate success
  }

    /**
   * @method getSuggestedKPIsAndCharts
   * @description Queries Gemini for suggested KPIs and charts based on analysis results.
   * This represents an advanced, dynamic interaction where Gemini provides recommendations.
   * @param {CDBIAIAnalysisResult} analysisResult - The AI analysis result.
   * @returns {Promise<{ kpis: Record<string, number | string>, charts: Array<{ title: string, data: any, type: string }> }>}
   */
  public async getSuggestedKPIsAndCharts(analysisResult: CDBIAIAnalysisResult): Promise<{ kpis: Record<string, number | string>, charts: Array<{ title: string, data: any, type: string }> }> {
    console.log("CDBIAIGeminiAnalyticsService: Requesting suggested KPIs and charts from Gemini based on analysis.");
    // Simulate Gemini's response based on the analysis result.
    // In a real scenario, Gemini would use its intelligence to parse 'analysisResult'
    // and provide relevant, dynamic visualizations.

    const suggestedKpis: Record<string, number | string> = {
        ...analysisResult.summaryKpis,
        aiOverallStatus: analysisResult.overallStatus,
        criticalInsightsCount: analysisResult.insights.filter(i => i.severity === 'critical').length,
        highInsightsCount: analysisResult.insights.filter(i => i.severity === 'high').length,
        mediumInsightsCount: analysisResult.insights.filter(i => i.severity === 'medium').length,
    };

    const suggestedCharts: Array<{ title: string, data: any, type: string }> = [];

    // Add charts based on analysisResult.chartData
    if (Object.keys(analysisResult.chartData.anomalyTypeDistribution).length > 0) {
        suggestedCharts.push({
            title: "Anomaly Type Distribution",
            data: analysisResult.chartData.anomalyTypeDistribution,
            type: "pie"
        });
    }
    if (Object.keys(analysisResult.chartData.fraudRiskScoreDistribution).length > 0) {
        suggestedCharts.push({
            title: "Fraud Risk Score Distribution",
            data: analysisResult.chartData.fraudRiskScoreDistribution,
            type: "bar"
        });
    }
    if (Object.keys(analysisResult.chartData.cashFlowProjection).length > 0) {
        // Transform cashFlowProjection to an array of {date: string, amount: number} for line chart
        const cashFlowData = Object.entries(analysisResult.chartData.cashFlowProjection)
                                 .map(([date, amount]) => ({ date, amount }))
                                 .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
        suggestedCharts.push({
            title: "Cash Flow Forecast (Amounts by Due Date)",
            data: cashFlowData,
            type: "line"
        });
    }
    if (Object.keys(analysisResult.chartData.categoryDistribution).length > 0) {
        suggestedCharts.push({
            title: "AI Predicted Invoice Categories",
            data: analysisResult.chartData.categoryDistribution,
            type: "bar"
        });
    }
    if (Object.keys(analysisResult.chartData.complianceSeverityDistribution).length > 0) {
        suggestedCharts.push({
            title: "Compliance Issue Severity",
            data: analysisResult.chartData.complianceSeverityDistribution,
            type: "doughnut"
        });
    }
    if (Object.keys(analysisResult.chartData.paymentDelayDistribution).length > 0) {
        suggestedCharts.push({
            title: "Predicted Payment Delay Distribution",
            data: analysisResult.chartData.paymentDelayDistribution,
            type: "bar"
        });
    }


    console.log("Gemini Suggested KPIs:", suggestedKpis);
    console.log("Gemini Suggested Charts:", suggestedCharts);

    return { kpis: suggestedKpis, charts: suggestedCharts };
  }
}

// --- Main Component ---

/**
 * @function InvoiceBulkImport
 * @description Provides an interface for bulk importing invoices, now enhanced with CDBI AI capabilities.
 * It integrates an AI processor for advanced validation, fraud detection, payment prediction,
 * and categorization before submitting invoices. KPIs and chart data are linked to Gemini for analytics.
 * This component is self-contained with its AI logic and analytics integration.
 */
function InvoiceBulkImport(): JSX.Element {
  const [bulkCreateInvoices] = useBulkCreateInvoicesMutation();
  const [bulkValidateInvoiceImport] = useBulkValidateInvoiceImportMutation();

  // Initialize AI services using React.useMemo to ensure single instance per component lifecycle
  const cdbiGeminiAnalytics = React.useMemo(() => new CDBIAIGeminiAnalyticsService(), []);

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    // Pre-submission AI analysis for final review and enrichment
    console.log("CDBI AI: Performing final AI analysis before submission...");
    const aiProcessor = new CDBIAIInvoiceProcessor(resultsData);
    const aiAnalysisResult = await aiProcessor.analyzeInvoices();

    // Send summary KPIs and chart data to Gemini *before* actual submission to track pre-processing impact
    await cdbiGeminiAnalytics.sendKPIsToGemini(aiAnalysisResult.summaryKpis, "Pre-Submission Invoice AI Analysis");
    // Send all generated chart data to Gemini
    for (const chartKey in aiAnalysisResult.chartData) {
        // Map chartKey to a more human-readable title and appropriate chartTypeHint
        let chartTitle = chartKey.replace(/([A-Z])/g, ' $1').trim();
        let chartType = "bar"; // Default chart type hint
        if (chartKey === "cashFlowProjection") chartType = "line";
        else if (chartKey.includes("Distribution")) chartType = "pie";

        await cdbiGeminiAnalytics.generateAndSendChartDataToGemini(
            aiAnalysisResult.chartData[chartKey],
            chartType,
            `AI Insights: ${chartTitle}`,
            aiAnalysisResult.insights.filter(i => i.chartRecommendations?.some(rec => rec.includes(chartKey))) // Link relevant insights
        );
    }

    // Optionally, block submission or require override if critical issues are found
    const criticalIssues = aiAnalysisResult.insights.filter(
      (i) => i.severity === "critical" || i.severity === "high"
    );
    if (criticalIssues.length > 0) {
      console.warn(`CDBI AI: ${criticalIssues.length} Critical/High severity issues detected. Submission might be blocked or require override.`);
      // In a real UI, you'd present these issues to the user and ask for confirmation.
      // For this example, we'll proceed but log the warning. A more advanced system
      // might throw an error here or return { success: false } if strict policy is enabled.
    }

    // Enrich the resultsData with AI insights before sending to the backend,
    // allowing the backend to store or act upon these AI-derived fields.
    const enrichedResultsData = resultsData.map((invoice, index) => {
        const insightsForInvoice = aiAnalysisResult.insights.filter(i => i.rowIdentifier === index + 1);
        const categories = insightsForInvoice
            .filter(i => i.type === 'categorization' && i.details?.predictedCategory)
            .map(i => i.details?.predictedCategory);
        const fraudRiskScore = insightsForInvoice
            .filter(i => i.type === 'fraud' && i.details?.riskScore)
            .map(i => i.details?.riskScore);
        const anomalyTypes = insightsForInvoice
            .filter(i => i.type === 'anomaly' && i.details?.anomalyType)
            .map(i => i.details?.anomalyType);

        return {
            ...invoice,
            cdbi_ai_insights_summary: insightsForInvoice.map(i => ({
                type: i.type,
                severity: i.severity,
                message: i.message,
                suggestedAction: i.suggestedAction,
                details: i.details // Full details can be stored if backend supports rich JSON
            })),
            cdbi_ai_predicted_category: categories.length > 0 ? categories[0] : null,
            cdbi_ai_fraud_risk_score: fraudRiskScore.length > 0 ? fraudRiskScore[0] : null,
            cdbi_ai_detected_anomaly_types: anomalyTypes.length > 0 ? anomalyTypes : null,
            // Add other AI-derived fields as needed for backend persistence
        };
    });


    console.log("CDBI AI: Submitting invoices after AI pre-processing...");
    const { data } = await bulkCreateInvoices({
      variables: {
        input: {
          invoices: enrichedResultsData as Array<Record<string, CellValueUnion | null>>, // Cast back to original type for GraphQL
          flatfileSheetId,
          flatfileSpaceId,
        },
      },
    });
    const { bulkImportId } = data?.bulkCreateInvoices ?? {};

    // Post-submission analytics
    if (bulkImportId) {
      console.log(`CDBI AI: Bulk import successful with ID ${bulkImportId}. Sending post-submission KPIs to Gemini.`);
      await cdbiGeminiAnalytics.sendKPIsToGemini(
        {
          ...aiAnalysisResult.summaryKpis, // Include pre-submission KPIs
          successfulImports: enrichedResultsData.length,
          bulkImportId: bulkImportId,
          aiImpactRating: criticalIssues.length > 0 ? "High" : (aiAnalysisResult.insights.length > 0 ? "Medium" : "Low"),
          submissionTimestamp: new Date().toISOString(),
        },
        "Post-Submission Invoice Import Success"
      );
      return { success: true, bulkImportId };
    } else {
      console.error("CDBI AI: Bulk import failed. Sending failure metrics to Gemini.");
      await cdbiGeminiAnalytics.sendKPIsToGemini(
        {
          ...aiAnalysisResult.summaryKpis,
          successfulImports: 0,
          aiImpactRating: "Critical - Import Failure",
          failureReason: "Backend_Error", // Placeholder: replace with actual backend error reason
          submissionTimestamp: new Date().toISOString(),
        },
        "Post-Submission Invoice Import Failure"
      );
      return { success: false, bulkImportId: "" };
    }
  };

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    // Standard backend validation via GraphQL
    const response = await bulkValidateInvoiceImport({
      variables: {
        input: {
          invoiceLineItemRows: resultsData,
        },
      },
    });
    const backendErrors = response.data?.bulkValidateInvoiceImport?.recordErrors || [];

    // CDBI AI-powered advanced validation and insights
    console.log("CDBI AI: Performing advanced AI validation and generating insights...");
    const aiProcessor = new CDBIAIInvoiceProcessor(resultsData);
    const aiAnalysisResult = await aiProcessor.analyzeInvoices();

    // Merge backend errors with AI insights
    const mergedErrors: Array<Record<string, any>> = [...backendErrors];

    aiAnalysisResult.insights.forEach((insight) => {
        // Map AI insight to a Flatfile-compatible error structure if needed,
        // or display them separately in the UI. For this example, we'll simulate a Flatfile-like structure.
        mergedErrors.push({
            id: insight.rowIdentifier.toString(), // Flatfile typically uses row IDs (or unique identifiers)
            row: insight.rowIdentifier - 1, // Flatfile row index is 0-based
            field: insight.details?.field || "general",
            message: `[AI ${insight.type.toUpperCase()}] ${insight.message} (Severity: ${insight.severity.toUpperCase()}). Suggested: ${insight.suggestedAction || 'N/A'}`,
            level: insight.severity === "critical" || insight.severity === "high" ? "error" : "info", // Map severity to Flatfile levels
            meta: insight // Store full insight in meta for detailed display in a UI
        });
    });

    // Send AI-derived KPIs and potential charts to Gemini for immediate feedback
    // First, send the raw summary KPIs from the AI analysis
    await cdbiGeminiAnalytics.sendKPIsToGemini(aiAnalysisResult.summaryKpis, "Real-time Invoice Validation AI Analysis (Raw)");

    // Then, ask Gemini for more refined/suggested KPIs and charts based on the full analysis result
    const { kpis: suggestedKpis, charts: suggestedCharts } = await cdbiGeminiAnalytics.getSuggestedKPIsAndCharts(aiAnalysisResult);

    // Send these Gemini-suggested KPIs to Gemini itself (demonstrates feedback loop)
    await cdbiGeminiAnalytics.sendKPIsToGemini(suggestedKpis, "Gemini Refined Invoice Validation KPIs");

    // Send the Gemini-suggested charts to Gemini for visualization
    for (const chart of suggestedCharts) {
        await cdbiGeminiAnalytics.generateAndSendChartDataToGemini(
            chart.data,
            chart.type,
            `Gemini Suggested: ${chart.title}`,
            aiAnalysisResult.insights // Send all insights for context
        );
    }

    return mergedErrors.length > 0 ? mergedErrors : undefined;
  };

  return (
    <PageHeader
      crumbs={[
        {
          name: "Invoices",
          path: "/invoicing/invoices",
        },
      ]}
      title="CDBI AI Powered Bulk Invoice Imports"
    >
      <BulkImportHeader
        bulkImportType="Invoice"
        validate={validate}
        submit={submit}
        expectedFields={invoiceBlueprintFields}
        blueprint={invoiceBlueprint}
        resource={BulkResourceType.Invoices}
        // An extension point: a prop to display AI insights directly in the UI if needed
        // aiAnalysisComponent={<CDBIAIInsightsDisplayComponent insights={aiInsights} />}
      />
    </PageHeader>
  );
}

export default InvoiceBulkImport;