// Copyright CDBI Inc.

import React, { useCallback, useState, useEffect } from "react";
import { ClipLoader } from "react-spinners";
import isEmpty from "lodash/isEmpty";
import { Field, FieldProps, Form, Formik, FormikHelpers } from "formik";
import { sanitizeMetadata } from "../actions";
import { Button, KeyValueTable, Stack } from "../../common/ui-components";
import MetadataInput from "./MetadataInput";
import { ResourcesEnum } from "../../generated/dashboard/types/resources";

// --- New AI-Powered Types and Interfaces ---

/**
 * Represents a single AI-generated metadata suggestion.
 * @typedef {Object} AISuggestion
 * @property {string} key - The suggested metadata key.
 * @property {string} value - The suggested metadata value.
 * @property {string} rationale - A brief explanation from the AI for the suggestion.
 * @property {number} confidence - A score (0-1) indicating AI's confidence in the suggestion.
 */
export interface AISuggestion {
  key: string;
  value: string;
  rationale: string;
  confidence: number;
}

/**
 * Represents an AI-driven insight about the metadata.
 * @typedef {Object} AIInsight
 * @property {string} title - A brief title for the insight.
 * @property {string} description - A detailed explanation of the insight.
 * @property {'info' | 'warning' | 'error' | 'success'} type - The severity or type of the insight.
 * @property {string[]} relatedKeys - Metadata keys related to this insight.
 */
export interface AIInsight {
  title: string;
  description: string;
  type: "info" | "warning" | "error" | "success";
  relatedKeys?: string[];
}

/**
 * Represents a Key Performance Indicator (KPI) generated by AI, linked to Gemini for analysis.
 * @typedef {Object} AI_KPI
 * @property {string} id - Unique identifier for the KPI.
 * @property {string} name - Display name of the KPI.
 * @property {string | number} value - Current value of the KPI.
 * @property {string} unit - Unit of measurement (e.g., '%', 'count').
 * @property {string} description - Detailed description of what the KPI measures.
 * @property {string} trend - Optional, 'up' | 'down' | 'stable'.
 * @property {string} trendDescription - Optional, explanation of the trend.
 * @property {string} geminiAnalysisLink - A simulated link to a detailed Gemini analysis for this KPI.
 */
export interface AI_KPI {
  id: string;
  name: string;
  value: string | number;
  unit?: string;
  description?: string;
  trend?: "up" | "down" | "stable";
  trendDescription?: string;
  geminiAnalysisLink?: string; // Link to a more detailed Gemini AI analysis dashboard/report
}

/**
 * Represents data for an AI-generated chart, linked to Gemini.
 * @typedef {Object} AI_ChartData
 * @property {string} id - Unique identifier for the chart.
 * @property {string} title - Title of the chart.
 * @property {'bar' | 'line' | 'pie' | 'table'} type - Type of chart to render.
 * @property {any} data - Chart data in a generic format (would be specific to a charting library).
 * @property {any} options - Chart options (would be specific to a charting library).
 * @property {string} description - Description of what the chart represents.
 * @property {string} geminiAnalysisLink - A simulated link to a detailed Gemini analysis for this chart.
 */
export interface AI_ChartData {
  id: string;
  title: string;
  type: "bar" | "line" | "pie" | "table"; // Example chart types
  data: any; // Data structure would depend on the charting library
  options?: any; // Options for the chart
  description?: string;
  geminiAnalysisLink?: string; // Link to a more detailed Gemini AI analysis dashboard/report
}

/**
 * The combined output from a Gemini-powered AI analysis.
 * @typedef {Object} AIGeminiAnalysisResult
 * @property {AISuggestion[]} suggestions - Suggested metadata key-value pairs.
 * @property {AIInsight[]} insights - AI-driven insights about the metadata.
 * @property {AI_KPI[]} kpis - Key Performance Indicators derived from metadata.
 * @property {AI_ChartData[]} charts - Data structures for potential charts.
 */
export interface AIGeminiAnalysisResult {
  suggestions: AISuggestion[];
  insights: AIInsight[];
  kpis: AI_KPI[];
  charts: AI_ChartData[];
}

// --- AI Simulation Functions (would typically be API calls to a Gemini-powered backend) ---

/**
 * Simulates an API call to a Gemini-powered AI service for metadata analysis.
 * This function is designed to be highly advanced, leveraging large language models
 * to understand context, infer meaning, and generate intelligent suggestions, insights,
 * and performance indicators.
 * @param {Record<string, string>} currentMetadata - The metadata currently being viewed/edited.
 * @param {ResourcesEnum} resourceType - The type of resource the metadata belongs to (e.g., 'account', 'transaction').
 * @param {string} userId - Identifier for the current user to personalize AI responses.
 * @returns {Promise<AIGeminiAnalysisResult>} A promise that resolves with AI suggestions, insights, KPIs, and chart data.
 */
export async function analyzeMetadataWithGemini(
  currentMetadata: Record<string, string>,
  resourceType: ResourcesEnum,
  userId: string = "cdbi-user-123", // Default user ID for demonstration
): Promise<AIGeminiAnalysisResult> {
  // In a real-world application, this would be an API call to a backend service
  // that integrates with Google's Gemini AI. The backend would handle:
  // 1. Sending currentMetadata and resourceType to Gemini.
  // 2. Prompt engineering to guide Gemini's analysis for suggestions, insights, KPIs.
  // 3. Parsing Gemini's response into structured JSON (AISuggestion[], AIInsight[], AI_KPI[], AI_ChartData[]).
  // 4. Potentially fetching historical data or user preferences to enrich Gemini's context.

  console.log(
    `[CDBI AI] Calling Gemini for analysis on resource '${resourceType}' with metadata:`,
    currentMetadata,
  );
  console.log(`[CDBI AI] User Context: ${userId}`);

  // Simulate network delay for AI processing
  await new Promise((resolve) => setTimeout(resolve, 2000));

  // --- Dynamic AI Response Generation Logic (simulated) ---
  // This logic is designed to be highly dynamic, mimicking Gemini's ability to
  // generate relevant content based on input.

  const suggestions: AISuggestion[] = [];
  const insights: AIInsight[] = [];
  const kpis: AI_KPI[] = [];
  const charts: AI_ChartData[] = [];

  // General suggestions based on common patterns
  if (!currentMetadata["category"]) {
    suggestions.push({
      key: "category",
      value: "FinancialService",
      rationale:
        "Based on common financial resource patterns, 'category' is a frequently used metadata key.",
      confidence: 0.85,
    });
  }
  if (!currentMetadata["tags"] && Math.random() > 0.5) {
    suggestions.push({
      key: "tags",
      value: "AI-Enhanced, Secure",
      rationale:
        "Suggesting common tags for advanced financial services and security.",
      confidence: 0.78,
    });
  }

  // Resource-specific suggestions
  if (resourceType === ResourcesEnum.Account) {
    if (!currentMetadata["account_type"]) {
      suggestions.push({
        key: "account_type",
        value: "Savings",
        rationale: "Common metadata key for financial accounts.",
        confidence: 0.9,
      });
    }
    if (!currentMetadata["risk_level"]) {
      suggestions.push({
        key: "risk_level",
        value: "Low",
        rationale:
          "AI assessment suggests a 'Low' risk level based on typical new account profiles.",
        confidence: 0.7,
      });
    }
    insights.push({
      title: "Account Metadata Completeness",
      description: `AI suggests reviewing account-specific metadata. Missing keys include: ${[
        "account_type",
        "risk_level",
      ]
        .filter((k) => !currentMetadata[k])
        .join(", ")}.`,
      type: "info",
      relatedKeys: ["account_type", "risk_level"],
    });
    kpis.push({
      id: "account_meta_comp",
      name: "Account Metadata Completeness Score",
      value:
        (Object.keys(currentMetadata).length / 5) * 100 > 100
          ? 100
          : (Object.keys(currentMetadata).length / 5) * 100, // Dummy score
      unit: "%",
      description: "Percentage of recommended account metadata fields populated.",
      geminiAnalysisLink:
        "https://gemini.google.com/analysis/account_completeness",
    });
  } else if (resourceType === ResourcesEnum.Transaction) {
    if (!currentMetadata["merchant_category"]) {
      suggestions.push({
        key: "merchant_category",
        value: "E-commerce",
        rationale: "Common metadata key for transaction categorization.",
        confidence: 0.88,
      });
    }
    if (!currentMetadata["transaction_priority"]) {
      suggestions.push({
        key: "transaction_priority",
        value: "Normal",
        rationale:
          "AI suggests 'Normal' priority for standard transactions.",
        confidence: 0.65,
      });
    }
    insights.push({
      title: "Transaction Anomaly Detection",
      description:
        "AI detected no significant anomalies in transaction metadata. All values appear consistent with historical patterns.",
      type: "success",
    });
    kpis.push({
      id: "transaction_anomaly_rate",
      name: "Transaction Metadata Anomaly Rate",
      value: 0,
      unit: "%",
      description: "Percentage of transaction metadata flagged as anomalous by AI.",
      geminiAnalysisLink:
        "https://gemini.google.com/analysis/transaction_anomalies",
    });

    // Simulate chart data for transactions
    charts.push({
      id: "transaction_category_distribution",
      title: "AI-Analyzed Transaction Category Distribution",
      type: "pie",
      data: {
        labels: ["E-commerce", "Utilities", "Food", "Other"],
        datasets: [
          {
            data: [
              Math.random() * 40 + 20,
              Math.random() * 20 + 10,
              Math.random() * 20 + 10,
              Math.random() * 10 + 5,
            ],
            backgroundColor: ["#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0"],
            hoverBackgroundColor: ["#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0"],
          },
        ],
      },
      description: "Distribution of transaction categories based on AI analysis of metadata.",
      geminiAnalysisLink:
        "https://gemini.google.com/analysis/transaction_category_chart",
    });
  }

  // AI-powered data quality check
  const hasInvalidChars = Object.values(currentMetadata).some((v) =>
    /[^a-zA-Z0-9\s_-]/.test(v),
  );
  if (hasInvalidChars) {
    insights.push({
      title: "Metadata Quality Alert",
      description:
        "AI detected special characters in some metadata values. Consider standardizing for better searchability and data integrity.",
      type: "warning",
      relatedKeys: Object.keys(currentMetadata).filter((k) =>
        /[^a-zA-Z0-9\s_-]/.test(currentMetadata[k]),
      ),
    });
    kpis.push({
      id: "data_quality_score",
      name: "Metadata Data Quality Score",
      value: 75, // Simulated lower score due to detected issues
      unit: "/100",
      description: "AI-driven score for the overall quality and consistency of metadata.",
      trend: "down",
      trendDescription: "Potential issues with special characters detected.",
      geminiAnalysisLink: "https://gemini.google.com/analysis/data_quality",
    });
  } else if (Object.keys(currentMetadata).length > 0) {
    insights.push({
      title: "Metadata Quality",
      description:
        "AI assessment indicates high quality and consistency in current metadata entries.",
      type: "success",
    });
    kpis.push({
      id: "data_quality_score",
      name: "Metadata Data Quality Score",
      value: 98,
      unit: "/100",
      description: "AI-driven score for the overall quality and consistency of metadata.",
      trend: "up",
      trendDescription: "Consistent and well-formed metadata observed.",
      geminiAnalysisLink: "https://gemini.google.com/analysis/data_quality",
    });
  }

  // Add a general KPI for AI suggestion adoption (simulated)
  kpis.push({
    id: "ai_suggestion_adoption",
    name: "AI Suggestion Adoption Rate",
    value: Math.floor(Math.random() * 100), // Random for simulation
    unit: "%",
    description: "Percentage of AI-suggested metadata fields that are adopted by users.",
    trend: "stable",
    geminiAnalysisLink:
      "https://gemini.google.com/analysis/suggestion_adoption",
  });

  return { suggestions, insights, kpis, charts };
}

// --- AI-Powered Components ---

/**
 * A placeholder component to display AI-generated KPIs.
 * In a real application, this would use a charting library (e.g., Chart.js, Recharts).
 */
export const AI_KPIDisplay: React.FC<{ kpis: AI_KPI[] }> = ({ kpis }) => {
  if (isEmpty(kpis)) return null;
  return (
    <Stack className="ai-kpi-display mt-4 gap-4 p-4 rounded-md bg-cdbi-blue-50 border border-cdbi-blue-100">
      <h3 className="text-lg font-semibold text-cdbi-blue-800">
        AI-Powered Key Performance Indicators
      </h3>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
        {kpis.map((kpi) => (
          <div
            key={kpi.id}
            className="bg-white p-4 rounded-md shadow-sm border border-alpha-black-50 flex flex-col justify-between"
          >
            <div className="flex items-center justify-between">
              <p className="text-sm font-medium text-gray-600">{kpi.name}</p>
              {kpi.trend && (
                <span
                  className={`text-xs font-semibold px-2 py-1 rounded-full ${
                    kpi.trend === "up"
                      ? "bg-green-100 text-green-700"
                      : kpi.trend === "down"
                      ? "bg-red-100 text-red-700"
                      : "bg-gray-100 text-gray-700"
                  }`}
                  title={kpi.trendDescription}
                >
                  {kpi.trend === "up" && "▲"}
                  {kpi.trend === "down" && "▼"}
                  {kpi.trend === "stable" && "●"}
                </span>
              )}
            </div>
            <p className="text-2xl font-bold text-cdbi-blue-700 mt-1">
              {kpi.value}
              {kpi.unit && <span className="text-lg font-normal ml-1">{kpi.unit}</span>}
            </p>
            {kpi.description && (
              <p className="text-xs text-gray-500 mt-1">{kpi.description}</p>
            )}
            {kpi.geminiAnalysisLink && (
              <a
                href={kpi.geminiAnalysisLink}
                target="_blank"
                rel="noopener noreferrer"
                className="text-cdbi-blue-600 hover:underline text-xs mt-2"
              >
                View Gemini Analysis →
              </a>
            )}
          </div>
        ))}
      </div>
    </Stack>
  );
};

/**
 * A placeholder component to display AI-generated charts.
 * In a real application, this would render actual charts using a library.
 */
export const AI_ChartDisplay: React.FC<{ charts: AI_ChartData[] }> = ({
  charts,
}) => {
  if (isEmpty(charts)) return null;

  const renderChartPlaceholder = (chart: AI_ChartData) => {
    // This is a simple placeholder. In a real app, you'd use a charting library
    // like Chart.js, Recharts, or D3.js here based on chart.type.
    return (
      <div
        key={chart.id}
        className="bg-white p-4 rounded-md shadow-sm border border-alpha-black-50 h-64 flex flex-col justify-between"
      >
        <h4 className="text-md font-semibold text-gray-800">{chart.title}</h4>
        <div className="flex-grow flex items-center justify-center text-gray-400 text-sm italic">
          [Placeholder for {chart.type} chart]
          <br />
          Data: {JSON.stringify(chart.data).substring(0, 50)}...
        </div>
        {chart.description && (
          <p className="text-xs text-gray-500 mt-2">{chart.description}</p>
        )}
        {chart.geminiAnalysisLink && (
          <a
            href={chart.geminiAnalysisLink}
            target="_blank"
            rel="noopener noreferrer"
            className="text-cdbi-blue-600 hover:underline text-xs mt-2"
          >
            View Gemini Analysis →
          </a>
        )}
      </div>
    );
  };

  return (
    <Stack className="ai-chart-display mt-4 gap-4 p-4 rounded-md bg-cdbi-blue-50 border border-cdbi-blue-100">
      <h3 className="text-lg font-semibold text-cdbi-blue-800">
        AI-Powered Visualizations
      </h3>
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        {charts.map(renderChartPlaceholder)}
      </div>
    </Stack>
  );
};

/**
 * A component to display AI-driven insights.
 */
export const AI_InsightDisplay: React.FC<{ insights: AIInsight[] }> = ({
  insights,
}) => {
  if (isEmpty(insights)) return null;
  return (
    <Stack className="ai-insight-display mt-4 gap-2">
      <h3 className="text-lg font-semibold text-cdbi-blue-800">
        AI Insights & Recommendations
      </h3>
      {insights.map((insight, index) => (
        <div
          key={index}
          className={`p-3 rounded-md border ${
            insight.type === "error"
              ? "bg-red-50 border-red-200 text-red-800"
              : insight.type === "warning"
              ? "bg-yellow-50 border-yellow-200 text-yellow-800"
              : insight.type === "success"
              ? "bg-green-50 border-green-200 text-green-800"
              : "bg-blue-50 border-blue-200 text-blue-800"
          }`}
        >
          <p className="font-semibold">{insight.title}</p>
          <p className="text-sm">{insight.description}</p>
          {insight.relatedKeys && insight.relatedKeys.length > 0 && (
            <p className="text-xs mt-1">
              Related Keys:{" "}
              <span className="font-mono">{insight.relatedKeys.join(", ")}</span>
            </p>
          )}
        </div>
      ))}
    </Stack>
  );
};

// --- Custom Hooks for AI Logic ---

/**
 * Custom hook to manage AI-powered metadata suggestions, insights, KPIs, and charts.
 * It fetches AI analysis based on the current metadata and resource type.
 */
export const useAIInsightsAndSuggestions = (
  initialMetadata: Record<string, string>,
  resource: ResourcesEnum,
  enabled: boolean,
) => {
  const [aiResult, setAiResult] = useState<AIGeminiAnalysisResult | null>(null);
  const [aiLoading, setAiLoading] = useState(false);
  const [aiError, setAiError] = useState<string | null>(null);

  const fetchAIAnalysis = useCallback(async () => {
    if (!enabled || isEmpty(initialMetadata)) {
      setAiResult(null); // Clear previous results if not enabled or no metadata
      setAiLoading(false);
      return;
    }

    setAiLoading(true);
    setAiError(null);
    try {
      const result = await analyzeMetadataWithGemini(
        initialMetadata,
        resource,
      );
      setAiResult(result);
    } catch (err) {
      console.error("[CDBI AI] Error fetching AI analysis:", err);
      setAiError("Failed to fetch AI analysis. Please try again.");
      setAiResult(null);
    } finally {
      setAiLoading(false);
    }
  }, [initialMetadata, resource, enabled]);

  // Fetch AI analysis when initialMetadata or resource changes
  useEffect(() => {
    fetchAIAnalysis();
  }, [fetchAIAnalysis]);

  return { aiResult, aiLoading, aiError, refetchAIAnalysis: fetchAIAnalysis };
};

// --- Main MetadataView Component ---

type MetadataViewProps<T> = {
  initialMetadata: { key: string; value: string }[];
  saveEntity?: (metadata: Record<string, string>) => Promise<T>;
  enableActions: boolean;
  resource: ResourcesEnum;
};

function MetadataView<T>({
  initialMetadata,
  enableActions,
  saveEntity,
  resource,
}: MetadataViewProps<T>) {
  const [isAdding, setIsAdding] = useState(false);
  // Convert initialMetadata to a Record<string, string> for AI analysis
  const initialMetadataRecord = initialMetadata.reduce(
    (acc, item) => ({ ...acc, [item.key]: item.value }),
    {},
  );

  const { aiResult, aiLoading, aiError, refetchAIAnalysis } =
    useAIInsightsAndSuggestions(
      initialMetadataRecord,
      resource,
      true, // Always enable AI for this advanced component
    );

  const onSubmit = useCallback(
    (
      metadata: Record<string, string>,
      actions: FormikHelpers<{
        metadata: Record<string, string>;
      }>,
    ) => {
      if (saveEntity) {
        saveEntity(metadata).then(
          () => {
            setIsAdding(false);
            actions.setSubmitting(false);
            // After successful save, refetch AI analysis to get updated insights
            void refetchAIAnalysis();
          },
          (error) => {
            console.error("Failed to save metadata:", error);
            actions.setSubmitting(false);
            actions.setStatus({
              message: "Failed to save metadata. Please try again.",
            });
          },
        );
      } else {
        // If no saveEntity function is provided, just close the form
        setIsAdding(false);
        actions.setSubmitting(false);
      }
    },
    [saveEntity, refetchAIAnalysis],
  );

  const onClick = useCallback(() => setIsAdding(true), []);

  return (
    <Stack className="metadata-view justify-items-start gap-4">
      {/* AI Loading Indicator */}
      {aiLoading && (
        <div className="flex items-center gap-2 text-cdbi-blue-700">
          <ClipLoader size={20} color="#3B82F6" />
          <p>CDBI AI is analyzing metadata...</p>
        </div>
      )}

      {/* AI Error Display */}
      {aiError && (
        <div className="p-3 rounded-md bg-red-50 border border-red-200 text-red-800">
          <p className="font-semibold">AI Analysis Error:</p>
          <p className="text-sm">{aiError}</p>
          <Button
            buttonType="secondary"
            className="mt-2 text-xs"
            onClick={refetchAIAnalysis}
          >
            Retry AI Analysis
          </Button>
        </div>
      )}

      {/* Display AI Insights */}
      {aiResult && <AI_InsightDisplay insights={aiResult.insights} />}

      {/* Display AI KPIs */}
      {aiResult && <AI_KPIDisplay kpis={aiResult.kpis} />}

      {/* Display AI Charts */}
      {aiResult && <AI_ChartDisplay charts={aiResult.charts} />}

      {!isAdding && isEmpty(initialMetadata) && !enableActions && "No Metadata"}
      {!isAdding && !isEmpty(initialMetadata) && (
        <div className="w-full rounded-md border border-alpha-black-100 bg-white p-6">
          <KeyValueTable
            data={initialMetadata}
            copyableData={initialMetadata.map(
              // we are combining the key/value because KeyValueTable does that when no dataMapping is passed
              (metadataKv) => metadataKv.key + metadataKv.value,
            )}
          />
        </div>
      )}
      {!isAdding && enableActions && (
        <Button id="update-metadata-btn" onClick={onClick}>
          Add or Update Metadata (AI-Powered)
        </Button>
      )}
      {isAdding && enableActions && (
        <Formik
          initialValues={{ metadata: {} }}
          onSubmit={(
            values: { metadata: Record<string, string> },
            actions: FormikHelpers<{ metadata: Record<string, string> }>,
          ) => onSubmit(values.metadata, actions)}
        >
          {({ isSubmitting, status }) => (
            <Form className="w-full">
              {status && status.message && (
                <div className="p-2 mb-2 text-sm text-red-700 bg-red-100 border border-red-200 rounded">
                  {status.message}
                </div>
              )}
              <Field name="metadata">
                {({
                  form,
                }: FieldProps<{ metadata: Record<string, string> }>) => (
                  <MetadataInput
                    onChange={(value) => {
                      void form.setFieldValue("metadata", value);
                    }}
                    initialValues={sanitizeMetadata(initialMetadata)}
                    resource={resource}
                    completedValuesAndKeys={false}
                    noInitialEmptyEntry={
                      Object.keys(sanitizeMetadata(initialMetadata)).length > 0
                    }
                    // Pass AI suggestions to MetadataInput for potential auto-fill/guidance
                    aiSuggestions={aiResult?.suggestions || []}
                  />
                )}
              </Field>
              <Stack className="flex-row items-center gap-2 mt-4">
                <Button
                  id="save-metadata-btn"
                  buttonType="primary"
                  isSubmit
                  disabled={isSubmitting}
                >
                  Save Metadata (AI-Validated)
                </Button>
                <Button
                  buttonType="secondary"
                  onClick={() => setIsAdding(false)}
                  disabled={isSubmitting}
                >
                  Cancel
                </Button>
                <ClipLoader loading={isSubmitting} size={20} />
              </Stack>
            </Form>
          )}
        </Formik>
      )}
    </Stack>
  );
}

export default MetadataView;