// Copyright James Burvel Oâ€™Callaghan III
// President Citibank Demo Business Inc.

import React, { useState, useEffect, useMemo, useCallback } from "react";
import reduce from "lodash/reduce";
import { useLineItemsViewQuery } from "../../generated/dashboard/graphqlSchema";
import { CursorPaginationInput } from "../types/CursorPaginationInput";

import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";

// --- New Interfaces and Types for CDBI AI Capabilities ---

/**
 * Represents a single line item, extended with potential AI-driven insights.
 */
export interface LineItem {
  id: string;
  description: string;
  amount: number;
  accountingCategoryName?: string;
  accountingLedgerClassName?: string;
  metadata: string; // JSON string
  // Add other properties from the GraphQL schema if needed
}

/**
 * Defines a Key Performance Indicator (KPI) generated by CDBI AI.
 */
export interface AIKPI {
  id: string;
  name: string;
  value: string | number;
  unit?: string;
  description: string;
  insightCategory: string; // e.g., "Anomaly", "Liquidity", "Efficiency"
  trend?: "up" | "down" | "stable";
  trendPercentage?: number; // e.g., 5.2 for 5.2% change
  geminiPrompt: string; // Simulated prompt to Gemini for this KPI
}

/**
 * Defines a chart suggestion linked to CDBI AI insights.
 */
export interface AIChartSuggestion {
  id: string;
  title: string;
  type: "line" | "bar" | "pie" | "area" | "scatter";
  data: any; // Simplified for this example; in reality, this would be structured data for a charting library
  description: string;
  kpiIds: string[]; // Links to relevant KPIs
  geminiPrompt: string; // Simulated prompt to Gemini for chart generation/data
  chartOptions?: any; // Options for charting library (e.g., D3, Chart.js)
}

/**
 * Represents an anomaly detected by CDBI AI for a specific line item.
 */
export interface AIAnomaly {
  lineItemId: string;
  reason: string;
  severity: "low" | "medium" | "high" | "critical";
  suggestedAction: string;
  confidence: number; // 0-1
  detectionTime: string;
}

/**
 * Comprehensive report for anomaly detection across multiple line items.
 */
export interface AIAnomalyReport {
  totalAnomalies: number;
  anomalies: AIAnomaly[];
  summary: string;
}

/**
 * Enhanced details for a line item provided by CDBI AI.
 */
export interface AIEnhancedDetail {
  lineItemId: string;
  originalDescription: string;
  aiSuggestedDescription?: string;
  aiSuggestedCategory?: string;
  confidenceCategory?: number;
  aiSuggestedTags?: string[];
  enrichmentScore: number; // 0-1
}

/**
 * Represents the predicted liquidity impact of a set of line items.
 */
export interface AILiquidityImpact {
  totalNetImpact: number; // Positive for inflow, negative for outflow
  impactBreakdown: {
    inflows: { amount: number; lineItemIds: string[] };
    outflows: { amount: number; lineItemIds: string[] };
  };
  predictedCashFlowTrend: number; // e.g., 0.05 for 5% increase
  forecastSummary: string;
  potentialRecommendations: string[]; // e.g., "Consider early payment discount"
}

// --- CDBI AI Service (Simulated) ---

/**
 * `CDBIAIInsightsService` provides simulated AI capabilities for financial line item analysis.
 * In a real-world scenario, this would interact with Google Gemini or other sophisticated AI models.
 * For this self-contained file, it generates deterministic or semi-randomized insights
 * to demonstrate functionality.
 */
export class CDBIAIInsightsService {
  private static instance: CDBIAIInsightsService;

  private constructor() {
    // Private constructor to ensure singleton pattern
  }

  public static getInstance(): CDBIAIInsightsService {
    if (!CDBIAIInsightsService.instance) {
      CDBIAIInsightsService.instance = new CDBIAIInsightsService();
    }
    return CDBIAIInsightsService.instance;
  }

  /**
   * Simulates AI-driven anomaly detection in financial line items.
   * Leverages Gemini-like reasoning for contextual analysis.
   * @param lineItems The list of line items to analyze.
   * @returns An AIAnomalyReport.
   */
  public async analyzeLineItemsForAnomalies(
    lineItems: LineItem[],
  ): Promise<AIAnomalyReport> {
    console.log("CDBI AI: Analyzing line items for anomalies...");
    const anomalies: AIAnomaly[] = [];
    let summary = "No significant anomalies detected.";

    for (const item of lineItems) {
      const isAnomaly = Math.random() < 0.15; // 15% chance of anomaly for demo
      if (isAnomaly) {
        let reason = "Unusual transaction amount.";
        let severity: AIAnomaly["severity"] = "medium";
        let action = "Review transaction details and supporting documents.";

        if (item.amount > 10000 && Math.random() < 0.5) {
          reason = "Significantly higher than average transaction for this category.";
          severity = "high";
          action = "Immediately flag for manual review and reconciliation.";
        } else if (item.description.includes("refund") && item.amount > 0) {
          reason = "Potential logic error: Refund with positive amount.";
          severity = "critical";
          action = "Investigate immediately; could indicate processing error or fraud.";
        }

        anomalies.push({
          lineItemId: item.id,
          reason,
          severity,
          suggestedAction: action,
          confidence: parseFloat((0.7 + Math.random() * 0.3).toFixed(2)), // 70-100% confidence
          detectionTime: new Date().toISOString(),
        });
      }
    }

    if (anomalies.length > 0) {
      summary = `CDBI AI detected ${anomalies.length} potential anomalies among the ${lineItems.length} line items. High priority items require immediate attention.`;
    }

    return {
      totalAnomalies: anomalies.length,
      anomalies,
      summary,
    };
  }

  /**
   * Simulates AI-driven enhancement of line item details.
   * Uses Gemini-like natural language processing for enrichment.
   * @param lineItem The line item to enhance.
   * @returns AIEnhancedDetail.
   */
  public async enhanceLineItemDetails(
    lineItem: LineItem,
  ): Promise<AIEnhancedDetail> {
    console.log(`CDBI AI: Enhancing details for line item ${lineItem.id}...`);
    const originalDesc = lineItem.description;
    let aiSuggestedDesc = originalDesc;
    let aiSuggestedCategory = lineItem.accountingCategoryName;
    let aiSuggestedTags: string[] = [];
    let confidenceCategory = 0.85;
    let enrichmentScore = 0.7;

    if (originalDesc.toLowerCase().includes("consulting fee")) {
      aiSuggestedDesc = "Professional consulting services rendered";
      aiSuggestedCategory = "Consulting Fees";
      aiSuggestedTags = ["services", "professional"];
      confidenceCategory = 0.95;
      enrichmentScore = 0.9;
    } else if (originalDesc.toLowerCase().includes("software license")) {
      aiSuggestedDesc = "Annual software license renewal";
      aiSuggestedCategory = "Software Subscriptions";
      aiSuggestedTags = ["tech", "subscription", "recurring"];
      confidenceCategory = 0.92;
      enrichmentScore = 0.88;
    } else if (originalDesc.toLowerCase().includes("travel expense")) {
      aiSuggestedDesc = "Business travel and accommodation expenses";
      aiSuggestedCategory = "Travel & Entertainment";
      aiSuggestedTags = ["expense", "logistics"];
      confidenceCategory = 0.90;
      enrichmentScore = 0.85;
    } else if (originalDesc.toLowerCase().includes("utility bill")) {
      aiSuggestedDesc = "Monthly utility charges (electricity, water)";
      aiSuggestedCategory = "Utilities";
      aiSuggestedTags = ["overhead", "fixed_cost"];
      confidenceCategory = 0.88;
      enrichmentScore = 0.82;
    }

    return {
      lineItemId: lineItem.id,
      originalDescription: originalDesc,
      aiSuggestedDescription:
        aiSuggestedDesc !== originalDesc ? aiSuggestedDesc : undefined,
      aiSuggestedCategory:
        aiSuggestedCategory !== lineItem.accountingCategoryName
          ? aiSuggestedCategory
          : undefined,
      confidenceCategory,
      aiSuggestedTags: aiSuggestedTags.length > 0 ? aiSuggestedTags : undefined,
      enrichmentScore,
    };
  }

  /**
   * Simulates AI-driven prediction of liquidity impact.
   * Uses Gemini's predictive analytics capabilities for financial forecasting.
   * @param lineItems The list of line items for impact analysis.
   * @returns AILiquidityImpact.
   */
  public async predictLiquidityImpact(
    lineItems: LineItem[],
  ): Promise<AILiquidityImpact> {
    console.log("CDBI AI: Predicting liquidity impact...");
    let totalNetImpact = 0;
    const inflows: string[] = [];
    const outflows: string[] = [];

    lineItems.forEach((item) => {
      if (item.amount > 0) {
        totalNetImpact += item.amount;
        inflows.push(item.id);
      } else {
        totalNetImpact += item.amount; // amount is negative
        outflows.push(item.id);
      }
    });

    const predictedCashFlowTrend = parseFloat((Math.random() * 0.1 - 0.02).toFixed(4)); // -2% to +8%
    const forecastSummary =
      predictedCashFlowTrend > 0
        ? `Projected positive cash flow trend of ${predictedCashFlowTrend * 100}% based on current line item patterns.`
        : `Potential negative cash flow trend of ${Math.abs(predictedCashFlowTrend * 100)}% observed. Review spending.`;

    const potentialRecommendations: string[] = [];
    if (totalNetImpact < 0) {
      potentialRecommendations.push("Negotiate extended payment terms for large outflows.");
      potentialRecommendations.push("Identify opportunities to accelerate receivables.");
    } else if (totalNetImpact > 0 && predictedCashFlowTrend > 0.03) {
      potentialRecommendations.push("Consider reinvesting surplus cash into high-yield instruments.");
      potentialRecommendations.push("Evaluate opportunities for strategic expansion.");
    } else {
      potentialRecommendations.push("Maintain current cash management strategies.");
    }

    return {
      totalNetImpact,
      impactBreakdown: {
        inflows: {
          amount: lineItems
            .filter((item) => item.amount > 0)
            .reduce((sum, item) => sum + item.amount, 0),
          lineItemIds: inflows,
        },
        outflows: {
          amount: lineItems
            .filter((item) => item.amount <= 0)
            .reduce((sum, item) => sum + item.amount, 0),
          lineItemIds: outflows,
        },
      },
      predictedCashFlowTrend,
      forecastSummary,
      potentialRecommendations,
    };
  }

  /**
   * Generates relevant KPIs based on AI analysis results.
   * @param analysisResults Object containing various AI analysis reports.
   * @returns An array of AIKPIs.
   */
  public async generateKPIs(
    analysisResults: {
      anomalyReport?: AIAnomalyReport;
      enhancedDetails?: AIEnhancedDetail[];
      liquidityImpact?: AILiquidityImpact;
      totalLineItems?: number;
    },
  ): Promise<AIKPI[]> {
    console.log("CDBI AI: Generating KPIs...");
    const kpis: AIKPI[] = [];
    const { anomalyReport, enhancedDetails, liquidityImpact, totalLineItems = 0 } = analysisResults;

    if (anomalyReport) {
      kpis.push({
        id: "kpi_anomaly_count",
        name: "Anomaly Count",
        value: anomalyReport.totalAnomalies,
        unit: "items",
        description: "Total number of suspicious or unusual line items detected by CDBI AI.",
        insightCategory: "Anomaly Detection",
        geminiPrompt: "Generate a summary of 'Anomaly Count' KPI for financial line items.",
      });
      kpis.push({
        id: "kpi_anomaly_rate",
        name: "Anomaly Rate",
        value: totalLineItems > 0 ? (anomalyReport.totalAnomalies / totalLineItems) * 100 : 0,
        unit: "%",
        description: "Percentage of line items identified as anomalies relative to total.",
        insightCategory: "Anomaly Detection",
        geminiPrompt: "Calculate 'Anomaly Rate' based on detected anomalies and total items.",
      });
      kpis.push({
        id: "kpi_critical_anomalies",
        name: "Critical Anomalies",
        value: anomalyReport.anomalies.filter((a) => a.severity === "critical").length,
        unit: "items",
        description: "Number of high-severity anomalies requiring immediate attention.",
        insightCategory: "Anomaly Detection",
        geminiPrompt: "Identify and count 'Critical Anomalies' from the anomaly report.",
      });
    }

    if (enhancedDetails) {
      const enrichedCount = enhancedDetails.filter((d) => d.enrichmentScore > 0.7).length;
      kpis.push({
        id: "kpi_enrichment_rate",
        name: "Data Enrichment Rate",
        value: totalLineItems > 0 ? (enrichedCount / totalLineItems) * 100 : 0,
        unit: "%",
        description: "Percentage of line items whose details were significantly enhanced by CDBI AI.",
        insightCategory: "Data Quality & Enrichment",
        geminiPrompt: "Determine 'Data Enrichment Rate' based on AI-enhanced line item details.",
      });
      const avgConfidence =
        enhancedDetails.reduce((sum, d) => sum + (d.confidenceCategory || 0), 0) /
        enhancedDetails.length;
      kpis.push({
        id: "kpi_avg_enrich_conf",
        name: "Avg. Enrichment Confidence",
        value: parseFloat(avgConfidence.toFixed(2)),
        unit: "%",
        description: "Average confidence score of AI-suggested categories or descriptions.",
        insightCategory: "Data Quality & Enrichment",
        geminiPrompt: "Calculate 'Average Enrichment Confidence' from AI enhancement scores.",
      });
    }

    if (liquidityImpact) {
      kpis.push({
        id: "kpi_net_liquidity_impact",
        name: "Net Liquidity Impact",
        value: liquidityImpact.totalNetImpact,
        unit: "USD",
        description: "Overall cash flow change (inflows - outflows) from current line items.",
        insightCategory: "Liquidity Management",
        trend: liquidityImpact.totalNetImpact >= 0 ? "up" : "down",
        geminiPrompt: "Provide 'Net Liquidity Impact' analysis for current financial transactions.",
      });
      kpis.push({
        id: "kpi_predicted_cash_flow_trend",
        name: "Predicted Cash Flow Trend",
        value: parseFloat((liquidityImpact.predictedCashFlowTrend * 100).toFixed(2)),
        unit: "%",
        description: "Short-term predicted percentage change in cash flow based on patterns.",
        insightCategory: "Liquidity Management",
        trend: liquidityImpact.predictedCashFlowTrend >= 0 ? "up" : "down",
        trendPercentage: parseFloat((liquidityImpact.predictedCashFlowTrend * 100).toFixed(2)),
        geminiPrompt: "Generate 'Predicted Cash Flow Trend' forecast for upcoming periods.",
      });
    }

    return kpis;
  }

  /**
   * Generates chart suggestions based on AI analysis results and KPIs.
   * @param kpis The list of generated KPIs.
   * @param analysisResults Object containing various AI analysis reports.
   * @returns An array of AIChartSuggestions.
   */
  public async generateChartSuggestions(
    kpis: AIKPI[],
    analysisResults: {
      anomalyReport?: AIAnomalyReport;
      enhancedDetails?: AIEnhancedDetail[];
      liquidityImpact?: AILiquidityImpact;
      lineItems?: LineItem[];
    },
  ): Promise<AIChartSuggestion[]> {
    console.log("CDBI AI: Generating chart suggestions...");
    const charts: AIChartSuggestion[] = [];
    const { anomalyReport, enhancedDetails, liquidityImpact, lineItems } = analysisResults;

    if (kpis.some((k) => k.id === "kpi_anomaly_count") && anomalyReport) {
      charts.push({
        id: "chart_anomaly_severity_distribution",
        title: "Anomaly Severity Distribution",
        type: "pie",
        data: {
          labels: ["Critical", "High", "Medium", "Low"],
          datasets: [
            {
              data: [
                anomalyReport.anomalies.filter((a) => a.severity === "critical").length,
                anomalyReport.anomalies.filter((a) => a.severity === "high").length,
                anomalyReport.anomalies.filter((a) => a.severity === "medium").length,
                anomalyReport.anomalies.filter((a) => a.severity === "low").length,
              ],
              backgroundColor: ["#FF6384", "#FF9F40", "#FFCD56", "#4BC0C0"],
            },
          ],
        },
        description: "Visualizes the distribution of detected anomalies by their severity level.",
        kpiIds: ["kpi_anomaly_count", "kpi_critical_anomalies"],
        geminiPrompt: "Create a pie chart showing 'Anomaly Severity Distribution' from detection reports.",
      });

      if (lineItems && anomalyReport.anomalies.length > 0) {
        // Simulate a timeline for anomalies based on detectionTime
        const anomalyDates = anomalyReport.anomalies.map(a => new Date(a.detectionTime).toLocaleDateString());
        const dateCounts = anomalyDates.reduce((acc, date) => {
          acc[date] = (acc[date] || 0) + 1;
          return acc;
        }, {} as Record<string, number>);

        const sortedDates = Object.keys(dateCounts).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());

        charts.push({
          id: "chart_anomaly_trend",
          title: "Anomaly Detection Trend",
          type: "line",
          data: {
            labels: sortedDates,
            datasets: [
              {
                label: "Anomalies Detected",
                data: sortedDates.map(date => dateCounts[date]),
                borderColor: "#36A2EB",
                backgroundColor: "rgba(54, 162, 235, 0.2)",
                fill: true,
              },
            ],
          },
          description: "Tracks the number of anomalies detected over time, highlighting potential patterns.",
          kpiIds: ["kpi_anomaly_count", "kpi_anomaly_rate"],
          geminiPrompt: "Generate a line chart for 'Anomaly Detection Trend' over a specified period.",
          chartOptions: {
            scales: {
              x: { title: { display: true, text: "Date" } },
              y: { title: { display: true, text: "Number of Anomalies" }, beginAtZero: true },
            },
          },
        });
      }
    }

    if (kpis.some((k) => k.id === "kpi_net_liquidity_impact") && liquidityImpact && lineItems) {
      // Aggregate amounts by a simplified category for demo
      const categoryAmounts = lineItems.reduce((acc, item) => {
        const category = item.accountingCategoryName || "Uncategorized";
        acc[category] = (acc[category] || 0) + item.amount;
        return acc;
      }, {} as Record<string, number>);

      charts.push({
        id: "chart_cash_flow_breakdown",
        title: "Cash Flow Inflows vs. Outflows",
        type: "bar",
        data: {
          labels: ["Inflows", "Outflows"],
          datasets: [
            {
              label: "Amount (USD)",
              data: [
                liquidityImpact.impactBreakdown.inflows.amount,
                Math.abs(liquidityImpact.impactBreakdown.outflows.amount), // Display as positive magnitude
              ],
              backgroundColor: ["#28a745", "#dc3545"], // Green for inflows, Red for outflows
            },
          ],
        },
        description: "Illustrates the total value of cash inflows against outflows.",
        kpiIds: ["kpi_net_liquidity_impact"],
        geminiPrompt: "Visualize 'Cash Flow Inflows vs. Outflows' using a bar chart for liquidity analysis.",
        chartOptions: {
          scales: {
            y: { beginAtZero: true, title: { display: true, text: "Amount (USD)" } },
          },
        },
      });

      charts.push({
        id: "chart_predicted_cash_flow",
        title: "Predicted Cash Flow Trend",
        type: "line",
        data: {
          labels: ["Current", "Forecast +1M", "Forecast +2M"], // Simplified forecast points
          datasets: [
            {
              label: "Projected Cash Flow (USD)",
              data: [
                liquidityImpact.totalNetImpact,
                liquidityImpact.totalNetImpact * (1 + liquidityImpact.predictedCashFlowTrend * 1), // Simple linear projection
                liquidityImpact.totalNetImpact * (1 + liquidityImpact.predictedCashFlowTrend * 2),
              ],
              borderColor: "#6f42c1",
              backgroundColor: "rgba(111, 66, 193, 0.2)",
              fill: true,
            },
          ],
        },
        description: "Forecasts the future cash flow trend based on AI predictive analytics.",
        kpiIds: ["kpi_predicted_cash_flow_trend"],
        geminiPrompt: "Generate a line chart to show 'Predicted Cash Flow Trend' over the next few periods.",
        chartOptions: {
          scales: {
            x: { title: { display: true, text: "Time" } },
            y: { title: { display: true, text: "Cash Flow (USD)" } },
          },
        },
      });
    }

    if (kpis.some((k) => k.id === "kpi_enrichment_rate") && enhancedDetails && lineItems) {
      const categoryDistribution = lineItems.reduce((acc, item) => {
        const category = item.accountingCategoryName || "Uncategorized";
        acc[category] = (acc[category] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const labels = Object.keys(categoryDistribution);
      const data = Object.values(categoryDistribution);
      const backgroundColors = labels.map(() => `#${Math.floor(Math.random() * 16777215).toString(16)}`); // Random colors

      charts.push({
        id: "chart_category_distribution",
        title: "Line Item Category Distribution",
        type: "pie",
        data: {
          labels: labels,
          datasets: [
            {
              data: data,
              backgroundColor: backgroundColors,
            },
          ],
        },
        description: "Shows the distribution of line items across different accounting categories.",
        kpiIds: ["kpi_enrichment_rate", "kpi_avg_enrich_conf"],
        geminiPrompt: "Display 'Line Item Category Distribution' as a pie chart, based on actual or AI-suggested categories.",
      });
    }

    return charts;
  }
}

// --- Main Component ---

export function LineItemsView({
  itemizableType,
  itemizableId,
}: {
  itemizableType: string;
  itemizableId: string;
}) {
  const { loading, data, error, refetch } = useLineItemsViewQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: INITIAL_PAGINATION.perPage,
      paymentOrderId:
        itemizableType === "payment_orders" ? itemizableId : undefined,
      expectedPaymentId:
        itemizableType === "expected_payments" ? itemizableId : undefined,
    },
  });

  const rawLineItems: LineItem[] =
    loading || !data || error
      ? []
      : data.lineItems.edges.map(({ node }) => ({
          ...node,
          accountingCategoryName: node.accountingCategory?.name,
          accountingLedgerClassName: node.accountingLedgerClass?.name,
          // Ensure 'metadata' is always a string, even if null in schema, for JSON.parse
          metadata: node.metadata || "[]",
        }));

  const [aiLoading, setAiLoading] = useState(false);
  const [anomalyReport, setAnomalyReport] = useState<AIAnomalyReport | null>(
    null,
  );
  const [enhancedDetails, setEnhancedDetails] = useState<
    AIEnhancedDetail[] | null
  >(null);
  const [liquidityImpact, setLiquidityImpact] = useState<AILiquidityImpact | null>(
    null,
  );
  const [kpis, setKpis] = useState<AIKPI[]>([]);
  const [chartSuggestions, setChartSuggestions] = useState<AIChartSuggestion[]>(
    [],
  );

  const cdbiAIService = useMemo(() => CDBIAIInsightsService.getInstance(), []);

  useEffect(() => {
    const runAIAnalysis = async () => {
      if (rawLineItems.length === 0 || loading || error) {
        setAnomalyReport(null);
        setEnhancedDetails(null);
        setLiquidityImpact(null);
        setKpis([]);
        setChartSuggestions([]);
        return;
      }

      setAiLoading(true);
      try {
        const currentAnomalyReport =
          await cdbiAIService.analyzeLineItemsForAnomalies(rawLineItems);
        setAnomalyReport(currentAnomalyReport);

        const currentEnhancedDetails = await Promise.all(
          rawLineItems.map((item) =>
            cdbiAIService.enhanceLineItemDetails(item),
          ),
        );
        setEnhancedDetails(currentEnhancedDetails);

        const currentLiquidityImpact =
          await cdbiAIService.predictLiquidityImpact(rawLineItems);
        setLiquidityImpact(currentLiquidityImpact);

        const generatedKpis = await cdbiAIService.generateKPIs({
          anomalyReport: currentAnomalyReport,
          enhancedDetails: currentEnhancedDetails,
          liquidityImpact: currentLiquidityImpact,
          totalLineItems: rawLineItems.length,
        });
        setKpis(generatedKpis);

        const generatedCharts = await cdbiAIService.generateChartSuggestions(
          generatedKpis,
          {
            anomalyReport: currentAnomalyReport,
            enhancedDetails: currentEnhancedDetails,
            liquidityImpact: currentLiquidityImpact,
            lineItems: rawLineItems,
          },
        );
        setChartSuggestions(generatedCharts);
      } catch (aiError) {
        console.error("CDBI AI Analysis Error:", aiError);
        // Handle AI errors gracefully, perhaps display a message
      } finally {
        setAiLoading(false);
      }
    };

    runAIAnalysis();
  }, [rawLineItems, loading, error, cdbiAIService]); // Re-run AI analysis if line items change

  const expandedData = useMemo(() => {
    return reduce(
      rawLineItems,
      (acc, curr) => {
        const itemEnhancedDetail = enhancedDetails?.find(
          (d) => d.lineItemId === curr.id,
        );
        const itemAnomaly = anomalyReport?.anomalies.find(
          (a) => a.lineItemId === curr.id,
        );

        const metadataParsed = JSON.parse(curr.metadata) as Array<{
          key: string;
          value: string;
        }>;

        acc[curr.id] = [
          { key: "ID", value: curr.id },
          { key: "Description", value: curr.description },
          {
            key: "CDBI AI Description",
            value: itemEnhancedDetail?.aiSuggestedDescription || "N/A",
            className: itemEnhancedDetail?.aiSuggestedDescription ? "text-blue-600 font-medium" : "text-gray-500 italic"
          },
          {
            key: "Accounting Category",
            value: curr.accountingCategoryName,
          },
          {
            key: "CDBI AI Category",
            value: itemEnhancedDetail?.aiSuggestedCategory || "N/A",
            className: itemEnhancedDetail?.aiSuggestedCategory ? "text-blue-600 font-medium" : "text-gray-500 italic"
          },
          { key: "Accounting Class", value: curr.accountingLedgerClassName },
          ...(metadataParsed.length > 0 ? metadataParsed : [{ key: "Metadata", value: "No additional metadata" }]),
          {
            key: "CDBI AI Anomaly Status",
            value: itemAnomaly
              ? `${itemAnomaly.severity.toUpperCase()}: ${itemAnomaly.reason}`
              : "No anomaly detected",
            className: itemAnomaly
              ? `font-semibold text-${
                  itemAnomaly.severity === "critical"
                    ? "red-600"
                    : itemAnomaly.severity === "high"
                      ? "orange-600"
                      : "yellow-600"
                }`
              : "text-green-600",
          },
          ...(itemAnomaly
            ? [
                {
                  key: "AI Confidence",
                  value: `${(itemAnomaly.confidence * 100).toFixed(0)}%`,
                },
                { key: "AI Suggested Action", value: itemAnomaly.suggestedAction },
              ]
            : []),
        ];
        return acc;
      },
      {} as Record<string, any[]>,
    );
  }, [rawLineItems, anomalyReport, enhancedDetails]);

  const handleRefetch = useCallback(
    async (options: {
      cursorPaginationParams: CursorPaginationInput;
      query: unknown;
    }) => {
      const { cursorPaginationParams } = options;
      await refetch({ ...cursorPaginationParams });
    },
    [refetch],
  );

  return (
    <div className="flex flex-col space-y-6">
      <h2 className="text-2xl font-bold text-gray-900">
        CDBI Line Items Overview
      </h2>

      {/* CDBI AI Insights Panel */}
      <div className="bg-gradient-to-r from-blue-50 to-indigo-100 p-6 rounded-lg shadow-xl border border-blue-200">
        <h3 className="text-xl font-semibold text-blue-800 mb-4 flex items-center">
          <svg className="w-6 h-6 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.75 17L9 20l-1 1h8l-1-1-1.75-3M3 13l3 3m0 0l3 3m-3-3l-3 3m12 0l3-3m0 0l3-3m-3 3l3 3M14 8h1.2c.32 0 .58-.26.58-.58V6.58c0-.32-.26-.58-.58-.58H14v-.5C14 4.14 12.86 3 11.5 3S9 4.14 9 5.5v.5h-1.2c-.32 0-.58.26-.58.58v1.84c0 .32.26.58.58.58H9M9 13v-3h5v3h.5c.32 0 .58-.26.58-.58V9.58c0-.32-.26-.58-.58-.58H9.58c-.32 0-.58.26-.58.58v2.84c0 .32.26.58.58.58H14M9 8h5"></path></svg>
          CDBI AI-Powered Financial Insights
          {aiLoading && (
            <span className="ml-3 text-sm text-blue-700 animate-pulse">
              Analyzing with Gemini...
            </span>
          )}
        </h3>

        {aiLoading && rawLineItems.length > 0 && (
          <div className="text-center py-4 text-blue-700 italic">
            <p>Leveraging advanced AI models to process financial data...</p>
            <div className="h-2 bg-blue-200 rounded-full overflow-hidden mt-2">
              <div className="h-full bg-blue-500 w-1/2 animate-pulse-progress"></div>
            </div>
          </div>
        )}

        {!aiLoading && rawLineItems.length === 0 && (
          <p className="text-gray-600 italic">
            No line items available for CDBI AI analysis.
          </p>
        )}

        {!aiLoading && rawLineItems.length > 0 && (
          <>
            {/* AI KPIs */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
              {kpis.map((kpi) => (
                <div
                  key={kpi.id}
                  className="bg-white p-4 rounded-md shadow-sm border border-gray-200"
                >
                  <div className="text-sm font-medium text-gray-500">
                    {kpi.name}
                  </div>
                  <div className="mt-1 text-2xl font-bold text-gray-900 flex items-baseline">
                    {typeof kpi.value === "number" ? kpi.value.toLocaleString() : kpi.value}
                    {kpi.unit && (
                      <span className="ml-1 text-base font-medium text-gray-500">
                        {kpi.unit}
                      </span>
                    )}
                    {kpi.trend && (
                      <span
                        className={`ml-2 inline-flex items-center text-sm font-semibold ${
                          kpi.trend === "up" ? "text-green-600" : "text-red-600"
                        }`}
                      >
                        {kpi.trend === "up" ? (
                          <svg
                            className="w-4 h-4 mr-1"
                            fill="currentColor"
                            viewBox="0 0 20 20"
                          >
                            <path
                              fillRule="evenodd"
                              d="M5.293 9.707a1 1 0 010-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 01-1.414 1.414L11 7.414V15a1 1 0 11-2 0V7.414L6.707 9.707a1 1 0 01-1.414 0z"
                              clipRule="evenodd"
                            />
                          </svg>
                        ) : (
                          <svg
                            className="w-4 h-4 mr-1"
                            fill="currentColor"
                            viewBox="0 0 20 20"
                          >
                            <path
                              fillRule="evenodd"
                              d="M14.707 10.293a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L9 12.586V5a1 1 0 012 0v7.586l2.293-2.293a1 1 0 011.414 0z"
                              clipRule="evenodd"
                            />
                          </svg>
                        )}
                        {kpi.trendPercentage ? `${kpi.trendPercentage}%` : ""}
                      </span>
                    )}
                  </div>
                  <p className="mt-2 text-xs text-gray-600">
                    {kpi.description}
                  </p>
                  <p className="mt-1 text-xs text-gray-400 italic">
                    Gemini Prompt: "{kpi.geminiPrompt}"
                  </p>
                </div>
              ))}
            </div>

            {/* AI Chart Suggestions */}
            {chartSuggestions.length > 0 && (
              <div className="mt-6">
                <h4 className="text-lg font-semibold text-blue-700 mb-3">
                  CDBI AI Chart Visualizations
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {chartSuggestions.map((chart) => (
                    <div
                      key={chart.id}
                      className="bg-white p-5 rounded-md shadow-md border border-gray-200"
                    >
                      <h5 className="text-md font-bold text-gray-800 mb-2">
                        {chart.title}
                      </h5>
                      <p className="text-sm text-gray-600 mb-3">
                        {chart.description} (Type: {chart.type})
                      </p>
                      {/* Placeholder for chart rendering.
                          In a real app, you'd use a charting library like Chart.js or Recharts
                          and pass `chart.data` and `chart.chartOptions` to it.
                          For example: <ChartComponent type={chart.type} data={chart.data} options={chart.chartOptions} />
                      */}
                      <div className="bg-gray-100 h-48 flex items-center justify-center text-gray-500 italic rounded-md border border-dashed border-gray-300">
                        Chart Placeholder for {chart.title}
                      </div>
                      <p className="mt-3 text-xs text-gray-400 italic">
                        Gemini Prompt: "{chart.geminiPrompt}"
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* AI Anomaly Summary */}
            {anomalyReport && anomalyReport.totalAnomalies > 0 && (
              <div className="mt-6 p-4 bg-red-50 border border-red-200 rounded-lg">
                <h4 className="text-lg font-semibold text-red-800 mb-2 flex items-center">
                  <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd"></path></svg>
                  CDBI AI Anomaly Alert
                </h4>
                <p className="text-red-700">{anomalyReport.summary}</p>
                <ul className="mt-3 list-disc list-inside text-red-600 text-sm">
                  {anomalyReport.anomalies.slice(0, 3).map((anomaly) => (
                    <li key={anomaly.lineItemId}>
                      Line Item ID: {anomaly.lineItemId} -{" "}
                      <strong>{anomaly.severity.toUpperCase()}</strong>:{" "}
                      {anomaly.reason}. Suggested Action:{" "}
                      {anomaly.suggestedAction}
                    </li>
                  ))}
                  {anomalyReport.anomalies.length > 3 && (
                    <li>...and {anomalyReport.anomalies.length - 3} more.</li>
                  )}
                </ul>
              </div>
            )}

            {/* AI Liquidity Recommendations */}
            {liquidityImpact && (
              <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
                <h4 className="text-lg font-semibold text-green-800 mb-2 flex items-center">
                  <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-3.707-9.293a1 1 0 00-1.414 1.414L8.586 12H7a1 1 0 100 2h3a1 1 0 001-1V8a1 1 0 10-2 0v2.586l-1.293-1.293z" clipRule="evenodd"></path></svg>
                  CDBI AI Liquidity Recommendations
                </h4>
                <p className="text-green-700 font-medium">
                  Net liquidity impact from these items:{" "}
                  <span className="text-xl">
                    ${liquidityImpact.totalNetImpact.toLocaleString()}
                  </span>
                </p>
                <p className="text-green-700 italic">
                  {liquidityImpact.forecastSummary}
                </p>
                <ul className="mt-3 list-disc list-inside text-green-600 text-sm">
                  {liquidityImpact.potentialRecommendations.map((rec, index) => (
                    <li key={index}>{rec}</li>
                  ))}
                </ul>
              </div>
            )}
          </>
        )}
      </div>

      {/* Original EntityTableView */}
      <EntityTableView
        data={rawLineItems}
        loading={loading}
        dataMapping={{ amount: "Amount", description: "Description" }}
        styleMapping={{
          amount: "table-entry-small",
        }}
        onQueryArgChange={handleRefetch}
        cursorPagination={data?.lineItems?.pageInfo}
        enableActions={!!expandedData}
        expandedData={expandedData}
      />
    </div>
  );
}

export default LineItemsView;