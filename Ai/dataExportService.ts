// Copyright James Burvel Oâ€™Callaghan III
// President Citibank Demo Business Inc.

// This file implements a robust, enterprise-grade backend service for fetching,
// aggregating, and preparing archived financial data from various external and
// internal systems for secure export. It is designed to handle large volumes
// of data, support pagination, error handling with retries, and data normalization.
// The service integrates conceptually with Modern Treasury, Stripe, Plaid, and
// Citibank Demo Business's internal financial systems. All external API interactions
// are simulated internally to adhere to the 'no imports, no dependencies' constraint,
// while demonstrating the full logic flow.

// --- Constants and Enums ---

/**
 * Enumerates the various financial data sources supported for archival export.
 * This provides a clear, type-safe identifier for each system.
 */
enum FinancialDataSource {
  MODERN_TREASURY = "ModernTreasury",
  STRIPE = "Stripe",
  PLAID = "Plaid",
  CITIBANK_INTERNAL = "CitibankInternal",
}

/**
 * Defines the possible states of an asynchronous data export job,
 * enabling real-time status tracking for users and administrators.
 */
enum ExportJobStatus {
  PENDING = "PENDING",
  IN_PROGRESS = "IN_PROGRESS",
  COMPLETED = "COMPLETED",
  FAILED = "FAILED",
  CANCELLED = "CANCELLED", // Future extension for job cancellation
}

/**
 * Defines the types of financial records that can be exported.
 * This common enumeration allows for flexible selection of data types
 * across disparate source systems.
 */
enum FinancialRecordType {
  TRANSACTION = "Transaction",
  LEDGER_ENTRY = "LedgerEntry", // From Modern Treasury
  PAYOUT = "Payout",             // From Stripe
  CHARGE = "Charge",             // From Stripe
  ACCOUNT_BALANCE = "AccountBalance", // From Plaid (or internal)
  BANK_TRANSFER = "BankTransfer", // General bank transfer type
  INVOICE = "Invoice",           // Future: from Stripe or other invoicing
  REFUND = "Refund",             // From Stripe
  DEPOSIT = "Deposit",           // General deposit type
  WITHDRAWAL = "Withdrawal",     // General withdrawal type
  FEE = "Fee",                   // General fee type
  ADJUSTMENT = "Adjustment",     // General adjustment type
}

/**
 * Common currency codes used across all financial systems.
 */
enum Currency {
  USD = "USD",
  EUR = "EUR",
  GBP = "GBP",
  CAD = "CAD",
  JPY = "JPY",
  AUD = "AUD",
  CHF = "CHF",
  MXN = "MXN", // Added for more variety
  SGD = "SGD",
}

/**
 * Default number of records to attempt to fetch per API call for pagination.
 * This value is a crucial performance tuning parameter in a real system.
 */
const API_PAGE_SIZE = 250; // Reduced slightly to demonstrate more pagination calls

/**
 * Maximum number of retries for external API calls before failing,
 * implementing a robust fault tolerance mechanism.
 */
const MAX_API_RETRIES = 5; // Increased retries for better resilience

/**
 * Base URL for Citibank Demo Business internal API routes,
 * establishing the domain for all internal service interactions.
 */
const CITIBANK_DEMO_BUSINESS_API_BASE_URL = "https://api.citibankdemobusiness.dev";

/**
 * Base URL for storing exported files (simulated S3 bucket).
 */
const CITIBANK_DEMO_BUSINESS_EXPORT_STORAGE_URL = "https://exports.citibankdemobusiness.dev";

// --- Interfaces and Types - Common ---

/**
 * Represents a normalized financial record. This unified schema is critical
 * for aggregating data from various sources into a consistent format for export.
 */
interface FinancialRecord {
  id: string; // Unique ID generated by the export service (e.g., source-originalId)
  source: FinancialDataSource;
  recordType: FinancialRecordType;
  timestamp: string; // ISO 8601 string, crucial for chronological sorting
  amount: number; // Stored in minor units (e.g., cents for USD), signed (positive for income, negative for expense)
  currency: Currency;
  description: string;
  status: string; // e.g., "completed", "pending", "failed", normalized
  metadata?: Record<string, any>; // Arbitrary additional data from source system
  originatingAccountId?: string; // ID of the account from which funds moved
  destinationAccountId?: string; // ID of the account to which funds moved
  relatedTransactionId?: string; // Links to other internal or external transactions
  externalReferenceId?: string; // Original ID from the source system (e.g., Stripe Charge ID)
  liveMode: boolean; // Indicates if the data originated from a live or sandbox environment
  category?: string; // Normalized category, if derivable
  counterpartyName?: string; // Name of the other party in the transaction
}

/**
 * Defines the comprehensive parameters required to initiate a data export request.
 */
interface DataExportRequest {
  exportId: string; // Globally unique ID for this specific export job
  userId: string;   // Identifier for the user who initiated the export
  email: string;    // Email address for sending completion notifications
  resourceTypes: FinancialRecordType[]; // Specific types of financial records to include
  dataSources: FinancialDataSource[]; // Which source systems to pull data from
  startDate: string; // ISO 8601 date string (e.g., 'YYYY-MM-DD'), inclusive start
  endDate: string;   // ISO 8601 date string (e.g., 'YYYY-MM-DD'), inclusive end
  liveMode: boolean; // Boolean indicating whether to export live or sandbox data
  filters?: Record<string, any>; // Advanced filtering criteria (e.g., by account ID, status)
  webhookUrl?: string; // Optional webhook URL for real-time status updates
  requestedAt: string; // Timestamp when the request was first made
}

/**
 * Represents the current status and detailed information of an export job,
 * essential for tracking progress and providing user feedback.
 */
interface ExportJobDetails {
  exportId: string;
  userId: string;
  status: ExportJobStatus;
  requestedAt: string; // When the export was initially requested
  startedAt?: string;   // When processing actually began
  completedAt?: string; // When the job finished (successfully or failed)
  failedReason?: string; // Detailed error message if the job failed
  progress: number; // 0-100 percentage indicating completion
  fileUrl?: string; // Secure, pre-signed URL for downloading the generated CSV
  recordCount?: number; // Total number of records successfully exported
  request: DataExportRequest; // A copy of the original request for auditing
  logMessages?: string[]; // A collection of important log messages during processing
}

/**
 * Represents a generic error structure for simulated external API calls,
 * providing consistent error reporting.
 */
interface ExternalApiError {
  statusCode: number;
  message: string;
  code?: string;
  details?: Record<string, any>;
}

// --- Interfaces and Types - External Service Specific (Simulated) ---

// Modern Treasury Data Models (Simulated)
interface ModernTreasuryTransaction {
  id: string;
  amount: number; // in minor units
  currency: string;
  description: string;
  status: "completed" | "pending" | "returned" | "void";
  posted_at: string; // ISO 8601 datetime
  type: "incoming" | "outgoing" | "reversal";
  direction: "credit" | "debit";
  metadata: Record<string, any>;
  live_mode: boolean;
  ledger_account_id?: string;
  vendor_id?: string;
  transaction_code?: string; // e.g., ACH, Wire
  effective_at: string; // Date of value
  counterparty_id?: string;
  counterparty_name?: string;
}

interface ModernTreasuryLedgerAccount {
  id: string;
  name: string;
  description?: string;
  currency: string;
  live_mode: boolean;
  created_at: string;
  updated_at: string;
  normal_balance: "credit" | "debit";
  metadata: Record<string, any>;
}

interface ModernTreasuryPaginationResponse<T> {
  data: T[];
  has_more: boolean;
  next_page_token?: string;
}

// Stripe Data Models (Simulated)
interface StripeCharge {
  id: string;
  amount: number; // in minor units
  currency: string;
  description: string | null;
  created: number; // Unix timestamp
  status: "succeeded" | "pending" | "failed";
  livemode: boolean;
  customer?: string; // Customer ID
  payment_method_details?: any; // Detailed payment method info
  receipt_email?: string;
  metadata: Record<string, any>;
  source_transfer?: string; // ID of transfer if associated
  balance_transaction?: string; // ID of the balance transaction
}

interface StripePayout {
  id: string;
  amount: number; // in minor units
  currency: string;
  created: number; // Unix timestamp
  description: string | null;
  status: "pending" | "in_transit" | "paid" | "failed" | "canceled";
  livemode: boolean;
  destination: string; // Bank account or card ID
  statement_descriptor?: string;
  metadata: Record<string, any>;
  arrival_date: number; // Unix timestamp
}

interface StripeRefund {
  id: string;
  amount: number; // in minor units
  currency: string;
  created: number; // Unix timestamp
  status: "pending" | "succeeded" | "failed";
  charge: string; // ID of the charge refunded
  livemode: boolean;
  reason?: "duplicate" | "fraudulent" | "requested_by_customer" | "partial_charge";
  metadata: Record<string, any>;
  balance_transaction?: string;
}

interface StripeTransaction {
  id: string;
  amount: number; // in minor units
  currency: string;
  description: string;
  created: number; // Unix timestamp
  type: string; // e.g., "charge", "refund", "payout", "stripe_fee"
  status: string; // "available", "pending"
  livemode: boolean;
  net: number; // amount after fees
  fee: number; // fee amount
}

interface StripePaginationResponse<T> {
  data: T[];
  has_more: boolean;
  object: "list";
  url: string; // Used for pagination cursor
}

// Plaid Data Models (Simulated)
interface PlaidTransaction {
  transaction_id: string;
  account_id: string;
  amount: number; // Raw amount, positive is credit, negative is debit
  iso_currency_code: string | null;
  unofficial_currency_code: string | null;
  date: string; // YYYY-MM-DD
  authorized_date?: string; // YYYY-MM-DD
  name: string;
  merchant_name: string | null;
  payment_channel: "online" | "in store" | "other";
  transaction_type: "digital" | "place" | "special" | "unresolved";
  pending: boolean;
  transaction_code: string | null;
  personal_finance_category?: {
    primary: string;
    detailed: string;
  };
  live_mode: boolean; // Simulating this for consistency with other sources
  payment_meta?: {
    by_order_of?: string;
    payee?: string;
    payer?: string;
    payment_method?: string;
    ppd_id?: string;
    reason?: string;
    reference_number?: string;
  };
}

interface PlaidAccount {
  account_id: string;
  name: string;
  subtype: string;
  type: string;
  balances: {
    available: number | null;
    current: number | null;
    iso_currency_code: string | null;
    unofficial_currency_code: string | null;
    limit: number | null;
  };
  mask: string; // Last 4 digits of account number
  official_name: string | null;
  live_mode: boolean; // Simulating for consistency
}

interface PlaidTransactionsGetResponse {
  transactions: PlaidTransaction[];
  accounts: PlaidAccount[];
  total_transactions: number;
  request_id: string;
  item: {
    item_id: string;
    institution_id: string;
    webhook: string | null;
    error: any | null;
  };
}

// Citibank Internal Systems Data Models (Hypothetical)
interface CitibankInternalTransaction {
  transactionIdentifier: string; // Unique internal ID
  accountNumber: string; // Associated internal account number
  transactionDate: string; // ISO 8601 date-time
  valueDate: string; // ISO 8601 date-time for when value moved
  amountMinorUnits: number; // Transaction amount in minor units
  currencyCode: string;
  transactionType: "DEBIT" | "CREDIT" | "FEE" | "ADJUSTMENT";
  description: string;
  status: "COMPLETED" | "PENDING" | "REVERSED" | "FAILED";
  liveEnv: boolean; // 'true' for live, 'false' for sandbox
  category?: string; // Internal categorization
  merchantDetails?: string;
  referenceId?: string; // Any external reference ID
  internalApprovalCode?: string;
  customMetadata?: Record<string, any>;
  counterpartyAccount?: string; // Counterparty account number
  counterpartyName?: string;
}

interface CitibankInternalAccount {
  accountNumber: string;
  accountName: string;
  accountType: string;
  currentBalanceMinorUnits: number;
  currencyCode: string;
  lastUpdated: string; // ISO 8601 date-time
  liveEnv: boolean;
  customerIdentifier: string;
}

interface CitibankInternalPaginationResponse<T> {
  data: T[];
  totalRecords: number;
  hasMore: boolean;
  nextOffset?: number; // For offset-based pagination
}

// --- Simulated API Clients ---

/**
 * Base abstract class for all simulated API clients.
 * Provides common infrastructure like base URL management and robust retry logic
 * with exponential backoff for transient network issues.
 */
abstract class BaseApiClient {
  protected baseUrl: string;
  protected apiKey: string; // In a real system, this would be securely managed.

  constructor(baseUrl: string, apiKey: string) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
  }

  /**
   * Simulates an HTTP GET request to an external service.
   * This method incorporates exponential backoff and retries to enhance resilience
   * against transient network or service errors.
   * @param path The API endpoint path (e.g., "/v1/charges").
   * @param params Query parameters to append to the URL.
   * @param retries Current retry count, defaults to 0.
   * @returns A Promise resolving to the simulated parsed JSON response.
   * @throws ExternalApiError on persistent failure after maximum retries.
   */
  protected async get<T>(
    path: string,
    params: Record<string, any> = {},
    retries = 0
  ): Promise<T> {
    const queryString = new URLSearchParams(params).toString();
    const url = `${this.baseUrl}${path}${queryString ? `?${queryString}` : ''}`;

    console.log(`[SIMULATED API CALL] GET ${url} (Retry: ${retries})`); // For comprehensive logging

    // Simulate network latency.
    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 300));

    // Simulate transient network errors or rate limiting that can be retried.
    if (Math.random() < 0.15 && retries < MAX_API_RETRIES) {
      const backoffTime = Math.pow(2, retries) * 500 + Math.random() * 200; // Exponential backoff with jitter
      console.warn(`[SIMULATED API ERROR] Transient error for ${url}. Retrying in ${backoffTime}ms (${retries + 1}/${MAX_API_RETRIES})...`);
      await new Promise(resolve => setTimeout(resolve, backoffTime));
      return this.get<T>(path, params, retries + 1);
    }

    // Simulate a persistent error (e.g., bad request, unauthorized, internal server error)
    // that cannot be resolved by retries, or occurs after max retries.
    if (Math.random() < 0.05 || retries >= MAX_API_RETRIES) {
      const statusCode = retries >= MAX_API_RETRIES ? 500 : (Math.random() > 0.5 ? 401 : 400);
      const errorMessage = statusCode === 401 ? "Unauthorized" : "Bad Request or Internal Server Error";
      console.error(`[SIMULATED API ERROR] Persistent error for ${url}. Status: ${statusCode}, Message: ${errorMessage}`);
      throw { statusCode, message: `Failed to fetch data from ${this.baseUrl}${path}: ${errorMessage}` } as ExternalApiError;
    }

    // Simulate successful response with dummy data generation
    return this.generateDummyResponse<T>(path, params);
  }

  /**
   * Abstract method to generate realistic dummy responses for specific API paths.
   * Each concrete client must implement this to provide relevant simulated data.
   */
  protected abstract generateDummyResponse<T>(path: string, params: Record<string, any>): T;
}

/**
 * Simulated client for Modern Treasury API.
 * Provides methods to interact with Modern Treasury's transaction and ledger endpoints.
 */
class ModernTreasuryClient extends BaseApiClient {
  constructor(apiKey: string, liveMode: boolean) {
    const baseUrl = liveMode
      ? "https://api.moderntreasury.com"
      : "https://sandbox.moderntreasury.com";
    super(baseUrl, apiKey);
  }

  protected generateDummyResponse<T>(path: string, params: Record<string, any>): T {
    const liveMode = this.baseUrl.includes("api.moderntreasury.com");
    if (path.includes("/transactions")) {
      const transactions: ModernTreasuryTransaction[] = [];
      const count = parseInt(params.per_page || API_PAGE_SIZE, 10);
      const startDateTime = new Date(params.effective_at_start).getTime();
      const endDateTime = new Date(params.effective_at_end).getTime();

      for (let i = 0; i < count; i++) {
        const randomTime = startDateTime + Math.random() * (endDateTime - startDateTime);
        const postedAt = new Date(randomTime).toISOString();
        const amount = Math.floor(Math.random() * 5000000) + 100; // up to $50,000
        const isCredit = Math.random() > 0.5;

        transactions.push({
          id: `mt_txn_${params.after_cursor || '0'}_${i + 1}`,
          amount: amount,
          currency: (Math.random() > 0.8 ? Currency.EUR : Currency.USD),
          description: `MT ${isCredit ? 'Incoming' : 'Outgoing'} Payment ${i + 1} for ${Math.floor(randomTime / 1000000)}`,
          status: Math.random() > 0.1 ? "completed" : "pending",
          posted_at: postedAt,
          effective_at: postedAt.split('T')[0],
          type: isCredit ? "incoming" : "outgoing",
          direction: isCredit ? "credit" : "debit",
          metadata: {
            customer_ref: `cust_${Math.floor(Math.random() * 5000)}`,
            invoice_id: `inv_${Math.floor(Math.random() * 10000)}`,
            department: Math.random() > 0.5 ? "Sales" : "Operations",
          },
          live_mode: liveMode,
          ledger_account_id: `la_${Math.floor(Math.random() * 200)}`,
          vendor_id: `ven_${Math.floor(Math.random() * 300)}`,
          transaction_code: Math.random() > 0.7 ? "ACH" : "WIRE",
          counterparty_name: `Vendor XYZ ${Math.floor(Math.random() * 50)}`,
        });
      }
      return {
        data: transactions,
        has_more: Math.random() > 0.2, // Simulate consistent pagination for testing
        next_page_token: Math.random() > 0.2 ? `cursor_${Math.floor(Math.random() * 1000)}` : undefined,
      } as T;
    } else if (path.includes("/ledger_accounts")) {
      const ledgerAccounts: ModernTreasuryLedgerAccount[] = [];
      const count = parseInt(params.per_page || API_PAGE_SIZE, 10);
      for (let i = 0; i < count; i++) {
        ledgerAccounts.push({
          id: `la_${Math.floor(Math.random() * 1000)}`,
          name: `Ledger Account ${i + 1}`,
          description: `Description for Ledger Account ${i + 1}`,
          currency: (Math.random() > 0.8 ? Currency.EUR : Currency.USD),
          live_mode: liveMode,
          created_at: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
          updated_at: new Date().toISOString(),
          normal_balance: Math.random() > 0.5 ? "credit" : "debit",
          metadata: { type: Math.random() > 0.5 ? "Asset" : "Liability" }
        });
      }
      return {
        data: ledgerAccounts,
        has_more: Math.random() > 0.8,
        next_page_token: Math.random() > 0.8 ? `lacursor_${Math.floor(Math.random() * 100)}` : undefined,
      } as T;
    }
    throw new Error(`Unsupported Modern Treasury path for dummy data: ${path}`);
  }

  /**
   * Fetches Modern Treasury transactions, automatically handling API pagination.
   * @param startDate ISO 8601 start date.
   * @param endDate ISO 8601 end date.
   * @param liveMode Boolean indicating live or sandbox environment.
   * @param cursor Optional pagination cursor.
   * @returns A paginated response object containing transactions and continuation info.
   */
  async fetchTransactions(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    cursor?: string
  ): Promise<ModernTreasuryPaginationResponse<ModernTreasuryTransaction>> {
    const params: Record<string, any> = {
      per_page: API_PAGE_SIZE.toString(),
      effective_at_start: startDate,
      effective_at_end: endDate,
      status: "completed", // Filter for completed transactions by default
    };
    if (cursor) {
      params.after_cursor = cursor;
    }
    return this.get<ModernTreasuryPaginationResponse<ModernTreasuryTransaction>>(
      "/api/transactions",
      params
    );
  }

  /**
   * Fetches Modern Treasury Ledger Accounts.
   * @param liveMode Boolean indicating live or sandbox environment.
   * @param cursor Optional pagination cursor.
   * @returns A paginated response object containing ledger accounts and continuation info.
   */
  async fetchLedgerAccounts(
    liveMode: boolean,
    cursor?: string
  ): Promise<ModernTreasuryPaginationResponse<ModernTreasuryLedgerAccount>> {
    const params: Record<string, any> = {
      per_page: API_PAGE_SIZE.toString(),
    };
    if (cursor) {
      params.after_cursor = cursor;
    }
    return this.get<ModernTreasuryPaginationResponse<ModernTreasuryLedgerAccount>>(
      "/api/ledger_accounts",
      params
    );
  }
}

/**
 * Simulated client for Stripe API.
 * Provides methods for fetching charges, payouts, refunds, and balance transactions.
 */
class StripeClient extends BaseApiClient {
  constructor(apiKey: string, liveMode: boolean) {
    const baseUrl = "https://api.stripe.com"; // Stripe API URL is consistent, mode determined by API key
    super(baseUrl, apiKey);
  }

  protected generateDummyResponse<T>(path: string, params: Record<string, any>): T {
    const records: (StripeCharge | StripePayout | StripeRefund | StripeTransaction)[] = [];
    const count = parseInt(params.limit || API_PAGE_SIZE, 10);
    const startTimestamp = Math.floor(new Date(params.created?.gte || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)).getTime() / 1000);
    const endTimestamp = Math.floor(new Date(params.created?.lte || new Date()).getTime() / 1000);
    const livemode = this.apiKey.startsWith("sk_live"); // Infer live mode from API key prefix

    for (let i = 0; i < count; i++) {
      const created = Math.floor(startTimestamp + Math.random() * (endTimestamp - startTimestamp));
      if (path.includes("/charges")) {
        records.push({
          id: `ch_${params.starting_after || '0'}_${i + 1}`,
          amount: Math.floor(Math.random() * 1000000) + 500, // up to $10,000
          currency: (Math.random() > 0.8 ? Currency.GBP : Currency.USD),
          description: `Stripe Charge ${i + 1} for Product ${Math.floor(Math.random() * 100)}`,
          created: created,
          status: Math.random() > 0.1 ? "succeeded" : "pending",
          livemode: livemode,
          customer: `cus_${Math.floor(Math.random() * 5000)}`,
          receipt_email: `customer${Math.floor(Math.random() * 5000)}@example.com`,
          metadata: {
            order_id: `ord_${Math.floor(Math.random() * 20000)}`,
            product_sku: `SKU-${Math.floor(Math.random() * 999)}`,
          },
          balance_transaction: `bt_charge_${i}`,
        } as StripeCharge);
      } else if (path.includes("/payouts")) {
        records.push({
          id: `po_${params.starting_after || '0'}_${i + 1}`,
          amount: Math.floor(Math.random() * 2000000) + 1000, // up to $20,000
          currency: (Math.random() > 0.8 ? Currency.EUR : Currency.USD),
          description: `Stripe Payout ${i + 1} to Bank Account`,
          created: created,
          status: Math.random() > 0.05 ? "paid" : "in_transit",
          livemode: livemode,
          destination: `ba_${Math.floor(Math.random() * 1000)}`,
          statement_descriptor: `PAYOUT-${Math.floor(Math.random() * 100)}`,
          metadata: {
            batch_id: `batch_${Math.floor(Math.random() * 200)}`,
            vendor_payout: true,
          },
          arrival_date: created + (3 * 24 * 60 * 60), // 3 days later
        } as StripePayout);
      } else if (path.includes("/refunds")) {
        records.push({
          id: `re_${params.starting_after || '0'}_${i + 1}`,
          amount: Math.floor(Math.random() * 500000) + 100, // up to $5,000
          currency: (Math.random() > 0.8 ? Currency.GBP : Currency.USD),
          description: `Stripe Refund ${i + 1} for product return`,
          created: created,
          status: Math.random() > 0.05 ? "succeeded" : "pending",
          charge: `ch_refunded_${Math.floor(Math.random() * 10000)}`,
          livemode: livemode,
          reason: Math.random() > 0.6 ? "requested_by_customer" : (Math.random() > 0.5 ? "duplicate" : "fraudulent"),
          metadata: {
            customer_dispute: Math.random() > 0.7,
            item_returned: true,
          },
          balance_transaction: `bt_refund_${i}`,
        } as StripeRefund);
      } else if (path.includes("/balance_transactions")) {
        // Simulate various balance transaction types
        const types = ["charge", "payout", "refund", "adjustment", "stripe_fee", "transfer"];
        records.push({
          id: `bt_${params.starting_after || '0'}_${i + 1}`,
          amount: Math.floor(Math.random() * 1000000) + 100,
          currency: (Math.random() > 0.8 ? Currency.EUR : Currency.USD),
          description: `Balance Transaction ${i + 1}`,
          created: created,
          type: types[Math.floor(Math.random() * types.length)],
          status: "available", // Balance transactions are typically settled
          livemode: livemode,
          net: Math.floor(Math.random() * 900000) + 50,
          fee: Math.floor(Math.random() * 10000) + 10,
        } as StripeTransaction);
      }
    }
    return {
      data: records,
      has_more: Math.random() > 0.2, // Consistent pagination simulation
      object: "list",
      url: path,
    } as T;
  }

  /**
   * Fetches Stripe charges, managing pagination through the `starting_after` parameter.
   */
  async fetchCharges(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    startingAfterId?: string
  ): Promise<StripePaginationResponse<StripeCharge>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      created: {
        gte: Math.floor(new Date(startDate).getTime() / 1000),
        lte: Math.floor(new Date(endDate).getTime() / 1000),
      },
      status: "succeeded", // Often only interested in successful charges for archival
    };
    if (startingAfterId) {
      params.starting_after = startingAfterId;
    }
    return this.get<StripePaginationResponse<StripeCharge>>(
      "/v1/charges",
      params
    );
  }

  /**
   * Fetches Stripe payouts, managing pagination.
   */
  async fetchPayouts(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    startingAfterId?: string
  ): Promise<StripePaginationResponse<StripePayout>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      created: {
        gte: Math.floor(new Date(startDate).getTime() / 1000),
        lte: Math.floor(new Date(endDate).getTime() / 1000),
      },
      status: "paid", // Only fetch paid payouts for archival
    };
    if (startingAfterId) {
      params.starting_after = startingAfterId;
    }
    return this.get<StripePaginationResponse<StripePayout>>(
      "/v1/payouts",
      params
    );
  }

  /**
   * Fetches Stripe refunds, managing pagination.
   */
  async fetchRefunds(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    startingAfterId?: string
  ): Promise<StripePaginationResponse<StripeRefund>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      created: {
        gte: Math.floor(new Date(startDate).getTime() / 1000),
        lte: Math.floor(new Date(endDate).getTime() / 1000),
      },
      status: "succeeded", // Only fetch succeeded refunds
    };
    if (startingAfterId) {
      params.starting_after = startingAfterId;
    }
    return this.get<StripePaginationResponse<StripeRefund>>(
      "/v1/refunds",
      params
    );
  }

  /**
   * Fetches Stripe Balance Transactions.
   */
  async fetchBalanceTransactions(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    startingAfterId?: string
  ): Promise<StripePaginationResponse<StripeTransaction>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      created: {
        gte: Math.floor(new Date(startDate).getTime() / 1000),
        lte: Math.floor(new Date(endDate).getTime() / 1000),
      },
    };
    if (startingAfterId) {
      params.starting_after = startingAfterId;
    }
    return this.get<StripePaginationResponse<StripeTransaction>>(
      "/v1/balance_transactions",
      params
    );
  }
}

/**
 * Simulated client for Plaid API.
 * Focuses on fetching transaction data, which is the primary use case for export.
 */
class PlaidClient extends BaseApiClient {
  constructor(apiKey: string, liveMode: boolean) {
    const baseUrl = liveMode
      ? "https://production.plaid.com"
      : "https://sandbox.plaid.com";
    super(baseUrl, apiKey);
  }

  protected generateDummyResponse<T>(path: string, params: Record<string, any>): T {
    const liveMode = this.baseUrl.includes("production.plaid.com");
    if (path.includes("/transactions/get")) {
      const transactions: PlaidTransaction[] = [];
      const count = parseInt(params.options?.count || API_PAGE_SIZE, 10);
      const startDate = params.start_date;
      const endDate = params.end_date;

      for (let i = 0; i < count; i++) {
        const randomDate = new Date(new Date(startDate).getTime() + Math.random() * (new Date(endDate).getTime() - new Date(startDate).getTime()));
        const transactionDate = randomDate.toISOString().split('T')[0];
        const amount = parseFloat((Math.random() * 2000 - 1000).toFixed(2)); // Can be positive (credit) or negative (debit)

        transactions.push({
          transaction_id: `pl_txn_${params.options?.offset || '0'}_${i + 1}`,
          account_id: `acc_${Math.floor(Math.random() * 500)}`,
          amount: amount,
          iso_currency_code: (Math.random() > 0.8 ? Currency.CAD : Currency.USD),
          unofficial_currency_code: null,
          date: transactionDate,
          authorized_date: new Date(randomDate.getTime() - 24 * 60 * 60 * 1000).toISOString().split('T')[0], // Day before
          name: `Plaid Transaction ${i + 1}: ${Math.random() > 0.5 ? 'Coffee Shop' : 'Online Retailer'}`,
          merchant_name: Math.random() > 0.5 ? `Merchant X ${Math.floor(Math.random() * 100)}` : null,
          payment_channel: Math.random() > 0.5 ? "online" : "in store",
          transaction_type: Math.random() > 0.3 ? "digital" : "place",
          pending: Math.random() > 0.9,
          transaction_code: Math.random() > 0.7 ? "ACH" : null,
          personal_finance_category: {
            primary: Math.random() > 0.5 ? "Food and Drink" : "Bills and Utilities",
            detailed: Math.random() > 0.5 ? "Restaurants" : "Rent & Mortgage",
          },
          live_mode: liveMode,
          payment_meta: {
            payee: Math.random() > 0.5 ? `Recipient Y ${Math.floor(Math.random() * 50)}` : undefined,
            reference_number: `REF-${Math.floor(Math.random() * 99999)}`,
          }
        });
      }
      return {
        transactions: transactions,
        accounts: [], // Accounts are typically fetched separately or provided as part of item data
        total_transactions: Math.min(100000, (parseInt(params.options?.offset || '0', 10) + count + (Math.random() * 1000))), // Simulate a large, but finite total
        request_id: `req_${Math.floor(Math.random() * 100000)}`,
        item: {
          item_id: "item_dummy_id", institution_id: "ins_dummy_id", webhook: null, error: null
        }
      } as T;
    } else if (path.includes("/accounts/get")) {
      const accounts: PlaidAccount[] = [];
      const count = Math.floor(Math.random() * 5) + 1; // 1-5 accounts
      for (let i = 0; i < count; i++) {
        accounts.push({
          account_id: `acc_${Math.floor(Math.random() * 500)}`,
          name: `Checking Account ${i + 1}`,
          subtype: "checking",
          type: "depository",
          balances: {
            available: parseFloat((Math.random() * 10000).toFixed(2)),
            current: parseFloat((Math.random() * 12000).toFixed(2)),
            iso_currency_code: Currency.USD,
            unofficial_currency_code: null,
            limit: null,
          },
          mask: (Math.floor(1000 + Math.random() * 8999)).toString(),
          official_name: `Citibank Premier Checking`,
          live_mode: liveMode
        });
      }
      return {
        accounts: accounts,
        item: {
          item_id: "item_dummy_id", institution_id: "ins_dummy_id", webhook: null, error: null
        },
        request_id: `req_acc_${Math.floor(Math.random() * 100000)}`,
      } as T;
    }
    throw new Error(`Unsupported Plaid path for dummy data: ${path}`);
  }

  /**
   * Fetches Plaid transactions, handling pagination.
   * Plaid's API typically requires an `access_token` for specific items (institutions).
   * For this simulation, we assume `accessToken` is a "master" token or represents
   * a single customer's access, simplified for demonstration.
   * @param accessToken Plaid access token (e.g., associated with an Item).
   * @param startDate YYYY-MM-DD start date.
   * @param endDate YYYY-MM-DD end date.
   * @param liveMode Boolean indicating live or sandbox environment.
   * @param offset Current offset for pagination.
   * @returns A PlaidTransactionsGetResponse containing transactions and total count.
   */
  async fetchTransactions(
    accessToken: string,
    startDate: string,
    endDate: string,
    liveMode: boolean,
    offset = 0
  ): Promise<PlaidTransactionsGetResponse> {
    const params: Record<string, any> = {
      client_id: "dummy_plaid_client_id",
      secret: this.apiKey,
      access_token: accessToken,
      start_date: startDate,
      end_date: endDate,
      options: {
        count: API_PAGE_SIZE,
        offset: offset,
      },
    };
    return this.get<PlaidTransactionsGetResponse>(
      "/transactions/get",
      params
    );
  }

  /**
   * Fetches Plaid Accounts associated with an access token.
   */
  async fetchAccounts(
    accessToken: string,
    liveMode: boolean,
  ): Promise<{ accounts: PlaidAccount[] }> {
    const params: Record<string, any> = {
      client_id: "dummy_plaid_client_id",
      secret: this.apiKey,
      access_token: accessToken,
    };
    return this.get<{ accounts: PlaidAccount[] }>("/accounts/get", params);
  }
}

/**
 * Simulated client for Citibank Demo Business Internal Systems.
 * Assumes a proprietary REST API hosted at citibankdemobusiness.dev for internal financial data.
 */
class CitibankInternalClient extends BaseApiClient {
  constructor(apiKey: string, liveMode: boolean) {
    // For internal systems, liveMode might map to different API keys, specific endpoints,
    // or internal environment routing. We'll use the same base URL for simplicity
    // and let the `liveEnv` flag in the dummy data reflect the mode.
    super(CITIBANK_DEMO_BUSINESS_API_BASE_URL, apiKey);
  }

  protected generateDummyResponse<T>(path: string, params: Record<string, any>): T {
    const liveEnv = this.apiKey.startsWith("cb_live"); // Infer from API key prefix
    if (path.includes("/transactions")) {
      const transactions: CitibankInternalTransaction[] = [];
      const limit = parseInt(params.limit || API_PAGE_SIZE, 10);
      const offset = parseInt(params.offset || '0', 10);
      const startDateTime = new Date(params.startDate).getTime();
      const endDateTime = new Date(params.endDate).getTime();

      for (let i = 0; i < limit; i++) {
        const randomTime = startDateTime + Math.random() * (endDateTime - startDateTime);
        const transactionDate = new Date(randomTime).toISOString();
        const amountMinorUnits = Math.floor(Math.random() * 10000000) + 1000; // up to $100,000
        const transactionType = Math.random() > 0.6 ? "DEBIT" : (Math.random() > 0.5 ? "CREDIT" : "FEE");

        transactions.push({
          transactionIdentifier: `cb_int_txn_${offset}_${i + 1}`,
          accountNumber: `ACC-${Math.floor(Math.random() * 20000)}`,
          transactionDate: transactionDate,
          valueDate: new Date(randomTime + 24 * 60 * 60 * 1000).toISOString(), // Value date usually next day
          amountMinorUnits: amountMinorUnits,
          currencyCode: (Math.random() > 0.7 ? Currency.JPY : Currency.USD),
          transactionType: transactionType,
          description: `Internal Transfer ${i + 1} for ${transactionType} from Dept ${Math.floor(Math.random() * 10)}`,
          status: Math.random() > 0.1 ? "COMPLETED" : "PENDING",
          liveEnv: liveEnv,
          category: transactionType === "DEBIT" ? "Operating Expenses" : (transactionType === "CREDIT" ? "Revenue" : "Bank Fees"),
          merchantDetails: transactionType === "DEBIT" ? `Internal Vendor ${Math.floor(Math.random() * 100)}` : undefined,
          referenceId: `REF-${Math.floor(Math.random() * 999999)}`,
          internalApprovalCode: `APP-${Math.floor(Math.random() * 10000)}`,
          customMetadata: {
            project_code: `PRJ-${Math.floor(Math.random() * 50)}`,
            cost_center: `CC-${Math.floor(Math.random() * 20)}`,
          },
          counterpartyAccount: `ACC-CP-${Math.floor(Math.random() * 20000)}`,
          counterpartyName: `Citibank Dept ${Math.floor(Math.random() * 10)}`,
        });
      }
      return {
        data: transactions,
        totalRecords: Math.min(500000, (offset + limit + Math.floor(Math.random() * 500))), // Simulate a large total
        hasMore: Math.random() > 0.2, // Consistent pagination
        nextOffset: Math.random() > 0.2 ? offset + limit : undefined,
      } as T;
    } else if (path.includes("/accounts")) {
      const accounts: CitibankInternalAccount[] = [];
      const limit = parseInt(params.limit || API_PAGE_SIZE, 10);
      for (let i = 0; i < limit; i++) {
        accounts.push({
          accountNumber: `ACC-${Math.floor(Math.random() * 20000)}`,
          accountName: `Operating Account ${i + 1}`,
          accountType: "Checking",
          currentBalanceMinorUnits: Math.floor(Math.random() * 100000000) + 100000, // up to $1,000,000
          currencyCode: (Math.random() > 0.7 ? Currency.JPY : Currency.USD),
          lastUpdated: new Date().toISOString(),
          liveEnv: liveEnv,
          customerIdentifier: `CUST-${Math.floor(Math.random() * 5000)}`
        });
      }
      return {
        data: accounts,
        totalRecords: Math.min(10000, (limit + Math.floor(Math.random() * 100))),
        hasMore: Math.random() > 0.8,
        nextOffset: Math.random() > 0.8 ? offset + limit : undefined,
      } as T;
    }
    throw new Error(`Unsupported Citibank Internal path for dummy data: ${path}`);
  }

  /**
   * Fetches internal Citibank transactions, managing pagination through `offset`.
   */
  async fetchTransactions(
    startDate: string,
    endDate: string,
    liveMode: boolean,
    offset = 0
  ): Promise<CitibankInternalPaginationResponse<CitibankInternalTransaction>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      startDate: startDate,
      endDate: endDate,
      offset: offset.toString(),
      liveMode: liveMode.toString(),
    };
    return this.get<CitibankInternalPaginationResponse<CitibankInternalTransaction>>(
      "/v1/transactions",
      params
    );
  }

  /**
   * Fetches internal Citibank accounts, managing pagination.
   */
  async fetchAccounts(
    liveMode: boolean,
    offset = 0
  ): Promise<CitibankInternalPaginationResponse<CitibankInternalAccount>> {
    const params: Record<string, any> = {
      limit: API_PAGE_SIZE.toString(),
      offset: offset.toString(),
      liveMode: liveMode.toString(),
    };
    return this.get<CitibankInternalPaginationResponse<CitibankInternalAccount>>(
      "/v1/accounts",
      params
    );
  }
}

// --- Data Normalization and Transformation ---

/**
 * Normalizes a Modern Treasury transaction into the unified `FinancialRecord` format.
 */
function normalizeModernTreasuryTransaction(
  txn: ModernTreasuryTransaction
): FinancialRecord {
  return {
    id: `mt-${txn.id}`,
    source: FinancialDataSource.MODERN_TREASURY,
    recordType: FinancialRecordType.TRANSACTION,
    timestamp: txn.posted_at,
    amount: txn.amount,
    currency: txn.currency.toUpperCase() as Currency,
    description: txn.description,
    status: txn.status,
    metadata: { ...txn.metadata, type: txn.type, direction: txn.direction, ledger_account_id: txn.ledger_account_id, vendor_id: txn.vendor_id, transaction_code: txn.transaction_code, effective_at: txn.effective_at },
    externalReferenceId: txn.id,
    liveMode: txn.live_mode,
    counterpartyName: txn.counterparty_name,
  };
}

/**
 * Normalizes a Modern Treasury Ledger Account into a generic FinancialRecord (representing a balance).
 * This is an interpretation of how a ledger account might be represented in a transaction-centric export.
 */
function normalizeModernTreasuryLedgerAccount(
  account: ModernTreasuryLedgerAccount
): FinancialRecord {
  // We don't have a direct "balance" for a LedgerAccount in MT's model typically,
  // but we can represent its conceptual existence. For a true balance, an actual balance query would be needed.
  return {
    id: `mt-la-${account.id}`,
    source: FinancialDataSource.MODERN_TREASURY,
    recordType: FinancialRecordType.LEDGER_ENTRY, // Or ACCOUNT_BALANCE if we fetched balances
    timestamp: account.updated_at,
    amount: 0, // Placeholder, would need balance lookup
    currency: account.currency.toUpperCase() as Currency,
    description: `Ledger Account: ${account.name}`,
    status: "active",
    metadata: { ...account.metadata, normal_balance: account.normal_balance, created_at: account.created_at, description: account.description },
    externalReferenceId: account.id,
    liveMode: account.live_mode,
  };
}

/**
 * Normalizes a Stripe Charge into a common `FinancialRecord` format.
 */
function normalizeStripeCharge(charge: StripeCharge): FinancialRecord {
  return {
    id: `st-ch-${charge.id}`,
    source: FinancialDataSource.STRIPE,
    recordType: FinancialRecordType.CHARGE,
    timestamp: new Date(charge.created * 1000).toISOString(),
    amount: charge.amount, // positive for income
    currency: charge.currency.toUpperCase() as Currency,
    description: charge.description || `Stripe Charge ${charge.id}`,
    status: charge.status,
    metadata: { ...charge.metadata, customer: charge.customer, receipt_email: charge.receipt_email, source_transfer: charge.source_transfer, balance_transaction: charge.balance_transaction },
    externalReferenceId: charge.id,
    liveMode: charge.livemode,
    counterpartyName: charge.customer ? `Stripe Customer ${charge.customer}` : "Customer",
  };
}

/**
 * Normalizes a Stripe Payout into a common `FinancialRecord` format.
 */
function normalizeStripePayout(payout: StripePayout): FinancialRecord {
  return {
    id: `st-po-${payout.id}`,
    source: FinancialDataSource.STRIPE,
    recordType: FinancialRecordType.PAYOUT,
    timestamp: new Date(payout.created * 1000).toISOString(),
    amount: -payout.amount, // negative for outflow
    currency: payout.currency.toUpperCase() as Currency,
    description: payout.description || `Stripe Payout ${payout.id}`,
    status: payout.status,
    metadata: { ...payout.metadata, destination: payout.destination, statement_descriptor: payout.statement_descriptor, arrival_date: new Date(payout.arrival_date * 1000).toISOString() },
    externalReferenceId: payout.id,
    liveMode: payout.livemode,
    counterpartyName: `Payout Destination ${payout.destination}`,
  };
}

/**
 * Normalizes a Stripe Refund into a common `FinancialRecord` format.
 */
function normalizeStripeRefund(refund: StripeRefund): FinancialRecord {
  return {
    id: `st-re-${refund.id}`,
    source: FinancialDataSource.STRIPE,
    recordType: FinancialRecordType.REFUND,
    timestamp: new Date(refund.created * 1000).toISOString(),
    amount: -refund.amount, // negative for refund outflow
    currency: refund.currency.toUpperCase() as Currency,
    description: `Refund for charge ${refund.charge}` + (refund.reason ? `: ${refund.reason}` : ''),
    status: refund.status,
    metadata: { ...refund.metadata, charge_id: refund.charge, reason: refund.reason, balance_transaction: refund.balance_transaction },
    externalReferenceId: refund.id,
    liveMode: refund.livemode,
    relatedTransactionId: `st-ch-${refund.charge}`,
  };
}

/**
 * Normalizes a Stripe Balance Transaction into a common `FinancialRecord` format.
 */
function normalizeStripeBalanceTransaction(txn: StripeTransaction): FinancialRecord {
  return {
    id: `st-bt-${txn.id}`,
    source: FinancialDataSource.STRIPE,
    recordType: FinancialRecordType.TRANSACTION, // Generic transaction type
    timestamp: new Date(txn.created * 1000).toISOString(),
    amount: txn.amount,
    currency: txn.currency.toUpperCase() as Currency,
    description: txn.description || `Stripe Balance Transaction ${txn.id} (${txn.type})`,
    status: txn.status,
    metadata: { type: txn.type, net_amount: txn.net, fee_amount: txn.fee },
    externalReferenceId: txn.id,
    liveMode: txn.livemode,
  };
}


/**
 * Normalizes a Plaid Transaction into a common `FinancialRecord` format.
 * Plaid amounts are typically positive for credit, negative for debit.
 * We might want to standardize debit as negative in our `FinancialRecord`.
 */
function normalizePlaidTransaction(
  txn: PlaidTransaction,
  liveMode: boolean
): FinancialRecord {
  return {
    id: `pl-${txn.transaction_id}`,
    source: FinancialDataSource.PLAID,
    recordType: FinancialRecordType.TRANSACTION,
    timestamp: `${txn.date}T00:00:00.000Z`, // Plaid date is YYYY-MM-DD
    amount: Math.round(txn.amount * 100) * -1, // Convert to minor units and negate (assume standard financial reporting where expenses are negative)
    currency: (txn.iso_currency_code || txn.unofficial_currency_code || Currency.USD).toUpperCase() as Currency,
    description: txn.name,
    status: txn.pending ? "pending" : "completed",
    metadata: {
      merchant_name: txn.merchant_name,
      payment_channel: txn.payment_channel,
      transaction_type_plaid: txn.transaction_type,
      category_primary: txn.personal_finance_category?.primary,
      category_detailed: txn.personal_finance_category?.detailed,
      account_id: txn.account_id,
      authorized_date: txn.authorized_date,
      transaction_code: txn.transaction_code,
      payment_meta: txn.payment_meta,
    },
    externalReferenceId: txn.transaction_id,
    liveMode: liveMode,
    originatingAccountId: txn.account_id,
    category: txn.personal_finance_category?.primary,
    counterpartyName: txn.merchant_name || txn.payment_meta?.payee,
  };
}

/**
 * Normalizes a Citibank Internal Transaction into a common `FinancialRecord` format.
 */
function normalizeCitibankInternalTransaction(
  txn: CitibankInternalTransaction
): FinancialRecord {
  const amount = txn.transactionType === "DEBIT" || txn.transactionType === "FEE"
    ? -txn.amountMinorUnits
    : txn.amountMinorUnits; // Apply sign based on type
  return {
    id: `cb-int-${txn.transactionIdentifier}`,
    source: FinancialDataSource.CITIBANK_INTERNAL,
    recordType: FinancialRecordType.TRANSACTION,
    timestamp: txn.transactionDate,
    amount: amount,
    currency: txn.currencyCode.toUpperCase() as Currency,
    description: txn.description,
    status: txn.status === "COMPLETED" ? "completed" : txn.status.toLowerCase(), // Normalize status
    metadata: { ...txn.customMetadata, transaction_type_cb: txn.transactionType, category: txn.category, merchant_details: txn.merchantDetails, account_number: txn.accountNumber, value_date: txn.valueDate, reference_id: txn.referenceId, internal_approval_code: txn.internalApprovalCode, counterparty_account: txn.counterpartyAccount },
    originatingAccountId: txn.accountNumber,
    externalReferenceId: txn.transactionIdentifier,
    liveMode: txn.liveEnv,
    category: txn.category,
    counterpartyName: txn.counterpartyName || txn.merchantDetails,
  };
}

// --- CSV Generation ---

/**
 * A utility class responsible for converting an array of `FinancialRecord` objects
 * into a standard CSV (Comma Separated Values) string.
 * It handles header generation, proper data mapping, and CSV escaping rules.
 */
class CsvGenerator {
  /**
   * Defines a default, ordered set of headers for the CSV, prioritizing common fields.
   * Dynamic metadata fields will be appended.
   */
  private static readonly BASE_CSV_HEADERS: string[] = [
    "ID",
    "Source",
    "RecordType",
    "Timestamp",
    "Amount", // Displayed as float currency
    "Currency",
    "Description",
    "Status",
    "LiveMode",
    "Category",
    "CounterpartyName",
    "OriginatingAccountId",
    "DestinationAccountId",
    "RelatedTransactionId",
    "ExternalReferenceId",
  ];

  /**
   * Generates a comprehensive CSV header row by combining base headers and all unique
   * metadata keys found across the provided records.
   * @param records An array of `FinancialRecord` to infer all possible metadata fields.
   * @returns An array of strings representing the ordered CSV header.
   */
  private static getCsvHeaders(records: FinancialRecord[]): string[] {
    const metadataKeys = new Set<string>();
    for (const record of records) {
      if (record.metadata) {
        for (const key of Object.keys(record.metadata)) {
          metadataKeys.add(key);
        }
      }
    }

    const sortedMetadataKeys = Array.from(metadataKeys).sort();
    return [...CsvGenerator.BASE_CSV_HEADERS, ...sortedMetadataKeys.map(key => `Metadata_${key}`)];
  }

  /**
   * Escapes a string value according to RFC 4180 CSV rules.
   * Values containing commas, double-quotes, or newlines are enclosed in double-quotes,
   * and any internal double-quotes are escaped by doubling them.
   * @param value The raw value to be escaped.
   * @returns The CSV-escaped string.
   */
  private static escapeCsvValue(value: any): string {
    if (value === null || value === undefined) {
      return "";
    }
    let stringValue = String(value);

    // Format amount as currency string, assuming minor units
    if (typeof value === 'number' && typeof stringValue !== 'boolean' && !isNaN(value) && stringValue.length > 0 && stringValue[0] !== '-') {
      // Check if it's likely an amount in minor units (e.g., no decimal, or too many decimal places for a currency)
      // This is a heuristic. A more robust solution would pass currency to the formatter.
      if (value % 1 === 0) { // If it's an integer, assume minor units and convert to major.
         stringValue = (value / 100).toFixed(2);
      } else { // Already has decimals, treat as is or format for consistency.
         stringValue = value.toFixed(2); // Ensure two decimal places for currency
      }
    }

    // Handle boolean values
    if (typeof value === 'boolean') {
      stringValue = value ? 'TRUE' : 'FALSE';
    }

    // Handle objects/arrays in metadata by stringifying them
    if (typeof value === 'object' && value !== null) {
      stringValue = JSON.stringify(value);
    }

    // Apply CSV escaping rules
    if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n') || stringValue.includes('\r')) {
      return `"${stringValue.replace(/"/g, '""')}"`;
    }
    return stringValue;
  }

  /**
   * Converts a single `FinancialRecord` object into an array of CSV-escaped strings,
   * aligned with the provided header order.
   * @param record The `FinancialRecord` object to format.
   * @param headers The ordered list of headers to match when extracting values.
   * @returns An array of strings representing a single CSV row.
   */
  private static formatRecordToCsvRow(record: FinancialRecord, headers: string[]): string[] {
    const row: string[] = [];
    for (const header of headers) {
      if (header === "ID") row.push(this.escapeCsvValue(record.id));
      else if (header === "Source") row.push(this.escapeCsvValue(record.source));
      else if (header === "RecordType") row.push(this.escapeCsvValue(record.recordType));
      else if (header === "Timestamp") row.push(this.escapeCsvValue(record.timestamp));
      else if (header === "Amount") row.push(this.escapeCsvValue(record.amount));
      else if (header === "Currency") row.push(this.escapeCsvValue(record.currency));
      else if (header === "Description") row.push(this.escapeCsvValue(record.description));
      else if (header === "Status") row.push(this.escapeCsvValue(record.status));
      else if (header === "LiveMode") row.push(this.escapeCsvValue(record.liveMode));
      else if (header === "Category") row.push(this.escapeCsvValue(record.category));
      else if (header === "CounterpartyName") row.push(this.escapeCsvValue(record.counterpartyName));
      else if (header === "OriginatingAccountId") row.push(this.escapeCsvValue(record.originatingAccountId));
      else if (header === "DestinationAccountId") row.push(this.escapeCsvValue(record.destinationAccountId));
      else if (header === "RelatedTransactionId") row.push(this.escapeCsvValue(record.relatedTransactionId));
      else if (header === "ExternalReferenceId") row.push(this.escapeCsvValue(record.externalReferenceId));
      else if (header.startsWith("Metadata_")) {
        const metadataKey = header.substring("Metadata_".length);
        const value = record.metadata?.[metadataKey];
        row.push(this.escapeCsvValue(value));
      } else {
        row.push(""); // Fallback for unexpected headers
      }
    }
    return row;
  }

  /**
   * Generates a complete CSV string from an array of `FinancialRecord` objects.
   * This is the primary entry point for CSV generation.
   * @param records The array of `FinancialRecord` objects to convert.
   * @returns A string containing the CSV data, including headers.
   */
  public static generateCsv(records: FinancialRecord[]): string {
    if (records.length === 0) {
      // If no records, return only headers based on base headers
      return CsvGenerator.BASE_CSV_HEADERS.map(this.escapeCsvValue).join(",");
    }

    const headers = CsvGenerator.getCsvHeaders(records);
    const csvRows: string[] = [];

    csvRows.push(headers.map(this.escapeCsvValue).join(",")); // Header row

    for (const record of records) {
      csvRows.push(this.formatRecordToCsvRow(record, headers).join(","));
    }

    return csvRows.join("\n");
  }
}

// --- Export Service Logic ---

/**
 * The `DataExportService` orchestrates the entire data export lifecycle.
 * It manages initiation, status tracking, data fetching, aggregation, transformation,
 * CSV generation, and secure storage. Designed for high scalability and reliability.
 */
class DataExportService {
  private modernTreasuryClient: ModernTreasuryClient;
  private stripeClient: StripeClient;
  private plaidClient: PlaidClient;
  private citibankInternalClient: CitibankInternalClient;

  // In a real application, API keys would be loaded securely from environment variables,
  // a secrets manager (e.g., AWS Secrets Manager, HashiCorp Vault), or a secure configuration system.
  // For this simulation, we use dummy keys and re-instantiate clients per request to
  // properly handle the `liveMode` setting.
  private apiKeys: {
    modernTreasury: string;
    stripe: string;
    plaid: string;
    citibankInternal: string;
  };

  constructor(apiKeys: {
    modernTreasury: string;
    stripe: string;
    plaid: string;
    citibankInternal: string;
  }) {
    this.apiKeys = apiKeys;
    // Clients are initially instantiated with dummy values; they will be
    // properly initialized per request with the correct liveMode.
    this.modernTreasuryClient = new ModernTreasuryClient("dummy", false);
    this.stripeClient = new StripeClient("dummy", false);
    this.plaidClient = new PlaidClient("dummy", false);
    this.citibankInternalClient = new CitibankInternalClient("dummy", false);
  }

  /**
   * Initializes or re-initializes all external API clients based on the
   * `liveMode` setting of the incoming `DataExportRequest`.
   * This ensures that the service interacts with the correct environment (live/sandbox)
   * for each individual export job.
   */
  private initClientsForRequest(request: DataExportRequest) {
    // In a real system, `this.apiKeys` would hold both live and sandbox keys,
    // or a mechanism to retrieve the correct key based on `request.liveMode`.
    // Here, we simulate by constructing placeholder keys.
    this.modernTreasuryClient = new ModernTreasuryClient(
      request.liveMode ? this.apiKeys.modernTreasury + "_live" : this.apiKeys.modernTreasury + "_test",
      request.liveMode
    );
    this.stripeClient = new StripeClient(
      request.liveMode ? this.apiKeys.stripe + "_live" : this.apiKeys.stripe + "_test",
      request.liveMode
    );
    this.plaidClient = new PlaidClient(
      request.liveMode ? this.apiKeys.plaid + "_live" : this.apiKeys.plaid + "_test",
      request.liveMode
    );
    this.citibankInternalClient = new CitibankInternalClient(
      request.liveMode ? this.apiKeys.citibankInternal + "_live" : this.apiKeys.citibankInternal + "_test",
      request.liveMode
    );
  }

  /**
   * Simulated in-memory database to store export job details.
   * In a production environment, this would be a persistent database (e.g., PostgreSQL, DynamoDB)
   * to ensure durability and availability across service restarts and scaling.
   */
  private static exportJobs: Map<string, ExportJobDetails> = new Map();

  /**
   * Initiates a new data export job. This is an asynchronous operation designed to
   * return quickly, allowing the actual data processing to occur in the background.
   * A unique `exportId` is generated or provided to track the job.
   * @param request The complete data export request parameters.
   * @returns A Promise resolving to the initial `ExportJobDetails`, reflecting its `PENDING` state.
   */
  public async initiateExport(request: DataExportRequest): Promise<ExportJobDetails> {
    if (DataExportService.exportJobs.has(request.exportId)) {
      throw new Error(`Export job with ID ${request.exportId} already exists.`);
    }

    const jobDetails: ExportJobDetails = {
      exportId: request.exportId,
      userId: request.userId,
      status: ExportJobStatus.PENDING,
      requestedAt: new Date().toISOString(),
      progress: 0,
      request: { ...request, requestedAt: new Date().toISOString() }, // Store request with current timestamp
      logMessages: [`Export job created at ${new Date().toISOString()}`],
    };
    DataExportService.exportJobs.set(request.exportId, jobDetails);

    console.log(`[EXPORT SERVICE] Export job ${request.exportId} initiated for user ${request.userId}.`);

    // Kick off the background processing. In a real-world, high-volume system,
    // this call would typically publish a message to a message queue (e.g., AWS SQS, Apache Kafka, RabbitMQ),
    // and a separate worker service would consume these messages to perform the heavy lifting.
    // This decouples the API request from long-running computations, improving responsiveness and scalability.
    this.processExportJob(request.exportId)
      .catch((error) => {
        // Handle unexpected errors during background processing
        const errorMessage = `Unexpected error during background processing for job ${request.exportId}: ${error.message || 'Unknown error'}`;
        console.error(errorMessage, error);
        this.updateExportJobStatus(request.exportId, {
          status: ExportJobStatus.FAILED,
          failedReason: errorMessage,
          completedAt: new Date().toISOString(),
          logMessages: (this.getExportJobDetails(request.exportId)?.logMessages || []).concat([errorMessage]),
        });
        if (request.webhookUrl) {
          this.sendWebhookNotification(request.webhookUrl, this.getExportJobDetails(request.exportId));
        }
      });

    return jobDetails;
  }

  /**
   * Retrieves the current status and detailed information for a specific export job.
   * This method is typically exposed via an API endpoint for users to check job progress.
   * @param exportId The unique identifier of the export job.
   * @returns The `ExportJobDetails` object, or `undefined` if no job with the given ID is found.
   */
  public getExportJobDetails(exportId: string): ExportJobDetails | undefined {
    return DataExportService.exportJobs.get(exportId);
  }

  /**
   * Internal method to update the status and details of an export job.
   * It ensures that updates are properly merged and logged.
   * @param exportId The ID of the export job to update.
   * @param updates A partial `ExportJobDetails` object containing the fields to modify.
   */
  private updateExportJobStatus(exportId: string, updates: Partial<ExportJobDetails>) {
    const currentJob = DataExportService.exportJobs.get(exportId);
    if (currentJob) {
      const updatedJob = {
        ...currentJob,
        ...updates,
        logMessages: updates.logMessages ? (currentJob.logMessages || []).concat(updates.logMessages) : currentJob.logMessages,
      };
      DataExportService.exportJobs.set(exportId, updatedJob);
      console.log(`[EXPORT SERVICE] Job ${exportId} updated: Status=${updatedJob.status}, Progress=${updatedJob.progress}%`);
    } else {
      console.warn(`[EXPORT SERVICE] Attempted to update non-existent export job: ${exportId}`);
    }
  }

  /**
   * Simulates sending a webhook notification to an external URL.
   * In a real system, this would use a robust HTTP client (e.g., `axios`, `node-fetch`)
   * and potentially include retry logic for webhook deliveries.
   * @param webhookUrl The URL to which the notification should be sent.
   * @param jobDetails The current job details to be sent in the webhook payload.
   */
  private async sendWebhookNotification(webhookUrl: string, jobDetails: ExportJobDetails | undefined) {
    if (!webhookUrl || !jobDetails) return;

    try {
      const payload = JSON.stringify(jobDetails, null, 2);
      console.log(`[WEBHOOK] Simulating notification to ${webhookUrl} for job ${jobDetails.exportId}. Payload: ${payload}`);
      // In a real application, replace this with a proper HTTP POST request:
      // await fetch(webhookUrl, {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: payload,
      // });
      await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 500)); // Simulate network call
      this.updateExportJobStatus(jobDetails.exportId, { logMessages: [`Webhook sent to ${webhookUrl}`] });
      console.log(`[WEBHOOK] Webhook for job ${jobDetails.exportId} sent successfully.`);
    } catch (error: any) {
      const errorMessage = `Failed to send webhook for job ${jobDetails.exportId} to ${webhookUrl}: ${error.message || 'Unknown error'}`;
      this.updateExportJobStatus(jobDetails.exportId, { logMessages: [errorMessage] });
      console.error(`[WEBHOOK ERROR] ${errorMessage}`, error);
    }
  }

  /**
   * The core logic for processing an individual export job. This method orchestrates
   * the entire data pipeline:
   * 1. Initializes API clients for the specific `liveMode`.
   * 2. Iteratively fetches data from all specified financial sources, handling pagination.
   * 3. Aggregates and normalizes all fetched data into a common `FinancialRecord` format.
   * 4. Generates a CSV file from the normalized data.
   * 5. Uploads the generated CSV to a secure, long-term storage solution (simulated S3).
   * 6. Updates the job status throughout the process and sends webhook notifications.
   * @param exportId The ID of the export job to process.
   * @returns A Promise that resolves when the job is completed or rejects if a fatal error occurs.
   */
  private async processExportJob(exportId: string): Promise<void> {
    const job = this.getExportJobDetails(exportId);
    if (!job) {
      console.error(`[EXPORT SERVICE] Export job ${exportId} not found for processing.`);
      return;
    }

    this.updateExportJobStatus(exportId, {
      status: ExportJobStatus.IN_PROGRESS,
      startedAt: new Date().toISOString(),
      progress: 5,
      logMessages: [`Job processing started.`],
    });
    this.initClientsForRequest(job.request); // Ensure clients are configured for the correct environment

    const allRecords: FinancialRecord[] = [];
    let completedSources = 0;
    const totalSources = job.request.dataSources.length;
    const progressPerSourceBlock = 70 / totalSources; // 5% initial + 10% CSV/upload, leaving 70% for fetching

    try {
      // Step 1: Fetch data from Modern Treasury
      if (job.request.dataSources.includes(FinancialDataSource.MODERN_TREASURY)) {
        this.updateExportJobStatus(exportId, { logMessages: [`Fetching Modern Treasury data...`] });
        await this.fetchModernTreasuryData(job.request, allRecords);
        completedSources++;
        this.updateExportJobStatus(exportId, { progress: Math.floor(5 + completedSources * progressPerSourceBlock) });
      }

      // Step 2: Fetch data from Stripe
      if (job.request.dataSources.includes(FinancialDataSource.STRIPE)) {
        this.updateExportJobStatus(exportId, { logMessages: [`Fetching Stripe data...`] });
        await this.fetchStripeData(job.request, allRecords);
        completedSources++;
        this.updateExportJobStatus(exportId, { progress: Math.floor(5 + completedSources * progressPerSourceBlock) });
      }

      // Step 3: Fetch data from Plaid
      if (job.request.dataSources.includes(FinancialDataSource.PLAID)) {
        this.updateExportJobStatus(exportId, { logMessages: [`Fetching Plaid data...`] });
        // Plaid requires an access token per item/institution. For this simulation,
        // we use a single dummy token. In a real application, you'd manage these tokens
        // for each customer/institution connected via Plaid.
        const plaidAccessToken = job.request.liveMode ? "plaid_live_access_token_customer1" : "plaid_sandbox_access_token_customer1";
        await this.fetchPlaidData(job.request, allRecords, plaidAccessToken);
        completedSources++;
        this.updateExportJobStatus(exportId, { progress: Math.floor(5 + completedSources * progressPerSourceBlock) });
      }

      // Step 4: Fetch data from Citibank Internal Systems
      if (job.request.dataSources.includes(FinancialDataSource.CITIBANK_INTERNAL)) {
        this.updateExportJobStatus(exportId, { logMessages: [`Fetching Citibank Internal data...`] });
        await this.fetchCitibankInternalData(job.request, allRecords);
        completedSources++;
        this.updateExportJobStatus(exportId, { progress: Math.floor(5 + completedSources * progressPerSourceBlock) });
      }

      console.log(`[EXPORT SERVICE] Finished fetching data for job ${exportId}. Total records collected: ${allRecords.length}`);
      this.updateExportJobStatus(exportId, {
        progress: 80,
        recordCount: allRecords.length,
        logMessages: [`Data fetching complete. Collected ${allRecords.length} records.`],
      });

      // Step 5: Sort records chronologically (important for financial data)
      allRecords.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

      // Step 6: Generate CSV file
      this.updateExportJobStatus(exportId, { progress: 85, logMessages: [`Generating CSV file...`] });
      const csvContent = CsvGenerator.generateCsv(allRecords);

      // Step 7: Simulate secure file upload to cloud storage (e.g., S3, GCS)
      this.updateExportJobStatus(exportId, { progress: 90, logMessages: [`Uploading generated CSV to secure storage...`] });
      const fileName = `financial_export_${exportId}_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
      // In a real system, `storeExportFile` would interact with AWS S3 SDK, Azure Blob Storage SDK, etc.
      const fileUrl = await this.storeExportFile(exportId, fileName, csvContent);

      // Step 8: Finalize job status
      this.updateExportJobStatus(exportId, {
        status: ExportJobStatus.COMPLETED,
        completedAt: new Date().toISOString(),
        fileUrl: fileUrl,
        progress: 100,
        logMessages: [`Export job completed successfully. File available at ${fileUrl}.`],
      });
      console.log(`[EXPORT SERVICE] Export job ${exportId} completed. File available at: ${fileUrl}`);

      // Step 9: Send final webhook notification
      if (job.request.webhookUrl) {
        this.sendWebhookNotification(job.request.webhookUrl, this.getExportJobDetails(exportId));
      }

    } catch (error: any) {
      // Catch any errors during the processing and mark the job as FAILED
      const errorMessage = `Export job ${exportId} failed during processing: ${error.message || 'Unknown error'}`;
      console.error(`[EXPORT SERVICE ERROR] ${errorMessage}`, error);
      this.updateExportJobStatus(exportId, {
        status: ExportJobStatus.FAILED,
        failedReason: errorMessage,
        completedAt: new Date().toISOString(),
        progress: 100,
        logMessages: (this.getExportJobDetails(exportId)?.logMessages || []).concat([errorMessage]),
      });
      // Send webhook for failure as well
      if (job.request.webhookUrl) {
        this.sendWebhookNotification(job.request.webhookUrl, this.getExportJobDetails(exportId));
      }
    }
  }

  /**
   * Fetches data from Modern Treasury based on the export request parameters.
   * This method handles pagination to retrieve all relevant transactions within the date range.
   * @param request The data export request.
   * @param allRecords The array to which normalized records will be appended.
   */
  private async fetchModernTreasuryData(
    request: DataExportRequest,
    allRecords: FinancialRecord[]
  ): Promise<void> {
    const includedTypes = request.resourceTypes;

    if (includedTypes.includes(FinancialRecordType.TRANSACTION)) {
      let hasMore = true;
      let cursor: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [MT] Fetching transactions page ${++page} (cursor: ${cursor || 'start'})`);
        try {
          const response = await this.modernTreasuryClient.fetchTransactions(
            request.startDate,
            request.endDate,
            request.liveMode,
            cursor
          );
          response.data.forEach((txn) => allRecords.push(normalizeModernTreasuryTransaction(txn)));
          hasMore = response.has_more;
          cursor = response.next_page_token;
          // Implement a safety break to prevent infinite loops in dummy data or API issues
          if (page > 100) { console.warn("  [MT] Safety break: fetched over 100 pages, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Modern Treasury transactions: ${error.message}`);
        }
      }
    }

    if (includedTypes.includes(FinancialRecordType.LEDGER_ENTRY) || includedTypes.includes(FinancialRecordType.ACCOUNT_BALANCE)) {
      let hasMore = true;
      let cursor: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [MT] Fetching ledger accounts page ${++page} (cursor: ${cursor || 'start'})`);
        try {
          const response = await this.modernTreasuryClient.fetchLedgerAccounts(
            request.liveMode,
            cursor
          );
          response.data.forEach((account) => allRecords.push(normalizeModernTreasuryLedgerAccount(account)));
          hasMore = response.has_more;
          cursor = response.next_page_token;
          if (page > 10) { console.warn("  [MT] Safety break: fetched over 10 pages for ledger accounts, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Modern Treasury ledger accounts: ${error.message}`);
        }
      }
    }
  }

  /**
   * Fetches data from Stripe based on the export request parameters.
   * Handles pagination for various Stripe resource types like charges, payouts, and refunds.
   * @param request The data export request.
   * @param allRecords The array to which normalized records will be appended.
   */
  private async fetchStripeData(
    request: DataExportRequest,
    allRecords: FinancialRecord[]
  ): Promise<void> {
    const includedTypes = request.resourceTypes;

    if (includedTypes.includes(FinancialRecordType.CHARGE)) {
      let hasMore = true;
      let startingAfterId: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [Stripe] Fetching charges page ${++page} (startingAfterId: ${startingAfterId || 'start'})`);
        try {
          const response = await this.stripeClient.fetchCharges(
            request.startDate,
            request.endDate,
            request.liveMode,
            startingAfterId
          );
          response.data.forEach((charge) => allRecords.push(normalizeStripeCharge(charge)));
          hasMore = response.has_more;
          if (response.data.length > 0) {
            startingAfterId = response.data[response.data.length - 1].id;
          } else {
            hasMore = false; // No more data in this page
          }
          if (page > 100) { console.warn("  [Stripe] Safety break: fetched over 100 pages for charges, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Stripe charges: ${error.message}`);
        }
      }
    }

    if (includedTypes.includes(FinancialRecordType.PAYOUT)) {
      let hasMore = true;
      let startingAfterId: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [Stripe] Fetching payouts page ${++page} (startingAfterId: ${startingAfterId || 'start'})`);
        try {
          const response = await this.stripeClient.fetchPayouts(
            request.startDate,
            request.endDate,
            request.liveMode,
            startingAfterId
          );
          response.data.forEach((payout) => allRecords.push(normalizeStripePayout(payout)));
          hasMore = response.has_more;
          if (response.data.length > 0) {
            startingAfterId = response.data[response.data.length - 1].id;
          } else {
            hasMore = false;
          }
          if (page > 50) { console.warn("  [Stripe] Safety break: fetched over 50 pages for payouts, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Stripe payouts: ${error.message}`);
        }
      }
    }

    if (includedTypes.includes(FinancialRecordType.REFUND)) {
      let hasMore = true;
      let startingAfterId: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [Stripe] Fetching refunds page ${++page} (startingAfterId: ${startingAfterId || 'start'})`);
        try {
          const response = await this.stripeClient.fetchRefunds(
            request.startDate,
            request.endDate,
            request.liveMode,
            startingAfterId
          );
          response.data.forEach((refund) => allRecords.push(normalizeStripeRefund(refund)));
          hasMore = response.has_more;
          if (response.data.length > 0) {
            startingAfterId = response.data[response.data.length - 1].id;
          } else {
            hasMore = false;
          }
          if (page > 50) { console.warn("  [Stripe] Safety break: fetched over 50 pages for refunds, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Stripe refunds: ${error.message}`);
        }
      }
    }

    // Include general Stripe balance transactions if requested
    if (includedTypes.includes(FinancialRecordType.BANK_TRANSFER) || includedTypes.includes(FinancialRecordType.ADJUSTMENT) || includedTypes.includes(FinancialRecordType.FEE)) {
      let hasMore = true;
      let startingAfterId: string | undefined = undefined;
      let page = 0;
      while (hasMore) {
        console.log(`  [Stripe] Fetching balance transactions page ${++page} (startingAfterId: ${startingAfterId || 'start'})`);
        try {
          const response = await this.stripeClient.fetchBalanceTransactions(
            request.startDate,
            request.endDate,
            request.liveMode,
            startingAfterId
          );
          response.data.forEach((txn) => allRecords.push(normalizeStripeBalanceTransaction(txn)));
          hasMore = response.has_more;
          if (response.data.length > 0) {
            startingAfterId = response.data[response.data.length - 1].id;
          } else {
            hasMore = false;
          }
          if (page > 100) { console.warn("  [Stripe] Safety break: fetched over 100 pages for balance transactions, stopping."); break; }
        } catch (error: any) {
          throw new Error(`Failed to fetch Stripe balance transactions: ${error.message}`);
        }
      }
    }
  }

  /**
   * Fetches data from Plaid based on the export request parameters.
   * Requires an `accessToken` which would typically correspond to a specific
   * financial institution or "Item" connected via Plaid Link.
   * @param request The data export request.
   * @param allRecords The array to which normalized records will be appended.
   * @param accessToken Plaid access token (e.g., associated with an Item).
   */
  private async fetchPlaidData(
    request: DataExportRequest,
    allRecords: FinancialRecord[],
    accessToken: string
  ): Promise<void> {
    const includedTypes = request.resourceTypes;

    if (includedTypes.includes(FinancialRecordType.TRANSACTION)) {
      let totalTransactions = Infinity;
      let offset = 0;
      let page = 0;
      while (offset < totalTransactions) {
        console.log(`  [Plaid] Fetching transactions page ${++page} (offset: ${offset})`);
        try {
          const response = await this.plaidClient.fetchTransactions(
            accessToken,
            request.startDate,
            request.endDate,
            request.liveMode,
            offset
          );
          response.transactions.forEach((txn) =>
            allRecords.push(normalizePlaidTransaction(txn, request.liveMode))
          );
          totalTransactions = response.total_transactions;
          offset += response.transactions.length;

          // Safety break: if no transactions returned or exceed a reasonable limit for dummy data
          if (response.transactions.length === 0 || page > 200 || offset >= 100000) {
              console.warn(`  [Plaid] Safety break: fetched ${page} pages or reached 100,000 records, stopping.`);
              break;
          }
        } catch (error: any) {
          throw new Error(`Failed to fetch Plaid transactions: ${error.message}`);
        }
      }
    }

    if (includedTypes.includes(FinancialRecordType.ACCOUNT_BALANCE)) {
      // Plaid accounts/balances are typically fetched once per item, not paginated over time.
      // For this export, we assume a snapshot might be sufficient or we'd fetch transactions over time.
      // This is a simplified example.
      console.log(`  [Plaid] Fetching account balances...`);
      try {
        const response = await this.plaidClient.fetchAccounts(accessToken, request.liveMode);
        response.accounts.forEach(account => {
          if (account.balances.current && account.balances.iso_currency_code) {
            allRecords.push({
              id: `pl-bal-${account.account_id}-${new Date().toISOString().substring(0, 10)}`,
              source: FinancialDataSource.PLAID,
              recordType: FinancialRecordType.ACCOUNT_BALANCE,
              timestamp: new Date().toISOString(), // Snapshot date
              amount: Math.round(account.balances.current * 100), // Convert to minor units
              currency: account.balances.iso_currency_code.toUpperCase() as Currency,
              description: `Plaid Account Balance for ${account.name}`,
              status: "current",
              metadata: { account_type: account.type, account_subtype: account.subtype, official_name: account.official_name, mask: account.mask, available_balance: account.balances.available },
              originatingAccountId: account.account_id,
              externalReferenceId: account.account_id,
              liveMode: request.liveMode,
            });
          }
        });
      } catch (error: any) {
        throw new Error(`Failed to fetch Plaid accounts/balances: ${error.message}`);
      }
    }
  }

  /**
   * Fetches data from Citibank Internal systems based on the export request parameters.
   * @param request The data export request.
   * @param allRecords The array to which normalized records will be appended.
   */
  private async fetchCitibankInternalData(
    request: DataExportRequest,
    allRecords: FinancialRecord[]
  ): Promise<void> {
    const includedTypes = request.resourceTypes;

    if (includedTypes.includes(FinancialRecordType.TRANSACTION) || includedTypes.includes(FinancialRecordType.DEPOSIT) || includedTypes.includes(FinancialRecordType.WITHDRAWAL) || includedTypes.includes(FinancialRecordType.FEE) || includedTypes.includes(FinancialRecordType.ADJUSTMENT)) {
      let hasMore = true;
      let offset = 0;
      let page = 0;
      while (hasMore) {
        console.log(`  [Citibank Internal] Fetching transactions page ${++page} (offset: ${offset})`);
        try {
          const response = await this.citibankInternalClient.fetchTransactions(
            request.startDate,
            request.endDate,
            request.liveMode,
            offset
          );
          response.data.forEach((txn) =>
            allRecords.push(normalizeCitibankInternalTransaction(txn))
          );
          hasMore = response.hasMore;
          if (response.nextOffset !== undefined) {
            offset = response.nextOffset;
          } else {
            hasMore = false; // No explicit next offset, implies end of data
          }
          if (page > 200 || offset >= 200000) { // Safety break
              console.warn("  [Citibank Internal] Safety break: fetched over 200 pages or 200,000 records, stopping.");
              break;
          }
        } catch (error: any) {
          throw new Error(`Failed to fetch Citibank Internal transactions: ${error.message}`);
        }
      }
    }

    if (includedTypes.includes(FinancialRecordType.ACCOUNT_BALANCE)) {
      // Similar to Plaid, fetching account balances would be a snapshot, not time-series.
      console.log(`  [Citibank Internal] Fetching account balances...`);
      try {
        let hasMore = true;
        let offset = 0;
        let page = 0;
        while(hasMore) {
          const response = await this.citibankInternalClient.fetchAccounts(request.liveMode, offset);
          response.data.forEach(account => {
            allRecords.push({
              id: `cb-bal-${account.accountNumber}-${new Date().toISOString().substring(0, 10)}`,
              source: FinancialDataSource.CITIBANK_INTERNAL,
              recordType: FinancialRecordType.ACCOUNT_BALANCE,
              timestamp: account.lastUpdated,
              amount: account.currentBalanceMinorUnits,
              currency: account.currencyCode.toUpperCase() as Currency,
              description: `Citibank Internal Account Balance for ${account.accountName}`,
              status: "current",
              metadata: { account_type: account.accountType, customer_identifier: account.customerIdentifier },
              originatingAccountId: account.accountNumber,
              externalReferenceId: account.accountNumber,
              liveMode: request.liveMode,
            });
          });
          hasMore = response.hasMore;
          if (response.nextOffset !== undefined) {
            offset = response.nextOffset;
          } else {
            hasMore = false;
          }
          if (page > 10) { console.warn("  [Citibank Internal] Safety break: fetched over 10 pages for internal accounts, stopping."); break; }
        }
      } catch (error: any) {
        throw new Error(`Failed to fetch Citibank Internal accounts: ${error.message}`);
      }
    }
  }

  // --- Utility methods for API interaction simulation ---

  /**
   * Simulates the secure storage of an export file to a cloud storage solution
   * (e.g., Amazon S3, Google Cloud Storage, Azure Blob Storage).
   * In a production environment, this would involve authenticating with the cloud provider
   * and using their SDK to upload the file, potentially generating a pre-signed URL for temporary access.
   * @param exportId The ID of the export job.
   * @param fileName The desired file name for the stored CSV.
   * @param fileContent The content of the file (e.g., CSV string).
   * @returns A Promise resolving to the publicly accessible (or pre-signed) URL of the stored file.
   */
  private async storeExportFile(exportId: string, fileName: string, fileContent: string): Promise<string> {
    console.log(`[STORAGE] Simulating storage of export file '${fileName}' for job ${exportId}.`);
    // In a real scenario, this would involve:
    // 1. Authenticating with S3/GCS/Azure.
    // 2. Uploading `fileContent` to a bucket.
    // 3. Generating a time-limited, pre-signed URL for download.

    await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000)); // Simulate storage latency

    const dummyFileUrl = `${CITIBANK_DEMO_BUSINESS_EXPORT_STORAGE_URL}/${exportId}/${fileName}`;
    console.log(`[STORAGE] Export file for job ${exportId} simulated stored at: ${dummyFileUrl}`);

    // In a real system, you might also want to store metadata about the file
    // (e.g., content-type, size, hash) in your database alongside the job details.
    return dummyFileUrl;
  }
}

// --- Module Export ---
// This instance of the DataExportService would be created once at application startup
// and then used by various API route handlers to manage export requests.

// Instantiate the service with dummy API keys. In a real app, these would come from a secure config.
const serviceApiKeys = {
  modernTreasury: "mt_master_api_key_001",
  stripe: "sk_master_api_key_002",
  plaid: "plaid_master_api_key_003",
  citibankInternal: "cb_master_api_key_004",
};

// Export the service instance for use in API route handlers or other backend logic.
export const dataExportService = new DataExportService(serviceApiKeys);

// --- Example Usage (for internal testing/demonstration, not part of typical export) ---
/*
async function runExampleExportSimulation() {
  const exportRequest: DataExportRequest = {
    exportId: `exp_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
    userId: "user_test_456",
    email: "test.user@citibankdemobusiness.dev",
    resourceTypes: [FinancialRecordType.TRANSACTION, FinancialRecordType.CHARGE, FinancialRecordType.PAYOUT, FinancialRecordType.REFUND, FinancialRecordType.ACCOUNT_BALANCE],
    dataSources: [FinancialDataSource.MODERN_TREASURY, FinancialDataSource.STRIPE, FinancialDataSource.PLAID, FinancialDataSource.CITIBANK_INTERNAL],
    startDate: "2023-01-01",
    endDate: "2023-06-30",
    liveMode: true, // Simulate a live mode export
    filters: {
      minAmount: 10000, // Example filter: minimum amount $100.00
      currency: Currency.USD,
    },
    webhookUrl: "https://citibankdemobusiness.dev/api/webhooks/export-status-callback",
    requestedAt: new Date().toISOString(), // This will be overwritten by the service
  };

  console.log("\n--- Initiating Example Export Simulation ---");
  try {
    const initialJobDetails = await dataExportService.initiateExport(exportRequest);
    console.log("\nInitial Job Details:", JSON.stringify(initialJobDetails, null, 2));

    // Simulate polling for status by an external system or UI
    let jobStatus = dataExportService.getExportJobDetails(initialJobDetails.exportId);
    while (jobStatus && (jobStatus.status === ExportJobStatus.PENDING || jobStatus.status === ExportJobStatus.IN_PROGRESS)) {
      console.log(`\nPolling job ${jobStatus.exportId}: Status=${jobStatus.status}, Progress=${jobStatus.progress}%`);
      await new Promise(resolve => setTimeout(resolve, 3000)); // Poll every 3 seconds
      jobStatus = dataExportService.getExportJobDetails(initialJobDetails.exportId);
    }

    console.log("\n--- Final Job Details ---");
    console.log(JSON.stringify(jobStatus, null, 2));

    if (jobStatus?.status === ExportJobStatus.COMPLETED) {
      console.log(`\nExport successful! Download available at: ${jobStatus.fileUrl}`);
    } else {
      console.error(`\nExport failed: ${jobStatus?.failedReason}`);
    }

  } catch (error: any) {
    console.error("\nFailed to run example export simulation:", error.message, error);
  }
  console.log("\n--- Example Export Simulation Finished ---");
}

// To run this example, uncomment the line below:
// runExampleExportSimulation();
*/