// This file is a core component for managing internal financial accounts within a sophisticated enterprise system.
// It leverages advanced analytics, AI-driven insights, and robust data management practices to provide unparalleled
// control and visibility over internal financial operations, ensuring operational excellence and strategic foresight.

import createEntitySlice from "../utilities/createEntitySlice";
import { createAsyncThunk, createSelector } from "@reduxjs/toolkit"; // Essential for advanced Redux Toolkit patterns

// --- Comprehensive Type Definitions for Enhanced Data Models ---

/**
 * @typedef {Object} InternalAccount
 * @property {string} id - Unique identifier for the account (e.g., 'IA-001-USD-OPS').
 * @property {string} name - Human-readable name of the account (e.g., 'Operations Liquidity Pool').
 * @property {string} currency - ISO 4217 currency code (e.g., 'USD', 'EUR').
 * @property {string} type - Type of account (e.g., 'OPERATIONAL', 'SETTLEMENT', 'RESERVE', 'TREASURY', 'CAPEX_FUND').
 * @property {number} currentBalance - The current real-time balance of the account.
 * @property {number} availableBalance - The available balance considering holds, pending transactions, and minimum reserves.
 * @property {Date} createdAt - Timestamp when the account was initially created.
 * @property {Date} lastActivityAt - Timestamp of the last significant financial or administrative activity on the account.
 * @property {string} status - Current operational status ('ACTIVE', 'INACTIVE', 'BLOCKED', 'ARCHIVED', 'PENDING_REVIEW').
 * @property {string[]} authorizedUsers - List of user IDs authorized to interact with this account (e.g., approve transactions).
 * @property {string[]} authorizedDepartments - List of department IDs allowed to transact with this account.
 * @property {Object} metadata - Flexible field for additional operational or descriptive data.
 * @property {string} metadata.departmentId - The primary department this account serves.
 * @property {string} metadata.purpose - Detailed purpose description (e.g., "Daily operational expenses for IT department").
 * @property {number} [targetBalance] - An optional target balance for liquidity optimization and automated rebalancing.
 * @property {number} [minBalanceThreshold] - Minimum balance allowed; triggers alerts or automated top-ups if breached.
 * @property {number} [maxBalanceThreshold] - Maximum balance allowed; triggers alerts or automated sweep mechanisms if exceeded.
 * @property {string} [riskProfile] - AI-determined risk profile ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL') based on activity patterns.
 * @property {Object} [auditDetails] - AI-generated audit observations or last audit date.
 */

/**
 * @typedef {Object} InternalAccountTransaction
 * @property {string} id - Unique transaction identifier (e.g., 'TXN-ABC-12345').
 * @property {string} accountId - ID of the internal account involved in the transaction.
 * @property {string} type - Type of transaction ('DEBIT', 'CREDIT', 'TRANSFER_IN', 'TRANSFER_OUT', 'FEE', 'ADJUSTMENT').
 * @property {number} amount - Amount of the transaction.
 * @property {string} currency - Currency of the transaction.
 * @property {Date} timestamp - Exact timestamp when the transaction occurred or was recorded.
 * @property {string} description - A concise description of the transaction (e.g., "Vendor payment for Q3 services").
 * @property {string} category - Granular categorization for financial reporting and analytics (e.g., 'SALARY_PAYOUT', 'VENDOR_PAYMENT', 'INTER-DEPT_TRANSFER', 'REGULATORY_FEE').
 * @property {string} status - Current status of the transaction ('PENDING', 'COMPLETED', 'FAILED', 'REVERSED', 'ON_HOLD', 'FOR_REVIEW').
 * @property {string} [relatedAccountId] - For transfers, the ID of the counter-party account.
 * @property {string} [initiatorUserId] - The user ID who initiated the transaction.
 * @property {string} [approvalId] - Reference to an approval workflow if applicable.
 * @property {Object} [aiInsights] - AI-generated insights for the transaction, enhancing auditability and risk detection.
 * @property {boolean} [aiInsights.isAnomaly] - True if AI detected an unusual pattern or anomaly.
 * @property {number} [aiInsights.anomalyScore] - A quantitative score indicating the severity or likelihood of an anomaly (0-1).
 * @property {string[]} [aiInsights.tags] - AI-generated tags for dynamic categorization or policy matching.
 * @property {string} [aiInsights.nlpSummary] - A natural language summary generated by AI for complex transactions.
 */

/**
 * @typedef {Object} GeminiPrediction
 * @property {string} accountId - The ID of the account for which the prediction is made.
 * @property {Date} predictionDate - The specific date for which the predicted balance is valid.
 * @property {number} predictedBalance - The forecasted balance for the `predictionDate`.
 * @property {number} confidenceScore - A score (0-1) indicating the statistical confidence level of the prediction.
 * @property {Object} breakdown - Detailed breakdown of contributing factors (e.g., 'inflows', 'outflows', 'seasonal_impact').
 * @property {Object} [riskAssessment] - AI-generated risk assessment related to the predicted financial state.
 */

/**
 * @typedef {Object} GeminiOptimizationSuggestion
 * @property {string} suggestionId - Unique identifier for the optimization suggestion.
 * @property {string} type - Type of optimization ('BALANCE_TRANSFER', 'LIQUIDITY_ADJUSTMENT', 'INVESTMENT_OPPORTUNITY').
 * @property {string} sourceAccountId - Account from which funds are recommended to move.
 * @property {string} targetAccountId - Account to which funds are recommended to move.
 * @property {number} amount - Suggested amount for the transfer or adjustment.
 * @property {string} currency - Currency of the suggested transfer.
 * @property {string} rationale - AI-generated explanation and justification for the suggestion.
 * @property {number} estimatedImpact - Quantified benefit (e.g., 'saved interest', 'avoided overdraft fee') of applying the suggestion.
 * @property {Date} generatedAt - Timestamp when the suggestion was generated.
 */

/**
 * @typedef {Object} GeminiAnomalyResult
 * @property {boolean} isAnomaly - True if an anomaly was detected.
 * @property {number} anomalyScore - Score indicating severity (0-1).
 * @property {string} explanation - Natural language explanation of the anomaly.
 * @property {string[]} recommendedAction - Suggested actions to mitigate or investigate.
 * @property {Date} detectedAt - Timestamp of detection.
 */

/**
 * @typedef {Object} GeminiRiskAssessment
 * @property {string} accountId - The ID of the account assessed.
 * @property {number} riskScore - A numerical risk score.
 * @property {string} riskProfile - Categorical risk profile ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL').
 * @property {Object} contributingFactors - Detailed factors contributing to the risk score.
 * @property {string[]} recommendedMitigation - Actions to reduce identified risks.
 * @property {Date} assessedAt - Timestamp of the assessment.
 */

/**
 * @typedef {Object} GeminiComplianceFinding
 * @property {string} ruleId - The ID of the compliance rule.
 * @property {string} status - 'COMPLIANT', 'NON_COMPLIANT', 'REVIEW_REQUIRED'.
 * @property {string} details - Specific details about the finding.
 * @property {string} severity - 'INFO', 'WARNING', 'CRITICAL'.
 */

/**
 * @typedef {Object} GeminiComplianceResult
 * @property {string} accountId - Optional account ID.
 * @property {string[]} transactionIds - Optional list of transaction IDs checked.
 * @property {boolean} isCompliant - Overall compliance status.
 * @property {GeminiComplianceFinding[]} findings - Array of detailed findings.
 * @property {string[]} suggestedActions - Actions to achieve or verify compliance.
 * @property {Date} checkedAt - Timestamp of the compliance check.
 */

/**
 * @typedef {Object} GeminiAuditReport
 * @property {string} accountId - The ID of the account audited.
 * @property {string} reportSummary - A natural language summary of the audit findings.
 * @property {Object[]} identifiedDiscrepancies - Specific discrepancies found, with details.
 * @property {string} generatedReportId - Unique ID for the full report (if stored externally).
 * @property {Date} timestamp - When the report was generated.
 */

// --- Centralized API Endpoint Configuration for Scalability ---

/**
 * @constant {Object<string, string|Function>} API_ENDPOINTS
 * @description Defines all API endpoints used by this slice. Centralizing these improves maintainability
 * and allows for easy configuration across different environments.
 */
const API_ENDPOINTS = {
    INTERNAL_ACCOUNTS: "/api/v1/internal_accounts",
    INTERNAL_ACCOUNT_DETAIL: (id) => `/api/v1/internal_accounts/${id}`,
    INTERNAL_ACCOUNT_TRANSACTIONS: (id) => `/api/v1/internal_accounts/${id}/transactions`,
    GEMINI_PREDICT_BALANCE: "/api/v1/ai/gemini/predict_balance",
    GEMINI_ANOMALY_DETECTION: "/api/v1/ai/gemini/detect_anomaly",
    GEMINI_OPTIMIZE_LIQUIDITY: "/api/v1/ai/gemini/optimize_liquidity",
    GEMINI_NLP_QUERY: "/api/v1/ai/gemini/nlp_query",
    GEMINI_RECONCILE_TRANSACTIONS: "/api/v1/ai/gemini/reconcile_transactions",
    GEMINI_RISK_ASSESSMENT: "/api/v1/ai/gemini/risk_assessment",
    GEMINI_COMPLIANCE_CHECK: "/api/v1/ai/gemini/compliance_check",
    GEMINI_AUDIT_REPORT: "/api/v1/ai/gemini/audit_report",
    // Further endpoints for advanced features like real-time monitoring, AI-driven alerts, etc.
    INTERNAL_ACCOUNT_DEACTIVATE: (id) => `/api/v1/internal_accounts/${id}/deactivate`,
    INTERNAL_ACCOUNT_ACTIVATE: (id) => `/api/v1/internal_accounts/${id}/activate`,
};

// --- Core Internal Accounts Redux Toolkit Slice Definition ---

/**
 * Initializes the Redux Toolkit slice for internal accounts using a generic entity slice creator.
 * This provides foundational CRUD operations (Create, Read, Update, Delete) and state management
 * (loading status, error handling) for `InternalAccount` entities.
 *
 * @param {string} sliceName - The name of the slice in the Redux store.
 * @param {string} apiEndpoint - The base API endpoint for the entity.
 * @param {Function} stateSelector - A selector function to get the slice's state from the root state.
 * @returns {Object} An object containing the slice's actions, reducer, selectors, and base thunks.
 */
export const {
    slice: {
        actions: internalAccountsBaseActions, // Renamed to denote base actions from createEntitySlice
        reducer: internalAccountsBaseReducer // Renamed for clarity, this reducer will be wrapped
    },
    selector: baseEntitySelector, // Renamed for clarity, used internally for extended selectors
    thunks: baseEntityThunks, // Renamed for clarity, includes fetchAll, fetchOne, etc.
} = createEntitySlice(
    "internal_accounts", // The Redux state key for this slice
    API_ENDPOINTS.INTERNAL_ACCOUNTS, // Default API endpoint for entity management
    (state) => state.internalAccounts, // How to access this slice's state from the global Redux state
);

// --- Gemini AI Integration: Advanced Async Thunks for Intelligent Operations ---

/**
 * @namespace GeminiAI
 * @description This namespace encapsulates hypothetical interactions with a sophisticated Gemini AI service.
 * It provides advanced financial intelligence capabilities for internal accounts management, simulating
 * calls to an AI backend that performs complex data analysis, predictive modeling, optimization, and compliance checks.
 */
export const GeminiAI = {}; // Placeholder for AI-related functions and thunks

/**
 * Simulates a call to a Gemini AI service for advanced balance forecasting.
 * Provides granular predictions based on historical data, market trends, and defined operational schedules.
 * @async
 * @param {{accountId: string, startDate: Date, endDate: Date}} payload - The account ID and the date range for prediction.
 * @returns {Promise<GeminiPrediction[]>} A promise that resolves to an array of detailed balance predictions.
 * @throws {Error} If the AI service encounters an issue or the request is malformed.
 */
GeminiAI.predictBalance = createAsyncThunk(
    "internalAccounts/gemini/predictBalance",
    async ({
        accountId,
        startDate,
        endDate
    }, {
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.GEMINI_PREDICT_BALANCE, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY', // Best practice: use environment variables
                },
                body: JSON.stringify({
                    accountId,
                    predictionPeriod: {
                        startDate: startDate.toISOString(),
                        endDate: endDate.toISOString()
                    }
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI balance prediction failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            // Map raw data to rich GeminiPrediction objects, ensuring Date objects are parsed
            const predictions = data.predictions.map(p => ({
                ...p,
                predictionDate: new Date(p.predictionDate),
            }));
            return predictions;
        } catch (error) {
            console.error(`[GeminiAI.predictBalance] Error predicting balance for ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to a Gemini AI service for real-time anomaly detection on financial transactions.
 * It proactively identifies unusual or potentially fraudulent activities based on learned patterns.
 * @async
 * @param {InternalAccountTransaction} transactionData - The transaction object to be analyzed for anomalies.
 * @returns {Promise<GeminiAnomalyResult>} A promise that resolves to the anomaly detection result.
 * @throws {Error} If the AI service encounters an issue or required transaction data is missing.
 */
GeminiAI.detectTransactionAnomaly = createAsyncThunk(
    "internalAccounts/gemini/detectTransactionAnomaly",
    async (transactionData, {
        rejectWithValue
    }) => {
        try {
            if (!transactionData || !transactionData.accountId || !transactionData.amount) {
                throw new Error("Invalid transaction data provided for anomaly detection.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_ANOMALY_DETECTION, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    ...transactionData,
                    timestamp: transactionData.timestamp.toISOString(), // Ensure date is ISO string for API
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI anomaly detection failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                isAnomaly: data.isAnomaly,
                anomalyScore: data.anomalyScore,
                explanation: data.explanation,
                recommendedAction: data.recommendedAction || [],
                detectedAt: new Date(),
            };
        } catch (error) {
            console.error(`[GeminiAI.detectTransactionAnomaly] Error detecting transaction anomaly for ${transactionData?.id}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to a Gemini AI service for comprehensive liquidity optimization across a portfolio of internal accounts.
 * This function provides actionable suggestions for fund transfers to maintain target balances,
 * minimize idle cash, or optimize interest earnings based on predefined policies and real-time data.
 * @async
 * @param {{accountIds: string[], optimizationParameters?: Object}} payload - Array of account IDs and optional optimization parameters.
 * @returns {Promise<GeminiOptimizationSuggestion[]>} A promise that resolves to an array of detailed optimization suggestions.
 * @throws {Error} If the AI service encounters an issue or cannot process the request.
 */
GeminiAI.optimizeLiquidity = createAsyncThunk(
    "internalAccounts/gemini/optimizeLiquidity",
    async ({
        accountIds,
        optimizationParameters = {}
    }, {
        rejectWithValue,
        getState
    }) => {
        try {
            const allAccounts = InternalAccountsSelectors.selectAllAccounts(getState());
            const relevantAccounts = allAccounts.filter(acc => accountIds.includes(acc.id));

            if (relevantAccounts.length === 0) {
                throw new Error("No relevant accounts found for liquidity optimization.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_OPTIMIZE_LIQUIDITY, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    accounts: relevantAccounts.map(({
                        id,
                        currentBalance,
                        availableBalance,
                        currency,
                        targetBalance,
                        minBalanceThreshold,
                        maxBalanceThreshold,
                        riskProfile,
                        type,
                        metadata
                    }) => ({
                        id,
                        currentBalance,
                        availableBalance,
                        currency,
                        targetBalance,
                        minBalanceThreshold,
                        maxBalanceThreshold,
                        riskProfile,
                        type,
                        metadata
                    })),
                    optimizationParameters,
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI liquidity optimization failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            // Ensure suggestions have a generatedAt timestamp
            return data.suggestions.map(s => ({ ...s,
                generatedAt: new Date(s.generatedAt || Date.now())
            }));
        } catch (error) {
            console.error("[GeminiAI.optimizeLiquidity] Error optimizing liquidity:", error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to a Gemini AI service for Natural Language Processing (NLP) queries
 * regarding internal accounts. Users can interact with the system using plain English,
 * and the AI will interpret, extract relevant data, and provide intelligent responses.
 * @async
 * @param {{query: string, userId?: string, context?: Object}} payload - The natural language query and optional user/system context.
 * @returns {Promise<{ response: string, dataPoints: Object, suggestedActions: string[] }>} A promise that resolves to the AI's parsed response, extracted data points, and suggested follow-up actions.
 * @throws {Error} If the AI service encounters an issue during query processing.
 */
GeminiAI.nlpQueryAccounts = createAsyncThunk(
    "internalAccounts/gemini/nlpQueryAccounts",
    async ({
        query,
        userId,
        context = {}
    }, {
        rejectWithValue
    }) => {
        try {
            if (!query) {
                throw new Error("Natural language query cannot be empty.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_NLP_QUERY, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    query,
                    userContext: {
                        userId,
                        ...context
                    }, // Provide rich context for better AI understanding
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI NLP query failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                response: data.naturalLanguageResponse,
                dataPoints: data.extractedEntities || {},
                suggestedActions: data.suggestedActions || [],
            };
        } catch (error) {
            console.error("[GeminiAI.nlpQueryAccounts] Error with Gemini AI NLP query:", error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to a Gemini AI service for automated transaction reconciliation.
 * This function takes a set of unsettled transactions and attempts to match them
 * based on various criteria (e.g., amount, date, description keywords, related parties)
 * using advanced AI pattern matching and fuzzy logic algorithms.
 * @async
 * @param {InternalAccountTransaction[]} unsettledTransactions - An array of transactions to reconcile.
 * @returns {Promise<{ reconciledPairs: Array<{ transactionA: string, transactionB: string, confidence: number }>, unmatchedTransactions: string[] }>} A promise resolving to reconciliation results.
 * @throws {Error} If the AI service encounters an issue or the transaction data is insufficient.
 */
GeminiAI.reconcileTransactions = createAsyncThunk(
    "internalAccounts/gemini/reconcileTransactions",
    async (unsettledTransactions, {
        rejectWithValue
    }) => {
        try {
            if (!Array.isArray(unsettledTransactions) || unsettledTransactions.length < 2) {
                throw new Error("At least two transactions are required for reconciliation.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_RECONCILE_TRANSACTIONS, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    transactions: unsettledTransactions.map(t => ({
                        ...t,
                        timestamp: t.timestamp.toISOString()
                    })),
                    reconciliationStrategy: 'smart_match_v2', // Example: AI chooses strategy
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI transaction reconciliation failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                reconciledPairs: data.reconciledPairs || [],
                unmatchedTransactions: data.unmatchedTransactions || [],
            };
        } catch (error) {
            console.error("[GeminiAI.reconcileTransactions] Error with Gemini AI transaction reconciliation:", error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to a Gemini AI service for performing comprehensive risk assessments on accounts.
 * This can be used for new account onboarding, periodic risk reviews, or event-driven reassessments.
 * The AI evaluates multiple factors including transaction history, associated entities, and policy adherence.
 * @async
 * @param {{accountId: string, assessmentContext?: Object}} payload - The ID of the internal account and additional context.
 * @returns {Promise<GeminiRiskAssessment>} A promise resolving to the detailed risk assessment object.
 * @throws {Error} If the AI service encounters an issue or the account is not found.
 */
GeminiAI.performRiskAssessment = createAsyncThunk(
    "internalAccounts/gemini/performRiskAssessment",
    async ({
        accountId,
        assessmentContext = {}
    }, {
        rejectWithValue,
        getState
    }) => {
        try {
            const account = InternalAccountsSelectors.selectAccountById(getState(), accountId);
            if (!account) {
                throw new Error(`Account with ID ${accountId} not found for risk assessment.`);
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_RISK_ASSESSMENT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    accountData: {
                        id: account.id,
                        name: account.name,
                        type: account.type,
                        currency: account.currency,
                        currentBalance: account.currentBalance,
                        lastActivityAt: account.lastActivityAt?.toISOString(),
                        createdAt: account.createdAt?.toISOString(),
                        ...account.metadata, // Include metadata for richer context
                    },
                    assessmentContext,
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI risk assessment failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                accountId,
                riskScore: data.score,
                riskProfile: data.profile,
                contributingFactors: data.factors,
                recommendedMitigation: data.mitigations,
                assessedAt: new Date(),
            };
        } catch (error) {
            console.error(`[GeminiAI.performRiskAssessment] Error performing risk assessment for account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates an AI-driven compliance check for an account or a set of transactions.
 * It leverages Gemini's understanding of financial regulations, internal policies,
 * and historical compliance data to identify potential violations or areas of concern.
 * @async
 * @param {{accountId?: string, transactions?: InternalAccountTransaction[], complianceRulesetIds?: string[], checkContext?: Object}} payload - The payload for the compliance check.
 * @returns {Promise<GeminiComplianceResult>} A promise resolving to a detailed compliance check result.
 * @throws {Error} If the AI service encounters an issue or input data is insufficient.
 */
GeminiAI.performComplianceCheck = createAsyncThunk(
    "internalAccounts/gemini/performComplianceCheck",
    async (payload, {
        rejectWithValue
    }) => {
        try {
            if (!payload.accountId && (!payload.transactions || payload.transactions.length === 0)) {
                throw new Error("Either accountId or transactions must be provided for a compliance check.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_COMPLIANCE_CHECK, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    accountId: payload.accountId,
                    transactions: payload.transactions?.map(t => ({
                        ...t,
                        timestamp: t.timestamp.toISOString()
                    })),
                    complianceRulesetIds: payload.complianceRulesetIds || ['AML_V2', 'KYC_V1', 'INTERNAL_LIQUIDITY_POLICY'], // Default rulesets
                    checkContext: payload.checkContext,
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI compliance check failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                accountId: payload.accountId,
                transactionIds: payload.transactions?.map(t => t.id),
                isCompliant: data.isCompliant,
                findings: data.findings || [],
                suggestedActions: data.suggestedActions || [],
                checkedAt: new Date(),
            };
        } catch (error) {
            console.error("[GeminiAI.performComplianceCheck] Error performing compliance check with Gemini AI:", error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Simulates a call to Gemini AI to generate a detailed audit trail report summary or
 * identify discrepancies based on an account's historical data and predefined audit parameters.
 * The AI can cross-reference multiple data sources to provide a comprehensive audit view.
 * @async
 * @param {{accountId: string, startDate: Date, endDate: Date, auditScope?: string[]}} payload - Account ID, date range, and optional audit scope.
 * @returns {Promise<GeminiAuditReport>} A promise resolving to a summary of the audit findings.
 * @throws {Error} If the AI service encounters an issue or the date range is invalid.
 */
GeminiAI.generateAuditTrailReport = createAsyncThunk(
    "internalAccounts/gemini/generateAuditTrailReport",
    async ({
        accountId,
        startDate,
        endDate,
        auditScope = ['transactions', 'access_logs', 'configuration_changes']
    }, {
        rejectWithValue
    }) => {
        try {
            if (!startDate || !endDate || startDate > endDate) {
                throw new Error("Invalid date range provided for audit report generation.");
            }

            const response = await fetch(API_ENDPOINTS.GEMINI_AUDIT_REPORT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-AI-Service-Key': process.env.GEMINI_AI_API_KEY || 'AI_DEV_KEY',
                },
                body: JSON.stringify({
                    accountId,
                    auditPeriod: {
                        startDate: startDate.toISOString(),
                        endDate: endDate.toISOString()
                    },
                    auditScope,
                    requestTimestamp: new Date().toISOString(),
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Gemini AI audit report generation failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                accountId,
                reportSummary: data.summary,
                identifiedDiscrepancies: data.discrepancies || [],
                generatedReportId: data.reportId,
                timestamp: new Date(),
            };
        } catch (error) {
            console.error(`[GeminiAI.generateAuditTrailReport] Error generating audit report for account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);


// --- Additional Async Thunks for Advanced Account Management ---

/**
 * Thunk to fetch detailed information for a specific internal account.
 * This includes not only the basic account data but also potentially recent transactions,
 * and AI-generated insights fetched from auxiliary services.
 * @async
 * @param {string} accountId - The ID of the internal account to fetch.
 * @returns {Promise<InternalAccount>} A promise that resolves to the detailed account object.
 * @throws {Error} If the API call fails or the account is not found.
 */
export const fetchInternalAccountDetail = createAsyncThunk(
    "internalAccounts/fetchDetail",
    async (accountId, {
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.INTERNAL_ACCOUNT_DETAIL(accountId));
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to fetch account detail: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            // Ensure date strings are converted to Date objects
            return {
                ...data,
                createdAt: new Date(data.createdAt),
                lastActivityAt: new Date(data.lastActivityAt),
            };
        } catch (error) {
            console.error(`[fetchInternalAccountDetail] Error fetching detail for account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Thunk to fetch a comprehensive list of transactions for a specific internal account,
 * with options for filtering, pagination, and sorting.
 * @async
 * @param {{accountId: string, filters?: Object, pagination?: Object, sort?: Object}} payload - Account ID, optional filters, pagination, and sort parameters.
 * @returns {Promise<InternalAccountTransaction[]>} A promise that resolves to an array of transactions.
 * @throws {Error} If the API call fails.
 */
export const fetchAccountTransactions = createAsyncThunk(
    "internalAccounts/fetchTransactions",
    async ({
        accountId,
        filters = {},
        pagination = {
            page: 1,
            limit: 50
        },
        sort = {
            by: 'timestamp',
            order: 'desc'
        }
    }, {
        rejectWithValue
    }) => {
        try {
            const queryParams = new URLSearchParams({
                ...filters,
                page: pagination.page,
                limit: pagination.limit,
                sortBy: sort.by,
                sortOrder: sort.order,
            }).toString();
            const url = `${API_ENDPOINTS.INTERNAL_ACCOUNT_TRANSACTIONS(accountId)}?${queryParams}`;
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to fetch transactions: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            // Convert timestamp strings to Date objects
            return data.transactions.map(t => ({
                ...t,
                timestamp: new Date(t.timestamp),
            }));
        } catch (error) {
            console.error(`[fetchAccountTransactions] Error fetching transactions for account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Thunk to create a new internal account with specified initial properties.
 * This function also initiates an AI-driven risk assessment for the new account upon creation.
 * @async
 * @param {Object} newAccountData - Data for the new account including name, currency, type, initial balance.
 * @returns {Promise<InternalAccount>} A promise that resolves to the newly created and enriched account object.
 * @throws {Error} If the account creation fails.
 */
export const createInternalAccount = createAsyncThunk(
    "internalAccounts/createAccount",
    async (newAccountData, {
        dispatch,
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.INTERNAL_ACCOUNTS, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(newAccountData),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to create account: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            const createdAccount = {
                ...data,
                createdAt: new Date(data.createdAt),
                lastActivityAt: new Date(data.lastActivityAt),
            };

            // Immediately dispatch AI risk assessment for the newly created account (best practice for proactive risk management)
            dispatch(GeminiAI.performRiskAssessment({
                accountId: createdAccount.id,
                assessmentContext: {
                    initialCreation: true
                }
            }));

            return createdAccount;
        } catch (error) {
            console.error("[createInternalAccount] Error creating internal account:", error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Thunk to update an existing internal account's properties.
 * This can include administrative details, balance thresholds, or metadata.
 * @async
 * @param {{id: string, changes: Object}} payload - The ID of the account to update and the changes to apply.
 * @returns {Promise<InternalAccount>} A promise that resolves to the updated account object.
 * @throws {Error} If the update operation fails.
 */
export const updateInternalAccount = createAsyncThunk(
    "internalAccounts/updateAccount",
    async ({
        id,
        changes
    }, {
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.INTERNAL_ACCOUNT_DETAIL(id), {
                method: 'PUT', // Using PUT for full resource replacement/update, PATCH for partial
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(changes),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to update account: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            return {
                ...data,
                createdAt: new Date(data.createdAt),
                lastActivityAt: new Date(data.lastActivityAt),
            };
        } catch (error) {
            console.error(`[updateInternalAccount] Error updating internal account ${id}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Thunk to deactivate an internal account.
 * Deactivation typically means the account cannot be used for new transactions but retains its history for auditing.
 * It might trigger a compliance check or a final audit.
 * @async
 * @param {{accountId: string, reason: string, triggeredByUserId?: string}} payload - The ID of the account to deactivate and the reason.
 * @returns {Promise<string>} A promise that resolves to the ID of the deactivated account upon success.
 * @throws {Error} If the deactivation process fails.
 */
export const deactivateInternalAccount = createAsyncThunk(
    "internalAccounts/deactivateAccount",
    async ({
        accountId,
        reason,
        triggeredByUserId
    }, {
        dispatch,
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.INTERNAL_ACCOUNT_DEACTIVATE(accountId), {
                method: 'POST', // Or a PUT to update 'status' field directly
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    reason,
                    triggeredByUserId,
                    deactivationDate: new Date().toISOString()
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to deactivate account: ${response.status} ${response.statusText}`);
            }

            // Post-deactivation actions: e.g., trigger an AI audit or final compliance check
            dispatch(GeminiAI.generateAuditTrailReport({
                accountId,
                startDate: new Date(0), // From beginning of time
                endDate: new Date(),
                auditScope: ['all_transactions', 'status_changes']
            }));

            return accountId; // Return the ID of the successfully deactivated account
        } catch (error) {
            console.error(`[deactivateInternalAccount] Error deactivating account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);

/**
 * Thunk to activate a previously deactivated internal account, making it available for transactions again.
 * This operation typically requires proper authorization and might trigger an initial compliance check.
 * @async
 * @param {{accountId: string, reason: string, triggeredByUserId?: string}} payload - The ID of the account to activate and the reason.
 * @returns {Promise<string>} A promise that resolves to the ID of the activated account upon success.
 * @throws {Error} If the activation process fails.
 */
export const activateInternalAccount = createAsyncThunk(
    "internalAccounts/activateAccount",
    async ({
        accountId,
        reason,
        triggeredByUserId
    }, {
        dispatch,
        rejectWithValue
    }) => {
        try {
            const response = await fetch(API_ENDPOINTS.INTERNAL_ACCOUNT_ACTIVATE(accountId), {
                method: 'POST', // Or a PUT to update 'status' field directly
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    reason,
                    triggeredByUserId,
                    activationDate: new Date().toISOString()
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `Failed to activate account: ${response.status} ${response.statusText}`);
            }

            // Post-activation actions: e.g., trigger an AI risk assessment
            dispatch(GeminiAI.performRiskAssessment({
                accountId,
                assessmentContext: {
                    postActivation: true
                }
            }));

            return accountId; // Return the ID of the successfully activated account
        } catch (error) {
            console.error(`[activateInternalAccount] Error activating account ${accountId}:`, error);
            return rejectWithValue(error.message);
        }
    }
);


// --- Advanced Selectors for Intelligent Data Retrieval and Transformation ---

/**
 * @namespace InternalAccountsSelectors
 * @description Provides a comprehensive set of highly optimized selectors to efficiently retrieve
 * and transform internal account data from the Redux store. These selectors leverage `createSelector`
 * for memoization, ensuring high performance and preventing unnecessary re-renders in UI components.
 */
export const InternalAccountsSelectors = {
    /**
     * Selects all internal accounts from the normalized entity state.
     * @param {Object} state - The Redux state.
     * @returns {InternalAccount[]} An array of all internal accounts.
     */
    selectAllAccounts: baseEntitySelector.selectAll,

    /**
     * Selects a specific internal account by its unique ID.
     * @param {Object} state - The Redux state.
     * @param {string} accountId - The ID of the account to select.
     * @returns {InternalAccount|undefined} The internal account object or undefined if not found.
     */
    selectAccountById: baseEntitySelector.selectById,

    /**
     * Selects all internal accounts that are currently in 'ACTIVE' status.
     * @param {Object} state - The Redux state.
     * @returns {InternalAccount[]} An array of active internal accounts.
     */
    selectActiveAccounts: createSelector(
        baseEntitySelector.selectAll,
        (accounts) => accounts.filter(account => account.status === 'ACTIVE')
    ),

    /**
     * Selects internal accounts filtered by a specific currency code (e.g., 'USD', 'EUR').
     * @param {Object} state - The Redux state.
     * @param {string} currency - The ISO 4217 currency code.
     * @returns {InternalAccount[]} An array of internal accounts matching the specified currency.
     */
    selectAccountsByCurrency: createSelector(
        baseEntitySelector.selectAll,
        (state, currency) => currency, // Extractor for the currency argument
        (accounts, currency) => accounts.filter(account => account.currency === currency)
    ),

    /**
     * Selects internal accounts filtered by a specific account type (e.g., 'OPERATIONAL', 'SETTLEMENT').
     * @param {Object} state - The Redux state.
     * @param {string} type - The account type string.
     * @returns {InternalAccount[]} An array of internal accounts matching the specified type.
     */
    selectAccountsByType: createSelector(
        baseEntitySelector.selectAll,
        (state, type) => type, // Extractor for the type argument
        (accounts, type) => accounts.filter(account => account.type === type)
    ),

    /**
     * Calculates the total current balance across all internal accounts for a given currency.
     * @param {Object} state - The Redux state.
     * @param {string} currency - The currency code.
     * @returns {number} The aggregated total balance for the specified currency.
     */
    selectTotalBalanceByCurrency: createSelector(
        (state, currency) => InternalAccountsSelectors.selectAccountsByCurrency(state, currency),
        (accountsInCurrency) => accountsInCurrency.reduce((sum, account) => sum + (account.currentBalance || 0), 0)
    ),

    /**
     * Identifies and selects accounts that are currently below their defined minimum balance threshold.
     * These accounts may require immediate attention or automated liquidity top-ups.
     * @param {Object} state - The Redux state.
     * @returns {InternalAccount[]} An array of accounts with critically low balances.
     */
    selectAccountsBelowMinThreshold: createSelector(
        baseEntitySelector.selectAll,
        (accounts) => accounts.filter(account =>
            account.minBalanceThreshold !== undefined && account.currentBalance < account.minBalanceThreshold && account.status === 'ACTIVE'
        )
    ),

    /**
     * Identifies and selects accounts that are currently above their defined maximum balance threshold.
     * These accounts might be candidates for automated fund sweeps or investment opportunities.
     * @param {Object} state - The Redux state.
     * @returns {InternalAccount[]} An array of accounts with excessively high balances.
     */
    selectAccountsAboveMaxThreshold: createSelector(
        baseEntitySelector.selectAll,
        (accounts) => accounts.filter(account =>
            account.maxBalanceThreshold !== undefined && account.currentBalance > account.maxBalanceThreshold && account.status === 'ACTIVE'
        )
    ),

    /**
     * Selects accounts based on their AI-determined risk profile ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL').
     * @param {Object} state - The Redux state.
     * @param {string} riskProfile - The target risk profile.
     * @returns {InternalAccount[]} An array of accounts matching the specified risk profile.
     */
    selectAccountsByRiskProfile: createSelector(
        baseEntitySelector.selectAll,
        (state, riskProfile) => riskProfile,
        (accounts, riskProfile) => accounts.filter(account => account.riskProfile === riskProfile)
    ),

    /**
     * Selects the loading status for the primary internal accounts entity operations (e.g., fetching all accounts).
     * @param {Object} state - The Redux state.
     * @returns {boolean} True if primary account data is currently loading.
     */
    selectLoadingStatus: createSelector(
        (state) => state.internalAccounts.loading,
        (loading) => loading
    ),

    /**
     * Selects any error messages related to the primary internal accounts entity operations.
     * @param {Object} state - The Redux state.
     * @returns {string|null} The error message or null if no error.
     */
    selectErrorMessage: createSelector(
        (state) => state.internalAccounts.error,
        (error) => error
    ),

    /**
     * Selects all predicted balances stored for a specific internal account.
     * @param {Object} state - The Redux state.
     * @param {string} accountId - The ID of the account.
     * @returns {GeminiPrediction[]} An array of predictions for the specified account.
     */
    selectPredictionsForAccount: createSelector(
        (state) => state.internalAccounts.gemini.predictions, // Access the dedicated AI state
        (state, accountId) => accountId,
        (predictions, accountId) => predictions.filter(p => p.accountId === accountId)
    ),

    /**
     * Selects all currently active liquidity optimization suggestions generated by Gemini AI.
     * @param {Object} state - The Redux state.
     * @returns {GeminiOptimizationSuggestion[]} An array of optimization suggestions.
     */
    selectAllOptimizationSuggestions: createSelector(
        (state) => state.internalAccounts.gemini.optimizationSuggestions,
        (suggestions) => suggestions
    ),

    /**
     * Selects the latest AI-generated risk assessment for a given account.
     * @param {Object} state - The Redux state.
     * @param {string} accountId - The ID of the account.
     * @returns {GeminiRiskAssessment|undefined} The risk assessment object or undefined.
     */
    selectRiskAssessmentForAccount: createSelector(
        (state) => state.internalAccounts.gemini.riskAssessments,
        (state, accountId) => accountId,
        (riskAssessments, accountId) => riskAssessments[accountId]
    ),

    /**
     * Selects all recent compliance check results.
     * @param {Object} state - The Redux state.
     * @returns {GeminiComplianceResult[]} An array of compliance check results, usually ordered by recency.
     */
    selectAllComplianceResults: createSelector(
        (state) => state.internalAccounts.gemini.complianceResults,
        (results) => results
    ),

    /**
     * Selects the latest AI-generated audit report summary for a given account.
     * @param {Object} state - The Redux state.
     * @param {string} accountId - The ID of the account.
     * @returns {GeminiAuditReport|undefined} The audit report summary object or undefined.
     */
    selectAuditReportForAccount: createSelector(
        (state) => state.internalAccounts.gemini.auditReports,
        (state, accountId) => accountId,
        (auditReports, accountId) => auditReports[accountId]
    ),

    /**
     * Selects the general loading status of any Gemini AI operation.
     * @param {Object} state - The Redux state.
     * @returns {boolean} True if any Gemini AI operation is currently in progress.
     */
    selectGeminiAILoadingStatus: createSelector(
        (state) => state.internalAccounts.gemini.aiLoading,
        (loading) => loading
    ),

    /**
     * Selects the general error message for Gemini AI operations.
     * @param {Object} state - The Redux state.
     * @returns {string|null} The error message or null if no error.
     */
    selectGeminiAIErrorMessage: createSelector(
        (state) => state.internalAccounts.gemini.aiError,
        (error) => error
    ),

    /**
     * Selects the latest natural language processing response from Gemini AI.
     * @param {Object} state - The Redux state.
     * @returns {Object|null} The NLP response object or null.
     */
    selectLatestGeminiNLPResponse: createSelector(
        (state) => state.internalAccounts.gemini.nlpResponse,
        (response) => response
    ),

    /**
     * Selects the latest transaction reconciliation results from Gemini AI.
     * @param {Object} state - The Redux state.
     * @returns {Object|null} The reconciliation results object or null.
     */
    selectLatestGeminiReconciliationResults: createSelector(
        (state) => state.internalAccounts.gemini.reconciliationResults,
        (results) => results
    ),

    /**
     * Selects the list of transactions fetched for a specific account.
     * @param {Object} state - The Redux state.
     * @param {string} accountId - The ID of the account.
     * @returns {InternalAccountTransaction[]|undefined} An array of transactions or undefined.
     */
    selectTransactionsForAccount: createSelector(
        (state) => state.internalAccounts.transactions.byAccountId,
        (state, accountId) => accountId,
        (transactionsByAccountId, accountId) => transactionsByAccountId[accountId]
    ),

    /**
     * Selects the loading status for fetching transactions.
     * @param {Object} state - The Redux state.
     * @returns {boolean} True if transactions are currently loading.
     */
    selectTransactionsLoading: createSelector(
        (state) => state.internalAccounts.transactions.loading,
        (loading) => loading
    ),

    /**
     * Selects any error message encountered while fetching transactions.
     * @param {Object} state - The Redux state.
     * @returns {string|null} The error message or null.
     */
    selectTransactionsError: createSelector(
        (state) => state.internalAccounts.transactions.error,
        (error) => error
    ),
};


// --- Enhanced Reducer with AI-specific State Management and Thunk Handling ---

/**
 * The root reducer for the internal accounts slice, significantly enhanced with
 * AI-driven capabilities and extended state management. It wraps the base entity reducer
 * from `createEntitySlice` and adds specific handling for all Gemini AI interactions
 * and additional advanced account operations, ensuring a unified and robust state.
 *
 * @param {Object} state - The current Redux state for internal accounts.
 * @param {Object} action - The dispatched Redux action.
 * @returns {Object} The new, updated Redux state for internal accounts.
 */
export function enhancedInternalAccountsReducer(state, action) {
    let newState = internalAccountsBaseReducer(state, action); // Apply the base entity reducer first

    // Initialize Gemini AI specific state properties if they don't exist in the initial state.
    // This ensures consistency when the application starts or state is hydrated.
    if (!newState.gemini) {
        newState = {
            ...newState,
            gemini: {
                predictions: [],
                optimizationSuggestions: [],
                nlpResponse: null,
                reconciliationResults: null, // Store latest reconciliation result
                latestAnomalyResult: null, // Store latest anomaly check result
                riskAssessments: {},
                complianceResults: [],
                auditReports: {},
                aiLoading: false, // Global loading indicator for AI-related async operations
                aiError: null, // Global error message for AI-related async operations
            }
        };
    }

    // Initialize transactions-specific state for fetching historical data
    if (!newState.transactions) {
        newState.transactions = {
            byAccountId: {}, // Stores transactions, keyed by accountId
            loading: false,
            error: null,
            latestFetched: null, // Metadata about the last transaction fetch
        };
    }

    // --- Gemini AI Thunk Handlers: Managing AI-Specific State ---

    // Handle lifecycle for GeminiAI.predictBalance
    if (GeminiAI.predictBalance.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.predictBalance.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.predictions = action.payload; // Overwrite previous predictions for simplicity
        newState.gemini.aiError = null;
    } else if (GeminiAI.predictBalance.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.detectTransactionAnomaly
    if (GeminiAI.detectTransactionAnomaly.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.detectTransactionAnomaly.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.latestAnomalyResult = action.payload; // Store the most recent anomaly detection result
        newState.gemini.aiError = null;
        // Optionally, dispatch an action to update the specific transaction in the `transactions` state
        // if `transactions` were also managed within this slice's entities.
    } else if (GeminiAI.detectTransactionAnomaly.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.optimizeLiquidity
    if (GeminiAI.optimizeLiquidity.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.optimizeLiquidity.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.optimizationSuggestions = action.payload; // Update with latest suggestions
        newState.gemini.aiError = null;
    } else if (GeminiAI.optimizeLiquidity.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.nlpQueryAccounts
    if (GeminiAI.nlpQueryAccounts.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.nlpQueryAccounts.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.nlpResponse = action.payload; // Store the most recent NLP interaction
        newState.gemini.aiError = null;
    } else if (GeminiAI.nlpQueryAccounts.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.reconcileTransactions
    if (GeminiAI.reconcileTransactions.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.reconcileTransactions.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.reconciliationResults = action.payload; // Store the latest reconciliation outcome
        newState.gemini.aiError = null;
        // If transactions were managed as entities, would dispatch `updateMany` here
    } else if (GeminiAI.reconcileTransactions.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.performRiskAssessment
    if (GeminiAI.performRiskAssessment.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.performRiskAssessment.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        const {
            accountId,
            riskProfile
        } = action.payload;
        newState.gemini.riskAssessments = {
            ...newState.gemini.riskAssessments,
            [accountId]: action.payload
        };
        // Update the main account entity with the new risk profile directly
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        newState = adapter.updateOne(newState, {
            id: accountId,
            changes: {
                riskProfile: riskProfile
            }
        });
        newState.gemini.aiError = null;
    } else if (GeminiAI.performRiskAssessment.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.performComplianceCheck
    if (GeminiAI.performComplianceCheck.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.performComplianceCheck.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        // Prepend new results and keep a limited history of the last 10 compliance checks
        newState.gemini.complianceResults = [action.payload, ...newState.gemini.complianceResults].slice(0, 10);
        newState.gemini.aiError = null;
    } else if (GeminiAI.performComplianceCheck.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // Handle lifecycle for GeminiAI.generateAuditTrailReport
    if (GeminiAI.generateAuditTrailReport.matchPending(action)) {
        newState.gemini.aiLoading = true;
        newState.gemini.aiError = null;
    } else if (GeminiAI.generateAuditTrailReport.matchFulfilled(action)) {
        newState.gemini.aiLoading = false;
        const {
            accountId
        } = action.payload;
        newState.gemini.auditReports = {
            ...newState.gemini.auditReports,
            [accountId]: { ...action.payload,
                timestamp: new Date().toISOString()
            }
        };
        newState.gemini.aiError = null;
    } else if (GeminiAI.generateAuditTrailReport.matchRejected(action)) {
        newState.gemini.aiLoading = false;
        newState.gemini.aiError = action.payload || action.error?.message;
    }

    // --- Additional Account Management Thunk Handlers ---

    // Handle lifecycle for fetchInternalAccountDetail
    if (fetchInternalAccountDetail.matchPending(action)) {
        newState.loading = true; // Use general loading for core entity operations
        newState.error = null;
    } else if (fetchInternalAccountDetail.matchFulfilled(action)) {
        newState.loading = false;
        // Upsert the detailed account data into the entity state managed by createEntitySlice
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        newState = {
            ...newState,
            ...adapter.upsertOne(newState, action.payload)
        };
        newState.error = null;
    } else if (fetchInternalAccountDetail.matchRejected(action)) {
        newState.loading = false;
        newState.error = action.payload || action.error?.message;
    }

    // Handle lifecycle for fetchAccountTransactions
    if (fetchAccountTransactions.matchPending(action)) {
        newState.transactions.loading = true;
        newState.transactions.error = null;
    } else if (fetchAccountTransactions.matchFulfilled(action)) {
        newState.transactions.loading = false;
        const accountId = action.meta.arg.accountId; // Access the accountId from the thunk's argument
        newState.transactions.byAccountId[accountId] = action.payload; // Store transactions for this account
        newState.transactions.latestFetched = {
            accountId,
            dataCount: action.payload.length,
            timestamp: new Date().toISOString()
        };
        newState.transactions.error = null;
    } else if (fetchAccountTransactions.matchRejected(action)) {
        newState.transactions.loading = false;
        newState.transactions.error = action.payload || action.error?.message;
    }

    // Handle lifecycle for createInternalAccount
    if (createInternalAccount.matchPending(action)) {
        newState.loading = true;
        newState.error = null;
    } else if (createInternalAccount.matchFulfilled(action)) {
        newState.loading = false;
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        newState = {
            ...newState,
            ...adapter.addOne(newState, action.payload)
        }; // Add the newly created account to the entities
        newState.error = null;
    } else if (createInternalAccount.matchRejected(action)) {
        newState.loading = false;
        newState.error = action.payload || action.error?.message;
    }

    // Handle lifecycle for updateInternalAccount
    if (updateInternalAccount.matchPending(action)) {
        newState.loading = true;
        newState.error = null;
    } else if (updateInternalAccount.matchFulfilled(action)) {
        newState.loading = false;
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        // `upsertOne` is robust for updating, as it adds if not present or updates if present
        newState = {
            ...newState,
            ...adapter.upsertOne(newState, action.payload)
        };
        newState.error = null;
    } else if (updateInternalAccount.matchRejected(action)) {
        newState.loading = false;
        newState.error = action.payload || action.error?.message;
    }

    // Handle lifecycle for deactivateInternalAccount
    if (deactivateInternalAccount.matchPending(action)) {
        newState.loading = true;
        newState.error = null;
    } else if (deactivateInternalAccount.matchFulfilled(action)) {
        newState.loading = false;
        const accountId = action.payload;
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        newState = {
            ...newState,
            ...adapter.updateOne(newState, {
                id: accountId,
                changes: {
                    status: 'INACTIVE',
                    lastActivityAt: new Date().toISOString(), // Update last activity timestamp
                }
            })
        };
        newState.error = null;
    } else if (deactivateInternalAccount.matchRejected(action)) {
        newState.loading = false;
        newState.error = action.payload || action.error?.message;
    }

    // Handle lifecycle for activateInternalAccount
    if (activateInternalAccount.matchPending(action)) {
        newState.loading = true;
        newState.error = null;
    } else if (activateInternalAccount.matchFulfilled(action)) {
        newState.loading = false;
        const accountId = action.payload;
        const adapter = baseEntitySelector.getSelectors().getAdapter();
        newState = {
            ...newState,
            ...adapter.updateOne(newState, {
                id: accountId,
                changes: {
                    status: 'ACTIVE',
                    lastActivityAt: new Date().toISOString(), // Update last activity timestamp
                }
            })
        };
        newState.error = null;
    } else if (activateInternalAccount.matchRejected(action)) {
        newState.loading = false;
        newState.error = action.payload || action.error?.message;
    }

    return newState;
}

// --- Default Export for Redux Store Integration ---

/**
 * The default export of this file is the enhanced Redux reducer.
 * This reducer consolidates all internal accounts state management,
 * including base entity operations, advanced account features, and Gemini AI interactions.
 */
export default enhancedInternalAccountsReducer;


// --- Comprehensive Exports: Actions, Thunks, and Selectors for External Use ---

// Export all base actions generated by `createEntitySlice` for standard entity manipulation.
export const {
    setAll,
    setOne,
    addOne,
    removeOne,
    upsertOne,
    setMany,
    addMany,
    removeMany,
    upsertMany,
    updateMany,
    updateOne,
    removeAll,
} = internalAccountsBaseActions;

// Export all base thunks generated by `createEntitySlice`.
export const {
    fetchAll,
    fetchOne,
    createOne, // Standard create thunk
    updatePartial, // Standard partial update thunk
    removeOne: deleteBaseEntity, // Renamed to avoid conflict with `removeOne` action and custom thunks
} = baseEntityThunks;


// Export all custom asynchronous thunks for specific account management operations.
export {
    fetchInternalAccountDetail,
    fetchAccountTransactions,
    createInternalAccount,
    updateInternalAccount,
    deactivateInternalAccount,
    activateInternalAccount,
};

/**
 * Exports an object containing all Gemini AI-related asynchronous thunks for advanced intelligent operations.
 * This provides a single, organized point of access for all AI capabilities.
 */
export const GeminiAITunks = {
    predictBalance: GeminiAI.predictBalance,
    detectTransactionAnomaly: GeminiAI.detectTransactionAnomaly,
    optimizeLiquidity: GeminiAI.optimizeLiquidity,
    nlpQueryAccounts: GeminiAI.nlpQueryAccounts,
    reconcileTransactions: GeminiAI.reconcileTransactions,
    performRiskAssessment: GeminiAI.performRiskAssessment,
    performComplianceCheck: GeminiAI.performComplianceCheck,
    generateAuditTrailReport: GeminiAI.generateAuditTrailReport,
};

/**
 * Re-export the comprehensive set of memoized selectors.
 * This allows consuming components to easily access derived or transformed state for internal accounts.
 */
export const {
    selectAllAccounts,
    selectAccountById,
    selectActiveAccounts,
    selectAccountsByCurrency,
    selectAccountsByType,
    selectTotalBalanceByCurrency,
    selectAccountsBelowMinThreshold,
    selectAccountsAboveMaxThreshold,
    selectAccountsByRiskProfile,
    selectLoadingStatus,
    selectErrorMessage,
    selectPredictionsForAccount,
    selectAllOptimizationSuggestions,
    selectRiskAssessmentForAccount,
    selectAllComplianceResults,
    selectAuditReportForAccount,
    selectGeminiAILoadingStatus,
    selectGeminiAIErrorMessage,
    selectLatestGeminiNLPResponse,
    selectLatestGeminiReconciliationResults,
    selectTransactionsForAccount,
    selectTransactionsLoading,
    selectTransactionsError,
} = InternalAccountsSelectors;